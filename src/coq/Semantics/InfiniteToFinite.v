From Coq Require Import
  Relations
  String
  List
  Lia
  ZArith
  Morphisms.

Require Import Coq.Logic.ProofIrrelevance.

From Vellvm Require Import
  Semantics.InterpretationStack
  Semantics.LLVMEvents
  Semantics.Denotation
  Semantics.MemoryAddress
  Semantics.Memory.Sizeof
  Semantics.Lang
  Semantics.InterpretationStack
  Semantics.TopLevel
  Semantics.DynamicValues
  Semantics.LLVMParams
  Semantics.InfiniteToFinite.Conversions.BaseConversions
  Semantics.InfiniteToFinite.Conversions.DvalueConversions
  Semantics.InfiniteToFinite.Conversions.EventConversions
  Semantics.InfiniteToFinite.Conversions.TreeConversions
  Semantics.InfiniteToFinite.LangRefine
  Syntax.DynamicTypes
  Theory.TopLevelRefinements
  Theory.ContainsUBExtra
  Utils.Error
  Utils.Monads
  Utils.MapMonadExtra
  Utils.PropT
  Utils.InterpProp
  Utils.ListUtil
  Utils.Tactics
  Utils.OOMRutt
  Utils.OOMRuttProps
  Handlers.MemoryModules.FiniteAddresses
  Handlers.MemoryModules.InfiniteAddresses
  Handlers.MemoryModelImplementation.

From ExtLib Require Import
  Structures.Monads
  Structures.Functor.

From ITree Require Import
  ITree
  Basics
  Basics.HeterogeneousRelations
  Eq.Rutt
  Eq.RuttFacts
  Eq.Eqit
  Eq.EqAxiom.

Require Import Coq.Program.Equality.
Require Import Paco.paco.

Import InterpFacts.

Import MonadNotation.
Import ListNotations.

Notation LLVM_syntax :=
  (list (LLVMAst.toplevel_entity
           LLVMAst.typ
           (LLVMAst.block LLVMAst.typ * list (LLVMAst.block LLVMAst.typ)))).

Infix "Ã—" := prod_rel (at level 90, left associativity).

Module InfiniteToFinite.
  (* Import FinInfLangRefine. (* Just planning on using this for L4_convert from finite to infinite events. *) *)
  Import InfFinLangRefine.

  From Vellvm Require Import InterpreterMCFG.

  Import MCFGTheoryBigIntptr.
  Import MCFGTheory64BitIntptr.

  Module TLR_INF := TopLevelRefinementsBigIntptr.
  Module TLR_FIN := TopLevelRefinements64BitIntptr.

  Hint Resolve interp_PropT__mono : paco.

  (* TODO: Move these refine_OOM_h lemmas? *)
  Import Morphisms.


  Module E1 := InterpreterStackBigIntptr.LP.Events.
  Module E2 := InterpreterStack64BitIntptr.LP.Events.

  #[local] Notation E1 := (E1.ExternalCallE +' OOME +' UBE +' DebugE +' FailureE).
  #[local] Notation E2 := (E2.ExternalCallE +' OOME +' UBE +' DebugE +' FailureE).
  #[local] Notation OOM_h := (refine_OOM_handler).

  Module InfLLVM := Vellvm.Semantics.InterpretationStack.InterpreterStackBigIntptr.LLVM.
  Module FinLLVM := Vellvm.Semantics.InterpretationStack.InterpreterStack64BitIntptr.LLVM.

  Module EC1 := ECInfFin.
  Module DVC1 := DVCInfFin.
  Module DVC2 := DVCFinInf.

  Module InfMem := MemoryBigIntptr.
  Module FinMem := Memory64BitIntptr.

  Module InfMemMMSP := MemoryBigIntptr.MMEP.MMSP.
  Module FinMemMMSP := Memory64BitIntptr.MMEP.MMSP.

  Module InfMemInterp := MemoryBigIntptr.MEM_SPEC_INTERP.
  Module FinMemInterp := Memory64BitIntptr.MEM_SPEC_INTERP.

  Module InfLP := InterpreterStackBigIntptr.LP.
  Module FinLP := InterpreterStack64BitIntptr.LP.

  (* Module EC2 := EventConvert FinLP InfLP FinToInfAddrConvert InfToFinAddrConvert FinLP.Events InfLP.Events DVC1. *)

  Module DVCS := DVConvertSafe FinLP InfLP FinToInfAddrConvert InfToFinAddrConvert FinToInfAddrConvertSafe FinToInfIntptrConvertSafe FinLP.Events InfLP.Events DVC2 DVC1.
  Import DVCS.

  (* TODO: Should we move this? *)
  Definition addr_refine addr_inf addr_fin := InfToFinAddrConvert.addr_convert addr_inf = NoOom addr_fin.

  (* TODO: Should we move this? *)
  Definition fin_to_inf_addr (a : FinAddr.addr) : InfAddr.addr.
    unfold FinAddr.addr in a.
    unfold FiniteAddresses.Iptr in a.
    pose proof FinToInfAddrConvertSafe.addr_convert_succeeds a as [a' _].
    exact a'.
  Defined.

  Lemma unsigned_repr_eq:
    forall i, ((0 <=? i)%Z && (i <? Int64.modulus)%Z)%bool = true ->
         Int64.unsigned (Int64.repr i) = i.
  Proof.
    intros i H.
    Transparent Int64.repr.
    unfold Int64.repr.
    unfold Int64.unsigned.
    cbn.
    Opaque Int64.repr.
    symmetry in H.
    apply Bool.andb_true_eq in H.
    destruct H.
    assert (0 <= i < Integers.Int64.modulus)%Z by lia.
    rewrite Integers.Int64.Z_mod_modulus_eq.
    rewrite Zmod_small; auto.
  Qed.

  Lemma addr_convert_fin_to_inf_addr :
    forall addr_fin,
      InfToFinAddrConvert.addr_convert (fin_to_inf_addr addr_fin) = NoOom addr_fin.
  Proof.
    intros addr_fin.
    unfold fin_to_inf_addr in *.
    destruct (FinToInfAddrConvertSafe.addr_convert_succeeds addr_fin).
    apply FinToInfAddrConvertSafe.addr_convert_safe in e.
    auto.
  Qed.

  Lemma lift_addr_Convert_addr_inverse:
    forall {a_inf a_fin},
        InfToFinAddrConvert.addr_convert a_inf = NoOom a_fin ->
        fin_to_inf_addr a_fin = a_inf.
  Proof.
    intros.
    unfold InfToFinAddrConvert.addr_convert in H.
    destruct a_inf.
    unfold FinITOP.int_to_ptr in H.
    unfold fin_to_inf_addr.
    destruct (((i <? 0)%Z || (i >=? Int64.modulus)%Z)%bool) eqn: HEQ.
    - inversion H.
    - inversion H.
      unfold FiniteAddresses.Prov.
      unfold Prov in *.
      remember (FinToInfAddrConvertSafe.addr_convert_succeeds (Int64.repr i, p)) as X.
      destruct X. destruct x.
      unfold FinToInfAddrConvert.addr_convert in e.
      cbn in e.
      inversion e.
      subst.
      rewrite unsigned_repr_eq; auto.
      apply Bool.orb_false_elim in HEQ.
      apply andb_true_intro.
      lia.
  Qed.

  (* TODO: Should we move this? *)
  Definition fin_to_inf_dvalue (dv : LLVMParams64BitIntptr.Events.DV.dvalue) : LLVMParamsBigIntptr.Events.DV.dvalue.
    pose proof dvalue_convert_strict_safe dv as [dvi [CONV RCONV]].
    apply dvi.
  Defined.

  Lemma fin_to_inf_dvalue_refine_strict' :
    forall d_inf d_fin,
      DVC1.dvalue_refine_strict d_inf d_fin ->
      d_inf = fin_to_inf_dvalue d_fin.
  Proof.
    intros d_inf d_fin H.
    rewrite DVC1.dvalue_refine_strict_equation in H.
    unfold fin_to_inf_dvalue.
    break_match; cbn in *.
    destruct p.
    clear Heqs.

    revert d_fin H x e e0.
    induction d_inf; intros d_fin H' x' e e0; try rename H into H''; rename H' into H;
      try solve
        [ cbn in *; inv H;
          cbn in *; inv e;
          auto
        ].
    - cbn in *.
      break_match_hyp; inv H.
      cbn in *.
      break_match_hyp; inv e.
      cbn in *.
      break_match_hyp; inv e0.

      pose proof InfToFinAddrConvert.addr_convert_injective a a1 a0 Heqo Heqo1.
      subst.
      auto.
    - cbn in *; break_match_hyp; inv H.
      cbn in *; inv e.
      cbn in *; break_match_hyp; inv e0.

      pose proof (IP64Bit.from_Z_injective _ _ _ Heqo Heqo0).
      apply LLVMParamsBigIntptr.IP.to_Z_inj in H.
      subst.
      reflexivity.
    - cbn in *; break_match_hyp; inv H.
      cbn in *; break_match_hyp; inv e.
      cbn in *; break_match_hyp; inv e0.

      revert l Heqo l0 Heqo1 H'' Heqo0.
      induction fields; intros l Heqo l0 Heqo1 H'' Heqo0.
      + cbn in *. inv Heqo.
        cbn in *. inv Heqo0.
        reflexivity.
      + rewrite map_monad_unfold in Heqo.
        cbn in *.
        break_match_hyp; inv Heqo.
        break_match_hyp; inv H0.

        rewrite map_monad_unfold in Heqo0.
        cbn in *.
        break_match_hyp; inv Heqo0.
        break_match_hyp; inv H0.

        rewrite map_monad_unfold in Heqo1.
        cbn in *.
        break_match_hyp; inv Heqo1.
        break_match_hyp; inv H0.

        (* Show that a = u0 *)
        pose proof (H'' a (or_introl eq_refl) _ Heqo2 _ Heqo3 Heqo4); subst.

        specialize (IHfields _ eq_refl l Heqo1).
        forward IHfields; eauto.
        forward IHfields; eauto.
        inv IHfields.
        reflexivity.
    - cbn in *; break_match_hyp; inv H.
      cbn in *; break_match_hyp; inv e.
      cbn in *; break_match_hyp; inv e0.

      revert l Heqo l0 Heqo1 H'' Heqo0.
      induction fields; intros l Heqo l0 Heqo1 H'' Heqo0.
      + cbn in *. inv Heqo.
        cbn in *. inv Heqo0.
        reflexivity.
      + rewrite map_monad_unfold in Heqo.
        cbn in *.
        break_match_hyp; inv Heqo.
        break_match_hyp; inv H0.

        rewrite map_monad_unfold in Heqo0.
        cbn in *.
        break_match_hyp; inv Heqo0.
        break_match_hyp; inv H0.

        rewrite map_monad_unfold in Heqo1.
        cbn in *.
        break_match_hyp; inv Heqo1.
        break_match_hyp; inv H0.

        (* Show that a = u0 *)
        pose proof (H'' a (or_introl eq_refl) _ Heqo2 _ Heqo3 Heqo4); subst.

        specialize (IHfields _ eq_refl l Heqo1).
        forward IHfields; eauto.
        forward IHfields; eauto.
        inv IHfields.
        reflexivity.
    - cbn in *; break_match_hyp; inv H.
      cbn in *; break_match_hyp; inv e.
      cbn in *; break_match_hyp; inv e0.

      revert l Heqo l0 Heqo1 H'' Heqo0.
      induction elts; intros l Heqo l0 Heqo1 H'' Heqo0.
      + cbn in *. inv Heqo.
        cbn in *. inv Heqo0.
        reflexivity.
      + rewrite map_monad_unfold in Heqo.
        cbn in *.
        break_match_hyp; inv Heqo.
        break_match_hyp; inv H0.

        rewrite map_monad_unfold in Heqo0.
        cbn in *.
        break_match_hyp; inv Heqo0.
        break_match_hyp; inv H0.

        rewrite map_monad_unfold in Heqo1.
        cbn in *.
        break_match_hyp; inv Heqo1.
        break_match_hyp; inv H0.

        (* Show that a = u0 *)
        pose proof (H'' a (or_introl eq_refl) _ Heqo2 _ Heqo3 Heqo4); subst.

        specialize (IHelts _ eq_refl l Heqo1).
        forward IHelts; eauto.
        forward IHelts; eauto.
        inv IHelts.
        reflexivity.
    - cbn in *; break_match_hyp; inv H.
      cbn in *; break_match_hyp; inv e.
      cbn in *; break_match_hyp; inv e0.

      revert l Heqo l0 Heqo1 H'' Heqo0.
      induction elts; intros l Heqo l0 Heqo1 H'' Heqo0.
      + cbn in *. inv Heqo.
        cbn in *. inv Heqo0.
        reflexivity.
      + rewrite map_monad_unfold in Heqo.
        cbn in *.
        break_match_hyp; inv Heqo.
        break_match_hyp; inv H0.

        rewrite map_monad_unfold in Heqo0.
        cbn in *.
        break_match_hyp; inv Heqo0.
        break_match_hyp; inv H0.

        rewrite map_monad_unfold in Heqo1.
        cbn in *.
        break_match_hyp; inv Heqo1.
        break_match_hyp; inv H0.

        (* Show that a = u0 *)
        pose proof (H'' a (or_introl eq_refl) _ Heqo2 _ Heqo3 Heqo4); subst.

        specialize (IHelts _ eq_refl l Heqo1).
        forward IHelts; eauto.
        forward IHelts; eauto.
        inv IHelts.
        reflexivity.
  Qed.

  (* TODO: Should we move this? *)
  Definition fin_to_inf_uvalue (uv : LLVMParams64BitIntptr.Events.DV.uvalue) : LLVMParamsBigIntptr.Events.DV.uvalue.
    pose proof uvalue_convert_strict_safe uv as [uvi [CONV RCONV]].
    apply uvi.
  Defined.

  Lemma convert_fin_to_inf_uvalue_succeeds :
    forall {uv_fin},
      DVC1.uvalue_convert_strict (fin_to_inf_uvalue uv_fin) = NoOom uv_fin.
  Proof.
    intros.
    unfold fin_to_inf_uvalue.
    destruct  (uvalue_convert_strict_safe uv_fin).
    destruct p.
    rewrite e0.
    reflexivity.
  Qed.

  Lemma fin_to_inf_uvalue_refine_strict' :
    forall d_inf d_fin,
      DVC1.uvalue_refine_strict d_inf d_fin ->
      d_inf = fin_to_inf_uvalue d_fin.
  Proof.
    intros d_inf d_fin H.
    rewrite DVC1.uvalue_refine_strict_equation in H.
    unfold fin_to_inf_uvalue.
    break_match; cbn in *.
    destruct p.
    clear Heqs.

    revert d_fin H x e e0.
    induction d_inf; intros d_fin H' x' e e0; try rename H into H''; rename H' into H;
      try solve
        [ cbn in *; inv H;
          cbn in *; inv e;
          auto
        ].
    - cbn in *.
      break_match_hyp; inv H.
      cbn in *.
      break_match_hyp; inv e.
      cbn in *.
      break_match_hyp; inv e0.

      pose proof InfToFinAddrConvert.addr_convert_injective a a1 a0 Heqo Heqo1.
      subst.
      auto.
    - cbn in *; break_match_hyp; inv H.
      cbn in *; inv e.
      cbn in *; break_match_hyp; inv e0.

      pose proof (IP64Bit.from_Z_injective _ _ _ Heqo Heqo0).
      apply LLVMParamsBigIntptr.IP.to_Z_inj in H.
      subst.
      reflexivity.
    - cbn in *; break_match_hyp; inv H.
      cbn in *; break_match_hyp; inv e.
      cbn in *; break_match_hyp; inv e0.

      revert l Heqo l0 Heqo1 H'' Heqo0.
      induction fields; intros l Heqo l0 Heqo1 H'' Heqo0.
      + cbn in *. inv Heqo.
        cbn in *. inv Heqo0.
        reflexivity.
      + rewrite map_monad_unfold in Heqo.
        cbn in *.
        break_match_hyp; inv Heqo.
        break_match_hyp; inv H0.

        rewrite map_monad_unfold in Heqo0.
        cbn in *.
        break_match_hyp; inv Heqo0.
        break_match_hyp; inv H0.

        rewrite map_monad_unfold in Heqo1.
        cbn in *.
        break_match_hyp; inv Heqo1.
        break_match_hyp; inv H0.

        (* Show that a = u0 *)
        pose proof (H'' a (or_introl eq_refl) _ Heqo2 _ Heqo3 Heqo4); subst.

        specialize (IHfields _ eq_refl l Heqo1).
        forward IHfields; eauto.
        forward IHfields; eauto.
        inv IHfields.
        reflexivity.
    - cbn in *; break_match_hyp; inv H.
      cbn in *; break_match_hyp; inv e.
      cbn in *; break_match_hyp; inv e0.

      revert l Heqo l0 Heqo1 H'' Heqo0.
      induction fields; intros l Heqo l0 Heqo1 H'' Heqo0.
      + cbn in *. inv Heqo.
        cbn in *. inv Heqo0.
        reflexivity.
      + rewrite map_monad_unfold in Heqo.
        cbn in *.
        break_match_hyp; inv Heqo.
        break_match_hyp; inv H0.

        rewrite map_monad_unfold in Heqo0.
        cbn in *.
        break_match_hyp; inv Heqo0.
        break_match_hyp; inv H0.

        rewrite map_monad_unfold in Heqo1.
        cbn in *.
        break_match_hyp; inv Heqo1.
        break_match_hyp; inv H0.

        (* Show that a = u0 *)
        pose proof (H'' a (or_introl eq_refl) _ Heqo2 _ Heqo3 Heqo4); subst.

        specialize (IHfields _ eq_refl l Heqo1).
        forward IHfields; eauto.
        forward IHfields; eauto.
        inv IHfields.
        reflexivity.
    - cbn in *; break_match_hyp; inv H.
      cbn in *; break_match_hyp; inv e.
      cbn in *; break_match_hyp; inv e0.

      revert l Heqo l0 Heqo1 H'' Heqo0.
      induction elts; intros l Heqo l0 Heqo1 H'' Heqo0.
      + cbn in *. inv Heqo.
        cbn in *. inv Heqo0.
        reflexivity.
      + rewrite map_monad_unfold in Heqo.
        cbn in *.
        break_match_hyp; inv Heqo.
        break_match_hyp; inv H0.

        rewrite map_monad_unfold in Heqo0.
        cbn in *.
        break_match_hyp; inv Heqo0.
        break_match_hyp; inv H0.

        rewrite map_monad_unfold in Heqo1.
        cbn in *.
        break_match_hyp; inv Heqo1.
        break_match_hyp; inv H0.

        (* Show that a = u0 *)
        pose proof (H'' a (or_introl eq_refl) _ Heqo2 _ Heqo3 Heqo4); subst.

        specialize (IHelts _ eq_refl l Heqo1).
        forward IHelts; eauto.
        forward IHelts; eauto.
        inv IHelts.
        reflexivity.
    - cbn in *; break_match_hyp; inv H.
      cbn in *; break_match_hyp; inv e.
      cbn in *; break_match_hyp; inv e0.

      revert l Heqo l0 Heqo1 H'' Heqo0.
      induction elts; intros l Heqo l0 Heqo1 H'' Heqo0.
      + cbn in *. inv Heqo.
        cbn in *. inv Heqo0.
        reflexivity.
      + rewrite map_monad_unfold in Heqo.
        cbn in *.
        break_match_hyp; inv Heqo.
        break_match_hyp; inv H0.

        rewrite map_monad_unfold in Heqo0.
        cbn in *.
        break_match_hyp; inv Heqo0.
        break_match_hyp; inv H0.

        rewrite map_monad_unfold in Heqo1.
        cbn in *.
        break_match_hyp; inv Heqo1.
        break_match_hyp; inv H0.

        (* Show that a = u0 *)
        pose proof (H'' a (or_introl eq_refl) _ Heqo2 _ Heqo3 Heqo4); subst.

        specialize (IHelts _ eq_refl l Heqo1).
        forward IHelts; eauto.
        forward IHelts; eauto.
        inv IHelts.
        reflexivity.
    - (* IBinop *)
      cbn in *; break_match_hyp; inv H.
      cbn in *; break_match_hyp; inv H1.
      cbn in *; break_match_hyp; inv e.
      cbn in *; break_match_hyp; inv H0.
      cbn in *; break_match_hyp; inv e0.
      cbn in *; break_match_hyp; inv H0.

      erewrite IHd_inf1; eauto.
      erewrite IHd_inf2; eauto.
    - (* ICmp *)
      cbn in *; break_match_hyp; inv H.
      cbn in *; break_match_hyp; inv H1.
      cbn in *; break_match_hyp; inv e.
      cbn in *; break_match_hyp; inv H0.
      cbn in *; break_match_hyp; inv e0.
      cbn in *; break_match_hyp; inv H0.

      erewrite IHd_inf1; eauto.
      erewrite IHd_inf2; eauto.
    - (* FBinop *)
      cbn in *; break_match_hyp; inv H.
      cbn in *; break_match_hyp; inv H1.
      cbn in *; break_match_hyp; inv e.
      cbn in *; break_match_hyp; inv H0.
      cbn in *; break_match_hyp; inv e0.
      cbn in *; break_match_hyp; inv H0.

      erewrite IHd_inf1; eauto.
      erewrite IHd_inf2; eauto.
    - (* FCmp *)
      cbn in *; break_match_hyp; inv H.
      cbn in *; break_match_hyp; inv H1.
      cbn in *; break_match_hyp; inv e.
      cbn in *; break_match_hyp; inv H0.
      cbn in *; break_match_hyp; inv e0.
      cbn in *; break_match_hyp; inv H0.

      erewrite IHd_inf1; eauto.
      erewrite IHd_inf2; eauto.
    - (* Conversion *)
      cbn in *; break_match_hyp; inv H.
      cbn in *; break_match_hyp; inv e.
      cbn in *; break_match_hyp; inv e0.

      erewrite IHd_inf; eauto.
    - (* GEP *)
      cbn in *; break_match_hyp; inv H.
      cbn in *; break_match_hyp; inv H1.
      cbn in *; break_match_hyp; inv e.
      cbn in *; break_match_hyp; inv H0.
      cbn in *; break_match_hyp; inv e0.
      cbn in *; break_match_hyp; inv H0.

      revert l Heqo l0 u0 Heqo1 H'' Heqo0 Heqo2 Heqo4 Heqo3.
      induction idxs; intros l Heqo l0 u0 Heqo1 H'' Heqo0 Heqo2 Heqo4 Heqo3.
      + cbn in *. inv Heqo0.
        cbn in *. inv Heqo2.
        erewrite IHd_inf; eauto.
      + rewrite map_monad_unfold in Heqo0.
        cbn in *.
        break_match_hyp; inv Heqo0.
        break_match_hyp; inv H0.

        rewrite map_monad_unfold in Heqo2.
        cbn in *.
        break_match_hyp; inv Heqo2.
        break_match_hyp; inv H0.

        rewrite map_monad_unfold in Heqo4.
        cbn in *.
        break_match_hyp; inv Heqo4.
        break_match_hyp; inv H0.

        (* Show that a = u0 *)
        pose proof (H'' a (or_introl eq_refl)_ Heqo5 _ Heqo6 Heqo7); subst.

        specialize (IHidxs l1 Heqo l _ Heqo1).
        repeat (forward IHidxs; eauto).
        inv IHidxs.
        reflexivity.
    - (* ExtractElement *)
      cbn in *; break_match_hyp; inv H.
      cbn in *; break_match_hyp; inv H1.
      cbn in *; break_match_hyp; inv e.
      cbn in *; break_match_hyp; inv H0.
      cbn in *; break_match_hyp; inv e0.
      cbn in *; break_match_hyp; inv H0.

      erewrite IHd_inf1; eauto.
      erewrite IHd_inf2; eauto.
    - (* InsertElement *)
      cbn in *; break_match_hyp; inv H.
      cbn in *; break_match_hyp; inv H1.
      cbn in *; break_match_hyp; inv H0.
      cbn in *; break_match_hyp; inv e.
      cbn in *; break_match_hyp; inv H0.
      cbn in *; break_match_hyp; inv H1.
      cbn in *; break_match_hyp; inv e0.
      cbn in *; break_match_hyp; inv H0.
      cbn in *; break_match_hyp; inv H1.

      erewrite IHd_inf1; eauto.
      erewrite IHd_inf2; eauto.
      erewrite IHd_inf3; eauto.
    - (* ShuffleVector *)
      cbn in *; break_match_hyp; inv H.
      cbn in *; break_match_hyp; inv H1.
      cbn in *; break_match_hyp; inv H0.
      cbn in *; break_match_hyp; inv e.
      cbn in *; break_match_hyp; inv H0.
      cbn in *; break_match_hyp; inv H1.
      cbn in *; break_match_hyp; inv e0.
      cbn in *; break_match_hyp; inv H0.
      cbn in *; break_match_hyp; inv H1.

      erewrite IHd_inf1; eauto.
      erewrite IHd_inf2; eauto.
      erewrite IHd_inf3; eauto.
    - (* ExtractValue *)
      cbn in *; break_match_hyp; inv H.
      cbn in *; break_match_hyp; inv e.
      cbn in *; break_match_hyp; inv e0.

      erewrite IHd_inf; eauto.
    - (* InsertValue *)
      cbn in *; break_match_hyp; inv H.
      cbn in *; break_match_hyp; inv H1.
      cbn in *; break_match_hyp; inv e.
      cbn in *; break_match_hyp; inv H0.
      cbn in *; break_match_hyp; inv e0.
      cbn in *; break_match_hyp; inv H0.

      erewrite IHd_inf1; eauto.
      erewrite IHd_inf2; eauto.
    - (* Select *)
      cbn in *; break_match_hyp; inv H.
      cbn in *; break_match_hyp; inv H1.
      cbn in *; break_match_hyp; inv H0.
      cbn in *; break_match_hyp; inv e.
      cbn in *; break_match_hyp; inv H0.
      cbn in *; break_match_hyp; inv H1.
      cbn in *; break_match_hyp; inv e0.
      cbn in *; break_match_hyp; inv H0.
      cbn in *; break_match_hyp; inv H1.

      erewrite IHd_inf1; eauto.
      erewrite IHd_inf2; eauto.
      erewrite IHd_inf3; eauto.
    - (* ExtractByte *)
      cbn in *; break_match_hyp; inv H.
      cbn in *; break_match_hyp; inv e.
      cbn in *; break_match_hyp; inv e0.
      rewrite <- Heqo1 in Heqo.

      specialize (IHd_inf u eq_refl _ Heqo0 Heqo1).
      subst.
      eauto.
    - (* ConcatBytes *)
      cbn in *; break_match_hyp; inv H.
      cbn in *; break_match_hyp; inv e.
      cbn in *; break_match_hyp; inv e0.

      revert l Heqo l0 Heqo1 H'' Heqo0 Heqo.
      induction uvs; intros l Heqo l0 Heqo1 H'' Heqo0 Heqo2.
      + cbn in *. inv Heqo2.
        cbn in *. inv Heqo0.
        reflexivity.
      + rewrite map_monad_unfold in Heqo2.
        cbn in *.
        break_match_hyp; inv Heqo2.
        break_match_hyp; inv H0.

        rewrite map_monad_unfold in Heqo0.
        cbn in *.
        break_match_hyp; inv Heqo0.
        break_match_hyp; inv H0.

        rewrite map_monad_unfold in Heqo1.
        cbn in *.
        break_match_hyp; inv Heqo1.
        break_match_hyp; inv H0.

        (* Show that a = u0 *)
        pose proof (H'' a (or_introl eq_refl) _ Heqo3 _ Heqo4 Heqo5); subst.

        specialize (IHuvs l1 eq_refl l Heqo1).
        repeat (forward IHuvs; eauto).
        inv IHuvs.
        reflexivity.
  Qed.

  (* Could not put with the other conversions, need to know what memory structures like MemState are *)
  Definition convert_SByte (sb1 : MemoryBigIntptr.MP.BYTE_IMPL.SByte) : OOM (Memory64BitIntptr.MP.BYTE_IMPL.SByte).
    destruct sb1.
    refine (uv' <- DVC1.uvalue_convert_strict uv;;
            ret (FiniteSizeof.mkUByte LLVMParams64BitIntptr.Events.DV.uvalue uv' dt idx sid)).
  Defined.

  Definition lift_SByte (sb1 : Memory64BitIntptr.MP.BYTE_IMPL.SByte) : MemoryBigIntptr.MP.BYTE_IMPL.SByte.
    destruct sb1.
    exact (FiniteSizeof.mkUByte DVC2.DV2.uvalue (fin_to_inf_uvalue uv) dt idx sid).
  Defined.

  Lemma lift_SByte_convert_SByte_inverse :
    forall {sb_inf sb_fin},
      convert_SByte sb_inf = NoOom sb_fin ->
      lift_SByte sb_fin = sb_inf.
  Proof.
    intros.
    unfold convert_SByte in H.
    unfold lift_SByte.
    destruct sb_inf eqn: EQ1.
    destruct (DVC1.uvalue_convert_strict uv) eqn: EQ2; [|inversion H].
    cbn in H.
    inversion H.
    apply fin_to_inf_uvalue_refine_strict' in EQ2.
    rewrite EQ2.
    reflexivity.
  Qed.

  Definition sbyte_refine byte_inf byte_fin : Prop :=
    convert_SByte byte_inf = NoOom byte_fin.

  Lemma sbyte_refine_lifted :
    forall byte,
      sbyte_refine (lift_SByte byte) byte.
  Proof.
    intros.
    unfold sbyte_refine, lift_SByte.
    destruct byte.
    cbn.
    rewrite convert_fin_to_inf_uvalue_succeeds.
    reflexivity.
  Qed.

  Definition convert_mem_byte (mb1 : InfMemMMSP.mem_byte) : OOM (FinMemMMSP.mem_byte).
    destruct mb1.
    refine (s' <- convert_SByte s;;
            ret _).

    constructor.
    apply s'.
    apply a.
  Defined.

  Definition lift_mem_byte (mb1 : FinMemMMSP.mem_byte) : InfMemMMSP.mem_byte.
    destruct mb1.
    constructor.
    - exact (lift_SByte s).
    - apply a.
  Defined.

  Lemma lift_mem_byte_convert_mem_byte_inversion :
    forall {mb_inf mb_fin},
      convert_mem_byte mb_inf = NoOom mb_fin ->
      lift_mem_byte mb_fin = mb_inf.
  Proof.
    intros.
    unfold convert_mem_byte in H.
    destruct mb_inf eqn : EQ1.
    destruct (convert_SByte s) eqn: EQ2; [|inversion H].
    cbn in H.
    inversion H.
    apply lift_SByte_convert_SByte_inverse in EQ2.
    cbn.
    rewrite EQ2.
    reflexivity.
  Qed.

  (* Slightly tricky.

     Both the infinite and finite memory have the same underlying
     structure --- a map from Z to mem_bytes.

     The Z indexes in the finite memory may need to be limited to the
     range of the address type, but it may not matter because trying
     to look these up in a program should cause OOM anyway. Currently
     this check is added.
   *)
  Definition convert_memory (mem : InfMemMMSP.memory) : OOM (FinMemMMSP.memory).
    refine (elems <- map_monad _ (IntMaps.IM.elements mem);;
            ret (IntMaps.IP.of_list elems)).

    refine (fun '(ix, mb) =>
              (* Check if address fits in finite memory space :) *)
              LLVMParams64BitIntptr.ITOP.int_to_ptr ix PROV.nil_prov;;
              mb' <- convert_mem_byte mb;;
              ret (ix, mb')).
  Defined.

  Definition in_bounds (z:Z) : bool :=
    match LLVMParams64BitIntptr.ITOP.int_to_ptr z PROV.nil_prov with
    | NoOom _ => true
    | Oom _ => false
    end.

  Lemma in_bounds_Z : forall (z:Z), in_bounds z = ((0 <=? z)%Z && (z <? Int64.modulus)%Z)%bool.
  Proof.
    intros z.
    unfold in_bounds.
    unfold LLVMParams64BitIntptr.ITOP.int_to_ptr.
    break_match; break_match_hyp; inversion Heqo; lia.
  Qed.

  Lemma in_bounds_exists_addr : forall z (p:Prov), in_bounds z = true <-> exists addr, LLVMParams64BitIntptr.PTOI.ptr_to_int addr = z /\ snd addr = p.
  Proof.
    intros.
    unfold in_bounds.
    split; intros H.
    - break_match_hyp. exists (fst a, p).
      split; auto.
      unfold LLVMParams64BitIntptr.ITOP.int_to_ptr in Heqo.
      break_match_hyp; inversion Heqo.
      unfold LLVMParams64BitIntptr.PTOI.ptr_to_int. cbn.
      apply unsigned_repr_eq. lia.
      inversion H.
    - destruct H as [ptr [HP HPROV]].
      subst.
      unfold LLVMParams64BitIntptr.ITOP.int_to_ptr.
      unfold LLVMParams64BitIntptr.PTOI.ptr_to_int.
      break_match.
      break_match_hyp; inversion Heqo.
      reflexivity.
      break_match_hyp; inversion Heqo.
      destruct ptr.
      clear Heqo H0.
      cbn in *.
      rewrite <- Heqb.
      unfold FiniteAddresses.Iptr in i.
      destruct i.
      cbn.
      lia.
  Qed.

  Lemma in_bounds_exists_addr' : forall z, in_bounds z = true <-> exists addr, LLVMParams64BitIntptr.PTOI.ptr_to_int addr = z.
  Proof.
    intros.
    unfold in_bounds.
    split; intros H.
    - break_match_hyp_inv.
      exists (fst a, FinPROV.nil_prov).
      unfold LLVMParams64BitIntptr.ITOP.int_to_ptr in Heqo.
      break_match_hyp; inversion Heqo.
      unfold LLVMParams64BitIntptr.PTOI.ptr_to_int. cbn.
      apply unsigned_repr_eq. lia.
    - destruct H as [ptr HP].
      subst.
      unfold LLVMParams64BitIntptr.ITOP.int_to_ptr.
      unfold LLVMParams64BitIntptr.PTOI.ptr_to_int.
      break_match.
      break_match_hyp; inversion Heqo.
      reflexivity.
      break_match_hyp; inversion Heqo.
      destruct ptr.
      clear Heqo H0.
      cbn in *.
      rewrite <- Heqb.
      unfold FiniteAddresses.Iptr in i.
      destruct i.
      cbn.
      lia.
  Qed.

  Lemma in_bounds_ptr_to_int_fin :
    forall addr_fin,
      is_true (in_bounds (LLVMParams64BitIntptr.PTOI.ptr_to_int addr_fin)).
  Proof.
    intros addr_fin.
    eapply in_bounds_exists_addr'; eauto.
  Qed.

  Definition lift_memory (mem : FinMemMMSP.memory) : InfMemMMSP.memory :=
    let mem' := IntMaps.IP.filter_dom in_bounds mem in
    IntMaps.IM.map lift_mem_byte mem'.

  Lemma Forall2_cons_inversion :
    forall {A B} f (x:A) (y:B) xs ys,
      Forall2 f (x::xs) (y::ys) -> f x y /\ Forall2 f xs ys.
  Proof.
    intros.
    inversion H; subst.
    tauto.
  Qed.

  Lemma filter_dom_map_eq :
    forall {A B} (f : IntMaps.IM.key -> bool) (g : A -> B) (m : IntMaps.IntMap A) ,
      forall k e,
        IntMaps.IM.MapsTo k e (IntMaps.IM.map g (IntMaps.IP.filter_dom f m))
        <->
          IntMaps.IM.MapsTo k e (IntMaps.IP.filter_dom f (IntMaps.IM.map g m)).
  Proof.
    intros.
    unfold IntMaps.IP.filter_dom.
    split; intros H.
    - rewrite IntMaps.IP.filter_iff.
      apply IntMaps.IP.F.map_mapsto_iff in H.
      destruct H as [a [EQ HM]].
      apply IntMaps.IP.filter_iff in HM.
      destruct HM.
      split; auto.
      apply IntMaps.IP.F.map_mapsto_iff.
      exists a. tauto.
      repeat red; intros; subst; auto.
      repeat red; intros; subst; auto.
    - rewrite IntMaps.IP.filter_iff in H.
      destruct H.
      apply IntMaps.IP.F.map_mapsto_iff in H.
      destruct H as [a [EQ HM]].
      apply IntMaps.IP.F.map_mapsto_iff.
      exists a. split; auto.
      apply IntMaps.IP.filter_iff; auto.
      repeat red; intros; subst; auto.
      repeat red; intros; subst; auto.
  Qed.

  Lemma MapsTo_filter_true :
    forall {A} (f : IntMaps.IM.key -> A -> bool) m,
    forall k e,
       (f k e = true /\ IntMaps.IM.MapsTo k e m) <->
        IntMaps.IM.MapsTo k e (IntMaps.IP.filter f m).
  Proof.
    intros.
    split; intros.
    - apply IntMaps.IP.filter_iff.
      + repeat red; intros; subst; auto.
      + tauto.
    - apply IntMaps.IP.filter_iff in H.
      + tauto.
      + repeat red; intros; subst; auto.
  Qed.

  Lemma MapsTo_filter_subset :
    forall {A} (f : IntMaps.IM.key -> A -> bool) m,
    forall k e,
      IntMaps.IM.MapsTo k e (IntMaps.IP.filter f m) ->
      IntMaps.IM.MapsTo k e m.
  Proof.
    intros.
    apply IntMaps.IP.filter_iff in H.
    + tauto.
    + repeat red; intros; subst; auto.
  Qed.

  Lemma not_MapsTo_filter :
    forall {A} (f : IntMaps.IM.key -> A -> bool) m,
    forall k e,
      ~ IntMaps.IM.MapsTo k e m ->
      ~ IntMaps.IM.MapsTo k e (IntMaps.IP.filter f m).
  Proof.
    intros.
    intro C.
    apply H.
    eapply MapsTo_filter_subset.
    eauto.
  Qed.

  Lemma MapsTo_filter_dom_true :
    forall {A} (f : IntMaps.IM.key -> bool) (m : IntMaps.IntMap A),
    forall k e,
      (f k = true /\ IntMaps.IM.MapsTo k e m) <->
        IntMaps.IM.MapsTo k e (IntMaps.IP.filter_dom f m).
  Proof.
    intros.
    unfold IntMaps.IP.filter_dom.
    rewrite <- MapsTo_filter_true.
    tauto.
  Qed.

  Lemma MapsTo_filter_dom_subset :
    forall {A} (f : IntMaps.IM.key -> bool) (m : IntMaps.IntMap A),
    forall k e,
      IntMaps.IM.MapsTo k e (IntMaps.IP.filter_dom f m) ->
      IntMaps.IM.MapsTo k e m.
  Proof.
    intros.
    unfold IntMaps.IP.filter_dom.
    eapply MapsTo_filter_subset.
    eauto.
  Qed.

  Lemma not_MapsTo_filter_dom :
    forall {A} (f : IntMaps.IM.key -> bool) (m : IntMaps.IntMap A),
    forall k e,
      ~ IntMaps.IM.MapsTo k e m ->
      ~ IntMaps.IM.MapsTo k e (IntMaps.IP.filter_dom f m).
  Proof.
    intros.
    intro C.
    apply H.
    eapply MapsTo_filter_dom_subset.
    eauto.
  Qed.

  Lemma find_filter_true :
    forall {A} (f : IntMaps.IM.key -> A -> bool) (m : IntMaps.IntMap A),
      forall k a,
        IntMaps.IM.find k (IntMaps.IP.filter f m) = Some a <->
          IntMaps.IM.find k m = Some a /\ (f k a = true).
  Proof.
    intros.
    split; intros H.
    - apply IntMaps.IP.F.find_mapsto_iff in H.
      apply IntMaps.IP.filter_iff in H.
      destruct H.
      split; auto.
      apply IntMaps.IP.F.find_mapsto_iff. assumption.
      repeat red; intros; subst; auto.
    - destruct H.
      apply IntMaps.IP.F.find_mapsto_iff.
      apply IntMaps.IP.filter_iff.
      repeat red; intros; subst; auto.
      apply IntMaps.IP.F.find_mapsto_iff in H.
      split; auto.
  Qed.

  Lemma find_filter_dom_true :
    forall {A} (f : IntMaps.IM.key -> bool) (m : IntMaps.IntMap A),
      forall k a,
        IntMaps.IM.find k (IntMaps.IP.filter_dom f m) = Some a <->
          IntMaps.IM.find k m = Some a /\ (f k = true).
  Proof.
    intros.
    unfold IntMaps.IP.filter_dom.
    apply find_filter_true.
  Qed.

  Lemma IntMaps_find_None :
    forall {A} (k : IntMaps.IM.key) (m:IntMaps.IntMap A),
      IntMaps.IM.find k m = None <-> forall e, ~ IntMaps.IM.MapsTo k e m.
  Proof.
    intros.
    split; intros H.
    - intros. intro C.
      apply IntMaps.IP.F.find_mapsto_iff in C.
      rewrite H in C. inversion C.
    - destruct (IntMaps.IM.find k m) eqn:EQ; auto.
      apply IntMaps.IP.F.find_mapsto_iff in EQ.
      apply H in EQ.
      contradiction.
  Qed.

  Lemma find_filter_None :
    forall {A} (f : IntMaps.IM.key -> A -> bool) (m : IntMaps.IntMap A),
    forall k,
      IntMaps.IM.find k m = None ->
        IntMaps.IM.find k (IntMaps.IP.filter f m) = None.
  Proof.
    intros.
    rewrite IntMaps_find_None.
    intros e C.
    rewrite IntMaps_find_None in H.
    specialize (H e).
    apply H.
    apply (MapsTo_filter_subset f m).
    auto.
  Qed.

  Lemma find_filter_dom_None :
    forall {A} (f : IntMaps.IM.key -> bool) (m : IntMaps.IntMap A),
    forall k,
      IntMaps.IM.find k m = None ->
        IntMaps.IM.find k (IntMaps.IP.filter_dom f m) = None.
  Proof.
    intros.
    unfold IntMaps.IP.filter_dom.
    apply find_filter_None.
    assumption.
  Qed.

  Lemma find_filter_dom_false :
    forall {elt m k f},
      f k = false ->
      IntMaps.IM.find (elt:=elt) k (IntMaps.IP.filter_dom f m) = None.
  Proof.
    intros elt m k f F.
    unfold IntMaps.IP.filter_dom.
    apply IntMaps_find_None.
    intros e CONTRA.
    apply IntMaps.IP.filter_iff in CONTRA; try typeclasses eauto.
    destruct CONTRA as [_ CONTRA].
    rewrite F in CONTRA; inv CONTRA.
  Qed.

  #[global] Instance filter_dom_Proper {elt f} :
    Proper (IntMaps.IM.Equal (elt:=elt) ==> IntMaps.IM.Equal) (IntMaps.IP.filter_dom f).
  Proof.
    unfold Proper, respectful.
    intros x y EQ.
    red.
    intros y0.
    destruct (IntMaps.IM.find (elt:=elt) y0 (IntMaps.IP.filter_dom f x)) eqn:FIND.
    - apply find_filter_dom_true in FIND as (FIND&TRUE).
      red in EQ.
      rewrite EQ in FIND.
      symmetry.
      apply find_filter_dom_true.
      split; auto.
    - (* Two ways for this to be none... Either y0 was filtered out,
           or y0 was not in the original map *)
      destruct (IntMaps.IM.find (elt:=elt) y0 x) eqn:FIND'.
      + destruct (f y0) eqn:F.
        * epose proof find_filter_dom_true f x y0 e.
          destruct H.
          forward H0; auto.
          rewrite FIND in H0.
          discriminate.
        * symmetry.
          apply find_filter_dom_false; auto.
      + symmetry.
        apply find_filter_dom_None.
        rewrite <- EQ.
        auto.
  Qed.

  Lemma IntMaps_map_list_map_Equal :
    forall {A B} (f : A -> B) l,
      IntMaps.IM.Equal (IntMaps.IM.map f (IntMaps.IP.of_list l)) (IntMaps.IP.of_list (List.map (fun '(i, x) => (i, f x)) l)).
  Proof.
    (* Only seem to need these for lift_memory_convert_inversion, which currently is unused *)
  Admitted.

  Lemma IntMaps_filter_dom_list_filter_Equal :
    forall {A : Type} (f : IntMaps.IM.key -> bool) (l : list (IntMaps.IM.key * A)),
      IntMaps.IM.Equal (IntMaps.IP.filter_dom f (IntMaps.IP.of_list l))
        (IntMaps.IP.of_list (filter (fun '(i, x) => f i) l)).
  Proof.
    (* Only seem to need these for lift_memory_convert_inversion, which currently is unused *)
  Admitted.

  Lemma lift_memory_convert_memory_inversion :
    forall {mem_inf mem_fin},
      convert_memory mem_inf = NoOom mem_fin ->
      IntMaps.IM.Equal (lift_memory mem_fin) mem_inf.
  Proof.
    intros mem_inf mem_fin H.
    unfold convert_memory in H.
    unfold lift_memory.
    unfold FinMemMMSP.memory in *.
    unfold IntMaps.IM.key in *.
    destruct (map_monad
                (fun '(ix, mb) =>
                   _ <- LLVMParams64BitIntptr.ITOP.int_to_ptr ix PROV.nil_prov;;
                   mb' <- convert_mem_byte mb;; ret (ix, mb'))
                (IntMaps.IM.elements (elt:=InfMemMMSP.mem_byte) mem_inf)) eqn: EQ1; [| inversion H].

    cbn in H.
    inversion H.
    subst; clear H.
    apply map_monad_oom_Forall2 in EQ1.

    apply IntMaps.IP.F.Equal_mapsto_iff.
    intros.

    rewrite filter_dom_map_eq.
    rewrite IntMaps_map_list_map_Equal.
    rewrite IntMaps_filter_dom_list_filter_Equal.
    rewrite IntMaps.IP.of_list_1.
    - rewrite (@IntMaps.IP.F.elements_mapsto_iff _ _ k e).
      revert k e.
      remember (fun (a : Z * InfMemMMSP.mem_byte) (b : Z * FinMemMMSP.mem_byte) =>
             (let
            '(ix, mb) := a in
             _ <- LLVMParams64BitIntptr.ITOP.int_to_ptr ix PROV.nil_prov;;
             mb' <- convert_mem_byte mb;;
             ret (ix, mb')) = NoOom b) as body.
      remember (IntMaps.IM.elements (elt:=InfMemMMSP.mem_byte) mem_inf) as l_inf.
      clear mem_inf Heql_inf.
      revert l_inf EQ1.
      induction l; intros.
      + destruct l_inf.
        * intros. reflexivity.
        * inversion EQ1.
      + destruct l_inf.
        * inversion EQ1.
        * inversion EQ1; subst.
          intros.
          destruct p.
          destruct (LLVMParams64BitIntptr.ITOP.int_to_ptr k0 PROV.nil_prov) eqn: EQ2; [|inversion H2].
          cbn in H2.
          destruct (convert_mem_byte m) eqn: EQ3; [|inversion H2].
          inversion H2.
          subst.
          cbn.
          assert (in_bounds k0 = true) as IN_BOUNDS.
          { apply in_bounds_exists_addr'.
            exists a0.
            erewrite ITOP.ptr_to_int_int_to_ptr; eauto.
          }
          rewrite IN_BOUNDS.
          split; intros.
          -- apply SetoidList.InA_cons in H.
             destruct H as [HEQ | HR].
             ++ inversion HEQ.
                cbn in H. cbn in H0.
                subst.
                apply lift_mem_byte_convert_mem_byte_inversion in EQ3.
                rewrite EQ3.
                apply SetoidList.InA_cons_hd. reflexivity.
             ++ apply SetoidList.InA_cons_tl.
                apply IHl.
                apply Forall2_cons_inversion in EQ1.
                destruct EQ1 as [_ H].
                apply H.
                assumption.
          -- apply SetoidList.InA_cons in H.
             destruct H as [HEQ | HR].
             ++ inversion HEQ.
                cbn in H. cbn in H0.
                subst.
                apply lift_mem_byte_convert_mem_byte_inversion in EQ3.
                rewrite EQ3.
                apply SetoidList.InA_cons_hd. reflexivity.
             ++ apply SetoidList.InA_cons_tl.
                apply (@IHl l_inf).
                apply Forall2_cons_inversion in EQ1.
                destruct EQ1 as [_ H].
                apply H.
                assumption.
    - clear k. clear e.
      assert (SetoidList.NoDupA (IntMaps.IM.eq_key (elt:=InfMemMMSP.mem_byte))
                (IntMaps.IM.elements mem_inf)).
      { apply IntMaps.IM.elements_3w. }
      remember (IntMaps.IM.elements (elt:=InfMemMMSP.mem_byte) mem_inf) as l_inf.
      clear mem_inf Heql_inf.
      revert l EQ1.
      induction H; intros.
      + inversion EQ1. subst. cbn. auto.
      + inversion EQ1. subst. cbn.
        destruct x.
        destruct (LLVMParams64BitIntptr.ITOP.int_to_ptr k PROV.nil_prov) eqn: EQ2; [|inversion H3].
        cbn in H3.
        destruct (convert_mem_byte m) eqn: EQ3; [|inversion H3].
        inversion H3.
        subst. clear H3.

        assert (in_bounds k = true) as IN_BOUNDS.
        { apply in_bounds_exists_addr'.
          exists a.
          erewrite ITOP.ptr_to_int_int_to_ptr; eauto.
        }
        rewrite IN_BOUNDS.

        constructor.
        2 : { apply IHNoDupA. assumption. }
        intros X.
        apply H.
        clear H H0 IHNoDupA EQ1 a EQ2 EQ3.

        induction H5.
        * inversion X.
        * destruct x.
          destruct (LLVMParams64BitIntptr.ITOP.int_to_ptr z PROV.nil_prov) eqn: EQ2; [|inversion H].
          cbn in H.
          destruct (convert_mem_byte m1) eqn: EQ3; [|inversion H].
          inversion H.
          subst. clear H.
          cbn in X.
          assert (in_bounds z = true) as IN_BOUNDS'.
          { apply in_bounds_exists_addr'.
            exists a.
            erewrite ITOP.ptr_to_int_int_to_ptr; eauto.
          }
          rewrite IN_BOUNDS' in X.

          apply SetoidList.InA_cons in X.
          destruct X as [HEQ | HR].
          -- apply SetoidList.InA_cons_hd.
             apply HEQ.
          -- apply SetoidList.InA_cons_tl.
             apply IHForall2.
             apply HR.
  Qed.

  Definition convert_Frame (f : InfMemMMSP.Frame) : OOM (FinMemMMSP.Frame) :=
    map_monad InfToFinAddrConvert.addr_convert f.

  Definition lift_Frame (f : FinMemMMSP.Frame) : InfMemMMSP.Frame :=
    map fin_to_inf_addr f.

  Definition convert_FrameStack (fs : InfMemMMSP.FrameStack) : OOM (FinMemMMSP.FrameStack).
    induction fs.
    - refine (f' <- convert_Frame f;;
              ret (FinMemMMSP.Singleton f')).
    - refine (f' <- convert_Frame f;;
              fs' <- IHfs;;
              ret (FinMemMMSP.Snoc fs' f')).
  Defined.

  Definition lift_FrameStack (fs : FinMemMMSP.FrameStack) : InfMemMMSP.FrameStack.
    induction fs.
    - refine (let f' := lift_Frame f in
              InfMemMMSP.Singleton f').
    - refine (let f' := lift_Frame f in
              InfMemMMSP.Snoc IHfs f').
  Defined.

  Definition convert_Block (b : InfMemMMSP.Block) : OOM (FinMemMMSP.Block)
    := map_monad InfToFinAddrConvert.addr_convert b.

  Lemma addr_convert_map_fin_to_inf_addr_inv :
    forall l_inf l_fin,
      map_monad InfToFinAddrConvert.addr_convert l_inf = NoOom l_fin ->
      map fin_to_inf_addr l_fin = l_inf.
  Proof.
    intros l_inf l_fin.
    revert l_inf.
    induction l_fin; intros; cbn in *.
    - destruct l_inf; cbn in H; auto.
      break_match_hyp; auto.
      + break_match; inversion H.
      + inversion H.
    - destruct l_inf; cbn in *; auto.
      + inversion H.
      + break_match_hyp.
        * break_match_hyp.
          -- inversion H; subst.
             apply lift_addr_Convert_addr_inverse in Heqo.
             rewrite Heqo.
             erewrite IHl_fin.
             reflexivity.
             apply Heqo0.
          -- inversion H.
        * inversion H.
  Qed.

  Lemma map_fin_to_inf_addr_convert_succeeds :
    forall {l_fin},
      map_monad InfToFinAddrConvert.addr_convert (map fin_to_inf_addr l_fin) = NoOom l_fin.
  Proof.
    induction l_fin; intros; cbn in *.
    - reflexivity.
    - rewrite addr_convert_fin_to_inf_addr.
      rewrite IHl_fin.
      reflexivity.
  Qed.

  Definition lift_Block (b : FinMemMMSP.Block) : InfMemMMSP.Block
    := map fin_to_inf_addr b.

  Lemma lift_Block_convert_Block_inverse :
    forall {b_inf b_fin},
      convert_Block b_inf = NoOom b_fin ->
      lift_Block b_fin = b_inf.
  Proof.
    apply addr_convert_map_fin_to_inf_addr_inv.
  Qed.

  Definition convert_Heap (h : InfMemMMSP.Heap) : OOM (FinMemMMSP.Heap).
    refine (blocks <- map_monad _ (IntMaps.IM.elements h);;
            ret (IntMaps.IP.of_list blocks)).

    refine (fun '(ix, b) =>
              b' <- convert_Block b;;
              ret (ix, b')).
  Defined.

  Definition lift_Heap (h : FinMemMMSP.Heap) : InfMemMMSP.Heap
    :=
    let h' := IntMaps.IP.filter_dom in_bounds h in
    IntMaps.IM.map lift_Block h'.

  Lemma convert_Heap_find_block :
    forall {h_inf h_fin k b},
      convert_Heap h_inf = NoOom h_fin ->
      IntMaps.IM.find k h_inf = Some b ->
      exists b',
        IntMaps.IM.find k h_fin = Some b' /\
          convert_Block b = NoOom b'.
  Proof.
    intros h_inf h_fin k b H H0.
  Admitted.

  Lemma fin_inf_ptoi :
    forall a a',
      InfToFinAddrConvert.addr_convert a' = NoOom a ->
      LLVMParams64BitIntptr.PTOI.ptr_to_int a = LLVMParamsBigIntptr.PTOI.ptr_to_int a'.
  Proof.
    intros a a' H.
    unfold InfToFinAddrConvert.addr_convert in H.
    destruct a'.
    apply ITOP.ptr_to_int_int_to_ptr in H.
    rewrite H.
    unfold LLVMParamsBigIntptr.PTOI.ptr_to_int.
    reflexivity.
  Qed.

  Lemma fin_inf_from_Z :
    forall ip_f z,
      LLVMParams64BitIntptr.IP.from_Z z = NoOom ip_f ->
      exists ip_i,
        LLVMParamsBigIntptr.IP.from_Z z = NoOom ip_i.
  Proof.
    intros ip_f z H.

    unfold LLVMParams64BitIntptr.IP.from_Z in H.
    pose proof (IP.from_Z_to_Z z ip_f H).
    exists z.
    unfold LLVMParamsBigIntptr.IP.from_Z.
    cbn.
    reflexivity.
  Qed.

  (* TODO: Move this and use it in picky intptr reasoning admits *)
  Lemma fin_inf_from_Z_to_Z :
    forall z x y,
      LLVMParamsBigIntptr.IP.from_Z z = NoOom x ->
      LLVMParams64BitIntptr.IP.from_Z z = NoOom y ->
      LLVMParams64BitIntptr.IP.to_Z y = LLVMParamsBigIntptr.IP.to_Z x.
  Proof.
    intros z x y ZX ZY.
    pose proof BigIP.from_Z_to_Z z x ZX.
    pose proof IP.from_Z_to_Z z y ZY.
    rewrite H, H0.
    auto.
  Qed.

    (* TODO: Move this *)
  Lemma fin_to_inf_addr_ptr_to_int :
    forall ptr,
      LLVMParamsBigIntptr.PTOI.ptr_to_int (fin_to_inf_addr ptr) = LLVMParams64BitIntptr.PTOI.ptr_to_int ptr.
  Proof.
    intros ptr.
    destruct ptr.
    unfold fin_to_inf_addr.
    break_match_goal.
    erewrite fin_inf_ptoi; eauto.
    apply FinToInfAddrConvertSafe.addr_convert_safe; auto.
  Qed.

  Lemma fin_ptr_to_int_in_bounds:
    forall (ptr : FinAddr.addr),
          in_bounds (LLVMParams64BitIntptr.PTOI.ptr_to_int ptr) = true.
  Proof.
    intros.
    destruct ptr.
    unfold LLVMParams64BitIntptr.PTOI.ptr_to_int. cbn.
    eapply in_bounds_exists_addr.
    exists (i,p); auto.
  Qed.

  Lemma find_ptr_to_int_lift_Heap :
    forall h ptr,
      IntMaps.IM.find (LLVMParams64BitIntptr.PTOI.ptr_to_int ptr) (lift_Heap h) =
        option_map lift_Block (IntMaps.IM.find (LLVMParams64BitIntptr.PTOI.ptr_to_int ptr) h).
  Proof.
    intros.
    unfold lift_Heap.

    unfold option_map.
    break_match.
    - apply IntMaps.IP.F.find_mapsto_iff in Heqo.
      apply IntMaps.IP.F.find_mapsto_iff.
      apply IntMaps.IP.F.map_mapsto_iff.
      exists b. split; auto.
      apply MapsTo_filter_dom_true.
      split.
      apply fin_ptr_to_int_in_bounds.
      assumption.
    - rewrite IntMaps.IP.F.map_o.
      apply (find_filter_dom_None in_bounds) in Heqo.
      rewrite Heqo.
      reflexivity.
  Qed.

  Lemma convert_Block_lift :
    forall b,
      convert_Block (lift_Block b) = NoOom b.
  Proof.
    unfold lift_Block.
    unfold convert_Block.
    intros b.
    apply map_monad_oom_Forall2.
    induction b.
    - cbn.
      constructor.
    - cbn.
      constructor; auto.
      apply addr_convert_fin_to_inf_addr.
  Qed.

  Lemma IntMaps_MapsTo_not_Empty :
    forall elt k e m,
      IntMaps.IM.MapsTo k e m ->
      ~ IntMaps.IM.Empty (elt:=elt) m.
  Proof.
    intros elt k e m MAPS.
    intros CONTRA.
    eapply CONTRA.
    eapply MAPS.
  Qed.

  Lemma IntMaps_empty_map :
    forall {elt elt'} m f,
      IntMaps.IM.Empty (elt:=elt') (IntMaps.IM.map f m) ->
      IntMaps.IM.Empty (elt:=elt) m.
  Proof.
    intros elt elt'.
    induction m using IntMaps.IP.map_induction;
      intros f EMPTY; eauto.

    intros k e' CONTRA.
    eapply EMPTY.
    apply IntMaps.IP.F.find_mapsto_iff.
    rewrite (@IntMaps.IP.F.map_o elt elt' m2 x f).
    specialize (H0 x).
    rewrite IntMaps.IP.F.add_eq_o in H0; auto.
    rewrite H0.
    reflexivity.
  Qed.

  Lemma In_MapsTo_exists :
    forall {A} x (m : IntMaps.IntMap A),
      IntMaps.IM.In x m <->
        exists v, IntMaps.IM.MapsTo x v m.
  Proof.
    intros.
    split; intros.
    - rewrite IntMaps.IP.F.mem_in_iff in H.
      assert (IntMaps.member x m = true).
      unfold IntMaps.member. assumption.
      apply IntMaps.member_lookup in H0.
      destruct H0 as [v HV].
      exists v. unfold IntMaps.lookup in HV.
      apply IntMaps.IM.find_2 in HV.
      assumption.
    - destruct H as [v HV].
      rewrite IntMaps.IP.F.mem_in_iff.
      apply IntMaps.IM.find_1 in HV.
      eapply IntMaps.lookup_member.
      apply HV.
  Qed.

  Lemma root_in_heap_prop_lift :
    forall h root,
      FinMem.MMEP.MMSP.root_in_heap_prop h root ->
      InfMem.MMEP.MMSP.root_in_heap_prop (lift_Heap h) (fin_to_inf_addr root).
  Proof.
    intros h root H.
    unfold FinMem.MMEP.MMSP.root_in_heap_prop in H.
    unfold InfMem.MMEP.MMSP.root_in_heap_prop.
    rewrite fin_to_inf_addr_ptr_to_int.
    unfold lift_Heap.
    unfold IntMaps.member in *.
    apply IntMaps.IP.F.mem_in_iff.
    apply IntMaps.IP.F.mem_in_iff in H.
    apply In_MapsTo_exists.
    rewrite In_MapsTo_exists in H.
    destruct H as [b HM].
    exists (lift_Block b).
    rewrite filter_dom_map_eq.
    apply MapsTo_filter_dom_true.
    split.
    - apply fin_ptr_to_int_in_bounds.
    - apply IntMaps.IM.map_1.
      assumption.
  Qed.

  Definition convert_memory_stack (ms1 : InfMemMMSP.memory_stack) : OOM (FinMemMMSP.memory_stack).
    destruct ms1 as [mem fs h].
    refine (mem' <- convert_memory mem;;
            fs' <- convert_FrameStack fs;;
            h' <- convert_Heap h;;
            ret _).

    constructor; auto.
  Defined.

  Definition lift_memory_stack (ms1 : FinMemMMSP.memory_stack) : InfMemMMSP.memory_stack.
    destruct ms1 as [mem fs h].
    refine (let mem' := lift_memory mem in
            let fs' := lift_FrameStack fs in
            let h' := lift_Heap h in
            _).

    constructor; auto.
  Defined.

  (* TODO: Move this *)
  Lemma lift_memory_stack_convert_memory_stack_inverse :
    forall {ms_inf ms_fin},
      convert_memory_stack ms_inf = NoOom ms_fin ->
      lift_memory_stack ms_fin = ms_inf.
  Proof.
  Abort.

  Definition convert_MemState (m1 : InfMem.MMEP.MMSP.MemState) : OOM (FinMem.MMEP.MMSP.MemState).
    destruct m1 as [ms pr].
    refine (ms' <- convert_memory_stack ms;;
            ret _).

    constructor; auto.
  Defined.

  Definition lift_MemState (m1 : FinMem.MMEP.MMSP.MemState) : InfMem.MMEP.MMSP.MemState.
    destruct m1 as [ms pr].
    refine (let ms' := lift_memory_stack ms in
            _).

    constructor; auto.
  Defined.

  Definition MemState_refine (m1 : InfMem.MMEP.MMSP.MemState) (m2 : FinMem.MMEP.MMSP.MemState) : Prop
    := convert_MemState m1 = NoOom m2.

  Lemma MemState_refine_initial :
    MemState_refine InfMemMMSP.initial_memory_state FinMemMMSP.initial_memory_state.
  Proof.
    reflexivity.
  Qed.

  Definition Heap_in_bounds (ms_fin:FinMem.MMEP.MMSP.MemState) : Prop :=
    let h := Memory64BitIntptr.MMEP.MMSP.mem_state_heap ms_fin in
    forall i, is_true (IntMaps.member i h) -> exists ptr, FinPTOI.ptr_to_int ptr = i.

  Definition memory_in_bounds (ms_fin:FinMem.MMEP.MMSP.MemState) : Prop :=
    let mem := Memory64BitIntptr.MMEP.MMSP.mem_state_memory ms_fin in
    forall i, is_true (IntMaps.member i mem) -> exists ptr, FinPTOI.ptr_to_int ptr = i.

  Definition MemState_in_bounds (ms_fin:FinMem.MMEP.MMSP.MemState) :=
    Heap_in_bounds ms_fin /\ memory_in_bounds ms_fin.

  Lemma lift_mem_byte_convert_mem_byte_inverse :
    forall {mb_fin},
      convert_mem_byte (lift_mem_byte mb_fin) = NoOom mb_fin.
  Proof.
    intros.
    unfold convert_mem_byte.
    destruct mb_fin.
    cbn.
    rewrite sbyte_refine_lifted.
    reflexivity.
  Qed.
  
Lemma lift_memory_convert_mem_byte :
    forall {ms k m},
      In (k, m) (IntMaps.IM.elements (elt:=InfMemMMSP.mem_byte) (lift_memory ms)) ->
      is_true (in_bounds k) /\
        exists m', convert_mem_byte m = NoOom m'.
  Proof.
    intros ms k m ELEM.
    apply MemoryBigIntptr.MMEP.MMSP.In_InA in ELEM.
    apply IntMaps.IM.elements_2 in ELEM.
    unfold lift_memory in ELEM.
    eapply filter_dom_map_eq in ELEM.
    apply IntMaps.IP.F.find_mapsto_iff in ELEM.
    apply find_filter_dom_true in ELEM.
    destruct ELEM as (FIND & IN_BOUNDS).
    rewrite IntMaps.IP.F.map_o in FIND.
    unfold option_map in FIND.
    break_match_hyp_inv.
    split; eauto.
    rewrite lift_mem_byte_convert_mem_byte_inverse.
    exists m0; auto.    
  Qed.

  Lemma convert_memory_inv :
    forall ms,
      exists ms',
        convert_memory (lift_memory ms) = NoOom ms'.
  Proof.
    intros ms.
    Opaque lift_memory.
    cbn.
    Transparent lift_memory.
    break_inner_match_goal.
    2: {
      apply map_monad_OOM_fail in Heqo.
      destruct Heqo as (?&?&?).
      destruct x.

      pose proof lift_memory_convert_mem_byte H
        as (IN_BOUNDS & (m' & CONV)).
      rewrite CONV in H0.
      unfold LLVMParams64BitIntptr.ITOP.int_to_ptr in *.
      pose proof in_bounds_Z k.
      break_inner_match_hyp; try discriminate.
      rewrite IN_BOUNDS in H1.
      lia.
    }

    eexists; eauto.
  Qed.

  Lemma fin_to_inf_dvalue_refine_strict :
    forall d,
      DVC1.dvalue_refine_strict (fin_to_inf_dvalue d) d.
  Proof.
    intros d.
    rewrite DVC1.dvalue_refine_strict_equation.
    unfold fin_to_inf_dvalue.
    break_match; cbn in *.
    destruct p.
    auto.
  Qed.

  Lemma fin_to_inf_uvalue_refine_strict :
    forall u,
      DVC1.uvalue_refine_strict (fin_to_inf_uvalue u) u.
  Proof.
    intros u.
    rewrite DVC1.uvalue_refine_strict_equation.
    unfold fin_to_inf_uvalue.
    break_match; cbn in *.
    destruct p.
    auto.
  Qed.

  Import AListFacts.

  Definition lift_local_env (lenv : InterpreterStack64BitIntptr.LLVM.Local.local_env) : InterpreterStackBigIntptr.LLVM.Local.local_env.
    refine (map _ lenv).

    refine (fun '(ix, uv) =>
              let uv' := fin_to_inf_uvalue uv in
              (ix, uv')).
  Defined.

  Definition lift_global_env (genv : InterpreterStack64BitIntptr.LLVM.Global.global_env) : InterpreterStackBigIntptr.LLVM.Global.global_env.
    refine (map _ genv).

    refine (fun '(ix, dv) =>
              let dv' := fin_to_inf_dvalue dv in
              (ix, dv')).
  Defined.

  Definition lift_stack (stack : InterpreterStack64BitIntptr.LLVM.Stack.lstack) : InterpreterStackBigIntptr.LLVM.Stack.lstack.
    induction stack.
    - exact [].
    - exact (lift_local_env a :: IHstack).
  Defined.

  Lemma lift_local_env_refine_strict :
    forall l,
      local_refine_strict (lift_local_env l) l.
  Proof.
    induction l.
    - cbn.
      apply alist_refine_empty.
    - destruct a.
      apply alist_refine_cons; cbn; auto.
      apply fin_to_inf_uvalue_refine_strict.
  Qed.

  Lemma lift_stack_refine_strict :
    forall s,
      stack_refine_strict (lift_stack s) s.
  Proof.
    induction s.
    - cbn.
      apply stack_refine_strict_empty.
    - apply stack_refine_strict_add; auto.
      apply lift_local_env_refine_strict.
  Qed.

  Lemma lift_global_env_refine_strict :
    forall g,
      global_refine_strict (lift_global_env g) g.
  Proof.
    induction g.
    - cbn.
      apply alist_refine_empty.
    - destruct a.
      apply alist_refine_cons; cbn; auto.
      apply fin_to_inf_dvalue_refine_strict.
  Qed.

  Lemma convert_Frame_lift :
    forall f,
    exists f',
      convert_Frame (lift_Frame f) = NoOom f' /\
        FinMem.MMEP.MMSP.frame_eqv f f'.
  Proof.
    intros f.
    induction f.
    - cbn.
      eexists; split; eauto.
      reflexivity.
    - cbn.
      destruct IHf as (f'&CONV&EQV).
      rewrite addr_convert_fin_to_inf_addr.
      setoid_rewrite CONV.
      eexists; split; eauto.
      rewrite EQV.
      reflexivity.
  Qed.

  Lemma convert_FrameStack_lift :
    forall fs,
    exists fs',
      convert_FrameStack (lift_FrameStack fs) = NoOom fs' /\
        FinMem.MMEP.MMSP.frame_stack_eqv fs fs'.
  Proof.
    induction fs.
    - cbn.
      pose proof (convert_Frame_lift f) as (f'&CONV&EQV).
      rewrite CONV.
      eexists; split; eauto.
      rewrite EQV.
      reflexivity.
    - destruct IHfs as (fs' & CONV & EQV).
      pose proof (convert_Frame_lift f) as (f'&CONVf&EQVf).
      cbn.
      rewrite CONVf.
      setoid_rewrite CONV.
      eexists; split; eauto.
      rewrite EQVf, EQV.
      reflexivity.
  Qed.

  Lemma MapsTo_filter_dom_subset_strong :
    forall {A} x v f (m : IntMaps.IntMap A),
    IntMaps.IM.MapsTo x v (IntMaps.IP.filter_dom f m) ->
    IntMaps.IM.MapsTo x v m /\ f x = true.
  Proof.
    intros.
    apply IntMaps.IP.filter_iff in H; auto.
    repeat red; intros; subst; auto.
  Qed.

  Require Import ITree.Eq.EuttExtras.

  Lemma paco2_eq_itree_refl : forall E R r (t : itree E R), paco2 (eqit_ eq false false id) r t t.
  Proof.
    intros. eapply paco2_mon with (r := bot2); intuition.
    enough (t â‰… t); auto. reflexivity.
  Qed.


  (* (* TODO: Move this *) *)
  (* Definition heap_refine (h1 : InfMemMMSP.Heap) (h2 : FinMemMMSP.Heap) : Prop *)
  (*   := MemoryBigIntptr.MMEP.MemSpec.heap_preserved h1 (lift_Heap h2). *)

  (* TODO: Move this *)
  (* TODO: This may not be true... The roots are just keys in the map *)
  (*    for the heap, so nothing is forcing them to be in bounds for *)
  (*    finite memory... May be able to use MemState_refine_prop's *)
  (*    heap_preserved component to ensure this, though? *)
  (*  *)
  (* TODO: Will need the heap in bounds predicate *)
  Lemma root_in_heap_prop_lift_inv :
    forall {h root_inf},
      InfMem.MMEP.MMSP.root_in_heap_prop (lift_Heap h) root_inf ->
      exists root_fin,
        InfToFinAddrConvert.addr_convert root_inf = NoOom root_fin /\
        FinMem.MMEP.MMSP.root_in_heap_prop h root_fin.
  Proof.
    intros h root_inf IN.
    red in IN.
    apply IntMaps.member_lookup in IN.
    destruct IN as [v HV].
    unfold IntMaps.lookup in HV.
    unfold InfMem.MMEP.MMSP.Block in HV.
    unfold InfMemMMSP.Block in *.
    unfold lift_Heap in HV.
    apply IntMaps.IP.F.find_mapsto_iff in HV.
    apply filter_dom_map_eq in HV.
    apply MapsTo_filter_dom_subset_strong in HV.
    destruct HV as [HV IN].
    destruct root_inf.
    cbn in *.
    apply (in_bounds_exists_addr i p) in IN.
    destruct IN as [root_fin [HF EQ]].
    exists root_fin.
    split.
    - destruct root_fin. cbn in *.
      subst.
      apply LLVMParams64BitIntptr.ITOP.int_to_ptr_ptr_to_int. auto.
    - unfold FinMem.MMEP.MMSP.root_in_heap_prop.
      unfold IntMaps.member.
      apply IntMaps.IP.F.mem_in_iff.
      rewrite HF.
      apply IntMaps.IP.F.map_mapsto_iff in HV.
      destruct HV as [b [_ HIN]].
      apply In_MapsTo_exists.
      exists b.
      assumption.
  Qed.

  (* TODO: Move this *)
  Lemma ptr_in_heap_prop_intmap_elements_inf :
    forall {h root root_ptr block addr},
      LLVMParamsBigIntptr.PTOI.ptr_to_int root_ptr = root ->
      In (root, block) (IntMaps.IM.elements (elt:=InfMemMMSP.Block) h) ->
      In addr block ->
      InfMemMMSP.ptr_in_heap_prop h root_ptr addr.
  Proof.
    intros h root root_ptr block addr PTOI ELEMS BLOCK.
    red.
    eapply SetoidList.In_InA in ELEMS.
    eapply IntMaps.IP.F.elements_mapsto_iff in ELEMS.
    2: typeclasses eauto.
    eapply IntMaps.IP.F.find_mapsto_iff in ELEMS.
    rewrite PTOI, ELEMS.
    apply in_map; auto.
  Qed.

  (* TODO: Move this *)
  Lemma ptr_in_heap_prop_intmap_elements_fin :
    forall {h root root_ptr block addr},
      LLVMParams64BitIntptr.PTOI.ptr_to_int root_ptr = root ->
      In (root, block) (IntMaps.IM.elements (elt:=FinMemMMSP.Block) h) ->
      In addr block ->
      FinMemMMSP.ptr_in_heap_prop h root_ptr addr.
  Proof.
    intros h root root_ptr block addr PTOI ELEMS BLOCK.
    red.
    eapply SetoidList.In_InA in ELEMS.
    eapply IntMaps.IP.F.elements_mapsto_iff in ELEMS.
    2: typeclasses eauto.
    eapply IntMaps.IP.F.find_mapsto_iff in ELEMS.
    rewrite PTOI, ELEMS.
    apply in_map; auto.
  Qed.

  (* TODO: Move this *)
  Lemma every_int_has_big_ptr :
    forall z,
    exists addr, LLVMParamsBigIntptr.PTOI.ptr_to_int addr = z.
  Proof.
    intros z.
    pose proof (InfITOP_BIG.int_to_ptr_safe z InfPROV.nil_prov).
    break_match_hyp_inv.
    exists a.
    erewrite InterpreterStackBigIntptr.LP.ITOP.ptr_to_int_int_to_ptr; eauto.
  Qed.

  (* TODO: Move this *)
  Lemma ptr_in_heap_prop_lift_inv' :
    forall {h root_inf root_fin ptr_inf},
      InfMem.MMEP.MMSP.ptr_in_heap_prop (lift_Heap h) root_inf ptr_inf ->
      InfToFinAddrConvert.addr_convert root_inf = NoOom root_fin ->
      exists ptr_fin,
        InfToFinAddrConvert.addr_convert ptr_inf = NoOom ptr_fin /\
          FinMem.MMEP.MMSP.ptr_in_heap_prop h root_fin ptr_fin.
  Proof.
    intros h root_inf root_fin ptr_inf IN CONV.
    red in IN.
    unfold lift_Heap, lift_Block in IN.
    unfold FinMem.MMEP.MMSP.ptr_in_heap_prop.

    rewrite IntMaps.IP.F.map_o in IN.
    break_match_hyp; try contradiction.
    apply Util.option_map_some_inv in Heqo as (?&?&?).

    erewrite fin_inf_ptoi; eauto.
    apply find_filter_dom_true in H.
    destruct H as [H HB].
    rewrite H.

    generalize dependent b.
    clear H.
    induction x; intros b H0 IN.
    - cbn in *.
      inv H0.
      cbn in *.
      contradiction.
    - cbn in *.
      inv H0.
      destruct IN as [IN | IN].
      + destruct a.
        destruct ptr_inf.
        exists (i, p0).
        split; auto.
        {
          rewrite fin_to_inf_addr_ptr_to_int in IN.
          cbn in IN.
          unfold LLVMParams64BitIntptr.PTOI.ptr_to_int in IN.
          cbn in IN; subst.

          cbn.
          unfold FinITOP.int_to_ptr.
          break_match.
          {
            pose proof Integers.Int64.unsigned_range i.
            lia.
          }

          rewrite Int64.repr_unsigned.
          auto.
        }
      + rewrite List.map_map in IN.
        apply in_map_iff in IN.
        pose proof IN as IN'.
        destruct IN as (?&?&?).

        specialize (IHx _ eq_refl).
        forward IHx.
        { rewrite List.map_map.
          apply in_map_iff.
          auto.
        }

        destruct IHx as (?&?&?).
        exists x1.
        split; auto.
  Qed.

  (* TODO: Move this *)
  Lemma ptr_in_heap_prop_lift :
    forall h root ptr,
      FinMem.MMEP.MMSP.ptr_in_heap_prop h root ptr ->
      InfMem.MMEP.MMSP.ptr_in_heap_prop (lift_Heap h) (fin_to_inf_addr root) (fin_to_inf_addr ptr).
  Proof.
    intros h root ptr IN.
    red in *.
    rewrite fin_to_inf_addr_ptr_to_int.
    rewrite find_ptr_to_int_lift_Heap.

    destruct (IntMaps.IM.find (elt:=FinMem.MMEP.MMSP.Block) (LLVMParams64BitIntptr.PTOI.ptr_to_int root) h) eqn: EQ; simpl in *.
    - unfold lift_Block.
      apply in_map_iff in IN.
      destruct IN as [addr [EQ' HI]].
      apply in_map_iff.
      exists (fin_to_inf_addr addr).
      split.
      rewrite fin_to_inf_addr_ptr_to_int.
      rewrite fin_to_inf_addr_ptr_to_int.
      assumption.
      apply in_map.
      assumption.
    - contradiction.
  Qed.

  Lemma ptr_in_heap_prop_addr_convert:
    forall {h root_inf ptr_inf},
      InfMem.MMEP.MMSP.ptr_in_heap_prop (lift_Heap h) root_inf ptr_inf ->
      exists root_fin,
      InfToFinAddrConvert.addr_convert root_inf = NoOom root_fin.
  Proof.
    intros h root_inf ptr_inf IN.
    red in IN.
    unfold lift_Heap, lift_Block in IN.
    break_match_hyp; try contradiction.
    apply IntMaps.IP.F.find_mapsto_iff in Heqo.
    apply IntMaps.IP.F.map_mapsto_iff in Heqo.
    destruct Heqo as [b_fin [EQ HB]].
    apply MapsTo_filter_dom_true in HB.
    destruct HB as [IB HB].
    apply (in_bounds_exists_addr _ (snd root_inf)) in IB.
    destruct IB as [root_fin [EQR HS]].
    exists root_fin.
    rewrite <- fin_to_inf_addr_ptr_to_int in EQR.
    destruct root_inf.
    cbn in *. subst.
    destruct root_fin. cbn.
    erewrite <- fin_inf_ptoi.
    rewrite ITOP.int_to_ptr_ptr_to_int. reflexivity.
    auto.
    rewrite addr_convert_fin_to_inf_addr.
    reflexivity.
  Qed.

  Lemma ptr_in_heap_prop_lift_inv :
    forall {h root_inf ptr_inf},
      InfMem.MMEP.MMSP.ptr_in_heap_prop (lift_Heap h) root_inf ptr_inf ->
      exists root_fin, exists ptr_fin,
        InfToFinAddrConvert.addr_convert root_inf = NoOom root_fin /\
        InfToFinAddrConvert.addr_convert ptr_inf = NoOom ptr_fin /\
          FinMem.MMEP.MMSP.ptr_in_heap_prop h root_fin ptr_fin.
  Proof.
    intros h root_inf ptr_inf H.
    specialize (ptr_in_heap_prop_addr_convert H) as H1.
    destruct H1 as [root_fin HC].
    exists root_fin.
    specialize  (ptr_in_heap_prop_lift_inv' H HC) as HX.
    destruct HX as [ptr_fin [HP HH]].
    exists ptr_fin; eauto.
  Qed.

  (* TODO: Move this *)
  Lemma Heap_eqv_lift :
    forall h1 h2,
      FinMem.MMEP.MMSP.heap_eqv h1 h2 ->
      InfMem.MMEP.MMSP.heap_eqv (lift_Heap h1) (lift_Heap h2).
  Proof.
    intros h1 h2 H.
    inversion H.
    constructor; intros; split; intros.
    - apply root_in_heap_prop_lift_inv in H0.
      destruct H0 as [root_fin [HEQ HF]].
      apply heap_roots_eqv in HF.
      eapply root_in_heap_prop_lift in HF.
      erewrite lift_addr_Convert_addr_inverse in HF; eauto.
    - apply root_in_heap_prop_lift_inv in H0.
      destruct H0 as [root_fin [HEQ HF]].
      apply heap_roots_eqv in HF.
      eapply root_in_heap_prop_lift in HF.
      erewrite lift_addr_Convert_addr_inverse in HF; eauto.
    - specialize (ptr_in_heap_prop_lift_inv H0) as HL.
      destruct HL as [root_fin [ptr_fin [HR [HP HIN]]]].
      apply heap_ptrs_eqv in HIN.
      apply ptr_in_heap_prop_lift in HIN.

      rewrite (lift_addr_Convert_addr_inverse HR) in HIN.
      rewrite (lift_addr_Convert_addr_inverse HP) in HIN.
      assumption.
    - specialize (ptr_in_heap_prop_lift_inv H0) as HL.
      destruct HL as [root_fin [ptr_fin [HR [HP HIN]]]].
      apply heap_ptrs_eqv in HIN.
      apply ptr_in_heap_prop_lift in HIN.

      rewrite (lift_addr_Convert_addr_inverse HR) in HIN.
      rewrite (lift_addr_Convert_addr_inverse HP) in HIN.
      assumption.
  Qed.

  (* TODO: Move this *)
  Lemma Heap_eqv_lift' :
    forall h1 h2,
      InfMem.MMEP.MMSP.heap_eqv (lift_Heap h1) (lift_Heap h2) ->
      FinMem.MMEP.MMSP.heap_eqv h1 h2.
  Proof.
    intros h1 h2 H.
    inversion H.
    constructor; intros; split; intros.
    - apply root_in_heap_prop_lift in H0.
      apply heap_roots_eqv in H0.
      apply root_in_heap_prop_lift_inv in H0.
      destruct H0 as [root_fin [HEQ HF]].
      rewrite addr_convert_fin_to_inf_addr in HEQ; inv HEQ.
      auto.
    - apply root_in_heap_prop_lift in H0.
      apply heap_roots_eqv in H0.
      apply root_in_heap_prop_lift_inv in H0.
      destruct H0 as [root_fin [HEQ HF]].
      rewrite addr_convert_fin_to_inf_addr in HEQ; inv HEQ.
      auto.
    - specialize (ptr_in_heap_prop_lift _ _ _ H0) as HL.
      apply heap_ptrs_eqv in HL.
      apply ptr_in_heap_prop_lift_inv in HL.
      destruct HL as [root_fin [ptr_fin [HR [HP HIN]]]].
      rewrite addr_convert_fin_to_inf_addr in HR, HP.
      inv HR; inv HP.
      auto.
    - specialize (ptr_in_heap_prop_lift _ _ _ H0) as HL.
      apply heap_ptrs_eqv in HL.
      apply ptr_in_heap_prop_lift_inv in HL.
      destruct HL as [root_fin [ptr_fin [HR [HP HIN]]]].
      rewrite addr_convert_fin_to_inf_addr in HR, HP.
      inv HR; inv HP.
      auto.
  Qed.

  Lemma convert_Heap_lift :
    forall h,
    exists h',
      convert_Heap (lift_Heap h) = NoOom h' /\
        FinMemMMSP.heap_eqv h h'.
  Proof.
    intros h.

    Opaque convert_Block.
    Opaque lift_Block.
    Opaque IntMaps.IM.elements.
    unfold convert_Heap.
    cbn.
    break_match_goal.
    2: {
      exfalso.
      apply map_monad_OOM_fail in Heqo.
      destruct Heqo as (?&?&?).
      break_match_hyp.
      break_match_hyp_inv.
      eapply SetoidList.In_InA in H; eauto.
      eapply IntMaps.IP.F.elements_mapsto_iff in H.
      2: apply IntMaps.IP.eqke_equiv.

      unfold lift_Heap in H.
      apply IntMaps.IP.F.map_mapsto_iff in H.
      destruct H as (?&?&?).
      subst.
      rewrite convert_Block_lift in Heqo.
      discriminate.
    }

    remember (IntMaps.IM.elements (elt:=InfMemMMSP.Block) (lift_Heap h)) as h_inf.
    eexists; split; eauto.
    split; intros; split; intros IN;
      red; red in IN.
    - eapply IntMaps.member_lookup in IN as (b & IN).
      eapply map_monad_oom_Forall2 in Heqo.
      subst.
      unfold lift_Heap in *.
      apply IntMaps.IP.F.find_mapsto_iff in IN.
      pose proof IN as MAP.
      eapply IntMaps.IM.map_1 with (f:=lift_Block) in MAP.
      pose proof in_bounds_ptr_to_int_fin root as IN_BOUNDS.
      pose proof (conj IN_BOUNDS MAP).
      apply MapsTo_filter_dom_true in H.
      rewrite <- filter_dom_map_eq in H.
      rename H into FILTER.

      eapply IntMaps.lookup_member with (v:=b).
      apply IntMaps.IP.F.find_mapsto_iff.
      eapply IntMaps.IP.of_list_1.
      { pose proof @IntMaps.IM.elements_3w InfMemMMSP.Block (IntMaps.IM.map lift_Block (IntMaps.IP.filter_dom in_bounds h)).
        remember (IntMaps.IM.elements (elt:=InfMemMMSP.Block) (IntMaps.IM.map lift_Block (IntMaps.IP.filter_dom in_bounds h))) as elems.
        clear Heqelems.
        induction Heqo.
        - constructor.
        - inv H.
          constructor; eauto.
          intros CONTRA.
          destruct x.
          break_match_hyp_inv.
          eapply SetoidList.InA_alt in CONTRA; try typeclasses eauto.
          destruct CONTRA as (?&?&?).
          repeat red in H.
          cbn in H. destruct x; cbn in H; subst.
          eapply Forall2_In_exists2 in Heqo; eauto.
          destruct Heqo.
          destruct H.
          destruct x.
          break_match_hyp_inv.
          forward IHHeqo; eauto.
          eapply H3.
          eapply SetoidList.In_InA with (eqA:=(IntMaps.IM.eq_key (elt:=InfMemMMSP.Block))) in H; try typeclasses eauto.
          eapply SetoidList.InA_eqA; eauto.
          repeat red; eauto.
      }

      eapply SetoidList.InA_alt.
      eapply Forall2_In with (a:=((LLVMParams64BitIntptr.PTOI.ptr_to_int root), lift_Block b)) in Heqo; eauto.
      2: {
        apply IntMaps.IM.elements_1 in FILTER.
        eapply SetoidList.InA_alt in FILTER.
        destruct FILTER as (?&?&?).
        repeat red in H.
        destruct H, x; cbn in *; subst.
        eauto.
      }

      destruct Heqo as (?&?&?).
      rewrite convert_Block_lift in H0; inv H0.
      exists (LLVMParams64BitIntptr.PTOI.ptr_to_int root, b).
      split; eauto.
      repeat red.
      split; cbn; eauto.
    - eapply IntMaps.member_lookup in IN as (b & IN).
      eapply map_monad_oom_Forall2 in Heqo.
      subst.
      unfold lift_Heap in *.
      apply IntMaps.IP.F.find_mapsto_iff in IN.
      eapply IntMaps.IP.of_list_1 in IN.
      2: {
        clear H IN.
        pose proof @IntMaps.IM.elements_3w InfMemMMSP.Block (IntMaps.IM.map lift_Block (IntMaps.IP.filter_dom in_bounds h)).
        remember (IntMaps.IM.elements (elt:=InfMemMMSP.Block) (IntMaps.IM.map lift_Block (IntMaps.IP.filter_dom in_bounds h))) as elems.
        clear Heqelems.
        induction Heqo.
        - constructor.
        - inv H.
          constructor; eauto.
          intros CONTRA.
          destruct x.
          break_match_hyp_inv.
          eapply SetoidList.InA_alt in CONTRA; try typeclasses eauto.
          destruct CONTRA as (?&?&?).
          repeat red in H.
          cbn in H. destruct x; cbn in H; subst.
          eapply Forall2_In_exists2 in Heqo; eauto.
          destruct Heqo.
          destruct H.
          destruct x.
          break_match_hyp_inv.
          forward IHHeqo; eauto.
          eapply H3.
          eapply SetoidList.In_InA with (eqA:=(IntMaps.IM.eq_key (elt:=InfMemMMSP.Block))) in H; try typeclasses eauto.
          eapply SetoidList.InA_eqA; eauto.
          repeat red; eauto.
      }

      eapply SetoidList.InA_alt in IN.
      destruct IN as (? & ? & IN).
      eapply Forall2_In_exists2 in Heqo; eauto.
      destruct Heqo as (?&?&?).
      destruct x0.
      break_match_hyp_inv.

      eapply IntMaps.lookup_member with (v:=b1).      
      eapply SetoidList.In_InA with (eqA:=(IntMaps.IM.eq_key_elt (elt:=InfMemMMSP.Block))) in H0;
        try typeclasses eauto.

      eapply IntMaps.IM.elements_2 in H0.
      rewrite filter_dom_map_eq in H0.
      eapply MapsTo_filter_dom_true in H0.
      destruct H0.
      eapply IntMaps.IP.F.map_mapsto_iff in H1.
      destruct H1 as (?&?&?).
      subst.
      rewrite convert_Block_lift in Heqo;
        inv Heqo.

      repeat red in H.
      destruct H; cbn in *; subst.
      eapply IntMaps.IM.find_1; eauto.
    - break_match_hyp; try contradiction.
      eapply map_monad_oom_Forall2 in Heqo.
      subst.
      unfold lift_Heap in *.
      apply IntMaps.IP.F.find_mapsto_iff in Heqo0.
      pose proof Heqo0 as MAP.
      eapply IntMaps.IM.map_1 with (f:=lift_Block) in MAP.
      pose proof in_bounds_ptr_to_int_fin root as IN_BOUNDS.
      pose proof (conj IN_BOUNDS MAP).
      apply MapsTo_filter_dom_true in H.
      rewrite <- filter_dom_map_eq in H.
      rename H into FILTER.

      replace (IntMaps.IM.find (elt:=FinMemMMSP.Block) (LLVMParams64BitIntptr.PTOI.ptr_to_int root)
                 (IntMaps.IP.of_list l)) with (Some b); eauto.
      symmetry.

      apply IntMaps.IP.F.find_mapsto_iff.
      eapply IntMaps.IP.of_list_1.
      { pose proof @IntMaps.IM.elements_3w InfMemMMSP.Block (IntMaps.IM.map lift_Block (IntMaps.IP.filter_dom in_bounds h)).
        remember (IntMaps.IM.elements (elt:=InfMemMMSP.Block) (IntMaps.IM.map lift_Block (IntMaps.IP.filter_dom in_bounds h))) as elems.
        clear Heqelems.
        induction Heqo.
        - constructor.
        - inv H.
          constructor; eauto.
          intros CONTRA.
          destruct x.
          break_match_hyp_inv.
          eapply SetoidList.InA_alt in CONTRA; try typeclasses eauto.
          destruct CONTRA as (?&?&?).
          repeat red in H.
          cbn in H. destruct x; cbn in H; subst.
          eapply Forall2_In_exists2 in Heqo; eauto.
          destruct Heqo.
          destruct H.
          destruct x.
          break_match_hyp_inv.
          forward IHHeqo; eauto.
          eapply H3.
          eapply SetoidList.In_InA with (eqA:=(IntMaps.IM.eq_key (elt:=InfMemMMSP.Block))) in H; try typeclasses eauto.
          eapply SetoidList.InA_eqA; eauto.
          repeat red; eauto.
      }

      eapply SetoidList.InA_alt.
      eapply Forall2_In with (a:=((LLVMParams64BitIntptr.PTOI.ptr_to_int root), lift_Block b)) in Heqo; eauto.
      2: {
        apply IntMaps.IM.elements_1 in FILTER.
        eapply SetoidList.InA_alt in FILTER.
        destruct FILTER as (?&?&?).
        repeat red in H.
        destruct H, x; cbn in *; subst.
        eauto.
      }

      destruct Heqo as (?&?&?).
      rewrite convert_Block_lift in H0; inv H0.
      exists (LLVMParams64BitIntptr.PTOI.ptr_to_int root, b).
      split; eauto.
      repeat red.
      split; cbn; eauto.
    - break_match_hyp; try contradiction.
      eapply map_monad_oom_Forall2 in Heqo.
      subst.
      unfold lift_Heap in *.
      apply IntMaps.IP.F.find_mapsto_iff in Heqo0.
      eapply IntMaps.IP.of_list_1 in Heqo0.
      2: {
        clear H IN.
        pose proof @IntMaps.IM.elements_3w InfMemMMSP.Block (IntMaps.IM.map lift_Block (IntMaps.IP.filter_dom in_bounds h)).
        remember (IntMaps.IM.elements (elt:=InfMemMMSP.Block) (IntMaps.IM.map lift_Block (IntMaps.IP.filter_dom in_bounds h))) as elems.
        clear Heqelems Heqo0.
        induction Heqo.
        - constructor.
        - destruct x; break_match_hyp_inv.
          inv H.
          constructor; eauto.
          intros CONTRA.
          eapply SetoidList.InA_alt in CONTRA; try typeclasses eauto.
          destruct CONTRA as (?&?&?).
          repeat red in H.
          cbn in H. destruct x; cbn in H; subst.
          eapply Forall2_In_exists2 in Heqo; eauto.
          destruct Heqo.
          destruct H.
          destruct x.
          break_match_hyp_inv.
          forward IHHeqo; eauto.
          eapply H2.
          eapply SetoidList.In_InA with (eqA:=(IntMaps.IM.eq_key (elt:=InfMemMMSP.Block))) in H; try typeclasses eauto.
          eapply SetoidList.InA_eqA; eauto.
          repeat red; eauto.
      }

      replace (IntMaps.IM.find (elt:=FinMemMMSP.Block) (LLVMParams64BitIntptr.PTOI.ptr_to_int root) h)
        with (Some b); eauto.
      symmetry.

      eapply SetoidList.InA_alt in Heqo0.
      destruct Heqo0 as (?&?&?).
      destruct x.
      repeat red in H.
      destruct H; cbn in *; subst.

      eapply Forall2_In_exists2 in Heqo; eauto.
      destruct Heqo as (?&?&?).
      destruct x.
      break_match_hyp_inv.

      eapply SetoidList.In_InA with (eqA:=(IntMaps.IM.eq_key_elt (elt:=InfMemMMSP.Block))) in H;
        try typeclasses eauto.
      eapply IntMaps.IM.elements_2 in H.

      eapply filter_dom_map_eq in H.
      eapply MapsTo_filter_dom_true in H.
      destruct H.
      eapply IntMaps.IP.F.map_mapsto_iff in H1.
      destruct H1 as (?&?&?).
      subst.
      rewrite convert_Block_lift in Heqo;
        inv Heqo.

      repeat red in H.
      destruct H; cbn in *; subst.
      eapply IntMaps.IM.find_1; eauto.
  Qed.

  Lemma convert_memory_stack_lift :
    forall ms,
    exists ms',
      convert_memory_stack (lift_memory_stack ms) = NoOom ms' /\
        MMEP.MemSpec.memory_stack_eqv ms ms'.
  Proof.
    induction ms.

    Opaque convert_memory lift_memory.
    Opaque convert_Heap lift_Heap.
    Opaque convert_FrameStack lift_FrameStack.

    cbn.
    pose proof convert_memory_inv memory_stack_memory.
    destruct H.

    pose proof convert_FrameStack_lift memory_stack_frame_stack
      as (fs'&CONVfs&EQVfs).
    rewrite CONVfs.

    pose proof convert_Heap_lift memory_stack_heap as
      (h'&CONVh&EQVh).
    rewrite CONVh.

    eexists; split; try rewrite H; eauto.
    admit.

    Transparent convert_memory lift_memory.
    Transparent convert_Heap lift_Heap.
    Transparent convert_FrameStack lift_FrameStack.
  Admitted.

  Lemma fin_to_inf_uvalue_injective :
    forall uv1 uv2,
      fin_to_inf_uvalue uv1 = fin_to_inf_uvalue uv2 ->
      uv1 = uv2.
  Proof.
    intros uv1 uv2 FININF.
    unfold fin_to_inf_uvalue in *.
    break_match_hyp; clear Heqs; destruct p.
    break_match_hyp; clear Heqs; destruct p.
    subst.
    rewrite e0 in e2. inv e2.
    auto.
  Qed.

  Lemma lift_SByte_injective :
    forall b1 b2,
      lift_SByte b1 = lift_SByte b2 ->
      b1 = b2.
  Proof.
    intros b1 b2 H.
    destruct b1, b2.
    cbn in *.
    inv H.
    apply fin_to_inf_uvalue_injective in H1.
    subst.
    auto.
  Qed.

  Lemma equal_memory_read_byte_raw :
    forall m m' addr,
      IntMaps.IM.Equal (lift_memory m) (lift_memory m') ->
      is_true (in_bounds addr) ->
      Memory64BitIntptr.MMEP.MMSP.read_byte_raw m addr =
        Memory64BitIntptr.MMEP.MMSP.read_byte_raw m' addr.
  Proof.
    intros m m' addr0 EQ IN_BOUNDS.
    Transparent Memory64BitIntptr.MMEP.MMSP.read_byte_raw.
    unfold Memory64BitIntptr.MMEP.MMSP.read_byte_raw.
    red in EQ.
    unfold lift_memory in *.
    specialize (EQ addr0).
    repeat rewrite IntMaps.IP.F.map_o in EQ.
    unfold option_map in EQ.
    repeat break_match_hyp_inv.
    - apply find_filter_dom_true in Heqo, Heqo0.
      destruct Heqo, Heqo0; subst.
      rewrite H, H2.
      unfold lift_mem_byte in H1.
      destruct m0, m1.
      inv H1.
      apply lift_SByte_injective in H5; subst; auto.
    - destruct (IntMaps.IM.find (elt:=FinMemMMSP.mem_byte) addr0 m) eqn:M.
      { pose proof (conj M IN_BOUNDS).
        apply find_filter_dom_true in H.
        rewrite H in Heqo.
        discriminate.
      }

      destruct (IntMaps.IM.find (elt:=FinMemMMSP.mem_byte) addr0 m') eqn:M'.
      { pose proof (conj M' IN_BOUNDS).
        apply find_filter_dom_true in H.
        rewrite H in Heqo0.
        discriminate.
      }

      auto.      
  Qed.
    
  Lemma build_up_memory_stack_eqv :
    forall fs fs' h h' m m',
      FinMem.MMEP.MMSP.frame_stack_eqv fs fs' ->
      FinMemMMSP.heap_eqv h h' ->
      IntMaps.IM.Equal (lift_memory m) (lift_memory m') ->
      Memory64BitIntptr.MMEP.MemSpec.memory_stack_eqv
        {|
          FinMemMMSP.memory_stack_memory := m;
          FinMemMMSP.memory_stack_frame_stack := fs;
          FinMemMMSP.memory_stack_heap := h
        |}
        {|
          FinMemMMSP.memory_stack_memory := m';
          FinMemMMSP.memory_stack_frame_stack := fs';
          FinMemMMSP.memory_stack_heap := h'
        |}.
  Proof.
    intros fs fs' h h' m m' FS_EQV H_EQV M_EQV.
    split.
    - red.
      intros addr0 aid.
      split; intros ALLOC.
      + red; red in ALLOC.
        cbn in *.
        assert (Memory64BitIntptr.MMEP.MMSP.read_byte_raw m (LLVMParams64BitIntptr.PTOI.ptr_to_int addr0) = Memory64BitIntptr.MMEP.MMSP.read_byte_raw m' (LLVMParams64BitIntptr.PTOI.ptr_to_int addr0)).
        { eapply equal_memory_read_byte_raw; eauto.
          apply in_bounds_ptr_to_int_fin.
        }

        rewrite <- H.
        auto.
      + red; red in ALLOC.
        cbn in *.
        assert (Memory64BitIntptr.MMEP.MMSP.read_byte_raw m (LLVMParams64BitIntptr.PTOI.ptr_to_int addr0) = Memory64BitIntptr.MMEP.MMSP.read_byte_raw m' (LLVMParams64BitIntptr.PTOI.ptr_to_int addr0)).
        { eapply equal_memory_read_byte_raw; eauto.
          apply in_bounds_ptr_to_int_fin.
        }

        rewrite H.
        auto.
    - red.
      intros addr0 aid.
      split; intros ALLOC.
      + red; red in ALLOC.
        cbn in *.
        assert (Memory64BitIntptr.MMEP.MMSP.read_byte_raw m (LLVMParams64BitIntptr.PTOI.ptr_to_int addr0) = Memory64BitIntptr.MMEP.MMSP.read_byte_raw m' (LLVMParams64BitIntptr.PTOI.ptr_to_int addr0)).
        { eapply equal_memory_read_byte_raw; eauto.
          apply in_bounds_ptr_to_int_fin.
        }

        rewrite <- H.
        auto.
      + red; red in ALLOC.
        cbn in *.
        assert (Memory64BitIntptr.MMEP.MMSP.read_byte_raw m (LLVMParams64BitIntptr.PTOI.ptr_to_int addr0) = Memory64BitIntptr.MMEP.MMSP.read_byte_raw m' (LLVMParams64BitIntptr.PTOI.ptr_to_int addr0)).
        { eapply equal_memory_read_byte_raw; eauto.
          apply in_bounds_ptr_to_int_fin.
        }

        rewrite H.
        auto.
    - red.
      intros fs0.
      split; intros MSFSP.
      + red; red in MSFSP.
        cbn in *.
        rewrite <- FS_EQV.
        auto.
      + red; red in MSFSP.
        cbn in *.
        rewrite FS_EQV.
        auto.
    - red.
      intros h0.
      split; intros MSHP.
      + red; red in MSHP.
        cbn in *.
        rewrite <- H_EQV.
        auto.
      + red; red in MSHP.
        cbn in *.
        rewrite H_EQV.
        auto.
  Qed.

  Lemma MemState_fin_to_inf_to_fin_exists :
    forall ms,
    exists ms',
      convert_MemState (lift_MemState ms) = NoOom ms' /\
        Memory64BitIntptr.MMEP.MemSpec.MemState_eqv ms ms'.
  Proof.
    intros ms.
    destruct ms as [[ms fss hs] msprovs].

    Opaque convert_memory.
    Opaque convert_FrameStack.
    Opaque convert_Heap.
    cbn.
    repeat break_inner_match_goal.
    2-4: exfalso.
    4: {
      pose proof convert_memory_inv ms.
      destruct H.
      rewrite Heqo in H.
      discriminate.
    }
    3: {
      pose proof convert_FrameStack_lift fss.
      destruct H as (?&?&?).
      rewrite H in Heqo0.
      discriminate.
    }
    2: {
      pose proof convert_Heap_lift hs.
      destruct H as (?&?&?).
      rewrite H in Heqo1.
      discriminate.
    }

    eexists.
    split; eauto.

    pose proof convert_memory_inv ms as (ms'&?).
    pose proof convert_FrameStack_lift fss as (fss'&?&?).
    pose proof convert_Heap_lift hs as (hs'&?&?).

    rewrite H in Heqo; inv Heqo.
    rewrite H0 in Heqo0; inv Heqo0.
    rewrite H2 in Heqo1; inv Heqo1.

    eapply Memory64BitIntptr.MMEP.MemSpec.MemState_eqv'_MemState_eqv.
    red.
    cbn.
    split; cbn; [|red; reflexivity].

    epose proof lift_memory_convert_memory_inversion H.

    eapply build_up_memory_stack_eqv; eauto.
    symmetry.
    eauto.        
  Qed.

  (* TODO: Move this *)
  Lemma MemState_fin_to_inf_to_fin :
    forall ms ms',
      convert_MemState (lift_MemState ms) = NoOom ms' ->
      Memory64BitIntptr.MMEP.MemSpec.MemState_eqv ms ms'.
  Proof.
    intros ms ms' CONV.
    destruct ms as [[ms fss hs] msprovs].
    destruct ms' as [[ms' fss' hs'] msprovs'].

    Opaque convert_memory.
    Opaque convert_FrameStack.
    Opaque convert_Heap.
    cbn in *.
    repeat break_match_hyp_inv.

    eapply MMEP.MemSpec.MemState_eqv'_MemState_eqv.
    split; eauto; [|red; reflexivity].
    { pose proof convert_memory_inv ms as (ms''&?).
      pose proof convert_FrameStack_lift fss as (fss''&?&?).
      pose proof convert_Heap_lift hs as (hs''&?&?).

      rewrite H in Heqo0; inv Heqo0.
      rewrite H0 in Heqo; inv Heqo.
      rewrite H2 in Heqo1; inv Heqo1.

      eapply build_up_memory_stack_eqv; eauto.
      epose proof lift_memory_convert_memory_inversion H.
      symmetry.
      eauto.
    }
    
    Transparent convert_memory.
    Transparent convert_FrameStack.
    Transparent convert_Heap.
  Qed.

  Print Assumptions MemState_fin_to_inf_to_fin.

  (* TODO: Need a MemState_refine_prop that takes all of the predicates
      like write_byte_all_preserved and bundles them in one place
      between memories. Should use this for these lemmas... *)
  (* TODO: Confirm and move this *)
  Definition MemState_refine_prop ms_inf ms_fin :=
    let ms_fin_lifted := lift_MemState ms_fin in
    InfMem.MMEP.MemSpec.MemState_eqv ms_inf ms_fin_lifted.

  Definition sbytes_refine bytes_inf bytes_fin : Prop :=
    Forall2 sbyte_refine bytes_inf bytes_fin.

  (** More refinement relations *)
  Definition L3_E1E2_orutt_strict (t1 : PropT InfLP.Events.L3 (InfMemMMSP.MemState *
                                                                 (MemPropT.store_id * (InfLLVM.Local.local_env * InfLLVM.Stack.lstack * (InfLLVM.Global.global_env * InfLP.Events.DV.dvalue)))))
    (t2 : PropT FinLP.Events.L3 (FinMemMMSP.MemState *
                                   (MemPropT.store_id * (FinLLVM.Local.local_env * FinLLVM.Stack.lstack * (FinLLVM.Global.global_env * FinLP.Events.DV.dvalue)))))
    : Prop :=
    forall t', t2 t' ->
               exists t, t1 t /\
                           orutt
                             L3_refine_strict
                             L3_res_refine_strict
                             (MemState_refine_prop Ã— (eq Ã— (local_refine_strict Ã— stack_refine_strict Ã— (global_refine_strict Ã— DVC1.dvalue_refine_strict))))
                             t t' (OOM:=OOME).

  Definition model_E1E2_L3_orutt_strict p1 p2 :=
    L3_E1E2_orutt_strict
      (TopLevelBigIntptr.model_oom_L3 TLR_INF.R.refine_res2 p1)
      (TopLevel64BitIntptr.model_oom_L3 TLR_FIN.R.refine_res2 p2).

  #[global] Instance mempush_spec_MemState_eqv_Proper :
    Proper (MemoryBigIntptr.MMEP.MemSpec.MemState_eqv ==> MemoryBigIntptr.MMEP.MemSpec.MemState_eqv ==> iff) MemoryBigIntptr.MMEP.MemSpec.mempush_spec.
  Proof.
  Admitted.

  Lemma MemState_eqv_lift_MemState :
    forall ms1 ms2,
      Memory64BitIntptr.MMEP.MemSpec.MemState_eqv ms1 ms2 ->
      MemoryBigIntptr.MMEP.MemSpec.MemState_eqv (lift_MemState ms1) (lift_MemState ms2).
  Proof.
  Admitted.

  Unset Implicit Arguments.
  Unset Contextual Implicit.
  Definition get_inf_tree' :
    forall (t_fin2 : itree L3 (FinMem.MMEP.MMSP.MemState * (MemPropT.store_id * (local_env * @stack local_env * res_L1)))), itree InfLP.Events.L3 TopLevelBigIntptr.res_L6.
  Proof.
    cofix CIH.
    intros t_fin2.
    destruct t_fin2.
    destruct _observe.
    - (* Ret *)
      refine (ret _).
      destruct r as [ms [sid [[lenv s] [genv res]]]].
      constructor.
      exact (lift_MemState ms).

      constructor.
      exact sid.

      constructor.
      constructor.
      exact (lift_local_env lenv).
      exact (lift_stack s).

      constructor.
      exact (lift_global_env genv).
      exact (fin_to_inf_dvalue res).
    - (*Tau *)
      apply go.
      apply TauF.
      apply CIH.
      apply t.
    - (* Vis *)
      inversion e; clear e; subst.
      { (* ExternalCallE *)
        inversion H; subst.
        apply go.
        apply (VisF (subevent _ (E1.ExternalCall t (fin_to_inf_uvalue f) (map fin_to_inf_dvalue args)))).

        (* Continuation *)
        intros x.
        apply CIH.

        pose proof (DVCInfFin.dvalue_convert_strict x).
        destruct H0.
        - exact (k d).
        - (* OOM -- somewhat worried about this case *)
          exact (raiseOOM s).
      }

      inversion X0; clear X0; subst.
      { (* PickUvalue *)
        inversion X1; subst.
        apply go.
        apply (VisF (subevent _ (E1.pick Pre (fin_to_inf_uvalue x)))).

        (* Continuation *)
        intros res.
        destruct res.
        apply CIH.

        pose proof (DVCInfFin.dvalue_convert_strict x0).
        destruct H.
        - apply k.
          constructor.
          apply d.
          apply t.
        - (* OOM -- somewhat worried about this case *)
          exact (raiseOOM s).
      }

      inversion H; clear H; subst.
      { (* OOM *)
        inversion H0; subst.
        exact (raiseOOM "").
      }

      inversion H0; clear H0; subst.
      { (* UBE *)
        inversion H; subst.
        exact (raiseUB "").
      }

      inversion H; clear H; subst.
      { (* DebugE *)
        inversion H0; subst.
        apply go.
        apply (VisF (subevent _ (Debug H))).
        intros H1.
        apply CIH.
        apply k; auto.
      }

      { (* FailureE *)
        inversion H0; subst.
        exact (LLVMEvents.raise "").
      }

      (* Show Proof. *)
  Defined.

  Set Printing All.
  Set Printing Implicit.
  Set Printing Depth 1000.
  Print get_inf_tree'.


  Unset Printing All.
  Unset Printing Implicit.
  Definition get_inf_tree :
    forall (t_fin2 : itree L3 (FinMem.MMEP.MMSP.MemState * (MemPropT.store_id * (local_env * @stack local_env * res_L1)))), itree InfLP.Events.L3 TopLevelBigIntptr.res_L6 :=
cofix CIH
  (t_fin2 :
   itree L3
     (prod
        FinMem.MMEP.MMSP.MemState
        (prod
         MemPropT.store_id
         (prod
         (prod
         local_env
         (@stack
         local_env))
         (prod
         global_env
         dvalue))))) :
    itree
      InfLP.Events.L3
      (prod
         InterpreterStackBigIntptr.LLVM.MEM.MMEP.MMSP.MemState
         (prod
         MemPropT.store_id
         (prod
         (prod
         InterpreterStackBigIntptr.LLVM.Local.local_env
         InterpreterStackBigIntptr.LLVM.Stack.lstack)
         (prod
         InterpreterStackBigIntptr.LLVM.Global.global_env
         InterpreterStackBigIntptr.LP.Events.DV.dvalue)))) :=
  (fun
     _observe :
      itreeF
        L3
        (prod
         FinMem.MMEP.MMSP.MemState
         (prod
         MemPropT.store_id
         (prod
         (prod
         local_env
         (@stack
         local_env))
         (prod
         global_env
         dvalue))))
        (itree
         L3
         (prod
         FinMem.MMEP.MMSP.MemState
         (prod
         MemPropT.store_id
         (prod
         (prod
         local_env
         (@stack
         local_env))
         (prod
         global_env
         dvalue)))))
   =>
   match
     _observe
     return
       (itree
         InfLP.Events.L3
         (prod
         InterpreterStackBigIntptr.LLVM.MEM.MMEP.MMSP.MemState
         (prod
         MemPropT.store_id
         (prod
         (prod
         InterpreterStackBigIntptr.LLVM.Local.local_env
         InterpreterStackBigIntptr.LLVM.Stack.lstack)
         (prod
         InterpreterStackBigIntptr.LLVM.Global.global_env
         InterpreterStackBigIntptr.LP.Events.DV.dvalue)))))
   with
   | RetF r =>
       (fun
         r0 :
         prod
         FinMem.MMEP.MMSP.MemState
         (prod
         MemPropT.store_id
         (prod
         (prod
         local_env
         (@stack
         local_env))
         (prod
         global_env
         dvalue)))
        =>
        @ret
         (itree
         InfLP.Events.L3)
         (@Monad_itree
         InfLP.Events.L3)
         (prod
         InterpreterStackBigIntptr.LLVM.MEM.MMEP.MMSP.MemState
         (prod
         MemPropT.store_id
         (prod
         (prod
         InterpreterStackBigIntptr.LLVM.Local.local_env
         InterpreterStackBigIntptr.LLVM.Stack.lstack)
         (prod
         InterpreterStackBigIntptr.LLVM.Global.global_env
         InterpreterStackBigIntptr.LP.Events.DV.dvalue))))
         match
         r0
         return
         (prod
         InterpreterStackBigIntptr.LLVM.MEM.MMEP.MMSP.MemState
         (prod
         MemPropT.store_id
         (prod
         (prod
         InterpreterStackBigIntptr.LLVM.Local.local_env
         InterpreterStackBigIntptr.LLVM.Stack.lstack)
         (prod
         InterpreterStackBigIntptr.LLVM.Global.global_env
         InterpreterStackBigIntptr.LP.Events.DV.dvalue))))
         with
         | pair
         a b =>
         (fun
         (ms : FinMem.MMEP.MMSP.MemState)
         (p :
         prod
         MemPropT.store_id
         (prod
         (prod
         local_env
         (@stack
         local_env))
         (prod
         global_env
         dvalue)))
         =>
         match
         p
         return
         (prod
         InterpreterStackBigIntptr.LLVM.MEM.MMEP.MMSP.MemState
         (prod
         MemPropT.store_id
         (prod
         (prod
         InterpreterStackBigIntptr.LLVM.Local.local_env
         InterpreterStackBigIntptr.LLVM.Stack.lstack)
         (prod
         InterpreterStackBigIntptr.LLVM.Global.global_env
         InterpreterStackBigIntptr.LP.Events.DV.dvalue))))
         with
         | pair
         a0 b0 =>
         (fun
         (sid : MemPropT.store_id)
         (p0 :
         prod
         (prod
         local_env
         (@stack
         local_env))
         (prod
         global_env
         dvalue))
         =>
         match
         p0
         return
         (prod
         InterpreterStackBigIntptr.LLVM.MEM.MMEP.MMSP.MemState
         (prod
         MemPropT.store_id
         (prod
         (prod
         InterpreterStackBigIntptr.LLVM.Local.local_env
         InterpreterStackBigIntptr.LLVM.Stack.lstack)
         (prod
         InterpreterStackBigIntptr.LLVM.Global.global_env
         InterpreterStackBigIntptr.LP.Events.DV.dvalue))))
         with
         | pair
         a1 b1 =>
         (fun
         p1 :
         prod
         local_env
         (@stack
         local_env)
         =>
         match
         p1
         return
         (forall
         _ :
         prod
         global_env
         dvalue,
         prod
         InterpreterStackBigIntptr.LLVM.MEM.MMEP.MMSP.MemState
         (prod
         MemPropT.store_id
         (prod
         (prod
         InterpreterStackBigIntptr.LLVM.Local.local_env
         InterpreterStackBigIntptr.LLVM.Stack.lstack)
         (prod
         InterpreterStackBigIntptr.LLVM.Global.global_env
         InterpreterStackBigIntptr.LP.Events.DV.dvalue))))
         with
         | pair
         a2 b2 =>
         (fun
         (lenv : local_env)
         (s :
         @stack
         local_env)
         (p2 :
         prod
         global_env
         dvalue)
         =>
         match
         p2
         return
         (prod
         InterpreterStackBigIntptr.LLVM.MEM.MMEP.MMSP.MemState
         (prod
         MemPropT.store_id
         (prod
         (prod
         InterpreterStackBigIntptr.LLVM.Local.local_env
         InterpreterStackBigIntptr.LLVM.Stack.lstack)
         (prod
         InterpreterStackBigIntptr.LLVM.Global.global_env
         InterpreterStackBigIntptr.LP.Events.DV.dvalue))))
         with
         | pair
         a3 b3 =>
         (fun
         (genv : global_env)
         (res : dvalue)
         =>
         @pair
         InterpreterStackBigIntptr.LLVM.MEM.MMEP.MMSP.MemState
         (prod
         MemPropT.store_id
         (prod
         (prod
         InterpreterStackBigIntptr.LLVM.Local.local_env
         InterpreterStackBigIntptr.LLVM.Stack.lstack)
         (prod
         InterpreterStackBigIntptr.LLVM.Global.global_env
         InterpreterStackBigIntptr.LP.Events.DV.dvalue)))
         (lift_MemState
         ms)
         (@pair
         MemPropT.store_id
         (prod
         (prod
         InterpreterStackBigIntptr.LLVM.Local.local_env
         InterpreterStackBigIntptr.LLVM.Stack.lstack)
         (prod
         InterpreterStackBigIntptr.LLVM.Global.global_env
         InterpreterStackBigIntptr.LP.Events.DV.dvalue))
         sid
         (@pair
         (prod
         InterpreterStackBigIntptr.LLVM.Local.local_env
         InterpreterStackBigIntptr.LLVM.Stack.lstack)
         (prod
         InterpreterStackBigIntptr.LLVM.Global.global_env
         InterpreterStackBigIntptr.LP.Events.DV.dvalue)
         (@pair
         InterpreterStackBigIntptr.LLVM.Local.local_env
         InterpreterStackBigIntptr.LLVM.Stack.lstack
         (lift_local_env
         lenv)
         (lift_stack
         s))
         (@pair
         InterpreterStackBigIntptr.LLVM.Global.global_env
         InterpreterStackBigIntptr.LP.Events.DV.dvalue
         (lift_global_env
         genv)
         (fin_to_inf_dvalue
         res)))))
         a3 b3
         end)
         a2 b2
         end)
         a1 b1
         end)
         a0 b0
         end)
         a b
         end)
         r
   | TauF t =>
       (fun
         t0 :
         itree
         L3
         (prod
         FinMem.MMEP.MMSP.MemState
         (prod
         MemPropT.store_id
         (prod
         (prod
         local_env
         (@stack
         local_env))
         (prod
         global_env
         dvalue))))
        =>
        @go
         InfLP.Events.L3
         (prod
         InterpreterStackBigIntptr.LLVM.MEM.MMEP.MMSP.MemState
         (prod
         MemPropT.store_id
         (prod
         (prod
         InterpreterStackBigIntptr.LLVM.Local.local_env
         InterpreterStackBigIntptr.LLVM.Stack.lstack)
         (prod
         InterpreterStackBigIntptr.LLVM.Global.global_env
         InterpreterStackBigIntptr.LP.Events.DV.dvalue))))
         (@TauF
         InfLP.Events.L3
         (prod
         InterpreterStackBigIntptr.LLVM.MEM.MMEP.MMSP.MemState
         (prod
         MemPropT.store_id
         (prod
         (prod
         InterpreterStackBigIntptr.LLVM.Local.local_env
         InterpreterStackBigIntptr.LLVM.Stack.lstack)
         (prod
         InterpreterStackBigIntptr.LLVM.Global.global_env
         InterpreterStackBigIntptr.LP.Events.DV.dvalue))))
         (itree
         InfLP.Events.L3
         (prod
         InterpreterStackBigIntptr.LLVM.MEM.MMEP.MMSP.MemState
         (prod
         MemPropT.store_id
         (prod
         (prod
         InterpreterStackBigIntptr.LLVM.Local.local_env
         InterpreterStackBigIntptr.LLVM.Stack.lstack)
         (prod
         InterpreterStackBigIntptr.LLVM.Global.global_env
         InterpreterStackBigIntptr.LP.Events.DV.dvalue)))))
         (CIH
         t0)))
         t
   | @VisF _ _
     _ X e k =>
       (fun
         (X0 : Type)
         (e0 :
         L3 X0)
         (k0 :
         forall
         _ : X0,
         itree
         L3
         (prod
         FinMem.MMEP.MMSP.MemState
         (prod
         MemPropT.store_id
         (prod
         (prod
         local_env
         (@stack
         local_env))
         (prod
         global_env
         dvalue)))))
        =>
        let
         X1 :
         itree
         InfLP.Events.L3
         (prod
         InterpreterStackBigIntptr.LLVM.MEM.MMEP.MMSP.MemState
         (prod
         MemPropT.store_id
         (prod
         (prod
         InterpreterStackBigIntptr.LLVM.Local.local_env
         InterpreterStackBigIntptr.LLVM.Stack.lstack)
         (prod
         InterpreterStackBigIntptr.LLVM.Global.global_env
         InterpreterStackBigIntptr.LP.Events.DV.dvalue)))) :=
         match
         e0
         return
         (itree
         InfLP.Events.L3
         (prod
         InterpreterStackBigIntptr.LLVM.MEM.MMEP.MMSP.MemState
         (prod
         MemPropT.store_id
         (prod
         (prod
         InterpreterStackBigIntptr.LLVM.Local.local_env
         InterpreterStackBigIntptr.LLVM.Stack.lstack)
         (prod
         InterpreterStackBigIntptr.LLVM.Global.global_env
         InterpreterStackBigIntptr.LP.Events.DV.dvalue)))))
         with
         | inl1
         x =>
         (fun
         H :
         ExternalCallE
         X0 =>
         (fun
         H0 :
         ExternalCallE
         X0 =>
         let
         X1 :
         forall
         _ :
         @eq
         Type
         X0 X0,
         itree
         InfLP.Events.L3
         (prod
         InterpreterStackBigIntptr.LLVM.MEM.MMEP.MMSP.MemState
         (prod
         MemPropT.store_id
         (prod
         (prod
         InterpreterStackBigIntptr.LLVM.Local.local_env
         InterpreterStackBigIntptr.LLVM.Stack.lstack)
         (prod
         InterpreterStackBigIntptr.LLVM.Global.global_env
         InterpreterStackBigIntptr.LP.Events.DV.dvalue)))) :=
         match
         H0 in
         (ExternalCallE
         T)
         return
         (forall
         _ :
         @eq
         Type
         T X0,
         itree
         InfLP.Events.L3
         (prod
         InterpreterStackBigIntptr.LLVM.MEM.MMEP.MMSP.MemState
         (prod
         MemPropT.store_id
         (prod
         (prod
         InterpreterStackBigIntptr.LLVM.Local.local_env
         InterpreterStackBigIntptr.LLVM.Stack.lstack)
         (prod
         InterpreterStackBigIntptr.LLVM.Global.global_env
         InterpreterStackBigIntptr.LP.Events.DV.dvalue)))))
         with
         | ExternalCall
         t f
         args =>
         (fun
         (t0 : dtyp)
         (f0 : uvalue)
         (args0 :
         list
         dvalue)
         (H1 :
         @eq
         Type
         dvalue
         X0)
         =>
         (fun
         H2 :
         @eq
         Type
         dvalue
         X0 =>
         let
         H3 :
         @eq
         Type
         dvalue
         X0 :=
         H2 in
         @eq_rect
         Type
         dvalue
         (fun
         _ : Type
         =>
         forall
         (_ : dtyp)
         (_ : uvalue)
         (_ :
         list
         dvalue),
         itree
         InfLP.Events.L3
         (prod
         InterpreterStackBigIntptr.LLVM.MEM.MMEP.MMSP.MemState
         (prod
         MemPropT.store_id
         (prod
         (prod
         InterpreterStackBigIntptr.LLVM.Local.local_env
         InterpreterStackBigIntptr.LLVM.Stack.lstack)
         (prod
         InterpreterStackBigIntptr.LLVM.Global.global_env
         InterpreterStackBigIntptr.LP.Events.DV.dvalue)))))
         (fun
         (t1 : dtyp)
         (f1 : uvalue)
         (args1 :
         list
         dvalue)
         =>
         @eq_rect
         Type
         dvalue
         (fun
         X1 : Type
         =>
         forall
         (_ :
         forall
         _ : X1,
         itree
         L3
         (prod
         FinMem.MMEP.MMSP.MemState
         (prod
         MemPropT.store_id
         (prod
         (prod
         local_env
         (@stack
         local_env))
         (prod
         global_env
         dvalue)))))
         (_ :
         ExternalCallE
         X1),
         itree
         InfLP.Events.L3
         (prod
         InterpreterStackBigIntptr.LLVM.MEM.MMEP.MMSP.MemState
         (prod
         MemPropT.store_id
         (prod
         (prod
         InterpreterStackBigIntptr.LLVM.Local.local_env
         InterpreterStackBigIntptr.LLVM.Stack.lstack)
         (prod
         InterpreterStackBigIntptr.LLVM.Global.global_env
         InterpreterStackBigIntptr.LP.Events.DV.dvalue)))))
         (fun
         (k1 :
         forall
         _ : dvalue,
         itree
         L3
         (prod
         FinMem.MMEP.MMSP.MemState
         (prod
         MemPropT.store_id
         (prod
         (prod
         local_env
         (@stack
         local_env))
         (prod
         global_env
         dvalue)))))
         (_ :
         ExternalCallE
         dvalue)
         =>
         @go
         InfLP.Events.L3
         (prod
         InterpreterStackBigIntptr.LLVM.MEM.MMEP.MMSP.MemState
         (prod
         MemPropT.store_id
         (prod
         (prod
         InterpreterStackBigIntptr.LLVM.Local.local_env
         InterpreterStackBigIntptr.LLVM.Stack.lstack)
         (prod
         InterpreterStackBigIntptr.LLVM.Global.global_env
         InterpreterStackBigIntptr.LP.Events.DV.dvalue))))
         (@VisF
         InfLP.Events.L3
         (prod
         InterpreterStackBigIntptr.LLVM.MEM.MMEP.MMSP.MemState
         (prod
         MemPropT.store_id
         (prod
         (prod
         InterpreterStackBigIntptr.LLVM.Local.local_env
         InterpreterStackBigIntptr.LLVM.Stack.lstack)
         (prod
         InterpreterStackBigIntptr.LLVM.Global.global_env
         InterpreterStackBigIntptr.LP.Events.DV.dvalue))))
         (itree
         InfLP.Events.L3
         (prod
         InterpreterStackBigIntptr.LLVM.MEM.MMEP.MMSP.MemState
         (prod
         MemPropT.store_id
         (prod
         (prod
         InterpreterStackBigIntptr.LLVM.Local.local_env
         InterpreterStackBigIntptr.LLVM.Stack.lstack)
         (prod
         InterpreterStackBigIntptr.LLVM.Global.global_env
         InterpreterStackBigIntptr.LP.Events.DV.dvalue)))))
         E1.DV.dvalue
         (@subevent
         E1.ExternalCallE
         InfLP.Events.L3
         (@ReSum_inl
         (forall
         _ : Type,
         Type)
         IFun
         sum1
         Cat_IFun
         Inl_sum1
         E1.ExternalCallE
         InfLP.Events.ExternalCallE
         (sum1
         InfLP.Events.PickUvalueE
         (sum1
         OOME
         (sum1
         UBE
         (sum1
         DebugE
         FailureE))))
         (@ReSum_id
         (forall
         _ : Type,
         Type)
         IFun
         Id_IFun
         InfLP.Events.ExternalCallE))
         E1.DV.dvalue
         (E1.ExternalCall
         t1
         (fin_to_inf_uvalue
         f1)
         (@map
         LLVMParams64BitIntptr.Events.DV.dvalue
         LLVMParamsBigIntptr.Events.DV.dvalue
         fin_to_inf_dvalue
         args1)))
         (fun
         x0 : E1.DV.dvalue
         =>
         CIH
         (let
         H5 :
         OOM
         DVCInfFin.DV2.dvalue :=
         DVCInfFin.dvalue_convert_strict
         x0 in
         match
         H5
         return
         (itree
         L3
         (prod
         FinMem.MMEP.MMSP.MemState
         (prod
         MemPropT.store_id
         (prod
         (prod
         local_env
         (@stack
         local_env))
         (prod
         global_env
         dvalue)))))
         with
         | NoOom
         a =>
         (fun
         d : DVCInfFin.DV2.dvalue
         =>
         k1 d)
         a
         | Oom
         s =>
         (fun
         s0 : string
         =>
         @raiseOOM
         L3
         (@ReSum_inr
         (forall
         _ : Type,
         Type)
         IFun
         sum1
         Cat_IFun
         Inr_sum1
         OOME
         (sum1
         PickUvalueE
         (sum1
         OOME
         (sum1
         UBE
         (sum1
         DebugE
         FailureE))))
         ExternalCallE
         (@ReSum_inr
         (forall
         _ : Type,
         Type)
         IFun
         sum1
         Cat_IFun
         Inr_sum1
         OOME
         (sum1
         OOME
         (sum1
         UBE
         (sum1
         DebugE
         FailureE)))
         PickUvalueE
         (@ReSum_inl
         (forall
         _ : Type,
         Type)
         IFun
         sum1
         Cat_IFun
         Inl_sum1
         OOME
         OOME
         (sum1
         UBE
         (sum1
         DebugE
         FailureE))
         (@ReSum_id
         (forall
         _ : Type,
         Type)
         IFun
         Id_IFun
         OOME))))
         (prod
         FinMem.MMEP.MMSP.MemState
         (prod
         MemPropT.store_id
         (prod
         (prod
         local_env
         (@stack
         local_env))
         (prod
         global_env
         dvalue))))
         s0) s
         end))))
         X0 H2
         k0 H0)
         X0 H3)
         H1 t0
         f0
         args0)
         t f
         args
         end
         in
         X1
         (@eq_refl
         Type
         X0))
         H) x
         | inr1
         x =>
         (fun
         X1 :
         sum1
         PickUvalueE
         (sum1
         OOME
         (sum1
         UBE
         (sum1
         DebugE
         FailureE)))
         X0 =>
         (fun
         X2 :
         sum1
         PickUvalueE
         (sum1
         OOME
         (sum1
         UBE
         (sum1
         DebugE
         FailureE)))
         X0 =>
         let
         X3 :
         itree
         InfLP.Events.L3
         (prod
         InterpreterStackBigIntptr.LLVM.MEM.MMEP.MMSP.MemState
         (prod
         MemPropT.store_id
         (prod
         (prod
         InterpreterStackBigIntptr.LLVM.Local.local_env
         InterpreterStackBigIntptr.LLVM.Stack.lstack)
         (prod
         InterpreterStackBigIntptr.LLVM.Global.global_env
         InterpreterStackBigIntptr.LP.Events.DV.dvalue)))) :=
         match
         X2
         return
         (itree
         InfLP.Events.L3
         (prod
         InterpreterStackBigIntptr.LLVM.MEM.MMEP.MMSP.MemState
         (prod
         MemPropT.store_id
         (prod
         (prod
         InterpreterStackBigIntptr.LLVM.Local.local_env
         InterpreterStackBigIntptr.LLVM.Stack.lstack)
         (prod
         InterpreterStackBigIntptr.LLVM.Global.global_env
         InterpreterStackBigIntptr.LP.Events.DV.dvalue)))))
         with
         | inl1
         x0 =>
         (fun
         X3 :
         PickUvalueE
         X0 =>
         (fun
         X4 :
         PickUvalueE
         X0 =>
         let
         X5 :
         forall
         _ :
         @eq
         Type
         X0 X0,
         itree
         InfLP.Events.L3
         (prod
         InterpreterStackBigIntptr.LLVM.MEM.MMEP.MMSP.MemState
         (prod
         MemPropT.store_id
         (prod
         (prod
         InterpreterStackBigIntptr.LLVM.Local.local_env
         InterpreterStackBigIntptr.LLVM.Stack.lstack)
         (prod
         InterpreterStackBigIntptr.LLVM.Global.global_env
         InterpreterStackBigIntptr.LP.Events.DV.dvalue)))) :=
         match
         X4 in
         (PickE
         T)
         return
         (forall
         _ :
         @eq
         Type
         T X0,
         itree
         InfLP.Events.L3
         (prod
         InterpreterStackBigIntptr.LLVM.MEM.MMEP.MMSP.MemState
         (prod
         MemPropT.store_id
         (prod
         (prod
         InterpreterStackBigIntptr.LLVM.Local.local_env
         InterpreterStackBigIntptr.LLVM.Stack.lstack)
         (prod
         InterpreterStackBigIntptr.LLVM.Global.global_env
         InterpreterStackBigIntptr.LP.Events.DV.dvalue)))))
         with
         | pick
         Pre
         x1 =>
         (fun
         (Pre0 : Prop)
         (x2 : uvalue)
         (H :
         @eq
         Type
         (@sig
         dvalue
         (fun
         _ : dvalue
         =>
         True))
         X0)
         =>
         (fun
         H0 :
         @eq
         Type
         (@sig
         dvalue
         (fun
         _ : dvalue
         =>
         True))
         X0 =>
         let
         H1 :
         @eq
         Type
         (@sig
         dvalue
         (fun
         _ : dvalue
         =>
         True))
         X0 :=
         H0 in
         @eq_rect
         Type
         (@sig
         dvalue
         (fun
         _ : dvalue
         =>
         True))
         (fun
         _ : Type
         =>
         forall
         (_ : Prop)
         (_ : uvalue),
         itree
         InfLP.Events.L3
         (prod
         InterpreterStackBigIntptr.LLVM.MEM.MMEP.MMSP.MemState
         (prod
         MemPropT.store_id
         (prod
         (prod
         InterpreterStackBigIntptr.LLVM.Local.local_env
         InterpreterStackBigIntptr.LLVM.Stack.lstack)
         (prod
         InterpreterStackBigIntptr.LLVM.Global.global_env
         InterpreterStackBigIntptr.LP.Events.DV.dvalue)))))
         (fun
         (Pre1 : Prop)
         (x3 : uvalue)
         =>
         @eq_rect
         Type
         (@sig
         dvalue
         (fun
         _ : dvalue
         =>
         True))
         (fun
         X5 : Type
         =>
         forall
         (_ :
         forall
         _ : X5,
         itree
         L3
         (prod
         FinMem.MMEP.MMSP.MemState
         (prod
         MemPropT.store_id
         (prod
         (prod
         local_env
         (@stack
         local_env))
         (prod
         global_env
         dvalue)))))
         (_ :
         PickUvalueE
         X5),
         itree
         InfLP.Events.L3
         (prod
         InterpreterStackBigIntptr.LLVM.MEM.MMEP.MMSP.MemState
         (prod
         MemPropT.store_id
         (prod
         (prod
         InterpreterStackBigIntptr.LLVM.Local.local_env
         InterpreterStackBigIntptr.LLVM.Stack.lstack)
         (prod
         InterpreterStackBigIntptr.LLVM.Global.global_env
         InterpreterStackBigIntptr.LP.Events.DV.dvalue)))))
         (fun
         (k1 :
         forall
         _ :
         @sig
         dvalue
         (fun
         _ : dvalue
         =>
         True),
         itree
         L3
         (prod
         FinMem.MMEP.MMSP.MemState
         (prod
         MemPropT.store_id
         (prod
         (prod
         local_env
         (@stack
         local_env))
         (prod
         global_env
         dvalue)))))
         (_ :
         PickUvalueE
         (@sig
         dvalue
         (fun
         _ : dvalue
         =>
         True)))
         =>
         @go
         InfLP.Events.L3
         (prod
         InterpreterStackBigIntptr.LLVM.MEM.MMEP.MMSP.MemState
         (prod
         MemPropT.store_id
         (prod
         (prod
         InterpreterStackBigIntptr.LLVM.Local.local_env
         InterpreterStackBigIntptr.LLVM.Stack.lstack)
         (prod
         InterpreterStackBigIntptr.LLVM.Global.global_env
         InterpreterStackBigIntptr.LP.Events.DV.dvalue))))
         (@VisF
         InfLP.Events.L3
         (prod
         InterpreterStackBigIntptr.LLVM.MEM.MMEP.MMSP.MemState
         (prod
         MemPropT.store_id
         (prod
         (prod
         InterpreterStackBigIntptr.LLVM.Local.local_env
         InterpreterStackBigIntptr.LLVM.Stack.lstack)
         (prod
         InterpreterStackBigIntptr.LLVM.Global.global_env
         InterpreterStackBigIntptr.LP.Events.DV.dvalue))))
         (itree
         InfLP.Events.L3
         (prod
         InterpreterStackBigIntptr.LLVM.MEM.MMEP.MMSP.MemState
         (prod
         MemPropT.store_id
         (prod
         (prod
         InterpreterStackBigIntptr.LLVM.Local.local_env
         InterpreterStackBigIntptr.LLVM.Stack.lstack)
         (prod
         InterpreterStackBigIntptr.LLVM.Global.global_env
         InterpreterStackBigIntptr.LP.Events.DV.dvalue)))))
         (@sig
         InfLP.Events.DV.dvalue
         (fun
         _ : InfLP.Events.DV.dvalue
         =>
         True))
         (@subevent
         (@E1.PickE
         LLVMParamsBigIntptr.Events.DV.uvalue
         InfLP.Events.DV.dvalue
         (fun
         (_ : InfLP.Events.DV.uvalue)
         (_ : InfLP.Events.DV.dvalue)
         =>
         True))
         InfLP.Events.L3
         (@ReSum_inr
         (forall
         _ : Type,
         Type)
         IFun
         sum1
         Cat_IFun
         Inr_sum1
         (@E1.PickE
         LLVMParamsBigIntptr.Events.DV.uvalue
         InfLP.Events.DV.dvalue
         (fun
         (_ : InfLP.Events.DV.uvalue)
         (_ : InfLP.Events.DV.dvalue)
         =>
         True))
         (sum1
         InfLP.Events.PickUvalueE
         (sum1
         OOME
         (sum1
         UBE
         (sum1
         DebugE
         FailureE))))
         InfLP.Events.ExternalCallE
         (@ReSum_inl
         (forall
         _ : Type,
         Type)
         IFun
         sum1
         Cat_IFun
         Inl_sum1
         (@E1.PickE
         LLVMParamsBigIntptr.Events.DV.uvalue
         InfLP.Events.DV.dvalue
         (fun
         (_ : InfLP.Events.DV.uvalue)
         (_ : InfLP.Events.DV.dvalue)
         =>
         True))
         InfLP.Events.PickUvalueE
         (sum1
         OOME
         (sum1
         UBE
         (sum1
         DebugE
         FailureE)))
         (@ReSum_id
         (forall
         _ : Type,
         Type)
         IFun
         Id_IFun
         InfLP.Events.PickUvalueE)))
         (@sig
         InfLP.Events.DV.dvalue
         (fun
         _ : InfLP.Events.DV.dvalue
         =>
         True))
         (@E1.pick
         LLVMParamsBigIntptr.Events.DV.uvalue
         InfLP.Events.DV.dvalue
         (fun
         (_ : InfLP.Events.DV.uvalue)
         (_ : InfLP.Events.DV.dvalue)
         =>
         True)
         Pre1
         (fin_to_inf_uvalue
         x3)))
         (fun
         res :
         @sig
         InfLP.Events.DV.dvalue
         (fun
         _ : InfLP.Events.DV.dvalue
         =>
         True)
         =>
         match
         res
         return
         (itree
         InfLP.Events.L3
         (prod
         InterpreterStackBigIntptr.LLVM.MEM.MMEP.MMSP.MemState
         (prod
         MemPropT.store_id
         (prod
         (prod
         InterpreterStackBigIntptr.LLVM.Local.local_env
         InterpreterStackBigIntptr.LLVM.Stack.lstack)
         (prod
         InterpreterStackBigIntptr.LLVM.Global.global_env
         InterpreterStackBigIntptr.LP.Events.DV.dvalue)))))
         with
         | @exist
         _ _
         x4 p =>
         (fun
         (x5 : InfLP.Events.DV.dvalue)
         (t : True)
         =>
         CIH
         (let
         H2 :
         OOM
         DVCInfFin.DV2.dvalue :=
         DVCInfFin.dvalue_convert_strict
         x5 in
         match
         H2
         return
         (itree
         L3
         (prod
         FinMem.MMEP.MMSP.MemState
         (prod
         MemPropT.store_id
         (prod
         (prod
         local_env
         (@stack
         local_env))
         (prod
         global_env
         dvalue)))))
         with
         | NoOom
         a =>
         (fun
         d : DVCInfFin.DV2.dvalue
         =>
         k1
         (@exist
         dvalue
         (fun
         _ : dvalue
         =>
         True)
         d t))
         a
         | Oom
         s =>
         (fun
         s0 : string
         =>
         @raiseOOM
         L3
         (@ReSum_inr
         (forall
         _ : Type,
         Type)
         IFun
         sum1
         Cat_IFun
         Inr_sum1
         OOME
         (sum1
         PickUvalueE
         (sum1
         OOME
         (sum1
         UBE
         (sum1
         DebugE
         FailureE))))
         ExternalCallE
         (@ReSum_inr
         (forall
         _ : Type,
         Type)
         IFun
         sum1
         Cat_IFun
         Inr_sum1
         OOME
         (sum1
         OOME
         (sum1
         UBE
         (sum1
         DebugE
         FailureE)))
         PickUvalueE
         (@ReSum_inl
         (forall
         _ : Type,
         Type)
         IFun
         sum1
         Cat_IFun
         Inl_sum1
         OOME
         OOME
         (sum1
         UBE
         (sum1
         DebugE
         FailureE))
         (@ReSum_id
         (forall
         _ : Type,
         Type)
         IFun
         Id_IFun
         OOME))))
         (prod
         FinMem.MMEP.MMSP.MemState
         (prod
         MemPropT.store_id
         (prod
         (prod
         local_env
         (@stack
         local_env))
         (prod
         global_env
         dvalue))))
         s0) s
         end))
         x4 p
         end)))
         X0 H0
         k0 X4)
         X0 H1)
         H
         Pre0
         x2)
         Pre
         x1
         end
         in
         X5
         (@eq_refl
         Type
         X0))
         X3)
         x0
         | inr1
         x0 =>
         (fun
         H :
         sum1
         OOME
         (sum1
         UBE
         (sum1
         DebugE
         FailureE))
         X0 =>
         (fun
         H0 :
         sum1
         OOME
         (sum1
         UBE
         (sum1
         DebugE
         FailureE))
         X0 =>
         let
         X3 :
         itree
         InfLP.Events.L3
         (prod
         InterpreterStackBigIntptr.LLVM.MEM.MMEP.MMSP.MemState
         (prod
         MemPropT.store_id
         (prod
         (prod
         InterpreterStackBigIntptr.LLVM.Local.local_env
         InterpreterStackBigIntptr.LLVM.Stack.lstack)
         (prod
         InterpreterStackBigIntptr.LLVM.Global.global_env
         InterpreterStackBigIntptr.LP.Events.DV.dvalue)))) :=
         match
         H0
         return
         (itree
         InfLP.Events.L3
         (prod
         InterpreterStackBigIntptr.LLVM.MEM.MMEP.MMSP.MemState
         (prod
         MemPropT.store_id
         (prod
         (prod
         InterpreterStackBigIntptr.LLVM.Local.local_env
         InterpreterStackBigIntptr.LLVM.Stack.lstack)
         (prod
         InterpreterStackBigIntptr.LLVM.Global.global_env
         InterpreterStackBigIntptr.LP.Events.DV.dvalue)))))
         with
         | inl1
         x1 =>
         (fun
         H1 :
         OOME
         X0 =>
         (fun
         H2 :
         OOME
         X0 =>
         let
         X3 :
         forall
         _ :
         @eq
         Type
         X0 X0,
         itree
         InfLP.Events.L3
         (prod
         InterpreterStackBigIntptr.LLVM.MEM.MMEP.MMSP.MemState
         (prod
         MemPropT.store_id
         (prod
         (prod
         InterpreterStackBigIntptr.LLVM.Local.local_env
         InterpreterStackBigIntptr.LLVM.Stack.lstack)
         (prod
         InterpreterStackBigIntptr.LLVM.Global.global_env
         InterpreterStackBigIntptr.LP.Events.DV.dvalue)))) :=
         match
         H2 in
         (OOME
         T)
         return
         (forall
         _ :
         @eq
         Type
         T X0,
         itree
         InfLP.Events.L3
         (prod
         InterpreterStackBigIntptr.LLVM.MEM.MMEP.MMSP.MemState
         (prod
         MemPropT.store_id
         (prod
         (prod
         InterpreterStackBigIntptr.LLVM.Local.local_env
         InterpreterStackBigIntptr.LLVM.Stack.lstack)
         (prod
         InterpreterStackBigIntptr.LLVM.Global.global_env
         InterpreterStackBigIntptr.LP.Events.DV.dvalue)))))
         with
         | ThrowOOM
         x2 =>
         (fun
         (H3 : unit)
         (H4 :
         @eq
         Type
         Empty_set
         X0)
         =>
         (fun
         H5 :
         @eq
         Type
         Empty_set
         X0 =>
         let
         H6 :
         @eq
         Type
         Empty_set
         X0 :=
         H5 in
         @eq_rect
         Type
         Empty_set
         (fun
         _ : Type
         =>
         forall
         _ : unit,
         itree
         InfLP.Events.L3
         (prod
         InterpreterStackBigIntptr.LLVM.MEM.MMEP.MMSP.MemState
         (prod
         MemPropT.store_id
         (prod
         (prod
         InterpreterStackBigIntptr.LLVM.Local.local_env
         InterpreterStackBigIntptr.LLVM.Stack.lstack)
         (prod
         InterpreterStackBigIntptr.LLVM.Global.global_env
         InterpreterStackBigIntptr.LP.Events.DV.dvalue)))))
         (fun
         _ : unit
         =>
         @eq_rect
         Type
         Empty_set
         (fun
         X3 : Type
         =>
         forall
         (_ :
         forall
         _ : X3,
         itree
         L3
         (prod
         FinMem.MMEP.MMSP.MemState
         (prod
         MemPropT.store_id
         (prod
         (prod
         local_env
         (@stack
         local_env))
         (prod
         global_env
         dvalue)))))
         (_ :
         OOME
         X3),
         itree
         InfLP.Events.L3
         (prod
         InterpreterStackBigIntptr.LLVM.MEM.MMEP.MMSP.MemState
         (prod
         MemPropT.store_id
         (prod
         (prod
         InterpreterStackBigIntptr.LLVM.Local.local_env
         InterpreterStackBigIntptr.LLVM.Stack.lstack)
         (prod
         InterpreterStackBigIntptr.LLVM.Global.global_env
         InterpreterStackBigIntptr.LP.Events.DV.dvalue)))))
         (fun
         (_ :
         forall
         _ : Empty_set,
         itree
         L3
         (prod
         FinMem.MMEP.MMSP.MemState
         (prod
         MemPropT.store_id
         (prod
         (prod
         local_env
         (@stack
         local_env))
         (prod
         global_env
         dvalue)))))
         (_ :
         OOME
         Empty_set)
         =>
         @raiseOOM
         InfLP.Events.L3
         (@ReSum_inr
         (forall
         _ : Type,
         Type)
         IFun
         sum1
         Cat_IFun
         Inr_sum1
         OOME
         (sum1
         InfLP.Events.PickUvalueE
         (sum1
         OOME
         (sum1
         UBE
         (sum1
         DebugE
         FailureE))))
         InfLP.Events.ExternalCallE
         (@ReSum_inr
         (forall
         _ : Type,
         Type)
         IFun
         sum1
         Cat_IFun
         Inr_sum1
         OOME
         (sum1
         OOME
         (sum1
         UBE
         (sum1
         DebugE
         FailureE)))
         InfLP.Events.PickUvalueE
         (@ReSum_inl
         (forall
         _ : Type,
         Type)
         IFun
         sum1
         Cat_IFun
         Inl_sum1
         OOME
         OOME
         (sum1
         UBE
         (sum1
         DebugE
         FailureE))
         (@ReSum_id
         (forall
         _ : Type,
         Type)
         IFun
         Id_IFun
         OOME))))
         (prod
         InterpreterStackBigIntptr.LLVM.MEM.MMEP.MMSP.MemState
         (prod
         MemPropT.store_id
         (prod
         (prod
         InterpreterStackBigIntptr.LLVM.Local.local_env
         InterpreterStackBigIntptr.LLVM.Stack.lstack)
         (prod
         InterpreterStackBigIntptr.LLVM.Global.global_env
         InterpreterStackBigIntptr.LP.Events.DV.dvalue))))
         EmptyString)
         X0 H5
         k0 H2)
         X0 H6)
         H4 H3)
         x2
         end
         in
         X3
         (@eq_refl
         Type
         X0))
         H1)
         x1
         | inr1
         x1 =>
         (fun
         H1 :
         sum1
         UBE
         (sum1
         DebugE
         FailureE)
         X0 =>
         (fun
         H2 :
         sum1
         UBE
         (sum1
         DebugE
         FailureE)
         X0 =>
         let
         X3 :
         itree
         InfLP.Events.L3
         (prod
         InterpreterStackBigIntptr.LLVM.MEM.MMEP.MMSP.MemState
         (prod
         MemPropT.store_id
         (prod
         (prod
         InterpreterStackBigIntptr.LLVM.Local.local_env
         InterpreterStackBigIntptr.LLVM.Stack.lstack)
         (prod
         InterpreterStackBigIntptr.LLVM.Global.global_env
         InterpreterStackBigIntptr.LP.Events.DV.dvalue)))) :=
         match
         H2
         return
         (itree
         InfLP.Events.L3
         (prod
         InterpreterStackBigIntptr.LLVM.MEM.MMEP.MMSP.MemState
         (prod
         MemPropT.store_id
         (prod
         (prod
         InterpreterStackBigIntptr.LLVM.Local.local_env
         InterpreterStackBigIntptr.LLVM.Stack.lstack)
         (prod
         InterpreterStackBigIntptr.LLVM.Global.global_env
         InterpreterStackBigIntptr.LP.Events.DV.dvalue)))))
         with
         | inl1
         x2 =>
         (fun
         H3 :
         UBE
         X0 =>
         (fun
         H4 :
         UBE
         X0 =>
         let
         X3 :
         forall
         _ :
         @eq
         Type
         X0 X0,
         itree
         InfLP.Events.L3
         (prod
         InterpreterStackBigIntptr.LLVM.MEM.MMEP.MMSP.MemState
         (prod
         MemPropT.store_id
         (prod
         (prod
         InterpreterStackBigIntptr.LLVM.Local.local_env
         InterpreterStackBigIntptr.LLVM.Stack.lstack)
         (prod
         InterpreterStackBigIntptr.LLVM.Global.global_env
         InterpreterStackBigIntptr.LP.Events.DV.dvalue)))) :=
         match
         H4 in
         (UBE
         T)
         return
         (forall
         _ :
         @eq
         Type
         T X0,
         itree
         InfLP.Events.L3
         (prod
         InterpreterStackBigIntptr.LLVM.MEM.MMEP.MMSP.MemState
         (prod
         MemPropT.store_id
         (prod
         (prod
         InterpreterStackBigIntptr.LLVM.Local.local_env
         InterpreterStackBigIntptr.LLVM.Stack.lstack)
         (prod
         InterpreterStackBigIntptr.LLVM.Global.global_env
         InterpreterStackBigIntptr.LP.Events.DV.dvalue)))))
         with
         | ThrowUB
         x3 =>
         (fun
         (H5 : unit)
         (H6 :
         @eq
         Type
         Empty_set
         X0)
         =>
         (fun
         H7 :
         @eq
         Type
         Empty_set
         X0 =>
         let
         H8 :
         @eq
         Type
         Empty_set
         X0 :=
         H7 in
         @eq_rect
         Type
         Empty_set
         (fun
         _ : Type
         =>
         forall
         _ : unit,
         itree
         InfLP.Events.L3
         (prod
         InterpreterStackBigIntptr.LLVM.MEM.MMEP.MMSP.MemState
         (prod
         MemPropT.store_id
         (prod
         (prod
         InterpreterStackBigIntptr.LLVM.Local.local_env
         InterpreterStackBigIntptr.LLVM.Stack.lstack)
         (prod
         InterpreterStackBigIntptr.LLVM.Global.global_env
         InterpreterStackBigIntptr.LP.Events.DV.dvalue)))))
         (fun
         _ : unit
         =>
         @eq_rect
         Type
         Empty_set
         (fun
         X3 : Type
         =>
         forall
         (_ :
         forall
         _ : X3,
         itree
         L3
         (prod
         FinMem.MMEP.MMSP.MemState
         (prod
         MemPropT.store_id
         (prod
         (prod
         local_env
         (@stack
         local_env))
         (prod
         global_env
         dvalue)))))
         (_ :
         UBE
         X3),
         itree
         InfLP.Events.L3
         (prod
         InterpreterStackBigIntptr.LLVM.MEM.MMEP.MMSP.MemState
         (prod
         MemPropT.store_id
         (prod
         (prod
         InterpreterStackBigIntptr.LLVM.Local.local_env
         InterpreterStackBigIntptr.LLVM.Stack.lstack)
         (prod
         InterpreterStackBigIntptr.LLVM.Global.global_env
         InterpreterStackBigIntptr.LP.Events.DV.dvalue)))))
         (fun
         (_ :
         forall
         _ : Empty_set,
         itree
         L3
         (prod
         FinMem.MMEP.MMSP.MemState
         (prod
         MemPropT.store_id
         (prod
         (prod
         local_env
         (@stack
         local_env))
         (prod
         global_env
         dvalue)))))
         (_ :
         UBE
         Empty_set)
         =>
         @raiseUB
         InfLP.Events.L3
         (@ReSum_inr
         (forall
         _ : Type,
         Type)
         IFun
         sum1
         Cat_IFun
         Inr_sum1
         UBE
         (sum1
         InfLP.Events.PickUvalueE
         (sum1
         OOME
         (sum1
         UBE
         (sum1
         DebugE
         FailureE))))
         InfLP.Events.ExternalCallE
         (@ReSum_inr
         (forall
         _ : Type,
         Type)
         IFun
         sum1
         Cat_IFun
         Inr_sum1
         UBE
         (sum1
         OOME
         (sum1
         UBE
         (sum1
         DebugE
         FailureE)))
         InfLP.Events.PickUvalueE
         (@ReSum_inr
         (forall
         _ : Type,
         Type)
         IFun
         sum1
         Cat_IFun
         Inr_sum1
         UBE
         (sum1
         UBE
         (sum1
         DebugE
         FailureE))
         OOME
         (@ReSum_inl
         (forall
         _ : Type,
         Type)
         IFun
         sum1
         Cat_IFun
         Inl_sum1
         UBE
         UBE
         (sum1
         DebugE
         FailureE)
         (@ReSum_id
         (forall
         _ : Type,
         Type)
         IFun
         Id_IFun
         UBE)))))
         (prod
         InterpreterStackBigIntptr.LLVM.MEM.MMEP.MMSP.MemState
         (prod
         MemPropT.store_id
         (prod
         (prod
         InterpreterStackBigIntptr.LLVM.Local.local_env
         InterpreterStackBigIntptr.LLVM.Stack.lstack)
         (prod
         InterpreterStackBigIntptr.LLVM.Global.global_env
         InterpreterStackBigIntptr.LP.Events.DV.dvalue))))
         EmptyString)
         X0 H7
         k0 H4)
         X0 H8)
         H6 H5)
         x3
         end
         in
         X3
         (@eq_refl
         Type
         X0))
         H3)
         x2
         | inr1
         x2 =>
         (fun
         H3 :
         sum1
         DebugE
         FailureE
         X0 =>
         (fun
         H4 :
         sum1
         DebugE
         FailureE
         X0 =>
         let
         X3 :
         itree
         InfLP.Events.L3
         (prod
         InterpreterStackBigIntptr.LLVM.MEM.MMEP.MMSP.MemState
         (prod
         MemPropT.store_id
         (prod
         (prod
         InterpreterStackBigIntptr.LLVM.Local.local_env
         InterpreterStackBigIntptr.LLVM.Stack.lstack)
         (prod
         InterpreterStackBigIntptr.LLVM.Global.global_env
         InterpreterStackBigIntptr.LP.Events.DV.dvalue)))) :=
         match
         H4
         return
         (itree
         InfLP.Events.L3
         (prod
         InterpreterStackBigIntptr.LLVM.MEM.MMEP.MMSP.MemState
         (prod
         MemPropT.store_id
         (prod
         (prod
         InterpreterStackBigIntptr.LLVM.Local.local_env
         InterpreterStackBigIntptr.LLVM.Stack.lstack)
         (prod
         InterpreterStackBigIntptr.LLVM.Global.global_env
         InterpreterStackBigIntptr.LP.Events.DV.dvalue)))))
         with
         | inl1
         x3 =>
         (fun
         H5 :
         DebugE
         X0 =>
         (fun
         H6 :
         DebugE
         X0 =>
         let
         X3 :
         forall
         _ :
         @eq
         Type
         X0 X0,
         itree
         InfLP.Events.L3
         (prod
         InterpreterStackBigIntptr.LLVM.MEM.MMEP.MMSP.MemState
         (prod
         MemPropT.store_id
         (prod
         (prod
         InterpreterStackBigIntptr.LLVM.Local.local_env
         InterpreterStackBigIntptr.LLVM.Stack.lstack)
         (prod
         InterpreterStackBigIntptr.LLVM.Global.global_env
         InterpreterStackBigIntptr.LP.Events.DV.dvalue)))) :=
         match
         H6 in
         (DebugE
         T)
         return
         (forall
         _ :
         @eq
         Type
         T X0,
         itree
         InfLP.Events.L3
         (prod
         InterpreterStackBigIntptr.LLVM.MEM.MMEP.MMSP.MemState
         (prod
         MemPropT.store_id
         (prod
         (prod
         InterpreterStackBigIntptr.LLVM.Local.local_env
         InterpreterStackBigIntptr.LLVM.Stack.lstack)
         (prod
         InterpreterStackBigIntptr.LLVM.Global.global_env
         InterpreterStackBigIntptr.LP.Events.DV.dvalue)))))
         with
         | Debug
         x4 =>
         (fun
         (H7 : unit)
         (H8 :
         @eq
         Type
         unit
         X0)
         =>
         (fun
         H9 :
         @eq
         Type
         unit
         X0 =>
         let
         H10 :
         @eq
         Type
         unit
         X0 :=
         H9 in
         @eq_rect
         Type
         unit
         (fun
         _ : Type
         =>
         forall
         _ : unit,
         itree
         InfLP.Events.L3
         (prod
         InterpreterStackBigIntptr.LLVM.MEM.MMEP.MMSP.MemState
         (prod
         MemPropT.store_id
         (prod
         (prod
         InterpreterStackBigIntptr.LLVM.Local.local_env
         InterpreterStackBigIntptr.LLVM.Stack.lstack)
         (prod
         InterpreterStackBigIntptr.LLVM.Global.global_env
         InterpreterStackBigIntptr.LP.Events.DV.dvalue)))))
         (fun
         H11 : unit
         =>
         @eq_rect
         Type
         unit
         (fun
         X3 : Type
         =>
         forall
         (_ :
         forall
         _ : X3,
         itree
         L3
         (prod
         FinMem.MMEP.MMSP.MemState
         (prod
         MemPropT.store_id
         (prod
         (prod
         local_env
         (@stack
         local_env))
         (prod
         global_env
         dvalue)))))
         (_ :
         DebugE
         X3),
         itree
         InfLP.Events.L3
         (prod
         InterpreterStackBigIntptr.LLVM.MEM.MMEP.MMSP.MemState
         (prod
         MemPropT.store_id
         (prod
         (prod
         InterpreterStackBigIntptr.LLVM.Local.local_env
         InterpreterStackBigIntptr.LLVM.Stack.lstack)
         (prod
         InterpreterStackBigIntptr.LLVM.Global.global_env
         InterpreterStackBigIntptr.LP.Events.DV.dvalue)))))
         (fun
         (k1 :
         forall
         _ : unit,
         itree
         L3
         (prod
         FinMem.MMEP.MMSP.MemState
         (prod
         MemPropT.store_id
         (prod
         (prod
         local_env
         (@stack
         local_env))
         (prod
         global_env
         dvalue)))))
         (_ :
         DebugE
         unit)
         =>
         @go
         InfLP.Events.L3
         (prod
         InterpreterStackBigIntptr.LLVM.MEM.MMEP.MMSP.MemState
         (prod
         MemPropT.store_id
         (prod
         (prod
         InterpreterStackBigIntptr.LLVM.Local.local_env
         InterpreterStackBigIntptr.LLVM.Stack.lstack)
         (prod
         InterpreterStackBigIntptr.LLVM.Global.global_env
         InterpreterStackBigIntptr.LP.Events.DV.dvalue))))
         (@VisF
         InfLP.Events.L3
         (prod
         InterpreterStackBigIntptr.LLVM.MEM.MMEP.MMSP.MemState
         (prod
         MemPropT.store_id
         (prod
         (prod
         InterpreterStackBigIntptr.LLVM.Local.local_env
         InterpreterStackBigIntptr.LLVM.Stack.lstack)
         (prod
         InterpreterStackBigIntptr.LLVM.Global.global_env
         InterpreterStackBigIntptr.LP.Events.DV.dvalue))))
         (itree
         InfLP.Events.L3
         (prod
         InterpreterStackBigIntptr.LLVM.MEM.MMEP.MMSP.MemState
         (prod
         MemPropT.store_id
         (prod
         (prod
         InterpreterStackBigIntptr.LLVM.Local.local_env
         InterpreterStackBigIntptr.LLVM.Stack.lstack)
         (prod
         InterpreterStackBigIntptr.LLVM.Global.global_env
         InterpreterStackBigIntptr.LP.Events.DV.dvalue)))))
         unit
         (@subevent
         DebugE
         InfLP.Events.L3
         (@ReSum_inr
         (forall
         _ : Type,
         Type)
         IFun
         sum1
         Cat_IFun
         Inr_sum1
         DebugE
         (sum1
         InfLP.Events.PickUvalueE
         (sum1
         OOME
         (sum1
         UBE
         (sum1
         DebugE
         FailureE))))
         InfLP.Events.ExternalCallE
         (@ReSum_inr
         (forall
         _ : Type,
         Type)
         IFun
         sum1
         Cat_IFun
         Inr_sum1
         DebugE
         (sum1
         OOME
         (sum1
         UBE
         (sum1
         DebugE
         FailureE)))
         InfLP.Events.PickUvalueE
         (@ReSum_inr
         (forall
         _ : Type,
         Type)
         IFun
         sum1
         Cat_IFun
         Inr_sum1
         DebugE
         (sum1
         UBE
         (sum1
         DebugE
         FailureE))
         OOME
         (@ReSum_inr
         (forall
         _ : Type,
         Type)
         IFun
         sum1
         Cat_IFun
         Inr_sum1
         DebugE
         (sum1
         DebugE
         FailureE)
         UBE
         (@ReSum_inl
         (forall
         _ : Type,
         Type)
         IFun
         sum1
         Cat_IFun
         Inl_sum1
         DebugE
         DebugE
         FailureE
         (@ReSum_id
         (forall
         _ : Type,
         Type)
         IFun
         Id_IFun
         DebugE))))))
         unit
         (Debug
         H11))
         (fun
         H13 : unit
         =>
         CIH
         (k1
         H13))))
         X0 H9
         k0 H6)
         X0
         H10)
         H8 H7)
         x4
         end
         in
         X3
         (@eq_refl
         Type
         X0))
         H5)
         x3
         | inr1
         x3 =>
         (fun
         H5 :
         FailureE
         X0 =>
         (fun
         H6 :
         FailureE
         X0 =>
         let
         X3 :
         forall
         _ :
         @eq
         Type
         X0 X0,
         itree
         InfLP.Events.L3
         (prod
         InterpreterStackBigIntptr.LLVM.MEM.MMEP.MMSP.MemState
         (prod
         MemPropT.store_id
         (prod
         (prod
         InterpreterStackBigIntptr.LLVM.Local.local_env
         InterpreterStackBigIntptr.LLVM.Stack.lstack)
         (prod
         InterpreterStackBigIntptr.LLVM.Global.global_env
         InterpreterStackBigIntptr.LP.Events.DV.dvalue)))) :=
         match
         H6 in
         (FailureE
         T)
         return
         (forall
         _ :
         @eq
         Type
         T X0,
         itree
         InfLP.Events.L3
         (prod
         InterpreterStackBigIntptr.LLVM.MEM.MMEP.MMSP.MemState
         (prod
         MemPropT.store_id
         (prod
         (prod
         InterpreterStackBigIntptr.LLVM.Local.local_env
         InterpreterStackBigIntptr.LLVM.Stack.lstack)
         (prod
         InterpreterStackBigIntptr.LLVM.Global.global_env
         InterpreterStackBigIntptr.LP.Events.DV.dvalue)))))
         with
         | Throw
         x4 =>
         (fun
         (H7 : unit)
         (H8 :
         @eq
         Type
         Empty_set
         X0)
         =>
         (fun
         H9 :
         @eq
         Type
         Empty_set
         X0 =>
         let
         H10 :
         @eq
         Type
         Empty_set
         X0 :=
         H9 in
         @eq_rect
         Type
         Empty_set
         (fun
         _ : Type
         =>
         forall
         _ : unit,
         itree
         InfLP.Events.L3
         (prod
         InterpreterStackBigIntptr.LLVM.MEM.MMEP.MMSP.MemState
         (prod
         MemPropT.store_id
         (prod
         (prod
         InterpreterStackBigIntptr.LLVM.Local.local_env
         InterpreterStackBigIntptr.LLVM.Stack.lstack)
         (prod
         InterpreterStackBigIntptr.LLVM.Global.global_env
         InterpreterStackBigIntptr.LP.Events.DV.dvalue)))))
         (fun
         _ : unit
         =>
         @eq_rect
         Type
         Empty_set
         (fun
         X3 : Type
         =>
         forall
         (_ :
         forall
         _ : X3,
         itree
         L3
         (prod
         FinMem.MMEP.MMSP.MemState
         (prod
         MemPropT.store_id
         (prod
         (prod
         local_env
         (@stack
         local_env))
         (prod
         global_env
         dvalue)))))
         (_ :
         FailureE
         X3),
         itree
         InfLP.Events.L3
         (prod
         InterpreterStackBigIntptr.LLVM.MEM.MMEP.MMSP.MemState
         (prod
         MemPropT.store_id
         (prod
         (prod
         InterpreterStackBigIntptr.LLVM.Local.local_env
         InterpreterStackBigIntptr.LLVM.Stack.lstack)
         (prod
         InterpreterStackBigIntptr.LLVM.Global.global_env
         InterpreterStackBigIntptr.LP.Events.DV.dvalue)))))
         (fun
         (_ :
         forall
         _ : Empty_set,
         itree
         L3
         (prod
         FinMem.MMEP.MMSP.MemState
         (prod
         MemPropT.store_id
         (prod
         (prod
         local_env
         (@stack
         local_env))
         (prod
         global_env
         dvalue)))))
         (_ :
         FailureE
         Empty_set)
         =>
         @LLVMEvents.raise
         InfLP.Events.L3
         (prod
         InterpreterStackBigIntptr.LLVM.MEM.MMEP.MMSP.MemState
         (prod
         MemPropT.store_id
         (prod
         (prod
         InterpreterStackBigIntptr.LLVM.Local.local_env
         InterpreterStackBigIntptr.LLVM.Stack.lstack)
         (prod
         InterpreterStackBigIntptr.LLVM.Global.global_env
         InterpreterStackBigIntptr.LP.Events.DV.dvalue))))
         (@ReSum_inr
         (forall
         _ : Type,
         Type)
         IFun
         sum1
         Cat_IFun
         Inr_sum1
         FailureE
         (sum1
         InfLP.Events.PickUvalueE
         (sum1
         OOME
         (sum1
         UBE
         (sum1
         DebugE
         FailureE))))
         InfLP.Events.ExternalCallE
         (@ReSum_inr
         (forall
         _ : Type,
         Type)
         IFun
         sum1
         Cat_IFun
         Inr_sum1
         FailureE
         (sum1
         OOME
         (sum1
         UBE
         (sum1
         DebugE
         FailureE)))
         InfLP.Events.PickUvalueE
         (@ReSum_inr
         (forall
         _ : Type,
         Type)
         IFun
         sum1
         Cat_IFun
         Inr_sum1
         FailureE
         (sum1
         UBE
         (sum1
         DebugE
         FailureE))
         OOME
         (@ReSum_inr
         (forall
         _ : Type,
         Type)
         IFun
         sum1
         Cat_IFun
         Inr_sum1
         FailureE
         (sum1
         DebugE
         FailureE)
         UBE
         (@ReSum_inr
         (forall
         _ : Type,
         Type)
         IFun
         sum1
         Cat_IFun
         Inr_sum1
         FailureE
         FailureE
         DebugE
         (@ReSum_id
         (forall
         _ : Type,
         Type)
         IFun
         Id_IFun
         FailureE))))))
         EmptyString)
         X0 H9
         k0 H6)
         X0
         H10)
         H8 H7)
         x4
         end
         in
         X3
         (@eq_refl
         Type
         X0))
         H5)
         x3
         end
         in
         X3)
         H3)
         x2
         end
         in
         X3)
         H1)
         x1
         end
         in
         X3) H)
         x0
         end
         in
         X3)
         X1) x
         end
         in
        X1) X
         e k
   end)
    (@_observe
       _ _
       t_fin2).

  Definition _get_inf_tree (t_fin2 : itree' L3 (FinMem.MMEP.MMSP.MemState * (MemPropT.store_id * (local_env * @stack local_env * res_L1)))) : itree InfLP.Events.L3 TopLevelBigIntptr.res_L6 :=
   match t_fin2 with
   | RetF r =>
       (fun
         r0 :
         prod
         FinMem.MMEP.MMSP.MemState
         (prod
         MemPropT.store_id
         (prod
         (prod
         local_env
         (@stack
         local_env))
         (prod
         global_env
         dvalue)))
        =>
        @ret
         (itree
         InfLP.Events.L3)
         (@Monad_itree
         InfLP.Events.L3)
         (prod
         InterpreterStackBigIntptr.LLVM.MEM.MMEP.MMSP.MemState
         (prod
         MemPropT.store_id
         (prod
         (prod
         InterpreterStackBigIntptr.LLVM.Local.local_env
         InterpreterStackBigIntptr.LLVM.Stack.lstack)
         (prod
         InterpreterStackBigIntptr.LLVM.Global.global_env
         InterpreterStackBigIntptr.LP.Events.DV.dvalue))))
         match
         r0
         return
         (prod
         InterpreterStackBigIntptr.LLVM.MEM.MMEP.MMSP.MemState
         (prod
         MemPropT.store_id
         (prod
         (prod
         InterpreterStackBigIntptr.LLVM.Local.local_env
         InterpreterStackBigIntptr.LLVM.Stack.lstack)
         (prod
         InterpreterStackBigIntptr.LLVM.Global.global_env
         InterpreterStackBigIntptr.LP.Events.DV.dvalue))))
         with
         | pair
         a b =>
         (fun
         (ms : FinMem.MMEP.MMSP.MemState)
         (p :
         prod
         MemPropT.store_id
         (prod
         (prod
         local_env
         (@stack
         local_env))
         (prod
         global_env
         dvalue)))
         =>
         match
         p
         return
         (prod
         InterpreterStackBigIntptr.LLVM.MEM.MMEP.MMSP.MemState
         (prod
         MemPropT.store_id
         (prod
         (prod
         InterpreterStackBigIntptr.LLVM.Local.local_env
         InterpreterStackBigIntptr.LLVM.Stack.lstack)
         (prod
         InterpreterStackBigIntptr.LLVM.Global.global_env
         InterpreterStackBigIntptr.LP.Events.DV.dvalue))))
         with
         | pair
         a0 b0 =>
         (fun
         (sid : MemPropT.store_id)
         (p0 :
         prod
         (prod
         local_env
         (@stack
         local_env))
         (prod
         global_env
         dvalue))
         =>
         match
         p0
         return
         (prod
         InterpreterStackBigIntptr.LLVM.MEM.MMEP.MMSP.MemState
         (prod
         MemPropT.store_id
         (prod
         (prod
         InterpreterStackBigIntptr.LLVM.Local.local_env
         InterpreterStackBigIntptr.LLVM.Stack.lstack)
         (prod
         InterpreterStackBigIntptr.LLVM.Global.global_env
         InterpreterStackBigIntptr.LP.Events.DV.dvalue))))
         with
         | pair
         a1 b1 =>
         (fun
         p1 :
         prod
         local_env
         (@stack
         local_env)
         =>
         match
         p1
         return
         (forall
         _ :
         prod
         global_env
         dvalue,
         prod
         InterpreterStackBigIntptr.LLVM.MEM.MMEP.MMSP.MemState
         (prod
         MemPropT.store_id
         (prod
         (prod
         InterpreterStackBigIntptr.LLVM.Local.local_env
         InterpreterStackBigIntptr.LLVM.Stack.lstack)
         (prod
         InterpreterStackBigIntptr.LLVM.Global.global_env
         InterpreterStackBigIntptr.LP.Events.DV.dvalue))))
         with
         | pair
         a2 b2 =>
         (fun
         (lenv : local_env)
         (s :
         @stack
         local_env)
         (p2 :
         prod
         global_env
         dvalue)
         =>
         match
         p2
         return
         (prod
         InterpreterStackBigIntptr.LLVM.MEM.MMEP.MMSP.MemState
         (prod
         MemPropT.store_id
         (prod
         (prod
         InterpreterStackBigIntptr.LLVM.Local.local_env
         InterpreterStackBigIntptr.LLVM.Stack.lstack)
         (prod
         InterpreterStackBigIntptr.LLVM.Global.global_env
         InterpreterStackBigIntptr.LP.Events.DV.dvalue))))
         with
         | pair
         a3 b3 =>
         (fun
         (genv : global_env)
         (res : dvalue)
         =>
         @pair
         InterpreterStackBigIntptr.LLVM.MEM.MMEP.MMSP.MemState
         (prod
         MemPropT.store_id
         (prod
         (prod
         InterpreterStackBigIntptr.LLVM.Local.local_env
         InterpreterStackBigIntptr.LLVM.Stack.lstack)
         (prod
         InterpreterStackBigIntptr.LLVM.Global.global_env
         InterpreterStackBigIntptr.LP.Events.DV.dvalue)))
         (lift_MemState
         ms)
         (@pair
         MemPropT.store_id
         (prod
         (prod
         InterpreterStackBigIntptr.LLVM.Local.local_env
         InterpreterStackBigIntptr.LLVM.Stack.lstack)
         (prod
         InterpreterStackBigIntptr.LLVM.Global.global_env
         InterpreterStackBigIntptr.LP.Events.DV.dvalue))
         sid
         (@pair
         (prod
         InterpreterStackBigIntptr.LLVM.Local.local_env
         InterpreterStackBigIntptr.LLVM.Stack.lstack)
         (prod
         InterpreterStackBigIntptr.LLVM.Global.global_env
         InterpreterStackBigIntptr.LP.Events.DV.dvalue)
         (@pair
         InterpreterStackBigIntptr.LLVM.Local.local_env
         InterpreterStackBigIntptr.LLVM.Stack.lstack
         (lift_local_env
         lenv)
         (lift_stack
         s))
         (@pair
         InterpreterStackBigIntptr.LLVM.Global.global_env
         InterpreterStackBigIntptr.LP.Events.DV.dvalue
         (lift_global_env
         genv)
         (fin_to_inf_dvalue
         res)))))
         a3 b3
         end)
         a2 b2
         end)
         a1 b1
         end)
         a0 b0
         end)
         a b
         end)
         r
   | TauF t =>
       (fun
         t0 :
         itree
         L3
         (prod
         FinMem.MMEP.MMSP.MemState
         (prod
         MemPropT.store_id
         (prod
         (prod
         local_env
         (@stack
         local_env))
         (prod
         global_env
         dvalue))))
        =>
        @go
         InfLP.Events.L3
         (prod
         InterpreterStackBigIntptr.LLVM.MEM.MMEP.MMSP.MemState
         (prod
         MemPropT.store_id
         (prod
         (prod
         InterpreterStackBigIntptr.LLVM.Local.local_env
         InterpreterStackBigIntptr.LLVM.Stack.lstack)
         (prod
         InterpreterStackBigIntptr.LLVM.Global.global_env
         InterpreterStackBigIntptr.LP.Events.DV.dvalue))))
         (@TauF
         InfLP.Events.L3
         (prod
         InterpreterStackBigIntptr.LLVM.MEM.MMEP.MMSP.MemState
         (prod
         MemPropT.store_id
         (prod
         (prod
         InterpreterStackBigIntptr.LLVM.Local.local_env
         InterpreterStackBigIntptr.LLVM.Stack.lstack)
         (prod
         InterpreterStackBigIntptr.LLVM.Global.global_env
         InterpreterStackBigIntptr.LP.Events.DV.dvalue))))
         (itree
         InfLP.Events.L3
         (prod
         InterpreterStackBigIntptr.LLVM.MEM.MMEP.MMSP.MemState
         (prod
         MemPropT.store_id
         (prod
         (prod
         InterpreterStackBigIntptr.LLVM.Local.local_env
         InterpreterStackBigIntptr.LLVM.Stack.lstack)
         (prod
         InterpreterStackBigIntptr.LLVM.Global.global_env
         InterpreterStackBigIntptr.LP.Events.DV.dvalue)))))
         (get_inf_tree
         t0)))
         t
   | @VisF _ _
     _ X e k =>
       (fun
         (X0 : Type)
         (e0 :
         L3 X0)
         (k0 :
         forall
         _ : X0,
         itree
         L3
         (prod
         FinMem.MMEP.MMSP.MemState
         (prod
         MemPropT.store_id
         (prod
         (prod
         local_env
         (@stack
         local_env))
         (prod
         global_env
         dvalue)))))
        =>
        let
         X1 :
         itree
         InfLP.Events.L3
         (prod
         InterpreterStackBigIntptr.LLVM.MEM.MMEP.MMSP.MemState
         (prod
         MemPropT.store_id
         (prod
         (prod
         InterpreterStackBigIntptr.LLVM.Local.local_env
         InterpreterStackBigIntptr.LLVM.Stack.lstack)
         (prod
         InterpreterStackBigIntptr.LLVM.Global.global_env
         InterpreterStackBigIntptr.LP.Events.DV.dvalue)))) :=
         match
         e0
         return
         (itree
         InfLP.Events.L3
         (prod
         InterpreterStackBigIntptr.LLVM.MEM.MMEP.MMSP.MemState
         (prod
         MemPropT.store_id
         (prod
         (prod
         InterpreterStackBigIntptr.LLVM.Local.local_env
         InterpreterStackBigIntptr.LLVM.Stack.lstack)
         (prod
         InterpreterStackBigIntptr.LLVM.Global.global_env
         InterpreterStackBigIntptr.LP.Events.DV.dvalue)))))
         with
         | inl1
         x =>
         (fun
         H :
         ExternalCallE
         X0 =>
         (fun
         H0 :
         ExternalCallE
         X0 =>
         let
         X1 :
         forall
         _ :
         @eq
         Type
         X0 X0,
         itree
         InfLP.Events.L3
         (prod
         InterpreterStackBigIntptr.LLVM.MEM.MMEP.MMSP.MemState
         (prod
         MemPropT.store_id
         (prod
         (prod
         InterpreterStackBigIntptr.LLVM.Local.local_env
         InterpreterStackBigIntptr.LLVM.Stack.lstack)
         (prod
         InterpreterStackBigIntptr.LLVM.Global.global_env
         InterpreterStackBigIntptr.LP.Events.DV.dvalue)))) :=
         match
         H0 in
         (ExternalCallE
         T)
         return
         (forall
         _ :
         @eq
         Type
         T X0,
         itree
         InfLP.Events.L3
         (prod
         InterpreterStackBigIntptr.LLVM.MEM.MMEP.MMSP.MemState
         (prod
         MemPropT.store_id
         (prod
         (prod
         InterpreterStackBigIntptr.LLVM.Local.local_env
         InterpreterStackBigIntptr.LLVM.Stack.lstack)
         (prod
         InterpreterStackBigIntptr.LLVM.Global.global_env
         InterpreterStackBigIntptr.LP.Events.DV.dvalue)))))
         with
         | ExternalCall
         t f
         args =>
         (fun
         (t0 : dtyp)
         (f0 : uvalue)
         (args0 :
         list
         dvalue)
         (H1 :
         @eq
         Type
         dvalue
         X0)
         =>
         (fun
         H2 :
         @eq
         Type
         dvalue
         X0 =>
         let
         H3 :
         @eq
         Type
         dvalue
         X0 :=
         H2 in
         @eq_rect
         Type
         dvalue
         (fun
         _ : Type
         =>
         forall
         (_ : dtyp)
         (_ : uvalue)
         (_ :
         list
         dvalue),
         itree
         InfLP.Events.L3
         (prod
         InterpreterStackBigIntptr.LLVM.MEM.MMEP.MMSP.MemState
         (prod
         MemPropT.store_id
         (prod
         (prod
         InterpreterStackBigIntptr.LLVM.Local.local_env
         InterpreterStackBigIntptr.LLVM.Stack.lstack)
         (prod
         InterpreterStackBigIntptr.LLVM.Global.global_env
         InterpreterStackBigIntptr.LP.Events.DV.dvalue)))))
         (fun
         (t1 : dtyp)
         (f1 : uvalue)
         (args1 :
         list
         dvalue)
         =>
         @eq_rect
         Type
         dvalue
         (fun
         X1 : Type
         =>
         forall
         (_ :
         forall
         _ : X1,
         itree
         L3
         (prod
         FinMem.MMEP.MMSP.MemState
         (prod
         MemPropT.store_id
         (prod
         (prod
         local_env
         (@stack
         local_env))
         (prod
         global_env
         dvalue)))))
         (_ :
         ExternalCallE
         X1),
         itree
         InfLP.Events.L3
         (prod
         InterpreterStackBigIntptr.LLVM.MEM.MMEP.MMSP.MemState
         (prod
         MemPropT.store_id
         (prod
         (prod
         InterpreterStackBigIntptr.LLVM.Local.local_env
         InterpreterStackBigIntptr.LLVM.Stack.lstack)
         (prod
         InterpreterStackBigIntptr.LLVM.Global.global_env
         InterpreterStackBigIntptr.LP.Events.DV.dvalue)))))
         (fun
         (k1 :
         forall
         _ : dvalue,
         itree
         L3
         (prod
         FinMem.MMEP.MMSP.MemState
         (prod
         MemPropT.store_id
         (prod
         (prod
         local_env
         (@stack
         local_env))
         (prod
         global_env
         dvalue)))))
         (_ :
         ExternalCallE
         dvalue)
         =>
         @go
         InfLP.Events.L3
         (prod
         InterpreterStackBigIntptr.LLVM.MEM.MMEP.MMSP.MemState
         (prod
         MemPropT.store_id
         (prod
         (prod
         InterpreterStackBigIntptr.LLVM.Local.local_env
         InterpreterStackBigIntptr.LLVM.Stack.lstack)
         (prod
         InterpreterStackBigIntptr.LLVM.Global.global_env
         InterpreterStackBigIntptr.LP.Events.DV.dvalue))))
         (@VisF
         InfLP.Events.L3
         (prod
         InterpreterStackBigIntptr.LLVM.MEM.MMEP.MMSP.MemState
         (prod
         MemPropT.store_id
         (prod
         (prod
         InterpreterStackBigIntptr.LLVM.Local.local_env
         InterpreterStackBigIntptr.LLVM.Stack.lstack)
         (prod
         InterpreterStackBigIntptr.LLVM.Global.global_env
         InterpreterStackBigIntptr.LP.Events.DV.dvalue))))
         (itree
         InfLP.Events.L3
         (prod
         InterpreterStackBigIntptr.LLVM.MEM.MMEP.MMSP.MemState
         (prod
         MemPropT.store_id
         (prod
         (prod
         InterpreterStackBigIntptr.LLVM.Local.local_env
         InterpreterStackBigIntptr.LLVM.Stack.lstack)
         (prod
         InterpreterStackBigIntptr.LLVM.Global.global_env
         InterpreterStackBigIntptr.LP.Events.DV.dvalue)))))
         E1.DV.dvalue
         (@subevent
         E1.ExternalCallE
         InfLP.Events.L3
         (@ReSum_inl
         (forall
         _ : Type,
         Type)
         IFun
         sum1
         Cat_IFun
         Inl_sum1
         E1.ExternalCallE
         InfLP.Events.ExternalCallE
         (sum1
         InfLP.Events.PickUvalueE
         (sum1
         OOME
         (sum1
         UBE
         (sum1
         DebugE
         FailureE))))
         (@ReSum_id
         (forall
         _ : Type,
         Type)
         IFun
         Id_IFun
         InfLP.Events.ExternalCallE))
         E1.DV.dvalue
         (E1.ExternalCall
         t1
         (fin_to_inf_uvalue
         f1)
         (@map
         LLVMParams64BitIntptr.Events.DV.dvalue
         LLVMParamsBigIntptr.Events.DV.dvalue
         fin_to_inf_dvalue
         args1)))
         (fun
         x0 : E1.DV.dvalue
         =>
         get_inf_tree
         (let
         H5 :
         OOM
         DVCInfFin.DV2.dvalue :=
         DVCInfFin.dvalue_convert_strict
         x0 in
         match
         H5
         return
         (itree
         L3
         (prod
         FinMem.MMEP.MMSP.MemState
         (prod
         MemPropT.store_id
         (prod
         (prod
         local_env
         (@stack
         local_env))
         (prod
         global_env
         dvalue)))))
         with
         | NoOom
         a =>
         (fun
         d : DVCInfFin.DV2.dvalue
         =>
         k1 d)
         a
         | Oom
         s =>
         (fun
         s0 : string
         =>
         @raiseOOM
         L3
         (@ReSum_inr
         (forall
         _ : Type,
         Type)
         IFun
         sum1
         Cat_IFun
         Inr_sum1
         OOME
         (sum1
         PickUvalueE
         (sum1
         OOME
         (sum1
         UBE
         (sum1
         DebugE
         FailureE))))
         ExternalCallE
         (@ReSum_inr
         (forall
         _ : Type,
         Type)
         IFun
         sum1
         Cat_IFun
         Inr_sum1
         OOME
         (sum1
         OOME
         (sum1
         UBE
         (sum1
         DebugE
         FailureE)))
         PickUvalueE
         (@ReSum_inl
         (forall
         _ : Type,
         Type)
         IFun
         sum1
         Cat_IFun
         Inl_sum1
         OOME
         OOME
         (sum1
         UBE
         (sum1
         DebugE
         FailureE))
         (@ReSum_id
         (forall
         _ : Type,
         Type)
         IFun
         Id_IFun
         OOME))))
         (prod
         FinMem.MMEP.MMSP.MemState
         (prod
         MemPropT.store_id
         (prod
         (prod
         local_env
         (@stack
         local_env))
         (prod
         global_env
         dvalue))))
         s0) s
         end))))
         X0 H2
         k0 H0)
         X0 H3)
         H1 t0
         f0
         args0)
         t f
         args
         end
         in
         X1
         (@eq_refl
         Type
         X0))
         H) x
         | inr1
         x =>
         (fun
         X1 :
         sum1
         PickUvalueE
         (sum1
         OOME
         (sum1
         UBE
         (sum1
         DebugE
         FailureE)))
         X0 =>
         (fun
         X2 :
         sum1
         PickUvalueE
         (sum1
         OOME
         (sum1
         UBE
         (sum1
         DebugE
         FailureE)))
         X0 =>
         let
         X3 :
         itree
         InfLP.Events.L3
         (prod
         InterpreterStackBigIntptr.LLVM.MEM.MMEP.MMSP.MemState
         (prod
         MemPropT.store_id
         (prod
         (prod
         InterpreterStackBigIntptr.LLVM.Local.local_env
         InterpreterStackBigIntptr.LLVM.Stack.lstack)
         (prod
         InterpreterStackBigIntptr.LLVM.Global.global_env
         InterpreterStackBigIntptr.LP.Events.DV.dvalue)))) :=
         match
         X2
         return
         (itree
         InfLP.Events.L3
         (prod
         InterpreterStackBigIntptr.LLVM.MEM.MMEP.MMSP.MemState
         (prod
         MemPropT.store_id
         (prod
         (prod
         InterpreterStackBigIntptr.LLVM.Local.local_env
         InterpreterStackBigIntptr.LLVM.Stack.lstack)
         (prod
         InterpreterStackBigIntptr.LLVM.Global.global_env
         InterpreterStackBigIntptr.LP.Events.DV.dvalue)))))
         with
         | inl1
         x0 =>
         (fun
         X3 :
         PickUvalueE
         X0 =>
         (fun
         X4 :
         PickUvalueE
         X0 =>
         let
         X5 :
         forall
         _ :
         @eq
         Type
         X0 X0,
         itree
         InfLP.Events.L3
         (prod
         InterpreterStackBigIntptr.LLVM.MEM.MMEP.MMSP.MemState
         (prod
         MemPropT.store_id
         (prod
         (prod
         InterpreterStackBigIntptr.LLVM.Local.local_env
         InterpreterStackBigIntptr.LLVM.Stack.lstack)
         (prod
         InterpreterStackBigIntptr.LLVM.Global.global_env
         InterpreterStackBigIntptr.LP.Events.DV.dvalue)))) :=
         match
         X4 in
         (PickE
         T)
         return
         (forall
         _ :
         @eq
         Type
         T X0,
         itree
         InfLP.Events.L3
         (prod
         InterpreterStackBigIntptr.LLVM.MEM.MMEP.MMSP.MemState
         (prod
         MemPropT.store_id
         (prod
         (prod
         InterpreterStackBigIntptr.LLVM.Local.local_env
         InterpreterStackBigIntptr.LLVM.Stack.lstack)
         (prod
         InterpreterStackBigIntptr.LLVM.Global.global_env
         InterpreterStackBigIntptr.LP.Events.DV.dvalue)))))
         with
         | pick
         Pre
         x1 =>
         (fun
         (Pre0 : Prop)
         (x2 : uvalue)
         (H :
         @eq
         Type
         (@sig
         dvalue
         (fun
         _ : dvalue
         =>
         True))
         X0)
         =>
         (fun
         H0 :
         @eq
         Type
         (@sig
         dvalue
         (fun
         _ : dvalue
         =>
         True))
         X0 =>
         let
         H1 :
         @eq
         Type
         (@sig
         dvalue
         (fun
         _ : dvalue
         =>
         True))
         X0 :=
         H0 in
         @eq_rect
         Type
         (@sig
         dvalue
         (fun
         _ : dvalue
         =>
         True))
         (fun
         _ : Type
         =>
         forall
         (_ : Prop)
         (_ : uvalue),
         itree
         InfLP.Events.L3
         (prod
         InterpreterStackBigIntptr.LLVM.MEM.MMEP.MMSP.MemState
         (prod
         MemPropT.store_id
         (prod
         (prod
         InterpreterStackBigIntptr.LLVM.Local.local_env
         InterpreterStackBigIntptr.LLVM.Stack.lstack)
         (prod
         InterpreterStackBigIntptr.LLVM.Global.global_env
         InterpreterStackBigIntptr.LP.Events.DV.dvalue)))))
         (fun
         (Pre1 : Prop)
         (x3 : uvalue)
         =>
         @eq_rect
         Type
         (@sig
         dvalue
         (fun
         _ : dvalue
         =>
         True))
         (fun
         X5 : Type
         =>
         forall
         (_ :
         forall
         _ : X5,
         itree
         L3
         (prod
         FinMem.MMEP.MMSP.MemState
         (prod
         MemPropT.store_id
         (prod
         (prod
         local_env
         (@stack
         local_env))
         (prod
         global_env
         dvalue)))))
         (_ :
         PickUvalueE
         X5),
         itree
         InfLP.Events.L3
         (prod
         InterpreterStackBigIntptr.LLVM.MEM.MMEP.MMSP.MemState
         (prod
         MemPropT.store_id
         (prod
         (prod
         InterpreterStackBigIntptr.LLVM.Local.local_env
         InterpreterStackBigIntptr.LLVM.Stack.lstack)
         (prod
         InterpreterStackBigIntptr.LLVM.Global.global_env
         InterpreterStackBigIntptr.LP.Events.DV.dvalue)))))
         (fun
         (k1 :
         forall
         _ :
         @sig
         dvalue
         (fun
         _ : dvalue
         =>
         True),
         itree
         L3
         (prod
         FinMem.MMEP.MMSP.MemState
         (prod
         MemPropT.store_id
         (prod
         (prod
         local_env
         (@stack
         local_env))
         (prod
         global_env
         dvalue)))))
         (_ :
         PickUvalueE
         (@sig
         dvalue
         (fun
         _ : dvalue
         =>
         True)))
         =>
         @go
         InfLP.Events.L3
         (prod
         InterpreterStackBigIntptr.LLVM.MEM.MMEP.MMSP.MemState
         (prod
         MemPropT.store_id
         (prod
         (prod
         InterpreterStackBigIntptr.LLVM.Local.local_env
         InterpreterStackBigIntptr.LLVM.Stack.lstack)
         (prod
         InterpreterStackBigIntptr.LLVM.Global.global_env
         InterpreterStackBigIntptr.LP.Events.DV.dvalue))))
         (@VisF
         InfLP.Events.L3
         (prod
         InterpreterStackBigIntptr.LLVM.MEM.MMEP.MMSP.MemState
         (prod
         MemPropT.store_id
         (prod
         (prod
         InterpreterStackBigIntptr.LLVM.Local.local_env
         InterpreterStackBigIntptr.LLVM.Stack.lstack)
         (prod
         InterpreterStackBigIntptr.LLVM.Global.global_env
         InterpreterStackBigIntptr.LP.Events.DV.dvalue))))
         (itree
         InfLP.Events.L3
         (prod
         InterpreterStackBigIntptr.LLVM.MEM.MMEP.MMSP.MemState
         (prod
         MemPropT.store_id
         (prod
         (prod
         InterpreterStackBigIntptr.LLVM.Local.local_env
         InterpreterStackBigIntptr.LLVM.Stack.lstack)
         (prod
         InterpreterStackBigIntptr.LLVM.Global.global_env
         InterpreterStackBigIntptr.LP.Events.DV.dvalue)))))
         (@sig
         InfLP.Events.DV.dvalue
         (fun
         _ : InfLP.Events.DV.dvalue
         =>
         True))
         (@subevent
         (@E1.PickE
         LLVMParamsBigIntptr.Events.DV.uvalue
         InfLP.Events.DV.dvalue
         (fun
         (_ : InfLP.Events.DV.uvalue)
         (_ : InfLP.Events.DV.dvalue)
         =>
         True))
         InfLP.Events.L3
         (@ReSum_inr
         (forall
         _ : Type,
         Type)
         IFun
         sum1
         Cat_IFun
         Inr_sum1
         (@E1.PickE
         LLVMParamsBigIntptr.Events.DV.uvalue
         InfLP.Events.DV.dvalue
         (fun
         (_ : InfLP.Events.DV.uvalue)
         (_ : InfLP.Events.DV.dvalue)
         =>
         True))
         (sum1
         InfLP.Events.PickUvalueE
         (sum1
         OOME
         (sum1
         UBE
         (sum1
         DebugE
         FailureE))))
         InfLP.Events.ExternalCallE
         (@ReSum_inl
         (forall
         _ : Type,
         Type)
         IFun
         sum1
         Cat_IFun
         Inl_sum1
         (@E1.PickE
         LLVMParamsBigIntptr.Events.DV.uvalue
         InfLP.Events.DV.dvalue
         (fun
         (_ : InfLP.Events.DV.uvalue)
         (_ : InfLP.Events.DV.dvalue)
         =>
         True))
         InfLP.Events.PickUvalueE
         (sum1
         OOME
         (sum1
         UBE
         (sum1
         DebugE
         FailureE)))
         (@ReSum_id
         (forall
         _ : Type,
         Type)
         IFun
         Id_IFun
         InfLP.Events.PickUvalueE)))
         (@sig
         InfLP.Events.DV.dvalue
         (fun
         _ : InfLP.Events.DV.dvalue
         =>
         True))
         (@E1.pick
         LLVMParamsBigIntptr.Events.DV.uvalue
         InfLP.Events.DV.dvalue
         (fun
         (_ : InfLP.Events.DV.uvalue)
         (_ : InfLP.Events.DV.dvalue)
         =>
         True)
         Pre1
         (fin_to_inf_uvalue
         x3)))
         (fun
         res :
         @sig
         InfLP.Events.DV.dvalue
         (fun
         _ : InfLP.Events.DV.dvalue
         =>
         True)
         =>
         match
         res
         return
         (itree
         InfLP.Events.L3
         (prod
         InterpreterStackBigIntptr.LLVM.MEM.MMEP.MMSP.MemState
         (prod
         MemPropT.store_id
         (prod
         (prod
         InterpreterStackBigIntptr.LLVM.Local.local_env
         InterpreterStackBigIntptr.LLVM.Stack.lstack)
         (prod
         InterpreterStackBigIntptr.LLVM.Global.global_env
         InterpreterStackBigIntptr.LP.Events.DV.dvalue)))))
         with
         | @exist
         _ _
         x4 p =>
         (fun
         (x5 : InfLP.Events.DV.dvalue)
         (t : True)
         =>
         get_inf_tree
         (let
         H2 :
         OOM
         DVCInfFin.DV2.dvalue :=
         DVCInfFin.dvalue_convert_strict
         x5 in
         match
         H2
         return
         (itree
         L3
         (prod
         FinMem.MMEP.MMSP.MemState
         (prod
         MemPropT.store_id
         (prod
         (prod
         local_env
         (@stack
         local_env))
         (prod
         global_env
         dvalue)))))
         with
         | NoOom
         a =>
         (fun
         d : DVCInfFin.DV2.dvalue
         =>
         k1
         (@exist
         dvalue
         (fun
         _ : dvalue
         =>
         True)
         d t))
         a
         | Oom
         s =>
         (fun
         s0 : string
         =>
         @raiseOOM
         L3
         (@ReSum_inr
         (forall
         _ : Type,
         Type)
         IFun
         sum1
         Cat_IFun
         Inr_sum1
         OOME
         (sum1
         PickUvalueE
         (sum1
         OOME
         (sum1
         UBE
         (sum1
         DebugE
         FailureE))))
         ExternalCallE
         (@ReSum_inr
         (forall
         _ : Type,
         Type)
         IFun
         sum1
         Cat_IFun
         Inr_sum1
         OOME
         (sum1
         OOME
         (sum1
         UBE
         (sum1
         DebugE
         FailureE)))
         PickUvalueE
         (@ReSum_inl
         (forall
         _ : Type,
         Type)
         IFun
         sum1
         Cat_IFun
         Inl_sum1
         OOME
         OOME
         (sum1
         UBE
         (sum1
         DebugE
         FailureE))
         (@ReSum_id
         (forall
         _ : Type,
         Type)
         IFun
         Id_IFun
         OOME))))
         (prod
         FinMem.MMEP.MMSP.MemState
         (prod
         MemPropT.store_id
         (prod
         (prod
         local_env
         (@stack
         local_env))
         (prod
         global_env
         dvalue))))
         s0) s
         end))
         x4 p
         end)))
         X0 H0
         k0 X4)
         X0 H1)
         H
         Pre0
         x2)
         Pre
         x1
         end
         in
         X5
         (@eq_refl
         Type
         X0))
         X3)
         x0
         | inr1
         x0 =>
         (fun
         H :
         sum1
         OOME
         (sum1
         UBE
         (sum1
         DebugE
         FailureE))
         X0 =>
         (fun
         H0 :
         sum1
         OOME
         (sum1
         UBE
         (sum1
         DebugE
         FailureE))
         X0 =>
         let
         X3 :
         itree
         InfLP.Events.L3
         (prod
         InterpreterStackBigIntptr.LLVM.MEM.MMEP.MMSP.MemState
         (prod
         MemPropT.store_id
         (prod
         (prod
         InterpreterStackBigIntptr.LLVM.Local.local_env
         InterpreterStackBigIntptr.LLVM.Stack.lstack)
         (prod
         InterpreterStackBigIntptr.LLVM.Global.global_env
         InterpreterStackBigIntptr.LP.Events.DV.dvalue)))) :=
         match
         H0
         return
         (itree
         InfLP.Events.L3
         (prod
         InterpreterStackBigIntptr.LLVM.MEM.MMEP.MMSP.MemState
         (prod
         MemPropT.store_id
         (prod
         (prod
         InterpreterStackBigIntptr.LLVM.Local.local_env
         InterpreterStackBigIntptr.LLVM.Stack.lstack)
         (prod
         InterpreterStackBigIntptr.LLVM.Global.global_env
         InterpreterStackBigIntptr.LP.Events.DV.dvalue)))))
         with
         | inl1
         x1 =>
         (fun
         H1 :
         OOME
         X0 =>
         (fun
         H2 :
         OOME
         X0 =>
         let
         X3 :
         forall
         _ :
         @eq
         Type
         X0 X0,
         itree
         InfLP.Events.L3
         (prod
         InterpreterStackBigIntptr.LLVM.MEM.MMEP.MMSP.MemState
         (prod
         MemPropT.store_id
         (prod
         (prod
         InterpreterStackBigIntptr.LLVM.Local.local_env
         InterpreterStackBigIntptr.LLVM.Stack.lstack)
         (prod
         InterpreterStackBigIntptr.LLVM.Global.global_env
         InterpreterStackBigIntptr.LP.Events.DV.dvalue)))) :=
         match
         H2 in
         (OOME
         T)
         return
         (forall
         _ :
         @eq
         Type
         T X0,
         itree
         InfLP.Events.L3
         (prod
         InterpreterStackBigIntptr.LLVM.MEM.MMEP.MMSP.MemState
         (prod
         MemPropT.store_id
         (prod
         (prod
         InterpreterStackBigIntptr.LLVM.Local.local_env
         InterpreterStackBigIntptr.LLVM.Stack.lstack)
         (prod
         InterpreterStackBigIntptr.LLVM.Global.global_env
         InterpreterStackBigIntptr.LP.Events.DV.dvalue)))))
         with
         | ThrowOOM
         x2 =>
         (fun
         (H3 : unit)
         (H4 :
         @eq
         Type
         Empty_set
         X0)
         =>
         (fun
         H5 :
         @eq
         Type
         Empty_set
         X0 =>
         let
         H6 :
         @eq
         Type
         Empty_set
         X0 :=
         H5 in
         @eq_rect
         Type
         Empty_set
         (fun
         _ : Type
         =>
         forall
         _ : unit,
         itree
         InfLP.Events.L3
         (prod
         InterpreterStackBigIntptr.LLVM.MEM.MMEP.MMSP.MemState
         (prod
         MemPropT.store_id
         (prod
         (prod
         InterpreterStackBigIntptr.LLVM.Local.local_env
         InterpreterStackBigIntptr.LLVM.Stack.lstack)
         (prod
         InterpreterStackBigIntptr.LLVM.Global.global_env
         InterpreterStackBigIntptr.LP.Events.DV.dvalue)))))
         (fun
         _ : unit
         =>
         @eq_rect
         Type
         Empty_set
         (fun
         X3 : Type
         =>
         forall
         (_ :
         forall
         _ : X3,
         itree
         L3
         (prod
         FinMem.MMEP.MMSP.MemState
         (prod
         MemPropT.store_id
         (prod
         (prod
         local_env
         (@stack
         local_env))
         (prod
         global_env
         dvalue)))))
         (_ :
         OOME
         X3),
         itree
         InfLP.Events.L3
         (prod
         InterpreterStackBigIntptr.LLVM.MEM.MMEP.MMSP.MemState
         (prod
         MemPropT.store_id
         (prod
         (prod
         InterpreterStackBigIntptr.LLVM.Local.local_env
         InterpreterStackBigIntptr.LLVM.Stack.lstack)
         (prod
         InterpreterStackBigIntptr.LLVM.Global.global_env
         InterpreterStackBigIntptr.LP.Events.DV.dvalue)))))
         (fun
         (_ :
         forall
         _ : Empty_set,
         itree
         L3
         (prod
         FinMem.MMEP.MMSP.MemState
         (prod
         MemPropT.store_id
         (prod
         (prod
         local_env
         (@stack
         local_env))
         (prod
         global_env
         dvalue)))))
         (_ :
         OOME
         Empty_set)
         =>
         @raiseOOM
         InfLP.Events.L3
         (@ReSum_inr
         (forall
         _ : Type,
         Type)
         IFun
         sum1
         Cat_IFun
         Inr_sum1
         OOME
         (sum1
         InfLP.Events.PickUvalueE
         (sum1
         OOME
         (sum1
         UBE
         (sum1
         DebugE
         FailureE))))
         InfLP.Events.ExternalCallE
         (@ReSum_inr
         (forall
         _ : Type,
         Type)
         IFun
         sum1
         Cat_IFun
         Inr_sum1
         OOME
         (sum1
         OOME
         (sum1
         UBE
         (sum1
         DebugE
         FailureE)))
         InfLP.Events.PickUvalueE
         (@ReSum_inl
         (forall
         _ : Type,
         Type)
         IFun
         sum1
         Cat_IFun
         Inl_sum1
         OOME
         OOME
         (sum1
         UBE
         (sum1
         DebugE
         FailureE))
         (@ReSum_id
         (forall
         _ : Type,
         Type)
         IFun
         Id_IFun
         OOME))))
         (prod
         InterpreterStackBigIntptr.LLVM.MEM.MMEP.MMSP.MemState
         (prod
         MemPropT.store_id
         (prod
         (prod
         InterpreterStackBigIntptr.LLVM.Local.local_env
         InterpreterStackBigIntptr.LLVM.Stack.lstack)
         (prod
         InterpreterStackBigIntptr.LLVM.Global.global_env
         InterpreterStackBigIntptr.LP.Events.DV.dvalue))))
         EmptyString)
         X0 H5
         k0 H2)
         X0 H6)
         H4 H3)
         x2
         end
         in
         X3
         (@eq_refl
         Type
         X0))
         H1)
         x1
         | inr1
         x1 =>
         (fun
         H1 :
         sum1
         UBE
         (sum1
         DebugE
         FailureE)
         X0 =>
         (fun
         H2 :
         sum1
         UBE
         (sum1
         DebugE
         FailureE)
         X0 =>
         let
         X3 :
         itree
         InfLP.Events.L3
         (prod
         InterpreterStackBigIntptr.LLVM.MEM.MMEP.MMSP.MemState
         (prod
         MemPropT.store_id
         (prod
         (prod
         InterpreterStackBigIntptr.LLVM.Local.local_env
         InterpreterStackBigIntptr.LLVM.Stack.lstack)
         (prod
         InterpreterStackBigIntptr.LLVM.Global.global_env
         InterpreterStackBigIntptr.LP.Events.DV.dvalue)))) :=
         match
         H2
         return
         (itree
         InfLP.Events.L3
         (prod
         InterpreterStackBigIntptr.LLVM.MEM.MMEP.MMSP.MemState
         (prod
         MemPropT.store_id
         (prod
         (prod
         InterpreterStackBigIntptr.LLVM.Local.local_env
         InterpreterStackBigIntptr.LLVM.Stack.lstack)
         (prod
         InterpreterStackBigIntptr.LLVM.Global.global_env
         InterpreterStackBigIntptr.LP.Events.DV.dvalue)))))
         with
         | inl1
         x2 =>
         (fun
         H3 :
         UBE
         X0 =>
         (fun
         H4 :
         UBE
         X0 =>
         let
         X3 :
         forall
         _ :
         @eq
         Type
         X0 X0,
         itree
         InfLP.Events.L3
         (prod
         InterpreterStackBigIntptr.LLVM.MEM.MMEP.MMSP.MemState
         (prod
         MemPropT.store_id
         (prod
         (prod
         InterpreterStackBigIntptr.LLVM.Local.local_env
         InterpreterStackBigIntptr.LLVM.Stack.lstack)
         (prod
         InterpreterStackBigIntptr.LLVM.Global.global_env
         InterpreterStackBigIntptr.LP.Events.DV.dvalue)))) :=
         match
         H4 in
         (UBE
         T)
         return
         (forall
         _ :
         @eq
         Type
         T X0,
         itree
         InfLP.Events.L3
         (prod
         InterpreterStackBigIntptr.LLVM.MEM.MMEP.MMSP.MemState
         (prod
         MemPropT.store_id
         (prod
         (prod
         InterpreterStackBigIntptr.LLVM.Local.local_env
         InterpreterStackBigIntptr.LLVM.Stack.lstack)
         (prod
         InterpreterStackBigIntptr.LLVM.Global.global_env
         InterpreterStackBigIntptr.LP.Events.DV.dvalue)))))
         with
         | ThrowUB
         x3 =>
         (fun
         (H5 : unit)
         (H6 :
         @eq
         Type
         Empty_set
         X0)
         =>
         (fun
         H7 :
         @eq
         Type
         Empty_set
         X0 =>
         let
         H8 :
         @eq
         Type
         Empty_set
         X0 :=
         H7 in
         @eq_rect
         Type
         Empty_set
         (fun
         _ : Type
         =>
         forall
         _ : unit,
         itree
         InfLP.Events.L3
         (prod
         InterpreterStackBigIntptr.LLVM.MEM.MMEP.MMSP.MemState
         (prod
         MemPropT.store_id
         (prod
         (prod
         InterpreterStackBigIntptr.LLVM.Local.local_env
         InterpreterStackBigIntptr.LLVM.Stack.lstack)
         (prod
         InterpreterStackBigIntptr.LLVM.Global.global_env
         InterpreterStackBigIntptr.LP.Events.DV.dvalue)))))
         (fun
         _ : unit
         =>
         @eq_rect
         Type
         Empty_set
         (fun
         X3 : Type
         =>
         forall
         (_ :
         forall
         _ : X3,
         itree
         L3
         (prod
         FinMem.MMEP.MMSP.MemState
         (prod
         MemPropT.store_id
         (prod
         (prod
         local_env
         (@stack
         local_env))
         (prod
         global_env
         dvalue)))))
         (_ :
         UBE
         X3),
         itree
         InfLP.Events.L3
         (prod
         InterpreterStackBigIntptr.LLVM.MEM.MMEP.MMSP.MemState
         (prod
         MemPropT.store_id
         (prod
         (prod
         InterpreterStackBigIntptr.LLVM.Local.local_env
         InterpreterStackBigIntptr.LLVM.Stack.lstack)
         (prod
         InterpreterStackBigIntptr.LLVM.Global.global_env
         InterpreterStackBigIntptr.LP.Events.DV.dvalue)))))
         (fun
         (_ :
         forall
         _ : Empty_set,
         itree
         L3
         (prod
         FinMem.MMEP.MMSP.MemState
         (prod
         MemPropT.store_id
         (prod
         (prod
         local_env
         (@stack
         local_env))
         (prod
         global_env
         dvalue)))))
         (_ :
         UBE
         Empty_set)
         =>
         @raiseUB
         InfLP.Events.L3
         (@ReSum_inr
         (forall
         _ : Type,
         Type)
         IFun
         sum1
         Cat_IFun
         Inr_sum1
         UBE
         (sum1
         InfLP.Events.PickUvalueE
         (sum1
         OOME
         (sum1
         UBE
         (sum1
         DebugE
         FailureE))))
         InfLP.Events.ExternalCallE
         (@ReSum_inr
         (forall
         _ : Type,
         Type)
         IFun
         sum1
         Cat_IFun
         Inr_sum1
         UBE
         (sum1
         OOME
         (sum1
         UBE
         (sum1
         DebugE
         FailureE)))
         InfLP.Events.PickUvalueE
         (@ReSum_inr
         (forall
         _ : Type,
         Type)
         IFun
         sum1
         Cat_IFun
         Inr_sum1
         UBE
         (sum1
         UBE
         (sum1
         DebugE
         FailureE))
         OOME
         (@ReSum_inl
         (forall
         _ : Type,
         Type)
         IFun
         sum1
         Cat_IFun
         Inl_sum1
         UBE
         UBE
         (sum1
         DebugE
         FailureE)
         (@ReSum_id
         (forall
         _ : Type,
         Type)
         IFun
         Id_IFun
         UBE)))))
         (prod
         InterpreterStackBigIntptr.LLVM.MEM.MMEP.MMSP.MemState
         (prod
         MemPropT.store_id
         (prod
         (prod
         InterpreterStackBigIntptr.LLVM.Local.local_env
         InterpreterStackBigIntptr.LLVM.Stack.lstack)
         (prod
         InterpreterStackBigIntptr.LLVM.Global.global_env
         InterpreterStackBigIntptr.LP.Events.DV.dvalue))))
         EmptyString)
         X0 H7
         k0 H4)
         X0 H8)
         H6 H5)
         x3
         end
         in
         X3
         (@eq_refl
         Type
         X0))
         H3)
         x2
         | inr1
         x2 =>
         (fun
         H3 :
         sum1
         DebugE
         FailureE
         X0 =>
         (fun
         H4 :
         sum1
         DebugE
         FailureE
         X0 =>
         let
         X3 :
         itree
         InfLP.Events.L3
         (prod
         InterpreterStackBigIntptr.LLVM.MEM.MMEP.MMSP.MemState
         (prod
         MemPropT.store_id
         (prod
         (prod
         InterpreterStackBigIntptr.LLVM.Local.local_env
         InterpreterStackBigIntptr.LLVM.Stack.lstack)
         (prod
         InterpreterStackBigIntptr.LLVM.Global.global_env
         InterpreterStackBigIntptr.LP.Events.DV.dvalue)))) :=
         match
         H4
         return
         (itree
         InfLP.Events.L3
         (prod
         InterpreterStackBigIntptr.LLVM.MEM.MMEP.MMSP.MemState
         (prod
         MemPropT.store_id
         (prod
         (prod
         InterpreterStackBigIntptr.LLVM.Local.local_env
         InterpreterStackBigIntptr.LLVM.Stack.lstack)
         (prod
         InterpreterStackBigIntptr.LLVM.Global.global_env
         InterpreterStackBigIntptr.LP.Events.DV.dvalue)))))
         with
         | inl1
         x3 =>
         (fun
         H5 :
         DebugE
         X0 =>
         (fun
         H6 :
         DebugE
         X0 =>
         let
         X3 :
         forall
         _ :
         @eq
         Type
         X0 X0,
         itree
         InfLP.Events.L3
         (prod
         InterpreterStackBigIntptr.LLVM.MEM.MMEP.MMSP.MemState
         (prod
         MemPropT.store_id
         (prod
         (prod
         InterpreterStackBigIntptr.LLVM.Local.local_env
         InterpreterStackBigIntptr.LLVM.Stack.lstack)
         (prod
         InterpreterStackBigIntptr.LLVM.Global.global_env
         InterpreterStackBigIntptr.LP.Events.DV.dvalue)))) :=
         match
         H6 in
         (DebugE
         T)
         return
         (forall
         _ :
         @eq
         Type
         T X0,
         itree
         InfLP.Events.L3
         (prod
         InterpreterStackBigIntptr.LLVM.MEM.MMEP.MMSP.MemState
         (prod
         MemPropT.store_id
         (prod
         (prod
         InterpreterStackBigIntptr.LLVM.Local.local_env
         InterpreterStackBigIntptr.LLVM.Stack.lstack)
         (prod
         InterpreterStackBigIntptr.LLVM.Global.global_env
         InterpreterStackBigIntptr.LP.Events.DV.dvalue)))))
         with
         | Debug
         x4 =>
         (fun
         (H7 : unit)
         (H8 :
         @eq
         Type
         unit
         X0)
         =>
         (fun
         H9 :
         @eq
         Type
         unit
         X0 =>
         let
         H10 :
         @eq
         Type
         unit
         X0 :=
         H9 in
         @eq_rect
         Type
         unit
         (fun
         _ : Type
         =>
         forall
         _ : unit,
         itree
         InfLP.Events.L3
         (prod
         InterpreterStackBigIntptr.LLVM.MEM.MMEP.MMSP.MemState
         (prod
         MemPropT.store_id
         (prod
         (prod
         InterpreterStackBigIntptr.LLVM.Local.local_env
         InterpreterStackBigIntptr.LLVM.Stack.lstack)
         (prod
         InterpreterStackBigIntptr.LLVM.Global.global_env
         InterpreterStackBigIntptr.LP.Events.DV.dvalue)))))
         (fun
         H11 : unit
         =>
         @eq_rect
         Type
         unit
         (fun
         X3 : Type
         =>
         forall
         (_ :
         forall
         _ : X3,
         itree
         L3
         (prod
         FinMem.MMEP.MMSP.MemState
         (prod
         MemPropT.store_id
         (prod
         (prod
         local_env
         (@stack
         local_env))
         (prod
         global_env
         dvalue)))))
         (_ :
         DebugE
         X3),
         itree
         InfLP.Events.L3
         (prod
         InterpreterStackBigIntptr.LLVM.MEM.MMEP.MMSP.MemState
         (prod
         MemPropT.store_id
         (prod
         (prod
         InterpreterStackBigIntptr.LLVM.Local.local_env
         InterpreterStackBigIntptr.LLVM.Stack.lstack)
         (prod
         InterpreterStackBigIntptr.LLVM.Global.global_env
         InterpreterStackBigIntptr.LP.Events.DV.dvalue)))))
         (fun
         (k1 :
         forall
         _ : unit,
         itree
         L3
         (prod
         FinMem.MMEP.MMSP.MemState
         (prod
         MemPropT.store_id
         (prod
         (prod
         local_env
         (@stack
         local_env))
         (prod
         global_env
         dvalue)))))
         (_ :
         DebugE
         unit)
         =>
         @go
         InfLP.Events.L3
         (prod
         InterpreterStackBigIntptr.LLVM.MEM.MMEP.MMSP.MemState
         (prod
         MemPropT.store_id
         (prod
         (prod
         InterpreterStackBigIntptr.LLVM.Local.local_env
         InterpreterStackBigIntptr.LLVM.Stack.lstack)
         (prod
         InterpreterStackBigIntptr.LLVM.Global.global_env
         InterpreterStackBigIntptr.LP.Events.DV.dvalue))))
         (@VisF
         InfLP.Events.L3
         (prod
         InterpreterStackBigIntptr.LLVM.MEM.MMEP.MMSP.MemState
         (prod
         MemPropT.store_id
         (prod
         (prod
         InterpreterStackBigIntptr.LLVM.Local.local_env
         InterpreterStackBigIntptr.LLVM.Stack.lstack)
         (prod
         InterpreterStackBigIntptr.LLVM.Global.global_env
         InterpreterStackBigIntptr.LP.Events.DV.dvalue))))
         (itree
         InfLP.Events.L3
         (prod
         InterpreterStackBigIntptr.LLVM.MEM.MMEP.MMSP.MemState
         (prod
         MemPropT.store_id
         (prod
         (prod
         InterpreterStackBigIntptr.LLVM.Local.local_env
         InterpreterStackBigIntptr.LLVM.Stack.lstack)
         (prod
         InterpreterStackBigIntptr.LLVM.Global.global_env
         InterpreterStackBigIntptr.LP.Events.DV.dvalue)))))
         unit
         (@subevent
         DebugE
         InfLP.Events.L3
         (@ReSum_inr
         (forall
         _ : Type,
         Type)
         IFun
         sum1
         Cat_IFun
         Inr_sum1
         DebugE
         (sum1
         InfLP.Events.PickUvalueE
         (sum1
         OOME
         (sum1
         UBE
         (sum1
         DebugE
         FailureE))))
         InfLP.Events.ExternalCallE
         (@ReSum_inr
         (forall
         _ : Type,
         Type)
         IFun
         sum1
         Cat_IFun
         Inr_sum1
         DebugE
         (sum1
         OOME
         (sum1
         UBE
         (sum1
         DebugE
         FailureE)))
         InfLP.Events.PickUvalueE
         (@ReSum_inr
         (forall
         _ : Type,
         Type)
         IFun
         sum1
         Cat_IFun
         Inr_sum1
         DebugE
         (sum1
         UBE
         (sum1
         DebugE
         FailureE))
         OOME
         (@ReSum_inr
         (forall
         _ : Type,
         Type)
         IFun
         sum1
         Cat_IFun
         Inr_sum1
         DebugE
         (sum1
         DebugE
         FailureE)
         UBE
         (@ReSum_inl
         (forall
         _ : Type,
         Type)
         IFun
         sum1
         Cat_IFun
         Inl_sum1
         DebugE
         DebugE
         FailureE
         (@ReSum_id
         (forall
         _ : Type,
         Type)
         IFun
         Id_IFun
         DebugE))))))
         unit
         (Debug
         H11))
         (fun
         H13 : unit
         =>
         get_inf_tree
         (k1
         H13))))
         X0 H9
         k0 H6)
         X0
         H10)
         H8 H7)
         x4
         end
         in
         X3
         (@eq_refl
         Type
         X0))
         H5)
         x3
         | inr1
         x3 =>
         (fun
         H5 :
         FailureE
         X0 =>
         (fun
         H6 :
         FailureE
         X0 =>
         let
         X3 :
         forall
         _ :
         @eq
         Type
         X0 X0,
         itree
         InfLP.Events.L3
         (prod
         InterpreterStackBigIntptr.LLVM.MEM.MMEP.MMSP.MemState
         (prod
         MemPropT.store_id
         (prod
         (prod
         InterpreterStackBigIntptr.LLVM.Local.local_env
         InterpreterStackBigIntptr.LLVM.Stack.lstack)
         (prod
         InterpreterStackBigIntptr.LLVM.Global.global_env
         InterpreterStackBigIntptr.LP.Events.DV.dvalue)))) :=
         match
         H6 in
         (FailureE
         T)
         return
         (forall
         _ :
         @eq
         Type
         T X0,
         itree
         InfLP.Events.L3
         (prod
         InterpreterStackBigIntptr.LLVM.MEM.MMEP.MMSP.MemState
         (prod
         MemPropT.store_id
         (prod
         (prod
         InterpreterStackBigIntptr.LLVM.Local.local_env
         InterpreterStackBigIntptr.LLVM.Stack.lstack)
         (prod
         InterpreterStackBigIntptr.LLVM.Global.global_env
         InterpreterStackBigIntptr.LP.Events.DV.dvalue)))))
         with
         | Throw
         x4 =>
         (fun
         (H7 : unit)
         (H8 :
         @eq
         Type
         Empty_set
         X0)
         =>
         (fun
         H9 :
         @eq
         Type
         Empty_set
         X0 =>
         let
         H10 :
         @eq
         Type
         Empty_set
         X0 :=
         H9 in
         @eq_rect
         Type
         Empty_set
         (fun
         _ : Type
         =>
         forall
         _ : unit,
         itree
         InfLP.Events.L3
         (prod
         InterpreterStackBigIntptr.LLVM.MEM.MMEP.MMSP.MemState
         (prod
         MemPropT.store_id
         (prod
         (prod
         InterpreterStackBigIntptr.LLVM.Local.local_env
         InterpreterStackBigIntptr.LLVM.Stack.lstack)
         (prod
         InterpreterStackBigIntptr.LLVM.Global.global_env
         InterpreterStackBigIntptr.LP.Events.DV.dvalue)))))
         (fun
         _ : unit
         =>
         @eq_rect
         Type
         Empty_set
         (fun
         X3 : Type
         =>
         forall
         (_ :
         forall
         _ : X3,
         itree
         L3
         (prod
         FinMem.MMEP.MMSP.MemState
         (prod
         MemPropT.store_id
         (prod
         (prod
         local_env
         (@stack
         local_env))
         (prod
         global_env
         dvalue)))))
         (_ :
         FailureE
         X3),
         itree
         InfLP.Events.L3
         (prod
         InterpreterStackBigIntptr.LLVM.MEM.MMEP.MMSP.MemState
         (prod
         MemPropT.store_id
         (prod
         (prod
         InterpreterStackBigIntptr.LLVM.Local.local_env
         InterpreterStackBigIntptr.LLVM.Stack.lstack)
         (prod
         InterpreterStackBigIntptr.LLVM.Global.global_env
         InterpreterStackBigIntptr.LP.Events.DV.dvalue)))))
         (fun
         (_ :
         forall
         _ : Empty_set,
         itree
         L3
         (prod
         FinMem.MMEP.MMSP.MemState
         (prod
         MemPropT.store_id
         (prod
         (prod
         local_env
         (@stack
         local_env))
         (prod
         global_env
         dvalue)))))
         (_ :
         FailureE
         Empty_set)
         =>
         @LLVMEvents.raise
         InfLP.Events.L3
         (prod
         InterpreterStackBigIntptr.LLVM.MEM.MMEP.MMSP.MemState
         (prod
         MemPropT.store_id
         (prod
         (prod
         InterpreterStackBigIntptr.LLVM.Local.local_env
         InterpreterStackBigIntptr.LLVM.Stack.lstack)
         (prod
         InterpreterStackBigIntptr.LLVM.Global.global_env
         InterpreterStackBigIntptr.LP.Events.DV.dvalue))))
         (@ReSum_inr
         (forall
         _ : Type,
         Type)
         IFun
         sum1
         Cat_IFun
         Inr_sum1
         FailureE
         (sum1
         InfLP.Events.PickUvalueE
         (sum1
         OOME
         (sum1
         UBE
         (sum1
         DebugE
         FailureE))))
         InfLP.Events.ExternalCallE
         (@ReSum_inr
         (forall
         _ : Type,
         Type)
         IFun
         sum1
         Cat_IFun
         Inr_sum1
         FailureE
         (sum1
         OOME
         (sum1
         UBE
         (sum1
         DebugE
         FailureE)))
         InfLP.Events.PickUvalueE
         (@ReSum_inr
         (forall
         _ : Type,
         Type)
         IFun
         sum1
         Cat_IFun
         Inr_sum1
         FailureE
         (sum1
         UBE
         (sum1
         DebugE
         FailureE))
         OOME
         (@ReSum_inr
         (forall
         _ : Type,
         Type)
         IFun
         sum1
         Cat_IFun
         Inr_sum1
         FailureE
         (sum1
         DebugE
         FailureE)
         UBE
         (@ReSum_inr
         (forall
         _ : Type,
         Type)
         IFun
         sum1
         Cat_IFun
         Inr_sum1
         FailureE
         FailureE
         DebugE
         (@ReSum_id
         (forall
         _ : Type,
         Type)
         IFun
         Id_IFun
         FailureE))))))
         EmptyString)
         X0 H9
         k0 H6)
         X0
         H10)
         H8 H7)
         x4
         end
         in
         X3
         (@eq_refl
         Type
         X0))
         H5)
         x3
         end
         in
         X3)
         H3)
         x2
         end
         in
         X3)
         H1)
         x1
         end
         in
         X3) H)
         x0
         end
         in
         X3)
         X1) x
         end
         in
        X1) X
         e k
   end.

  (* TODO: Move this *)
  Lemma ptr_in_frame_prop_lift :
    forall f ptr,
      FinMem.MMEP.MMSP.ptr_in_frame_prop f ptr ->
      InfMem.MMEP.MMSP.ptr_in_frame_prop (lift_Frame f) (fin_to_inf_addr ptr).
  Proof.
    intros f ptr IN.
    red in *.
    unfold lift_Frame.
    rewrite List.map_map.
    rewrite fin_to_inf_addr_ptr_to_int.
    replace (fun x : FinAddr.addr => LLVMParamsBigIntptr.PTOI.ptr_to_int (fin_to_inf_addr x)) with
      (fun x : FinAddr.addr => LLVMParams64BitIntptr.PTOI.ptr_to_int x).
    apply IN.

    apply Axioms.functional_extensionality.
    intros x.
    rewrite fin_to_inf_addr_ptr_to_int.
    auto.
  Qed.

  (* TODO: Move this *)
  Lemma ptr_in_frame_prop_lift_inv :
    forall f ptr_inf,
      InfMem.MMEP.MMSP.ptr_in_frame_prop (lift_Frame f) ptr_inf ->
      exists ptr_fin,
        InfToFinAddrConvert.addr_convert ptr_inf = NoOom ptr_fin /\
          FinMem.MMEP.MMSP.ptr_in_frame_prop f ptr_fin.
  Proof.
    intros f ptr IN.
    red in IN.
    unfold lift_Frame in IN.
    rewrite List.map_map in IN.
    apply in_map_iff in IN.
    destruct IN as (?&?&?).
    rewrite fin_to_inf_addr_ptr_to_int in H.
    pose proof ITOP.int_to_ptr_ptr_to_int_exists x (InfPROV.address_provenance ptr).
    destruct H1 as (?&?&?&?).
    exists x0.
    split.
    - destruct ptr.
      cbn in *; subst; auto.
    - red.
      apply in_map_iff.
      exists x.
      split; auto.
  Qed.


  (* TODO: Move this to MMSP or something *)
  Lemma frame_eqv_empty_l :
    forall f,
      Memory64BitIntptr.MMEP.MMSP.frame_eqv [] f ->
      f = [].
  Proof.
    intros f EQV.
    destruct f; auto.
    red in  EQV.
    specialize (EQV a).
    destruct EQV.
    forward H0; cbn; auto.
    red in H0.
    cbn in H0.
    contradiction.
  Qed.

  (* TODO: Move this to MMSP or something *)
  Lemma frame_eqv_empty_r :
    forall f,
      Memory64BitIntptr.MMEP.MMSP.frame_eqv f [] ->
      f = [].
  Proof.
    intros f EQV.
    symmetry in EQV.
    apply frame_eqv_empty_l.
    auto.
  Qed.


  (* TODO: Move this *)
  Lemma fin_to_inf_addr_conv_inf :
    forall ptr_inf ptr_fin,
      InfToFinAddrConvert.addr_convert ptr_inf = NoOom ptr_fin ->
      fin_to_inf_addr ptr_fin = ptr_inf.
  Proof.
    intros ptr_inf ptr_fin CONV.
    unfold fin_to_inf_addr.
    break_match_goal.
    clear Heqs.
    apply FinToInfAddrConvertSafe.addr_convert_safe in e.
    eapply InfToFinAddrConvert.addr_convert_injective; eauto.
  Qed.


  (* (* TODO: Move this *) *)
  (* Lemma frame_stack_eqv_lift_inv : *)
  (*   forall fs1 fs2, *)
  (*     InfMem.MMEP.MMSP.frame_stack_eqv fs1 fs2 -> *)
  (*     exists fs1_fin fs2_fin, *)
  (*       fs1 = lift_FrameStack fs1_fin /\ *)
  (*         fs2 = lift_FrameStack fs2_fin /\ *)
  (*         FinMem.MMEP.MMSP.frame_stack_eqv fs1_fin fs2_fin. *)
  (* Proof. *)
  (*   unfold InfMem.MMEP.MMSP.frame_stack_eqv. *)
  (*   induction fs1. *)
  (*   - destruct fs2; intros. *)
  (*     + specialize (H f). *)
  (* Admitted. *)

  (* TODO: Move this *)
  Lemma frame_eqv_lift :
    forall f1 f2,
      FinMem.MMEP.MMSP.frame_eqv f1 f2 ->
      InfMem.MMEP.MMSP.frame_eqv (lift_Frame f1) (lift_Frame f2).
  Proof.
    intros f1 f2 EQV.
    red in EQV; red.

    intros ptr.
    split; intros IN.
    - apply ptr_in_frame_prop_lift_inv in IN.
      destruct IN as (ptr_fin & CONV & IN).
      apply EQV in IN.
      apply ptr_in_frame_prop_lift in IN.
      erewrite fin_to_inf_addr_conv_inf in IN; eauto.
    - apply ptr_in_frame_prop_lift_inv in IN.
      destruct IN as (ptr_fin & CONV & IN).
      apply EQV in IN.
      apply ptr_in_frame_prop_lift in IN.
      erewrite fin_to_inf_addr_conv_inf in IN; eauto.
  Qed.

  (* TODO: Move this *)
  Lemma addr_refine_fin_to_inf_addr :
    forall addr_fin,
      addr_refine (fin_to_inf_addr addr_fin) addr_fin.
  Proof.
    intros addr_fin.
    red. unfold fin_to_inf_addr.
    break_match_goal.
    clear Heqs.
    apply FinToInfAddrConvertSafe.addr_convert_safe in e.
    auto.
  Qed.

  (* TODO: Move this *)
  Lemma frame_eqv_lift_inv :
    forall f1 f2,
      InfMem.MMEP.MMSP.frame_eqv (lift_Frame f1) (lift_Frame f2) ->
      FinMem.MMEP.MMSP.frame_eqv f1 f2.
  Proof.
    intros f1 f2 EQV.
    red in EQV; red.

    intros ptr.
    split; intros IN.
    - apply ptr_in_frame_prop_lift in IN.
      apply EQV in IN.
      apply ptr_in_frame_prop_lift_inv in IN.
      destruct IN as (ptr_fin & CONV & IN).
      pose proof addr_convert_fin_to_inf_addr ptr as CONV'.
      rewrite CONV in CONV'.
      inv CONV'.
      auto.
    - apply ptr_in_frame_prop_lift in IN.
      apply EQV in IN.
      apply ptr_in_frame_prop_lift_inv in IN.
      destruct IN as (ptr_fin & CONV & IN).
      pose proof addr_convert_fin_to_inf_addr ptr as CONV'.
      rewrite CONV in CONV'.
      inv CONV'.
      auto.
  Qed.

  (* TODO: Move this *)
  Lemma FSNth_eqv_lift :
    forall n fs f,
      FinMem.MMEP.MMSP.FSNth_eqv fs n f ->
      InfMem.MMEP.MMSP.FSNth_eqv (lift_FrameStack fs) n (lift_Frame f).
  Proof.
    induction n; intros fs f NTHEQV.
    - destruct fs; cbn in *;
        apply frame_eqv_lift; auto.
    - destruct fs; cbn in *; auto.
  Qed.

  (* TODO: Move this *)
  Lemma lift_FrameStack_snoc :
    forall fs f,
      lift_FrameStack (FinMemMMSP.Snoc fs f) = InfMemMMSP.Snoc (lift_FrameStack fs) (lift_Frame f).
  Proof.
    induction fs; intros f_fin; cbn; auto.
  Qed.

  (* TODO: Move this *)
  Lemma FSNth_eqv_lift_inv :
    forall n fs f,
      InfMem.MMEP.MMSP.FSNth_eqv (lift_FrameStack fs) n f ->
      exists f_fin,
        InfMem.MMEP.MMSP.frame_eqv (lift_Frame f_fin) f /\
          FinMem.MMEP.MMSP.FSNth_eqv fs n f_fin.
  Proof.
    induction n; intros fs f NTHEQV.
    - destruct fs; cbn in *; exists f0;
        split; auto; reflexivity.
    - destruct fs.
      cbn in *; contradiction.

      rewrite lift_FrameStack_snoc in NTHEQV.
      cbn in *.
      eauto.
  Qed.

  (* TODO: Move this *)
  Lemma frame_stack_eqv_lift :
    forall fs1 fs2,
      FinMem.MMEP.MMSP.frame_stack_eqv fs1 fs2 ->
      InfMem.MMEP.MMSP.frame_stack_eqv (lift_FrameStack fs1) (lift_FrameStack fs2).
  Proof.
    intros fs1 fs2 EQV.
    red in *.
    intros f n.
    split; intros FSE.
    - apply FSNth_eqv_lift_inv in FSE.
      destruct FSE as (f_fin & F & FSE).

      rewrite <- F.
      apply FSNth_eqv_lift.
      apply EQV.
      auto.
    - apply FSNth_eqv_lift_inv in FSE.
      destruct FSE as (f_fin & F & FSE).

      rewrite <- F.
      apply FSNth_eqv_lift.
      apply EQV.
      auto.
  Qed.

  (* TODO: Move this *)
  Lemma frame_stack_eqv_lift_inf_fin :
    forall fs1 fs2,
      InfMem.MMEP.MMSP.frame_stack_eqv (lift_FrameStack fs1) (lift_FrameStack fs2) ->
      FinMem.MMEP.MMSP.frame_stack_eqv fs1 fs2.
  Proof.
    intros fs1 fs2 EQV.
    red in *.
    intros f n.
    split; intros FSE.
    - apply FSNth_eqv_lift in FSE.
      apply EQV in FSE.
      apply FSNth_eqv_lift_inv in FSE.
      destruct FSE as (f_fin & F & FSE).
      apply frame_eqv_lift_inv in F.
      rewrite <- F.
      auto.
    - apply FSNth_eqv_lift in FSE.
      apply EQV in FSE.
      apply FSNth_eqv_lift_inv in FSE.
      destruct FSE as (f_fin & F & FSE).
      apply frame_eqv_lift_inv in F.
      rewrite <- F.
      auto.
  Qed.

  (* TODO: Move this, possibly to itrees library? *)
  Lemma paco2_eqit_RR_refl : forall E R RR `{REFL: Reflexive _ RR} r (t : itree E R), paco2 (eqit_ RR true true id) r t t.
  Proof.
    intros. eapply paco2_mon with (r := bot2); intuition.
    enough (eutt RR t t); auto. reflexivity.
  Qed.

  (* TODO: Move this, possibly to itrees library? *)
  Lemma paco2_eqit_b1b2_RR_refl : forall E R RR `{REFL: Reflexive _ RR} {b1 b2} r (t : itree E R), paco2 (eqit_ RR b1 b2 id) r t t.
  Proof.
    intros. eapply paco2_mon with (r := bot2); intuition.
    enough (eqit RR b1 b2 t t); auto. reflexivity.
  Qed.

  #[global] Instance paco2_eqit_RR_Reflexive {E R RR} `{REFL: Reflexive _ RR} r {b1 b2} (t : itree E R):
    Reflexive (paco2 (eqit_ (E:=E) (R2:=R) RR b1 b2 id) r).
  Proof.
    red.
    intros x.
    apply paco2_eqit_b1b2_RR_refl; eauto.
  Qed.

  #[global] Instance paco2_eqit_false_false_RR_Reflexive {E R RR} `{REFL: Reflexive _ RR} r (t : itree E R):
    Reflexive (paco2 (eqit_ (E:=E) (R2:=R) RR false false id) r).
  Proof.
    red.
    intros x.
    apply paco2_eqit_b1b2_RR_refl; eauto.
  Qed.

  Import Coq.Classes.RelationClasses.

  Lemma get_inf_tree_equation :
    forall t_fin2,
      get_inf_tree t_fin2 â‰… _get_inf_tree (observe t_fin2).
  Proof.
    pcofix CIH.
    intros t_fin2.
    destruct (observe t_fin2) eqn:HTFIN.
    - rewrite (itree_eta_ t_fin2).
      rewrite HTFIN.
      cbn.
      pstep; red; cbn.
      constructor.
      reflexivity.
    - rewrite (itree_eta_ t_fin2).
      rewrite HTFIN.
      cbn.
      pstep; red; cbn.
      constructor.
      left.
      apply paco2_eq_itree_refl.
    - rewrite (itree_eta_ t_fin2).
      unfold _get_inf_tree.
      rewrite HTFIN.
      destruct e.
      { (* ExternalCallE *)
        destruct e.
        cbn.
        pstep; red; cbn.
        constructor.
        intros v; red.
        left; eapply paco2_mon_bot; eauto.
        (* Why won't reflexivity work? *)
        eapply paco2_eqit_b1b2_RR_refl; eauto.
      }

      destruct s.
      { (* PickUvalue *)
        destruct p.
        cbn.
        pstep; red; cbn.
        constructor.
        intros v; red.
        left; eapply paco2_mon_bot; eauto.
        (* Why won't reflexivity work? *)
        eapply paco2_eqit_b1b2_RR_refl; eauto.
      }

      destruct s.
      { (* OOM *)
        destruct o.
        cbn.
        pstep; red; cbn.
        constructor.
        intros [].
      }

      destruct s.
      { (* UBE *)
        destruct u.
        cbn.
        pstep; red; cbn.
        constructor.
        intros [].
      }

      destruct s.
      { (* DebugE *)
        destruct d.
        cbn.
        pstep; red; cbn.
        constructor.
        intros []; red.
        left; eapply paco2_mon_bot; eauto.
        (* Why won't reflexivity work? *)
        eapply paco2_eqit_b1b2_RR_refl; eauto.
      }

      { (* FailureE *)
        destruct f.
        cbn.
        pstep; red; cbn.
        constructor.
        intros [].
      }
  Qed.

  Lemma lift_MemState_refine_prop :
    forall ms,
      MemState_refine_prop (lift_MemState ms) ms.
  Proof.
    intros ms.
    red.
    destruct ms.
    cbn.
    repeat split; intros; cbn in * ; try reflexivity; try intuition;
      try red in H; try (rewrite <- H; auto); try (rewrite H; auto).
  Qed.

  (* TODO: Move this... *)
  Lemma MemPropT_bind_ret_inv :
    forall {S A B}
      (ma : MemPropT S A)
      (mab : A -> MemPropT S B)
      {s1 s2 b}
      (M :
        (a <- ma;;
         mab a) s1 (ret (s2, b))),
    exists s' a, ma s1 (ret (s', a)) /\ mab a s' (ret (s2, b)).
  Proof.
    intros S A B ma mab s1 s2 b M.
    auto.
  Qed.

  (* TODO: Move this... *)
  Lemma MemPropT_bind_raise_ub_inv :
    forall {S A B}
      (ma : MemPropT S A)
      (mab : A -> MemPropT S B)
      {s1 msg}
      (M :
        (a <- ma;;
         mab a) s1 (raise_ub msg)),
      (ma s1 (raise_ub msg) \/
         exists s' a, ma s1 (ret (s', a)) /\ mab a s' (raise_ub msg)).
  Proof.
    intros S A B ma mab s1 msg M.
    auto.
  Qed.

  (* TODO: Move this... *)
  Lemma MemPropT_bind_raise_error_inv :
    forall {S A B}
      (ma : MemPropT S A)
      (mab : A -> MemPropT S B)
      {s1 msg}
      (M :
        (a <- ma;;
         mab a) s1 (raise_error msg)),
      (ma s1 (raise_error msg) \/
         exists s' a, ma s1 (ret (s', a)) /\ mab a s' (raise_error msg)).
  Proof.
    intros S A B ma mab s1 msg M.
    auto.
  Qed.

  (* This might be a good idea, should make the proofs more modular... *)
  (* TODO: Move this *)
  Lemma MemPropT_fin_inf_bind :
    forall {ms_inf_start : MemoryBigIntptr.MMEP.MMSP.MemState}
      {ms_fin_start ms_fin_final : Memory64BitIntptr.MMEP.MMSP.MemState}
      {A_FIN A_INF B_FIN B_INF}
      (ma_fin : MemPropT Memory64BitIntptr.MMEP.MMSP.MemState A_FIN)
      {ma_inf : MemPropT MemoryBigIntptr.MMEP.MMSP.MemState A_INF}
      {mab_fin : A_FIN -> MemPropT Memory64BitIntptr.MMEP.MMSP.MemState B_FIN}
      {mab_inf : A_INF -> MemPropT MemoryBigIntptr.MMEP.MMSP.MemState B_INF}
      {res_fin}

      (A_REF : A_INF -> A_FIN -> Prop)
      (B_REF : B_INF -> B_FIN -> Prop)

      (MEM_REF_START : MemState_refine_prop ms_inf_start ms_fin_start)

      (* Not sure about quantification *)
      (MA: forall a_fin ms_fin_ma,
          ma_fin ms_fin_start (ret (ms_fin_ma, a_fin)) ->
          exists a_inf ms_inf_ma,
            ma_inf ms_inf_start (ret (ms_inf_ma, a_inf)) /\
              A_REF a_inf a_fin /\
              MemState_refine_prop ms_inf_ma ms_fin_ma)

      (* Not sure about quantification *)
      (* ma >>= k *)
      (K: forall ms_inf ms_fin ms_fin' a_fin a_inf b_fin,
          A_REF a_inf a_fin ->
          MemState_refine_prop ms_inf ms_fin ->
          ma_inf ms_inf_start (ret (ms_inf, a_inf)) ->
          mab_fin a_fin ms_fin (ret (ms_fin', b_fin)) ->
          exists b_inf ms_inf',
            mab_inf a_inf ms_inf (ret (ms_inf', b_inf)) /\
              B_REF b_inf b_fin /\
              MemState_refine_prop ms_inf' ms_fin')

      (FIN: (a <- ma_fin;;
             mab_fin a) ms_fin_start (ret (ms_fin_final, res_fin))),

    exists res_inf ms_inf_final,
      (a <- ma_inf;;
       mab_inf a) ms_inf_start (ret (ms_inf_final, res_inf)) /\
        B_REF res_inf res_fin /\
        MemState_refine_prop ms_inf_final ms_fin_final.
  Proof.
    intros ms_inf_start ms_fin_start ms_fin_final A_FIN A_INF B_FIN B_INF ma_fin ma_inf mab_fin mab_inf res_fin A_REF B_REF MEM_REF_START MA K FIN.

    repeat red in FIN.
    destruct FIN as (sab&a&FIN&FIN_AB).

    apply MA in FIN as (a_inf&ms_inf''&INF&A&MSR).
    eapply K in FIN_AB; eauto.

    destruct FIN_AB as (res_inf & ms_inf_final & MAB_INF & RES_REF & MEM_RES_FINAL).

    exists res_inf. exists ms_inf_final.
    split; auto.

    repeat red.
    exists ms_inf''.
    exists a_inf.
    split; auto.
  Qed.

  #[global] Hint Resolve MemPropT_fin_inf_bind : FinInf.

  Lemma MemPropT_fin_inf_map_monad :
    forall {A_INF A_FIN B_INF B_FIN}
      {l_inf : list A_INF} {l_fin : list A_FIN}
      {f_fin : A_FIN -> MemPropT Memory64BitIntptr.MMEP.MMSP.MemState B_FIN} {f_inf : A_INF -> MemPropT MemoryBigIntptr.MMEP.MMSP.MemState B_INF}
      {ms_fin_start ms_fin_final : Memory64BitIntptr.MMEP.MMSP.MemState}
      {ms_inf_start : MemoryBigIntptr.MMEP.MMSP.MemState}
      {res_fin : list B_FIN}

      (A_REF : A_INF -> A_FIN -> Prop)
      (B_REF : B_INF -> B_FIN -> Prop)

      (MEM_REF_START : MemState_refine_prop ms_inf_start ms_fin_start)

      (F : forall a_fin a_inf b_fin ms_fin ms_inf ms_fin_ma,
          MemState_refine_prop ms_inf ms_fin ->
          A_REF a_inf a_fin ->
          f_fin a_fin ms_fin (ret (ms_fin_ma, b_fin)) ->
          exists b_inf ms_inf_ma,
            f_inf a_inf ms_inf (ret (ms_inf_ma, b_inf)) /\
              B_REF b_inf b_fin /\
              MemState_refine_prop ms_inf_ma ms_fin_ma)

      (AS : Forall2 A_REF l_inf l_fin)
      (FIN : map_monad f_fin l_fin ms_fin_start (ret (ms_fin_final, res_fin))),

    exists res_inf ms_inf_final,
      map_monad f_inf l_inf ms_inf_start (ret (ms_inf_final, res_inf)) /\
        Forall2 B_REF res_inf res_fin /\
        MemState_refine_prop ms_inf_final ms_fin_final.
  Proof.
    intros A_INF A_FIN B_INF B_FIN l_inf l_fin f_fin f_inf ms_fin_start ms_fin_final ms_inf_start res_fin A_REF
      B_REF MEM_REF_START F AS FIN.

    generalize dependent res_fin.
    generalize dependent ms_fin_start.
    generalize dependent ms_inf_start.
    induction AS; intros ms_inf_start ms_fin_start MEM_REF_START res_fin FIN.
    - cbn. exists []. exists ms_inf_start.
      cbn in FIN.
      destruct FIN; subst.

      split; auto.
    - rewrite map_monad_unfold in FIN.
      apply MemPropT_bind_ret_inv in FIN as (ms_fin' & b_fin & F_Y & FIN).
      apply MemPropT_bind_ret_inv in FIN as (ms_fin_final' & b_fin_rest & MAP_FIN & RET_FIN).
      cbn in RET_FIN.
      destruct RET_FIN; subst.

      pose proof (F _ _ _ _ _ _ MEM_REF_START H F_Y) as (b_inf & ms_inf' & F_X & B & MSR).
      specialize (IHAS ms_inf' ms_fin' MSR _ MAP_FIN) as (b_inf_rest & ms_inf_final' & MAP_INF & B_ALL & MSR_FINAL).

      exists (b_inf :: b_inf_rest).
      exists ms_inf_final'.
      split; auto.

      rewrite map_monad_unfold.

      repeat red.
      do 2 eexists.
      split; eauto.
      do 2 eexists.
      split; eauto.

      cbn.
      auto.
  Qed.

  #[global] Hint Resolve MemPropT_fin_inf_map_monad : FinInf.

  Lemma MemPropT_fin_inf_map_monad_In :
    forall {A_INF A_FIN B_INF B_FIN}
      {l_inf : list A_INF} {l_fin : list A_FIN}
      {f_fin : forall x, In x l_fin -> MemPropT Memory64BitIntptr.MMEP.MMSP.MemState B_FIN}
      {f_inf : forall x, In x l_inf -> MemPropT MemoryBigIntptr.MMEP.MMSP.MemState B_INF}
      {ms_fin_start ms_fin_final : Memory64BitIntptr.MMEP.MMSP.MemState}
      {ms_inf_start : MemoryBigIntptr.MMEP.MMSP.MemState}
      {res_fin : list B_FIN}

      (A_REF : A_INF -> A_FIN -> Prop)
      (B_REF : B_INF -> B_FIN -> Prop)

      (MEM_REF_START : MemState_refine_prop ms_inf_start ms_fin_start)

      (F : forall a_fin a_inf b_fin ms_fin ms_inf ms_fin_ma (HIN_FIN : In a_fin l_fin) (HIN_INF : In a_inf l_inf),
          MemState_refine_prop ms_inf ms_fin ->
          A_REF a_inf a_fin ->
          f_fin a_fin HIN_FIN ms_fin (ret (ms_fin_ma, b_fin)) ->
          exists b_inf ms_inf_ma,
            f_inf a_inf HIN_INF ms_inf (ret (ms_inf_ma, b_inf)) /\
              B_REF b_inf b_fin /\
              MemState_refine_prop ms_inf_ma ms_fin_ma)

      (AS : Forall2 A_REF l_inf l_fin)
      (FIN : map_monad_In l_fin f_fin ms_fin_start (ret (ms_fin_final, res_fin))),

    exists res_inf ms_inf_final,
      map_monad_In l_inf f_inf ms_inf_start (ret (ms_inf_final, res_inf)) /\
        Forall2 B_REF res_inf res_fin /\
        MemState_refine_prop ms_inf_final ms_fin_final.
  Proof.
    intros A_INF A_FIN B_INF B_FIN l_inf l_fin f_fin f_inf ms_fin_start ms_fin_final ms_inf_start res_fin A_REF
      B_REF MEM_REF_START F AS FIN.

    generalize dependent res_fin.
    generalize dependent ms_fin_start.
    generalize dependent ms_inf_start.
    induction AS; intros ms_inf_start ms_fin_start MEM_REF_START res_fin FIN.
    - cbn. exists []. exists ms_inf_start.
      cbn in FIN.
      destruct FIN; subst.

      split; auto.
    - rewrite map_monad_In_unfold in FIN.
      apply MemPropT_bind_ret_inv in FIN as (ms_fin' & b_fin & F_Y & FIN).
      apply MemPropT_bind_ret_inv in FIN as (ms_fin_final' & b_fin_rest & MAP_FIN & RET_FIN).
      cbn in RET_FIN.
      destruct RET_FIN; subst.

      epose proof (F _ _ _ _ _ _ _ _ MEM_REF_START H F_Y) as (b_inf & ms_inf' & F_X & B & MSR).

      epose proof (IHAS
                    (fun (x : A_FIN) (HIn : In x l') => f_fin x (or_intror HIn))
                    (fun (x : A_INF) (HIn : In x l) => f_inf x (or_intror HIn))
                    _ _ _ MSR _ MAP_FIN) as (b_inf_rest & ms_inf_final' & MAP_INF & B_ALL & MSR_FINAL).

      exists (b_inf :: b_inf_rest).
      exists ms_inf_final'.
      split; auto.

      rewrite map_monad_In_unfold.

      repeat red.
      do 2 eexists.
      split; eauto.
      do 2 eexists.
      split; eauto.

      cbn.
      auto.

      Unshelve.
      intros a_fin a_inf b_fin0 ms_fin ms_inf ms_fin_ma HIN_FIN HIN_INF H0 H1 H2.
      cbn in H2.
      eapply F; eauto.
  Qed.

  #[global] Hint Resolve MemPropT_fin_inf_map_monad_In : FinInf.

  Lemma MemPropT_fin_inf_bind_ub :
    forall {ms_inf_start : MemoryBigIntptr.MMEP.MMSP.MemState}
      {ms_fin_start ms_fin_final : Memory64BitIntptr.MMEP.MMSP.MemState}
      {A_FIN A_INF B_FIN B_INF}
      (ma_fin : MemPropT Memory64BitIntptr.MMEP.MMSP.MemState A_FIN)
      {ma_inf : MemPropT MemoryBigIntptr.MMEP.MMSP.MemState A_INF}
      {mab_fin : A_FIN -> MemPropT Memory64BitIntptr.MMEP.MMSP.MemState B_FIN}
      {mab_inf : A_INF -> MemPropT MemoryBigIntptr.MMEP.MMSP.MemState B_INF}
      {msg : string}

      (A_REF : A_INF -> A_FIN -> Prop)

      (MEM_REF_START : MemState_refine_prop ms_inf_start ms_fin_start)

      (* Not sure about quantification *)
      (MA: forall a_fin ms_fin_ma,
          ma_fin ms_fin_start (ret (ms_fin_ma, a_fin)) ->
          exists a_inf ms_inf_ma,
            ma_inf ms_inf_start (ret (ms_inf_ma, a_inf)) /\
              A_REF a_inf a_fin /\
              MemState_refine_prop ms_inf_ma ms_fin_ma)

      (MA_UB: forall msg,
          ma_fin ms_fin_start (raise_ub msg) ->
          ma_inf ms_inf_start (raise_ub msg))

      (* Not sure about quantification *)
      (* ma >>= k *)
      (K: forall ms_inf ms_fin a_fin a_inf msg,
          A_REF a_inf a_fin ->
          MemState_refine_prop ms_inf ms_fin ->
          ma_inf ms_inf_start (ret (ms_inf, a_inf)) ->
          mab_fin a_fin ms_fin (raise_ub msg) ->
          mab_inf a_inf ms_inf (raise_ub msg))

      (FIN: (a <- ma_fin;;
             mab_fin a) ms_fin_start (raise_ub msg)),

      (a <- ma_inf;;
       mab_inf a) ms_inf_start (raise_ub msg).
  Proof.
    intros ms_inf_start ms_fin_start ms_fin_final A_FIN A_INF B_FIN B_INF ma_fin ma_inf mab_fin mab_inf msg A_REF MEM_REF_START MA MA_UB K FIN.

    repeat red in FIN.
    destruct FIN as [UB | (sab&a&FIN&FIN_AB)].
    { (* UB in ma_fin *)
      left.
      auto.
    }

    apply MA in FIN as (a_inf&ms_inf''&INF&A&MSR).
    eapply K in FIN_AB; eauto.

    right.
    eauto.
  Qed.

  #[global] Hint Resolve MemPropT_fin_inf_bind_ub : FinInf.

  Lemma MemPropT_fin_inf_bind_error :
    forall {ms_inf_start : MemoryBigIntptr.MMEP.MMSP.MemState}
      {ms_fin_start ms_fin_final : Memory64BitIntptr.MMEP.MMSP.MemState}
      {A_FIN A_INF B_FIN B_INF}
      (ma_fin : MemPropT Memory64BitIntptr.MMEP.MMSP.MemState A_FIN)
      {ma_inf : MemPropT MemoryBigIntptr.MMEP.MMSP.MemState A_INF}
      {mab_fin : A_FIN -> MemPropT Memory64BitIntptr.MMEP.MMSP.MemState B_FIN}
      {mab_inf : A_INF -> MemPropT MemoryBigIntptr.MMEP.MMSP.MemState B_INF}
      {msg : string}

      (A_REF : A_INF -> A_FIN -> Prop)

      (MEM_REF_START : MemState_refine_prop ms_inf_start ms_fin_start)

      (* Not sure about quantification *)
      (MA: forall a_fin ms_fin_ma,
          ma_fin ms_fin_start (ret (ms_fin_ma, a_fin)) ->
          exists a_inf ms_inf_ma,
            ma_inf ms_inf_start (ret (ms_inf_ma, a_inf)) /\
              A_REF a_inf a_fin /\
              MemState_refine_prop ms_inf_ma ms_fin_ma)

      (MA_ERROR: forall msg,
          ma_fin ms_fin_start (raise_error msg) ->
          ma_inf ms_inf_start (raise_error msg))

      (* Not sure about quantification *)
      (* ma >>= k *)
      (K: forall ms_inf ms_fin a_fin a_inf msg,
          A_REF a_inf a_fin ->
          MemState_refine_prop ms_inf ms_fin ->
          ma_inf ms_inf_start (ret (ms_inf, a_inf)) ->
          mab_fin a_fin ms_fin (raise_error msg) ->
          mab_inf a_inf ms_inf (raise_error msg))

      (FIN: (a <- ma_fin;;
             mab_fin a) ms_fin_start (raise_error msg)),

      (a <- ma_inf;;
       mab_inf a) ms_inf_start (raise_error msg).
  Proof.
    intros ms_inf_start ms_fin_start ms_fin_final A_FIN A_INF B_FIN B_INF ma_fin ma_inf mab_fin mab_inf msg A_REF MEM_REF_START MA MA_ERROR K FIN.

    repeat red in FIN.
    destruct FIN as [UB | (sab&a&FIN&FIN_AB)].
    { (* UB in ma_fin *)
      left.
      auto.
    }

    apply MA in FIN as (a_inf&ms_inf''&INF&A&MSR).
    eapply K in FIN_AB; eauto.

    right.
    eauto.
  Qed.

  #[global] Hint Resolve MemPropT_fin_inf_bind_error : FinInf.

  Lemma MemPropT_fin_inf_map_monad_ub :
    forall {A_INF A_FIN B_INF B_FIN}
      {l_inf : list A_INF} {l_fin : list A_FIN}
      {f_fin : A_FIN -> MemPropT Memory64BitIntptr.MMEP.MMSP.MemState B_FIN} {f_inf : A_INF -> MemPropT MemoryBigIntptr.MMEP.MMSP.MemState B_INF}
      {ms_fin_start ms_fin_final : Memory64BitIntptr.MMEP.MMSP.MemState}
      {ms_inf_start : MemoryBigIntptr.MMEP.MMSP.MemState}
      {msg : string}

      (A_REF : A_INF -> A_FIN -> Prop)
      (B_REF : B_INF -> B_FIN -> Prop)

      (MEM_REF_START : MemState_refine_prop ms_inf_start ms_fin_start)

      (F : forall a_fin a_inf b_fin ms_fin ms_inf ms_fin_ma,
          MemState_refine_prop ms_inf ms_fin ->
          A_REF a_inf a_fin ->
          f_fin a_fin ms_fin (ret (ms_fin_ma, b_fin)) ->
          exists b_inf ms_inf_ma,
            f_inf a_inf ms_inf (ret (ms_inf_ma, b_inf)) /\
              B_REF b_inf b_fin /\
              MemState_refine_prop ms_inf_ma ms_fin_ma)

      (F_UB : forall a_fin a_inf ms_fin ms_inf msg,
          MemState_refine_prop ms_inf ms_fin ->
          A_REF a_inf a_fin ->
          f_fin a_fin ms_fin (raise_ub msg) ->
          f_inf a_inf ms_inf (raise_ub msg))

      (AS : Forall2 A_REF l_inf l_fin)
      (FIN : map_monad f_fin l_fin ms_fin_start (raise_ub msg)),

      map_monad f_inf l_inf ms_inf_start (raise_ub msg).
  Proof.
    intros A_INF A_FIN B_INF B_FIN l_inf l_fin f_fin f_inf ms_fin_start ms_fin_final ms_inf_start msg A_REF B_REF MEM_REF_START F F_UB AS FIN.

    generalize dependent msg.
    generalize dependent ms_fin_start.
    generalize dependent ms_inf_start.
    induction AS; intros ms_inf_start ms_fin_start MEM_REF_START msg FIN.
    - cbn in *; auto.
    - rewrite map_monad_unfold in FIN.
      apply MemPropT_bind_raise_ub_inv in FIN as [UB | (ms_fin' & b_fin & F_Y & FIN)].
      { (* UB in first component *)
        left; eauto.
      }

      apply MemPropT_bind_raise_ub_inv in FIN as [UB | (ms_fin_final' & b_fin_rest & MAP_FIN & RET_FIN)].
      2: {
        cbn in RET_FIN.
        contradiction.
      }

      (* UB in rest *)
      right.
      pose proof (F _ _ _ _ _ _ MEM_REF_START H F_Y) as (b_inf & ms_inf' & F_X & B & MSR).
      specialize (IHAS ms_inf' ms_fin' MSR msg UB).
      exists ms_inf'. exists b_inf.
      split; eauto.
      left; auto.
  Qed.

  #[global] Hint Resolve MemPropT_fin_inf_map_monad_ub : FinInf.

  Lemma MemPropT_fin_inf_map_monad_error :
    forall {A_INF A_FIN B_INF B_FIN}
      {l_inf : list A_INF} {l_fin : list A_FIN}
      {f_fin : A_FIN -> MemPropT Memory64BitIntptr.MMEP.MMSP.MemState B_FIN} {f_inf : A_INF -> MemPropT MemoryBigIntptr.MMEP.MMSP.MemState B_INF}
      {ms_fin_start ms_fin_final : Memory64BitIntptr.MMEP.MMSP.MemState}
      {ms_inf_start : MemoryBigIntptr.MMEP.MMSP.MemState}
      {msg : string}

      (A_REF : A_INF -> A_FIN -> Prop)
      (B_REF : B_INF -> B_FIN -> Prop)

      (MEM_REF_START : MemState_refine_prop ms_inf_start ms_fin_start)

      (F : forall a_fin a_inf b_fin ms_fin ms_inf ms_fin_ma,
          MemState_refine_prop ms_inf ms_fin ->
          A_REF a_inf a_fin ->
          f_fin a_fin ms_fin (ret (ms_fin_ma, b_fin)) ->
          exists b_inf ms_inf_ma,
            f_inf a_inf ms_inf (ret (ms_inf_ma, b_inf)) /\
              B_REF b_inf b_fin /\
              MemState_refine_prop ms_inf_ma ms_fin_ma)

      (F_ERROR : forall a_fin a_inf ms_fin ms_inf msg,
          MemState_refine_prop ms_inf ms_fin ->
          A_REF a_inf a_fin ->
          f_fin a_fin ms_fin (raise_error msg) ->
          f_inf a_inf ms_inf (raise_error msg))

      (AS : Forall2 A_REF l_inf l_fin)
      (FIN : map_monad f_fin l_fin ms_fin_start (raise_error msg)),

      map_monad f_inf l_inf ms_inf_start (raise_error msg).
  Proof.
    intros A_INF A_FIN B_INF B_FIN l_inf l_fin f_fin f_inf ms_fin_start ms_fin_final ms_inf_start msg A_REF B_REF MEM_REF_START F F_ERROR AS FIN.

    generalize dependent msg.
    generalize dependent ms_fin_start.
    generalize dependent ms_inf_start.
    induction AS; intros ms_inf_start ms_fin_start MEM_REF_START msg FIN.
    - cbn in *; auto.
    - rewrite map_monad_unfold in FIN.
      apply MemPropT_bind_raise_error_inv in FIN as [UB | (ms_fin' & b_fin & F_Y & FIN)].
      { (* UB in first component *)
        left; eauto.
      }

      apply MemPropT_bind_raise_error_inv in FIN as [UB | (ms_fin_final' & b_fin_rest & MAP_FIN & RET_FIN)].
      2: {
        cbn in RET_FIN.
        contradiction.
      }

      (* UB in rest *)
      right.
      pose proof (F _ _ _ _ _ _ MEM_REF_START H F_Y) as (b_inf & ms_inf' & F_X & B & MSR).
      specialize (IHAS ms_inf' ms_fin' MSR msg UB).
      exists ms_inf'. exists b_inf.
      split; eauto.
      left; auto.
  Qed.

  #[global] Hint Resolve MemPropT_fin_inf_map_monad_error : FinInf.

  Lemma MemPropT_fin_inf_map_monad_In_ub :
    forall {A_INF A_FIN B_INF B_FIN}
      {l_inf : list A_INF} {l_fin : list A_FIN}
      {f_fin : forall x, In x l_fin -> MemPropT Memory64BitIntptr.MMEP.MMSP.MemState B_FIN}
      {f_inf : forall x, In x l_inf -> MemPropT MemoryBigIntptr.MMEP.MMSP.MemState B_INF}
      {ms_fin_start ms_fin_final : Memory64BitIntptr.MMEP.MMSP.MemState}
      {ms_inf_start : MemoryBigIntptr.MMEP.MMSP.MemState}
      {msg : string}

      (A_REF : A_INF -> A_FIN -> Prop)
      (B_REF : B_INF -> B_FIN -> Prop)

      (MEM_REF_START : MemState_refine_prop ms_inf_start ms_fin_start)

      (F : forall a_fin a_inf b_fin ms_fin ms_inf ms_fin_ma (HIN_FIN : In a_fin l_fin) (HIN_INF : In a_inf l_inf),
          MemState_refine_prop ms_inf ms_fin ->
          A_REF a_inf a_fin ->
          f_fin a_fin HIN_FIN ms_fin (ret (ms_fin_ma, b_fin)) ->
          exists b_inf ms_inf_ma,
            f_inf a_inf HIN_INF ms_inf (ret (ms_inf_ma, b_inf)) /\
              B_REF b_inf b_fin /\
              MemState_refine_prop ms_inf_ma ms_fin_ma)

      (F_UB : forall a_fin a_inf ms_fin ms_inf (HIN_FIN : In a_fin l_fin) (HIN_INF : In a_inf l_inf) msg,
          MemState_refine_prop ms_inf ms_fin ->
          A_REF a_inf a_fin ->
          f_fin a_fin HIN_FIN ms_fin (raise_ub msg) ->
          f_inf a_inf HIN_INF ms_inf (raise_ub msg))

      (AS : Forall2 A_REF l_inf l_fin)
      (FIN : map_monad_In l_fin f_fin ms_fin_start (raise_ub msg)),
      map_monad_In l_inf f_inf ms_inf_start (raise_ub msg).
  Proof.
    intros A_INF A_FIN B_INF B_FIN l_inf l_fin f_fin f_inf ms_fin_start ms_fin_final ms_inf_start msg A_REF B_REF
      MEM_REF_START F F_UB AS FIN.

    generalize dependent msg.
    generalize dependent ms_fin_start.
    generalize dependent ms_inf_start.
    induction AS; intros msg ms_inf_start ms_fin_start MEM_REF_START FIN.
    - cbn in FIN; cbn; auto.
    - rewrite map_monad_In_unfold in FIN.
      rewrite map_monad_In_unfold.

      eapply MemPropT_fin_inf_bind_ub.
      5: apply FIN.
      all: eauto with FinInf.

      intros ms_inf ms_fin a_fin a_inf msg0 REF MSR F_INF MAP.
      eapply MemPropT_fin_inf_bind_ub.
      5: apply MAP.
      all: eauto with FinInf.

      { intros a_fin0 ms_fin_ma H0.
        eapply MemPropT_fin_inf_map_monad_In.
        3: apply AS.
        all: eauto with FinInf.

        intros a_fin1 a_inf0 b_fin ms_fin0 ms_inf0 ms_fin_ma0 HIN_FIN HIN_INF H1 H2 H3.
        eapply F; eauto.
        apply H3.
      }

      intros msg1 HMAP.
      specialize (IHAS (fun (x : A_FIN) (HIn : In x l') => f_fin x (or_intror HIn)) (fun (x0 : A_INF) (HIn : In x0 l) => f_inf x0 (or_intror HIn))).
      repeat (forward IHAS; eauto).

      Unshelve.
      all: eauto.
  Qed.

  #[global] Hint Resolve MemPropT_fin_inf_map_monad_In_ub : FinInf.

  Lemma MemPropT_fin_inf_map_monad_In_error :
    forall {A_INF A_FIN B_INF B_FIN}
      {l_inf : list A_INF} {l_fin : list A_FIN}
      {f_fin : forall x, In x l_fin -> MemPropT Memory64BitIntptr.MMEP.MMSP.MemState B_FIN}
      {f_inf : forall x, In x l_inf -> MemPropT MemoryBigIntptr.MMEP.MMSP.MemState B_INF}
      {ms_fin_start ms_fin_final : Memory64BitIntptr.MMEP.MMSP.MemState}
      {ms_inf_start : MemoryBigIntptr.MMEP.MMSP.MemState}
      {msg : string}

      (A_REF : A_INF -> A_FIN -> Prop)
      (B_REF : B_INF -> B_FIN -> Prop)

      (MEM_REF_START : MemState_refine_prop ms_inf_start ms_fin_start)

      (F : forall a_fin a_inf b_fin ms_fin ms_inf ms_fin_ma (HIN_FIN : In a_fin l_fin) (HIN_INF : In a_inf l_inf),
          MemState_refine_prop ms_inf ms_fin ->
          A_REF a_inf a_fin ->
          f_fin a_fin HIN_FIN ms_fin (ret (ms_fin_ma, b_fin)) ->
          exists b_inf ms_inf_ma,
            f_inf a_inf HIN_INF ms_inf (ret (ms_inf_ma, b_inf)) /\
              B_REF b_inf b_fin /\
              MemState_refine_prop ms_inf_ma ms_fin_ma)

      (F_ERROR : forall a_fin a_inf ms_fin ms_inf (HIN_FIN : In a_fin l_fin) (HIN_INF : In a_inf l_inf) msg,
          MemState_refine_prop ms_inf ms_fin ->
          A_REF a_inf a_fin ->
          f_fin a_fin HIN_FIN ms_fin (raise_error msg) ->
          f_inf a_inf HIN_INF ms_inf (raise_error msg))

      (AS : Forall2 A_REF l_inf l_fin)
      (FIN : map_monad_In l_fin f_fin ms_fin_start (raise_error msg)),
      map_monad_In l_inf f_inf ms_inf_start (raise_error msg).
  Proof.
    intros A_INF A_FIN B_INF B_FIN l_inf l_fin f_fin f_inf ms_fin_start ms_fin_final ms_inf_start msg A_REF B_REF
      MEM_REF_START F F_ERROR AS FIN.

    generalize dependent msg.
    generalize dependent ms_fin_start.
    generalize dependent ms_inf_start.
    induction AS; intros msg ms_inf_start ms_fin_start MEM_REF_START FIN.
    - cbn in FIN; cbn; auto.
    - rewrite map_monad_In_unfold in FIN.
      rewrite map_monad_In_unfold.

      eapply MemPropT_fin_inf_bind_error.
      5: apply FIN.
      all: eauto with FinInf.

      intros ms_inf ms_fin a_fin a_inf msg0 REF MSR F_INF MAP.
      eapply MemPropT_fin_inf_bind_error.
      5: apply MAP.
      all: eauto with FinInf.

      { intros a_fin0 ms_fin_ma H0.
        eapply MemPropT_fin_inf_map_monad_In.
        3: apply AS.
        all: eauto with FinInf.

        intros a_fin1 a_inf0 b_fin ms_fin0 ms_inf0 ms_fin_ma0 HIN_FIN HIN_INF H1 H2 H3.
        eapply F; eauto.
        apply H3.
      }

      intros msg1 HMAP.
      specialize (IHAS (fun (x : A_FIN) (HIn : In x l') => f_fin x (or_intror HIn)) (fun (x0 : A_INF) (HIn : In x0 l) => f_inf x0 (or_intror HIn))).
      repeat (forward IHAS; eauto).

      Unshelve.
      all: eauto.
  Qed.

  #[global] Hint Resolve MemPropT_fin_inf_map_monad_In_error : FinInf.

  Lemma MemPropT_fin_inf_repeatMN :
    forall {A_INF A_FIN}
      {m_fin : MemPropT Memory64BitIntptr.MMEP.MMSP.MemState A_FIN}
      {m_inf : MemPropT MemoryBigIntptr.MMEP.MMSP.MemState A_INF}
      {ms_fin_start ms_fin_final : Memory64BitIntptr.MMEP.MMSP.MemState}
      {ms_inf_start : MemoryBigIntptr.MMEP.MMSP.MemState}
      {num_elements res_fin}

      (A_REF : A_INF -> A_FIN -> Prop)

      (MEM_REF_START : MemState_refine_prop ms_inf_start ms_fin_start)

      (M : forall res_fin ms_fin ms_inf ms_fin_ma,
          MemState_refine_prop ms_inf ms_fin ->
          m_fin ms_fin (ret (ms_fin_ma, res_fin)) ->
          exists res_inf ms_inf_ma,
            m_inf ms_inf (ret (ms_inf_ma, res_inf)) /\
              A_REF res_inf res_fin /\
              MemState_refine_prop ms_inf_ma ms_fin_ma)

      (FIN : repeatMN num_elements m_fin ms_fin_start (ret (ms_fin_final, res_fin))),

    exists res_inf ms_inf_final,
      repeatMN num_elements m_inf ms_inf_start (ret (ms_inf_final, res_inf)) /\
        Forall2 A_REF res_inf res_fin /\
        MemState_refine_prop ms_inf_final ms_fin_final.
  Proof.
    intros A_INF A_FIN m_fin m_inf ms_fin_start ms_fin_final ms_inf_start num_elements res_fin A_REF MEM_REF_START M FIN.

    generalize dependent res_fin.
    generalize dependent ms_fin_start.
    generalize dependent ms_inf_start.
    generalize dependent ms_fin_final.
    induction num_elements using N.peano_ind; intros ms_fin_final ms_inf_start ms_fin_start MEM_REF_START res_fin FIN.
    - cbn. exists []. exists ms_inf_start.
      cbn in FIN.
      destruct FIN; subst.

      split; auto.
    - rewrite repeatMN_succ in FIN.
      rewrite repeatMN_succ.

      eapply MemPropT_fin_inf_bind.
      4: apply FIN.
      all: eauto with FinInf.

      intros ms_inf ms_fin ms_fin' a_fin a_inf b_fin REF MSR M_INF REPEAT.
      eapply MemPropT_fin_inf_bind.
      4: apply REPEAT.
      all: eauto with FinInf.

      intros ms_inf0 ms_fin0 ms_fin'0 a_fin0 a_inf0 b_fin0 H H0 H1 H2.
      cbn.
      cbn in H2.
      destruct H2; subst.
      do 2 eexists.
      split; eauto.
  Qed.

  #[global] Hint Resolve MemPropT_fin_inf_repeatMN : FinInf.

  Lemma MemPropT_fin_inf_repeatMN_ub :
    forall {A_INF A_FIN}
      {m_fin : MemPropT Memory64BitIntptr.MMEP.MMSP.MemState A_FIN}
      {m_inf : MemPropT MemoryBigIntptr.MMEP.MMSP.MemState A_INF}
      {ms_fin_start ms_fin_final : Memory64BitIntptr.MMEP.MMSP.MemState}
      {ms_inf_start : MemoryBigIntptr.MMEP.MMSP.MemState}
      {num_elements}
      {msg : string}

      (A_REF : A_INF -> A_FIN -> Prop)

      (MEM_REF_START : MemState_refine_prop ms_inf_start ms_fin_start)

      (M : forall res_fin ms_fin ms_inf ms_fin_ma,
          MemState_refine_prop ms_inf ms_fin ->
          m_fin ms_fin (ret (ms_fin_ma, res_fin)) ->
          exists res_inf ms_inf_ma,
            m_inf ms_inf (ret (ms_inf_ma, res_inf)) /\
              A_REF res_inf res_fin /\
              MemState_refine_prop ms_inf_ma ms_fin_ma)

      (M_UB : forall ms_fin ms_inf msg,
          MemState_refine_prop ms_inf ms_fin ->
          m_fin ms_fin (raise_ub msg) ->
          m_inf ms_inf (raise_ub msg))

      (FIN : repeatMN num_elements m_fin ms_fin_start (raise_ub msg)),
      repeatMN num_elements m_inf ms_inf_start (raise_ub msg).
  Proof.
    intros A_INF A_FIN m_fin m_inf ms_fin_start ms_fin_final ms_inf_start num_elements msg A_REF MEM_REF_START M M_UB FIN.

    generalize dependent msg.
    generalize dependent ms_fin_start.
    generalize dependent ms_inf_start.
    induction num_elements using N.peano_ind; intros ms_inf_start ms_fin_start MEM_REF_START msg FIN.
    - cbn in *; auto.
    - rewrite repeatMN_succ.
      rewrite repeatMN_succ in FIN.

      eapply MemPropT_fin_inf_bind_ub.
      5: apply FIN.
      all: eauto with FinInf.

      intros ms_inf ms_fin a_fin a_inf msg0 H H0 H1 H2.
      eapply MemPropT_fin_inf_bind_ub.
      5: apply H2.
      all: eauto with FinInf.

      Unshelve.
      all: eauto.
  Qed.

  #[global] Hint Resolve MemPropT_fin_inf_repeatMN_ub : FinInf.

  Lemma MemPropT_fin_inf_repeatMN_error :
    forall {A_INF A_FIN}
      {m_fin : MemPropT Memory64BitIntptr.MMEP.MMSP.MemState A_FIN}
      {m_inf : MemPropT MemoryBigIntptr.MMEP.MMSP.MemState A_INF}
      {ms_fin_start ms_fin_final : Memory64BitIntptr.MMEP.MMSP.MemState}
      {ms_inf_start : MemoryBigIntptr.MMEP.MMSP.MemState}
      {num_elements}
      {msg : string}

      (A_REF : A_INF -> A_FIN -> Prop)

      (MEM_REF_START : MemState_refine_prop ms_inf_start ms_fin_start)

      (M : forall res_fin ms_fin ms_inf ms_fin_ma,
          MemState_refine_prop ms_inf ms_fin ->
          m_fin ms_fin (ret (ms_fin_ma, res_fin)) ->
          exists res_inf ms_inf_ma,
            m_inf ms_inf (ret (ms_inf_ma, res_inf)) /\
              A_REF res_inf res_fin /\
              MemState_refine_prop ms_inf_ma ms_fin_ma)

      (M_ERROR : forall ms_fin ms_inf msg,
          MemState_refine_prop ms_inf ms_fin ->
          m_fin ms_fin (raise_error msg) ->
          m_inf ms_inf (raise_error msg))

      (FIN : repeatMN num_elements m_fin ms_fin_start (raise_error msg)),
      repeatMN num_elements m_inf ms_inf_start (raise_error msg).
  Proof.
    intros A_INF A_FIN m_fin m_inf ms_fin_start ms_fin_final ms_inf_start num_elements msg A_REF MEM_REF_START M M_ERROR FIN.

    generalize dependent msg.
    generalize dependent ms_fin_start.
    generalize dependent ms_inf_start.
    induction num_elements using N.peano_ind; intros ms_inf_start ms_fin_start MEM_REF_START msg FIN.
    - cbn in *; auto.
    - rewrite repeatMN_succ.
      rewrite repeatMN_succ in FIN.

      eapply MemPropT_fin_inf_bind_error.
      5: apply FIN.
      all: eauto with FinInf.

      intros ms_inf ms_fin a_fin a_inf msg0 H H0 H1 H2.
      eapply MemPropT_fin_inf_bind_error.
      5: apply H2.
      all: eauto with FinInf.

      Unshelve.
      all: eauto.
  Qed.

  #[global] Hint Resolve MemPropT_fin_inf_repeatMN_error : FinInf.


  Lemma get_inf_tree_orutt :
    forall t,
      orutt (OOM:=OOME) L3_refine_strict L3_res_refine_strict
        (MemState_refine_prop
           Ã— (eq
                Ã— (local_refine_strict Ã— stack_refine_strict
                     Ã— (global_refine_strict Ã— DVC1.dvalue_refine_strict)))) (get_inf_tree t) t.
  Proof.
    intros t.
    rewrite (itree_eta_ t).
    genobs t ot.
    clear t Heqot.
    revert ot.
    pcofix CIH.
    intros ot.

    induction ot.
    - (* Ret *)
      pstep; red; cbn.
      constructor.
      destruct r0.
      repeat destruct p.
      destruct p0.
      constructor.
      apply lift_MemState_refine_prop.
      repeat constructor; cbn; eauto.
      + apply lift_local_env_refine_strict.
      + apply lift_stack_refine_strict.
      + apply lift_global_env_refine_strict.
      + apply fin_to_inf_dvalue_refine_strict.
    - (* Tau *)
      pstep; red; cbn.
      constructor.
      right.
      rewrite (itree_eta_ t).
      apply CIH.
    - (* Vis nodes *)
      destruct e.
      { (* ExternalCallE *)
        destruct e.
        pstep; red; cbn.

        constructor.
        { red. cbn.
          split; auto.
          split.
          apply fin_to_inf_uvalue_refine_strict.
          apply Util.Forall2_forall.
          split.
          apply map_length.

          intros i a b H H0.
          apply Nth_map_iff in H.
          destruct H. destruct H.
          subst.

          cbn in *.
          rewrite H1 in H0.
          inv H0.
          apply fin_to_inf_dvalue_refine_strict.
        }

        { intros a b [TT [F [ARGS AB]]].
          rewrite DVCInfFin.dvalue_refine_strict_equation in AB.
          rewrite AB.
          rewrite (itree_eta_ (k b)).
          right.
          apply CIH.
        }

        { intros o CONTRA; inv CONTRA.
        }
      }

      destruct s.
      { (* PickUvalue *)
        destruct p.
        pstep; red; cbn.

        constructor.
        { red. cbn.
          split; [tauto|].
          apply fin_to_inf_uvalue_refine_strict.
        }

        { intros [a []] [b []] [_ [X AB]].
          rewrite DVCInfFin.dvalue_refine_strict_equation in AB.
          rewrite AB.
          rewrite (itree_eta_ (k _)).
          right.
          apply CIH.
        }

        { intros o CONTRA; inv CONTRA.
        }
      }

      destruct s.
      { (* OOM *)
        destruct o.
        pstep; red; cbn.

        change (inr1 (inr1 (inl1 (ThrowOOM u)))) with (@subevent _ _ (ReSum_inr IFun sum1 OOME
                                                                        (PickUvalueE +' OOME +' UBE +' DebugE +' FailureE)
                                                                        ExternalCallE) _ (ThrowOOM u)).

        apply EqVisOOM.
      }

      destruct s.
      { (* UBE *)
        destruct u.
        pstep; red; cbn.

        constructor.
        { cbn; auto.
        }

        { intros [] [] _.
        }

        { intros o CONTRA; inv CONTRA.
        }
      }

      destruct s.
      { (* DebugE *)
        destruct d.
        pstep; red; cbn.

        constructor.
        { cbn; auto.
        }

        { intros [] [] _.
          rewrite (itree_eta_ (k _)).
          right.
          apply CIH.
        }

        { intros o CONTRA; inv CONTRA.
        }
      }

      { (* FailureE *)
        destruct f.
        pstep; red; cbn.

        constructor.
        { cbn; auto.
          destruct u.
          unfold print_msg.
          reflexivity.
        }

        { intros [] [] _.
        }

        { intros o CONTRA; inv CONTRA.
        }
      }
  Qed.

  Import InterpMemoryProp.

  #[global] Instance get_inf_tree_eq_itree_eq_Proper :
    Proper (eq_itree eq ==> eq_itree eq) get_inf_tree.
  Proof.
    unfold Proper, respectful.
    intros x y EQ.
    rewrite (itree_eta_ x) in *.
    rewrite (itree_eta_ y) in *.
    genobs x ox.
    genobs y oy.
    clear x Heqox y Heqoy.
    revert ox oy EQ.
    pcofix CIH.
    intros ox oy EQ.
    punfold EQ. red in EQ. cbn in EQ.
    dependent induction EQ.
    - (* Ret Ret *)
      subst.
      pstep; red; cbn.
      constructor; auto.
    - (* Tau Tau *)
      pstep; red; cbn.
      constructor.
      right.
      rewrite (itree_eta_ m1).
      rewrite (itree_eta_ m2).
      eapply CIH.
      pclearbot.
      repeat rewrite <- itree_eta_.
      apply REL.
    - (* Vis Vis *)
      destruct e.

      { (* ExternalCallE *)
        destruct e.
        pstep; red; cbn.
        constructor.
        intros v.
        red.
        right.
        rewrite (itree_eta_
                   match DVCInfFin.dvalue_convert_strict v with
                   | NoOom a => k1 a
                   | Oom s => raiseOOM s
                   end).
        rewrite (itree_eta_
                   match DVCInfFin.dvalue_convert_strict v with
                   | NoOom a => k2 a
                   | Oom s => raiseOOM s
                   end).
        apply CIH.
        repeat rewrite <- itree_eta_.
        break_match; [|reflexivity].
        specialize (REL d).
        red in REL.
        pclearbot.
        eauto.
      }

      destruct s.
      { (* PickUvalueE *)
        destruct p.
        pstep; red; cbn.
        constructor.
        intros [v []].
        red.
        right.
        match goal with
        | H: _ |- r (get_inf_tree ?t1) (get_inf_tree ?t2) =>
            rewrite (itree_eta_ t1);
            rewrite (itree_eta_ t2)
        end.
        apply CIH.
        repeat rewrite <- itree_eta_.
        break_match; [|reflexivity].
        specialize (REL (exist _ d I)).
        red in REL.
        pclearbot.
        eauto.
      }

      destruct s.
      { (* OOME *)
        destruct o.
        pstep; red; cbn.
        constructor.
        intros [] _.
      }

      destruct s.
      { (* UBE *)
        destruct u0.
        pstep; red; cbn.
        constructor.
        intros [] _.
      }

      destruct s.
      { (* DebugE *)
        destruct d.
        pstep; red; cbn.
        constructor.
        intros [].
        red.
        right.
        match goal with
        | H: _ |- r (get_inf_tree ?t1) (get_inf_tree ?t2) =>
            rewrite (itree_eta_ t1);
            rewrite (itree_eta_ t2)
        end.
        apply CIH.
        repeat rewrite <- itree_eta_.
        specialize (REL tt).
        red in REL.
        pclearbot.
        eauto.
      }

      { (* FailureE *)
        destruct f.
        pstep; red; cbn.
        constructor.
        intros [] _.
      }
    - (* TauL *)
      pstep; red; cbn.
      constructor; auto.
      punfold IHEQ.
    - (* TauR *)
      pstep; red; cbn.
      constructor; auto.
      punfold IHEQ.
  Qed.

  #[global] Instance get_inf_tree_eq_itree_Proper :
    Proper (eq_itree (Memory64BitIntptr.MMEP.MemSpec.MemState_eqv Ã— eq) ==> eq_itree (MemoryBigIntptr.MMEP.MemSpec.MemState_eqv Ã— eq)) get_inf_tree.
  Proof.
    unfold Proper, respectful.
    intros x y EQ.
    rewrite (itree_eta_ x) in *.
    rewrite (itree_eta_ y) in *.
    genobs x ox.
    genobs y oy.
    clear x Heqox y Heqoy.
    revert ox oy EQ.
    pcofix CIH.
    intros ox oy EQ.
    punfold EQ. red in EQ. cbn in EQ.
    dependent induction EQ.
    - (* Ret Ret *)
      subst.
      pstep; red; cbn.
      constructor; auto.
      destruct r1 as (ms1&sid1&((lenv1&stack1)&genv1&r1)).
      destruct r2 as (ms2&sid2&((lenv2&stack2)&genv2&r2)).
      inv REL.
      cbn in *.
      inv snd_rel.
      constructor; cbn; auto.
      eapply MemState_eqv_lift_MemState; auto.
    - (* Tau Tau *)
      pstep; red; cbn.
      constructor.
      right.
      rewrite (itree_eta_ m1).
      rewrite (itree_eta_ m2).
      eapply CIH.
      pclearbot.
      repeat rewrite <- itree_eta_.
      apply REL.
    - (* Vis Vis *)
      destruct e.

      { (* ExternalCallE *)
        destruct e.
        pstep; red; cbn.
        constructor.
        intros v.
        red.
        right.
        rewrite (itree_eta_
                   match DVCInfFin.dvalue_convert_strict v with
                   | NoOom a => k1 a
                   | Oom s => raiseOOM s
                   end).
        rewrite (itree_eta_
                   match DVCInfFin.dvalue_convert_strict v with
                   | NoOom a => k2 a
                   | Oom s => raiseOOM s
                   end).
        apply CIH.
        repeat rewrite <- itree_eta_.
        break_match; [|reflexivity].
        specialize (REL d).
        red in REL.
        pclearbot.
        eauto.
      }

      destruct s.
      { (* PickUvalueE *)
        destruct p.
        pstep; red; cbn.
        constructor.
        intros [v []].
        red.
        right.
        match goal with
        | H: _ |- r (get_inf_tree ?t1) (get_inf_tree ?t2) =>
            rewrite (itree_eta_ t1);
            rewrite (itree_eta_ t2)
        end.
        apply CIH.
        repeat rewrite <- itree_eta_.
        break_match; [|reflexivity].
        specialize (REL (exist _ d I)).
        red in REL.
        pclearbot.
        eauto.
      }

      destruct s.
      { (* OOME *)
        destruct o.
        pstep; red; cbn.
        constructor.
        intros [] _.
      }

      destruct s.
      { (* UBE *)
        destruct u0.
        pstep; red; cbn.
        constructor.
        intros [] _.
      }

      destruct s.
      { (* DebugE *)
        destruct d.
        pstep; red; cbn.
        constructor.
        intros [].
        red.
        right.
        match goal with
        | H: _ |- r (get_inf_tree ?t1) (get_inf_tree ?t2) =>
            rewrite (itree_eta_ t1);
            rewrite (itree_eta_ t2)
        end.
        apply CIH.
        repeat rewrite <- itree_eta_.
        specialize (REL tt).
        red in REL.
        pclearbot.
        eauto.
      }

      { (* FailureE *)
        destruct f.
        pstep; red; cbn.
        constructor.
        intros [] _.
      }
    - (* TauL *)
      pstep; red; cbn.
      constructor; auto.
      punfold IHEQ.
    - (* TauR *)
      pstep; red; cbn.
      constructor; auto.
      punfold IHEQ.
  Qed.

  #[global] Instance get_inf_tree_eq_Proper :
    Proper (eutt eq ==> eutt eq) get_inf_tree.
  Proof.
    unfold Proper, respectful.
    intros x y EQ.
    rewrite (itree_eta_ x) in *.
    rewrite (itree_eta_ y) in *.
    genobs x ox.
    genobs y oy.
    clear x Heqox y Heqoy.
    revert ox oy EQ.
    pcofix CIH.
    intros ox oy EQ.
    punfold EQ. red in EQ. cbn in EQ.
    dependent induction EQ.
    - (* Ret Ret *)
      subst.
      pstep; red; cbn.
      constructor; auto.
    - (* Tau Tau *)
      pstep; red; cbn.
      constructor.
      right.
      rewrite (itree_eta_ m1).
      rewrite (itree_eta_ m2).
      eapply CIH.
      pclearbot.
      repeat rewrite <- itree_eta_.
      apply REL.
    - (* Vis Vis *)
      destruct e.

      { (* ExternalCallE *)
        destruct e.
        pstep; red; cbn.
        constructor.
        intros v.
        red.
        right.
        rewrite (itree_eta_
                   match DVCInfFin.dvalue_convert_strict v with
                   | NoOom a => k1 a
                   | Oom s => raiseOOM s
                   end).
        rewrite (itree_eta_
                   match DVCInfFin.dvalue_convert_strict v with
                   | NoOom a => k2 a
                   | Oom s => raiseOOM s
                   end).
        apply CIH.
        repeat rewrite <- itree_eta_.
        break_match; [|reflexivity].
        specialize (REL d).
        red in REL.
        pclearbot.
        eauto.
      }

      destruct s.
      { (* PickUvalueE *)
        destruct p.
        pstep; red; cbn.
        constructor.
        intros [v []].
        red.
        right.
        match goal with
        | H: _ |- r (get_inf_tree ?t1) (get_inf_tree ?t2) =>
            rewrite (itree_eta_ t1);
            rewrite (itree_eta_ t2)
        end.
        apply CIH.
        repeat rewrite <- itree_eta_.
        break_match; [|reflexivity].
        specialize (REL (exist _ d I)).
        red in REL.
        pclearbot.
        eauto.
      }

      destruct s.
      { (* OOME *)
        destruct o.
        pstep; red; cbn.
        constructor.
        intros [] _.
      }

      destruct s.
      { (* UBE *)
        destruct u0.
        pstep; red; cbn.
        constructor.
        intros [] _.
      }

      destruct s.
      { (* DebugE *)
        destruct d.
        pstep; red; cbn.
        constructor.
        intros [].
        red.
        right.
        match goal with
        | H: _ |- r (get_inf_tree ?t1) (get_inf_tree ?t2) =>
            rewrite (itree_eta_ t1);
            rewrite (itree_eta_ t2)
        end.
        apply CIH.
        repeat rewrite <- itree_eta_.
        specialize (REL tt).
        red in REL.
        pclearbot.
        eauto.
      }

      { (* FailureE *)
        destruct f.
        pstep; red; cbn.
        constructor.
        intros [] _.
      }
    - (* TauL *)
      pstep; red; cbn.
      constructor; auto.
      punfold IHEQ.
    - (* TauR *)
      pstep; red; cbn.
      constructor; auto.
      punfold IHEQ.
  Qed.

  #[global] Instance get_inf_tree_Proper :
    Proper (eutt (Memory64BitIntptr.MMEP.MemSpec.MemState_eqv Ã— eq) ==> eutt (MemoryBigIntptr.MMEP.MemSpec.MemState_eqv Ã— eq)) get_inf_tree.
  Proof.
    unfold Proper, respectful.
    intros x y EQ.
    rewrite (itree_eta_ x) in *.
    rewrite (itree_eta_ y) in *.
    genobs x ox.
    genobs y oy.
    clear x Heqox y Heqoy.
    revert ox oy EQ.
    pcofix CIH.
    intros ox oy EQ.
    punfold EQ. red in EQ. cbn in EQ.
    dependent induction EQ.
    - (* Ret Ret *)
      subst.
      pstep; red; cbn.
      destruct r1 as (ms1&sid1&((lenv1&stack1)&genv1&r1)).
      destruct r2 as (ms2&sid2&((lenv2&stack2)&genv2&r2)).
      constructor; auto.
      inv REL.
      cbn in *.
      inv snd_rel.
      constructor; cbn; auto.
      eapply MemState_eqv_lift_MemState; auto.
    - (* Tau Tau *)
      pstep; red; cbn.
      constructor.
      right.
      rewrite (itree_eta_ m1).
      rewrite (itree_eta_ m2).
      eapply CIH.
      pclearbot.
      repeat rewrite <- itree_eta_.
      apply REL.
    - (* Vis Vis *)
      destruct e.

      { (* ExternalCallE *)
        destruct e.
        pstep; red; cbn.
        constructor.
        intros v.
        red.
        right.
        rewrite (itree_eta_
                   match DVCInfFin.dvalue_convert_strict v with
                   | NoOom a => k1 a
                   | Oom s => raiseOOM s
                   end).
        rewrite (itree_eta_
                   match DVCInfFin.dvalue_convert_strict v with
                   | NoOom a => k2 a
                   | Oom s => raiseOOM s
                   end).
        apply CIH.
        repeat rewrite <- itree_eta_.
        break_match; [|reflexivity].
        specialize (REL d).
        red in REL.
        pclearbot.
        eauto.
      }

      destruct s.
      { (* PickUvalueE *)
        destruct p.
        pstep; red; cbn.
        constructor.
        intros [v []].
        red.
        right.
        match goal with
        | H: _ |- r (get_inf_tree ?t1) (get_inf_tree ?t2) =>
            rewrite (itree_eta_ t1);
            rewrite (itree_eta_ t2)
        end.
        apply CIH.
        repeat rewrite <- itree_eta_.
        break_match; [|reflexivity].
        specialize (REL (exist _ d I)).
        red in REL.
        pclearbot.
        eauto.
      }

      destruct s.
      { (* OOME *)
        destruct o.
        pstep; red; cbn.
        constructor.
        intros [] _.
      }

      destruct s.
      { (* UBE *)
        destruct u0.
        pstep; red; cbn.
        constructor.
        intros [] _.
      }

      destruct s.
      { (* DebugE *)
        destruct d.
        pstep; red; cbn.
        constructor.
        intros [].
        red.
        right.
        match goal with
        | H: _ |- r (get_inf_tree ?t1) (get_inf_tree ?t2) =>
            rewrite (itree_eta_ t1);
            rewrite (itree_eta_ t2)
        end.
        apply CIH.
        repeat rewrite <- itree_eta_.
        specialize (REL tt).
        red in REL.
        pclearbot.
        eauto.
      }

      { (* FailureE *)
        destruct f.
        pstep; red; cbn.
        constructor.
        intros [] _.
      }
    - (* TauL *)
      pstep; red; cbn.
      constructor; auto.
      punfold IHEQ.
    - (* TauR *)
      pstep; red; cbn.
      constructor; auto.
      punfold IHEQ.
  Qed.

  (* TODO: not 100% sure what R, T1T2, pre, post should be / what constraints are needed for them *)
  Lemma oom_orutt :
    forall {E F T1 T2}
      `{OE : OOME -< E}
      `{OF : OOME -< F}
      (R : relation T1)
      (T1T2 : T1 -> T2 -> Prop)
      (pre : prerel E F)
      (post : postrel E F)
      (t_source t_oom : itree E T1) (t_final : itree F T2),
      refine_OOM_h R t_source t_oom ->
      orutt (OOM:=OOME) pre post T1T2 t_oom t_final ->
      orutt (OOM:=OOME) pre post T1T2 t_source t_final.
  Proof.
    intros E F T1 T2 OE OF R T1T2 pre post t_source t_oom t_final REF_OOM ORUTT.
  Abort.

  (* TODO: inversion lemmas for dvalue_convert_strict *)
  Lemma dvalue_convert_strict_addr_inv :
    forall x a,
      DVCInfFin.dvalue_convert_strict x = NoOom (DVCInfFin.DV2.DVALUE_Addr a) ->
      exists a',
        InfToFinAddrConvert.addr_convert a' = NoOom a /\
          x = DVCInfFin.DV1.DVALUE_Addr a'.
  Proof.
    intros x a H.
    destruct x; inversion H; try solve [ break_match_hyp; inv H1 ].
    break_match_hyp; inv H1.
    exists a0; auto.
  Qed.

  Lemma dvalue_convert_strict_iptr_inv :
    forall x n,
      DVCInfFin.dvalue_convert_strict x = NoOom (DVCInfFin.DV2.DVALUE_IPTR n) ->
      exists n',
        IP.from_Z (InterpreterStackBigIntptr.LP.IP.to_Z n') = NoOom n /\
          x = DVCInfFin.DV1.DVALUE_IPTR n'.
  Proof.
    intros x n H.
    destruct x; inversion H; try solve [ break_match_hyp; inv H1 ].
    break_match_hyp; inv H1.
    exists x; auto.
  Qed.

  Lemma dvalue_convert_strict_i1_inv :
    forall x n,
      DVCInfFin.dvalue_convert_strict x = NoOom (DVCInfFin.DV2.DVALUE_I1 n) ->
      x = DVCInfFin.DV1.DVALUE_I1 n.
  Proof.
    intros x n H.
    destruct x; inversion H; try solve [ break_match_hyp; inv H1 ].
    subst.
    auto.
  Qed.

  Lemma dvalue_convert_strict_i8_inv :
    forall x n,
      DVCInfFin.dvalue_convert_strict x = NoOom (DVCInfFin.DV2.DVALUE_I8 n) ->
      x = DVCInfFin.DV1.DVALUE_I8 n.
  Proof.
    intros x n H.
    destruct x; inversion H; try solve [ break_match_hyp; inv H1 ].
    subst.
    auto.
  Qed.

  Lemma dvalue_convert_strict_i32_inv :
    forall x n,
      DVCInfFin.dvalue_convert_strict x = NoOom (DVCInfFin.DV2.DVALUE_I32 n) ->
      x = DVCInfFin.DV1.DVALUE_I32 n.
  Proof.
    intros x n H.
    destruct x; inversion H; try solve [ break_match_hyp; inv H1 ].
    subst.
    auto.
  Qed.

  Lemma dvalue_convert_strict_i64_inv :
    forall x n,
      DVCInfFin.dvalue_convert_strict x = NoOom (DVCInfFin.DV2.DVALUE_I64 n) ->
      x = DVCInfFin.DV1.DVALUE_I64 n.
  Proof.
    intros x n H.
    destruct x; inversion H; try solve [ break_match_hyp; inv H1 ].
    subst.
    auto.
  Qed.

  Lemma dvalue_convert_strict_double_inv :
    forall x v,
      DVCInfFin.dvalue_convert_strict x = NoOom (DVCInfFin.DV2.DVALUE_Double v) ->
      x = DVCInfFin.DV1.DVALUE_Double v.
  Proof.
    intros x n H.
    destruct x; inversion H; try solve [ break_match_hyp; inv H1 ].
    subst.
    auto.
  Qed.

  Lemma dvalue_convert_strict_float_inv :
    forall x v,
      DVCInfFin.dvalue_convert_strict x = NoOom (DVCInfFin.DV2.DVALUE_Float v) ->
      x = DVCInfFin.DV1.DVALUE_Float v.
  Proof.
    intros x n H.
    destruct x; inversion H; try solve [ break_match_hyp; inv H1 ].
    subst.
    auto.
  Qed.

  Lemma dvalue_convert_strict_poison_inv :
    forall x v,
      DVCInfFin.dvalue_convert_strict x = NoOom (DVCInfFin.DV2.DVALUE_Poison v) ->
      x = DVCInfFin.DV1.DVALUE_Poison v.
  Proof.
    intros x n H.
    destruct x; inversion H; try solve [ break_match_hyp; inv H1 ].
    subst.
    auto.
  Qed.

  Lemma dvalue_convert_strict_oom_inv :
    forall x v,
      DVCInfFin.dvalue_convert_strict x = NoOom (DVCInfFin.DV2.DVALUE_Oom v) ->
      x = DVCInfFin.DV1.DVALUE_Oom v.
  Proof.
    intros x n H.
    destruct x; inversion H; try solve [ break_match_hyp; inv H1 ].
    subst.
    auto.
  Qed.

  Lemma dvalue_convert_strict_none_inv :
    forall x,
      DVCInfFin.dvalue_convert_strict x = NoOom DVCInfFin.DV2.DVALUE_None ->
      x = DVCInfFin.DV1.DVALUE_None.
  Proof.
    intros x H.
    destruct x; inversion H; try solve [ break_match_hyp; inv H1 ].
    subst.
    auto.
  Qed.

  Lemma dvalue_convert_strict_struct_inv :
    forall x fields,
      DVCInfFin.dvalue_convert_strict x = NoOom (DVCInfFin.DV2.DVALUE_Struct fields) ->
      exists fields', x = DVCInfFin.DV1.DVALUE_Struct fields'.
  Proof.
    intros x fields H.
    destruct x; inversion H; try solve [ break_match_hyp; inv H1 ].
    break_match_hyp; inv H1.
    exists fields0. reflexivity.
  Qed.

  Lemma dvalue_convert_strict_packed_struct_inv :
    forall x fields,
      DVCInfFin.dvalue_convert_strict x = NoOom (DVCInfFin.DV2.DVALUE_Packed_struct fields) ->
      exists fields', x = DVCInfFin.DV1.DVALUE_Packed_struct fields'.
  Proof.
    intros x fields H.
    destruct x; inversion H; try solve [ break_match_hyp; inv H1 ].
    break_match_hyp; inv H1.
    exists fields0. reflexivity.
  Qed.

  Lemma dvalue_convert_strict_array_inv :
    forall x elts,
      DVCInfFin.dvalue_convert_strict x = NoOom (DVCInfFin.DV2.DVALUE_Array elts) ->
      exists elts', x = DVCInfFin.DV1.DVALUE_Array elts'.
  Proof.
    intros x elts H.
    destruct x; inversion H; try solve [ break_match_hyp; inv H1 ].
    break_match_hyp; inv H1.
    exists elts0. reflexivity.
  Qed.

  Lemma dvalue_convert_strict_vector_inv :
    forall x elts,
      DVCInfFin.dvalue_convert_strict x = NoOom (DVCInfFin.DV2.DVALUE_Vector elts) ->
      exists elts', x = DVCInfFin.DV1.DVALUE_Vector elts'.
  Proof.
    intros x elts H.
    destruct x; inversion H; try solve [ break_match_hyp; inv H1 ].
    break_match_hyp; inv H1.
    exists elts0. reflexivity.
  Qed.

  Lemma fin_inf_no_overlap :
    forall a1 sz1 a2 sz2 a1' a2',
      addr_refine a1' a1 ->
      addr_refine a2' a2 ->
      Memory64BitIntptr.MMEP.MemSpec.OVER_H.no_overlap a1 sz1 a2 sz2 = MemoryBigIntptr.MMEP.MemSpec.OVER_H.no_overlap a1' sz1 a2' sz2.
  Proof.
    intros a1 sz1 a2 sz2 a1' a2' REF1 REF2.
    unfold MemoryBigIntptr.MMEP.MemSpec.OVER_H.no_overlap.
    unfold Memory64BitIntptr.MMEP.MemSpec.OVER_H.no_overlap.
    unfold MemoryBigIntptr.MMEP.MemSpec.OVER.overlaps.
    unfold Memory64BitIntptr.MMEP.MemSpec.OVER.overlaps.
    apply InfToFinAddrConvert.addr_convert_ptoi in REF1, REF2.
    lia.
  Qed.

  Lemma fin_inf_intptr_seq :
    forall start len ips,
      Memory64BitIntptr.MMEP.MemSpec.MemHelpers.intptr_seq start len = NoOom ips ->
      exists ips_big, MemoryBigIntptr.MMEP.MemSpec.MemHelpers.intptr_seq start len = NoOom ips_big /\
                   Forall2 (fun a b => LLVMParams64BitIntptr.IP.to_Z a = LLVMParamsBigIntptr.IP.to_Z b) ips ips_big.
  Proof.
    intros start len ips SEQ.
    pose proof Memory64BitIntptr.MMEP.MemSpec.MemHelpers.intptr_seq_len _ _ _ SEQ as LEN.
    generalize dependent start.
    generalize dependent len.
    induction ips; intros len LEN start SEQ.
    - cbn in *; subst.
      exists [].
      split.
      + cbn; auto.
      + constructor.
    - cbn in *; inv LEN.
      pose proof SEQ.
      rewrite Memory64BitIntptr.MMEP.MemSpec.MemHelpers.intptr_seq_succ in H0.
      cbn in H0.
      break_match_hyp; inv H0.
      break_match_hyp; inv H2.

      pose proof Heqo.
      apply fin_inf_from_Z in Heqo as [ip_i IP_I].
      specialize (IHips (Datatypes.length ips) eq_refl (Z.succ start) Heqo0).
      destruct IHips as [ips_big [SEQ' ALL]].
      exists (ip_i :: ips_big).
      split.
      + rewrite MemoryBigIntptr.MMEP.MemSpec.MemHelpers.intptr_seq_succ.
        cbn.
        rewrite SEQ'.
        cbn in IP_I.
        inv IP_I.
        auto.
      + constructor; eauto.
        eapply fin_inf_from_Z_to_Z; eauto.
  Qed.

  Lemma fin_inf_get_consecutive_ptrs_success :
    forall a a' n ms ms_x xs ms_y ys,
      (* TODO: ADDR probably not necessary, can conclude this from ADDRS...
       *)
      InfToFinAddrConvert.addr_convert a' = NoOom a ->
      Forall2 (fun x y => InfToFinAddrConvert.addr_convert y = NoOom x) xs ys ->
      (@Memory64BitIntptr.MMEP.MemSpec.MemHelpers.get_consecutive_ptrs
         (MemPropT Memory64BitIntptr.MMEP.MMSP.MemState)
         (@MemPropT_Monad Memory64BitIntptr.MMEP.MMSP.MemState)
         (@MemPropT_RAISE_OOM Memory64BitIntptr.MMEP.MMSP.MemState)
         (@MemPropT_RAISE_ERROR Memory64BitIntptr.MMEP.MMSP.MemState) a n ms (success_unERR_UB_OOM (ms_x, xs))) ->
      (@MemoryBigIntptr.MMEP.MemSpec.MemHelpers.get_consecutive_ptrs
         (MemPropT MemoryBigIntptr.MMEP.MMSP.MemState)
         (@MemPropT_Monad MemoryBigIntptr.MMEP.MMSP.MemState)
         (@MemPropT_RAISE_OOM MemoryBigIntptr.MMEP.MMSP.MemState)
         (@MemPropT_RAISE_ERROR MemoryBigIntptr.MMEP.MMSP.MemState) a' n ms_y (success_unERR_UB_OOM (ms_y, ys))).
  Proof.
    intros a a' n ms ms_x xs ms_y ys A'A ADDRS CONSEC.
    cbn in *.
    destruct CONSEC as [sab [a0 [SEQ_OOM CONSEC]]].
    destruct (Memory64BitIntptr.MMEP.MemSpec.MemHelpers.intptr_seq 0 n) eqn:SEQ; cbn in *; try contradiction.
    destruct SEQ_OOM; subst.

    destruct CONSEC as [sab [addrs CONSEC]].

    pose proof (fin_inf_intptr_seq _ _ _ SEQ).
    destruct H as [lb [SEQ_BIG ALL]].
    exists ms_y. exists lb.
    split.
    { rewrite SEQ_BIG.
      cbn; auto.
    }

    destruct CONSEC as [GEN_ADDRS SEQ_ADDRS].
    destruct (map_monad
                (fun ix : LLVMParams64BitIntptr.IP.intptr =>
                   inr
                     (LLVMParams64BitIntptr.ITOP.int_to_ptr
                        (LLVMParams64BitIntptr.PTOI.ptr_to_int a +
                           Z.of_N (LLVMParams64BitIntptr.SIZEOF.sizeof_dtyp (DTYPE_I 8)) *
                             LLVMParams64BitIntptr.IP.to_Z ix)
                        (LLVMParams64BitIntptr.PROV.address_provenance a))) l) eqn:HMAPM; cbn in *; try contradiction.

    destruct GEN_ADDRS; subst.

    destruct (@map_monad err (EitherMonad.Monad_either string) LLVMParamsBigIntptr.IP.intptr
                (OOM LLVMParamsBigIntptr.ADDR.addr)
                (fun ix : LLVMParamsBigIntptr.IP.intptr =>
                   @inr string (OOM LLVMParamsBigIntptr.ADDR.addr)
                     (@NoOom (Z * Prov)
                        ((LLVMParamsBigIntptr.PTOI.ptr_to_int a' +
                            Z.of_N (LLVMParamsBigIntptr.SIZEOF.sizeof_dtyp (DTYPE_I 8)) *
                              LLVMParamsBigIntptr.IP.to_Z ix)%Z, LLVMParamsBigIntptr.PROV.address_provenance a')))
                lb) eqn:HMAPM'.
    { (* Should be a contradiction *)
      apply map_monad_err_fail in HMAPM'.
      destruct HMAPM' as [a'' [IN CONTRA]].
      inv CONTRA.
    }

    exists ms_y. exists l1.
    split.
    {
      red.
      (* I have no clue why this rewrite won't work *)
      (* rewrite HMAPM'. *)
      break_match_goal.
      { apply map_monad_err_fail in Heqs.
        destruct Heqs as [a'' [IN CONTRA]].
        inv CONTRA.
      }
      setoid_rewrite HMAPM' in Heqs.
      inv Heqs.

      cbn.
      split; reflexivity.
    }

    red.
    break_match_goal.
    2: {
      (* TODO: There's probably a nice lemma in here *)
      cbn.
      apply map_monad_OOM_fail in Heqo.
      destruct Heqo as [x [INx OOMx]].
      unfold id in OOMx.
      inv OOMx.

      apply map_monad_err_Forall2 in HMAPM'.
      apply Util.Forall2_forall in HMAPM' as [LEN HMAPM'].
      apply In_Nth in INx. destruct INx as [i NTHl1].

      epose proof (Nth_exists lb i) as NTHlb.
      forward NTHlb.
      { apply Nth_ix_lt_length in NTHl1.
        lia.
      }
      destruct NTHlb as (?&NTHlb).
      specialize (HMAPM' _ _ _ NTHlb NTHl1).
      inv HMAPM'.
    }

    cbn.

    split; auto.

    { (* Might follow from ADDRS? *)
      red in SEQ_ADDRS.
      break_match_hyp; cbn in *; try contradiction.
      inv SEQ_ADDRS.
      rename l3 into xs.
      rename l0 into oxs.
      rename l into ixs.
      rename lb into ixs_big.
      rename l1 into oys.
      rename l2 into ys'.

      (* Each y in ys should match up with a y in ys'... I.e.,

                                     forall i y y', Util.Nth ys i y -> Util.Nth ys' i y' -> y = y'

                                     Why?

                                     HMAPM' / Heqo should yield: y' = a' + i
                                     ADDRS should suggest that y = xs[i]
                                     HMAPM / Heqo0 yields xs[i] = a + i

       *)

      assert (forall i y y', Util.Nth ys i y -> Util.Nth ys' i y' -> y = y') as NTHysys'.
      {
        intros i y y' H H0.

        (* Figure out what y' is *)
        pose proof (map_monad_OOM_Nth _ _ _ y' i Heqo H0) as [y'' [Y NTHoys]].
        unfold id in Y. cbn in Y. inv Y. clear H1.
        pose proof (map_monad_err_Nth _ _ _ _ i HMAPM' NTHoys) as [y'' [Y NTHixs_big]].
        inv Y.

        (* Figure out what y is *)
        pose proof (Util.Forall2_Nth_right H ADDRS) as [x [NTHxs CONVxy]].
        pose proof (map_monad_OOM_Nth _ _ _ x i Heqo0 NTHxs) as [x'' [X NTHoxs]].
        unfold id in X. cbn in X. inv X. clear H1.
        pose proof (map_monad_err_Nth _ _ _ _ i HMAPM NTHoxs) as [x'' [X NTHixs]].
        inv X.

        eapply InfToFinAddrConvert.addr_convert_injective; eauto.
        unfold InfToFinAddrConvert.addr_convert.

        assert (LLVMParams64BitIntptr.IP.to_Z x'' = LLVMParamsBigIntptr.IP.to_Z y'') as X''Y''.
        {
          eapply fin_inf_from_Z_to_Z.
          - apply (MemoryBigIntptr.MMEP.MemSpec.MemHelpers.intptr_seq_nth 0 n _ i y'' SEQ_BIG NTHixs_big).
          - apply (Memory64BitIntptr.MMEP.MemSpec.MemHelpers.intptr_seq_nth 0 n _ i x'' SEQ NTHixs).
        }
        rewrite <- X''Y''.

        rewrite LLVMParamsBigIntptr.SIZEOF.sizeof_dtyp_i8.
        rewrite LLVMParams64BitIntptr.SIZEOF.sizeof_dtyp_i8 in H2.

        pose proof ADDRS.
        inversion H1; subst.
        { apply Util.not_Nth_nil in NTHxs.
          contradiction.
        }

        rename l into xs.
        rename l' into ys.

        (* x0 and y0 should correspond to a and a' *)
        assert (x0 = a).
        {
          eapply map_monad_OOM_Nth with (n:=0%nat) in Heqo0; cbn; eauto.
          destruct Heqo0 as (x0'&X0&NTHx0).
          unfold id in X0. subst.
          eapply map_monad_err_Nth with (n:=0%nat) in HMAPM; cbn; eauto.
          destruct HMAPM as (x0''&X0&NTHx0').
          cbn in *.
          inv X0.

          destruct ixs; inv NTHx0'.
          destruct n; inv SEQ.
          cbn in *.
          rewrite IP64Bit.from_Z_0 in H7.
          break_match_hyp; inv H7.
          rewrite IP64Bit.to_Z_0 in H6.
          replace (LLVMParams64BitIntptr.PTOI.ptr_to_int a +
                     Z.of_N (LLVMParams64BitIntptr.SIZEOF.sizeof_dtyp (DTYPE_I 8)) * 0)%Z with (LLVMParams64BitIntptr.PTOI.ptr_to_int a) in H6 by lia.

          pose proof LLVMParams64BitIntptr.ITOP.int_to_ptr_ptr_to_int a (LLVMParams64BitIntptr.PROV.address_provenance a) eq_refl.
          rewrite H6 in H5.
          inv H5.
          reflexivity.
        }
        subst.

        assert (y0 = a').
        { eapply InfToFinAddrConvert.addr_convert_injective.
          eapply H3.
          eauto.
        }
        subst.

        rewrite <- H2.
        destruct a' as (ptr', pr').
        erewrite fin_inf_ptoi; eauto.
        erewrite FinLP.ITOP.int_to_ptr_provenance; eauto.
      }

      eapply Nth_eq; eauto.
      (* Length:

                                     ys = xs = oxs = ixs = n
                                     ys' = oys = ixs_big = n
       *)

      apply Util.Forall2_length in ADDRS, ALL.
      apply map_monad_err_length in HMAPM, HMAPM'.
      apply map_monad_oom_length in Heqo, Heqo0.
      congruence.
    }
  Qed.

  Lemma inf_fin_addr_convert_provenance :
    forall a_inf a_fin,
      InfToFinAddrConvert.addr_convert a_inf = NoOom a_fin ->
      LLVMParamsBigIntptr.PROV.address_provenance a_inf = LLVMParams64BitIntptr.PROV.address_provenance a_fin.
  Proof.
    intros a_inf a_fin ADDR_CONV.
    destruct a_inf, a_fin.
    cbn in *.
    apply ITOP.int_to_ptr_provenance in ADDR_CONV.
    cbn in *.
    auto.
  Qed.

  (* TODO: Move this? *)
  (* Should figure out if there's a cleaner way to do this with typeclasses... *)
  Lemma withinify :
    forall {MemState X} (m : MemPropT MemState X) s res,
      m s res ->
      exists (pre : MemState) (post : MemState),
        @Within.within (MemPropT MemState) (@MemPropT_Eq1 MemState) err_ub_oom MemState MemState _ _ m pre (fmap snd res) post.
  Proof.
    intros MemState X m s res M.
    exists s.
    destruct_err_ub_oom res.
    - exists s.
      cbn; repeat red; cbn.
      auto.
    - exists s.
      cbn; repeat red; cbn.
      auto.
    - exists s.
      cbn; repeat red; cbn.
      auto.
    - destruct res0 as (s' & res').
      exists s'.
      cbn; repeat red; cbn.
      auto.
  Qed.

  (* TODO: Move this, kind of shocked this doesn't exist somewhere? *)
  Lemma fmap_ret :
    forall {M} `{HM: Monad M} `{EQM : Monad.Eq1 M} `{MLAWS : @Monad.MonadLawsE M EQM HM} {X Y} (f : X -> Y) x,
      Monad.eq1 (@fmap M _ X Y f (@ret M HM X x)) (@ret M HM Y (f x)).
  Proof.
    intros M HM EQM MLAWS X Y f x.
    unfold fmap.
    cbn.
    unfold liftM.
    pose proof Monad.bind_ret_l _ _ (fun x => (ret (f x))) x.
    cbn in H.
    auto.
  Qed.

  Lemma fin_inf_get_consecutive_ptrs_success_exists' :
    forall a_fin a_inf n ms_fin ms_fin' addrs_fin ms_inf,
      (* TODO: ADDR probably not necessary, can conclude this from ADDRS...
       *)
      InfToFinAddrConvert.addr_convert a_inf = NoOom a_fin ->
      (@Memory64BitIntptr.MMEP.MemSpec.MemHelpers.get_consecutive_ptrs
         (MemPropT Memory64BitIntptr.MMEP.MMSP.MemState)
         (@MemPropT_Monad Memory64BitIntptr.MMEP.MMSP.MemState)
         (@MemPropT_RAISE_OOM Memory64BitIntptr.MMEP.MMSP.MemState)
         (@MemPropT_RAISE_ERROR Memory64BitIntptr.MMEP.MMSP.MemState) a_fin n ms_fin (success_unERR_UB_OOM (ms_fin', addrs_fin))) ->
      exists addrs_inf,
        (@MemoryBigIntptr.MMEP.MemSpec.MemHelpers.get_consecutive_ptrs
           (MemPropT MemoryBigIntptr.MMEP.MMSP.MemState)
           (@MemPropT_Monad MemoryBigIntptr.MMEP.MMSP.MemState)
           (@MemPropT_RAISE_OOM MemoryBigIntptr.MMEP.MMSP.MemState)
           (@MemPropT_RAISE_ERROR MemoryBigIntptr.MMEP.MMSP.MemState) a_inf n ms_inf (success_unERR_UB_OOM (ms_inf, addrs_inf))) /\
          Forall2 (fun x y => InfToFinAddrConvert.addr_convert y = NoOom x) addrs_fin addrs_inf.
  Proof.
    intros a_fin a_inf n ms_fin ms_fin' addrs_fin ms_inf ADDR_CONV GCP.
    pose proof fin_inf_get_consecutive_ptrs_success a_fin a_inf n ms_fin ms_fin' addrs_fin ms_inf.
    pose proof MemoryBigIntptrInfiniteSpec.MSIH.big_intptr_seq_succeeds 0 n as (ips & SEQ_INF).
    pose proof
      map_monad_err_succeeds
      (fun ix : LLVMParamsBigIntptr.IP.intptr =>
         @inr string (OOM LLVMParamsBigIntptr.ADDR.addr)
           (@NoOom (Z * Prov)
              ((LLVMParamsBigIntptr.PTOI.ptr_to_int a_inf +
                  Z.of_N (LLVMParamsBigIntptr.SIZEOF.sizeof_dtyp (DTYPE_I 8)) *
                    LLVMParamsBigIntptr.IP.to_Z ix)%Z, LLVMParamsBigIntptr.PROV.address_provenance a_inf)))
      ips as ADDRS_INF.
    forward ADDRS_INF.
    { intros a IN.
      eexists; reflexivity.
    }

    destruct ADDRS_INF as [oaddrs_inf ADDRS_INF].

    pose proof
      map_monad_oom_succeeds id oaddrs_inf as SEQ.
    forward SEQ.
    {
      intros a IN.
      epose proof map_monad_err_In _ _ _ _ ADDRS_INF IN as (y&A&INy).
      inv A.
      eexists.
      unfold id.
      reflexivity.
    }
    destruct SEQ as (RES&MAP_INF).

    cbn.
    eexists.
    split.
    { eexists.
      eexists.
      split.
      - red.
        rewrite SEQ_INF.
        cbn.
        split; auto.
      - eexists. eexists.
        split.
        + red.
          (* TODO: Why can't I rewrite with ADDRS_INF? *)
          break_match_goal;
            setoid_rewrite ADDRS_INF in Heqs;
            inv Heqs.
          cbn.
          split; auto.
        + red.
          unfold Monads.sequence.
          rewrite MAP_INF.
          cbn.
          split; reflexivity.
    }

    apply Util.Forall2_forall.
    split.
    - apply map_monad_oom_length in MAP_INF.
      apply map_monad_err_length in ADDRS_INF.

      (* Need something about get_consecutive_ptrs_length...

                             There is one: FinLLVM.MEM.MMEP.MemSpec.MemHelpers.get_consecutive_ptrs_length.

                             Need to refresh memory on Within, though.
       *)

      assert (n = Datatypes.length addrs_fin) as ADDRS_FIN_LEN.
      {
        assert (exists (pre : Memory64BitIntptr.MMEP.MMSP.MemState) (post : Memory64BitIntptr.MMEP.MMSP.MemState),
                   @Within.within (MemPropT Memory64BitIntptr.MMEP.MMSP.MemState) (@MemPropT_Eq1 Memory64BitIntptr.MMEP.MMSP.MemState) err_ub_oom Memory64BitIntptr.MMEP.MMSP.MemState Memory64BitIntptr.MMEP.MMSP.MemState _ _ (FinLLVM.MEM.MMEP.MemSpec.MemHelpers.get_consecutive_ptrs a_fin n) pre
                     (ret addrs_fin) post).
        { exists FinMemMMSP.initial_memory_state. exists FinMemMMSP.initial_memory_state.
          cbn.
          exists FinMemMMSP.initial_memory_state.

          red in GCP.
          destruct (Memory64BitIntptr.MMEP.MemSpec.MemHelpers.intptr_seq 0 n) eqn:SEQ_FIN; cbn in GCP.
          2: { destruct GCP as [sab [a [[] _]]]. }

          destruct GCP as [sab [a [[MS A] GCP]]]; subst.
          destruct GCP as [sab [a [GCP SEQ]]]; subst.
          destruct (map_monad
                      (fun ix : LLVMParams64BitIntptr.IP.intptr =>
                         inr
                           (LLVMParams64BitIntptr.ITOP.int_to_ptr
                              (LLVMParams64BitIntptr.PTOI.ptr_to_int a_fin +
                                 Z.of_N (LLVMParams64BitIntptr.SIZEOF.sizeof_dtyp (DTYPE_I 8)) *
                                   LLVMParams64BitIntptr.IP.to_Z ix)
                              (LLVMParams64BitIntptr.PROV.address_provenance a_fin))) l) eqn:HMAPM; cbn in GCP; try contradiction.
          destruct GCP; subst.
          red in SEQ.
          break_match_hyp; inv SEQ.

          eexists; split; cbn; eauto.
          exists FinMemMMSP.initial_memory_state.
          eexists; split; cbn; eauto.
          rewrite HMAPM.
          cbn; eauto.
          rewrite Heqo. cbn. auto.
        }

        pose proof FinLLVM.MEM.MMEP.MemSpec.MemHelpers.get_consecutive_ptrs_length _ _ _ H0; eauto.
      }

      apply MemoryBigIntptr.MMEP.MemSpec.MemHelpers.intptr_seq_len in SEQ_INF.
      congruence.
    - intros i a b NTHaddrs NTHres.
      pose proof (map_monad_OOM_Nth _ _ _ _ _ MAP_INF NTHres) as (y&Y&NTHoaddrs).
      unfold id in Y; subst.

      pose proof (map_monad_err_Nth _ _ _ _ _ ADDRS_INF NTHoaddrs) as (y&Y&NTHips).
      cbn in Y. inv Y.

      rename a into ptr_fin.

      (* Need to break apart GCP to find out about ptr_fin *)
      pose proof Memory64BitIntptr.MMEP.MemSpec.MemHelpers.get_consecutive_ptrs_nth_eq1 a_fin n addrs_fin.
      forward H0.
      {
        red. red.
        intros ms x.
        split.
        - intros GCP'.
          cbn.
          destruct_err_ub_oom x.
          + (* Contradiction *)
            cbn in GCP'.
            clear H0.
            cbn in GCP.
            move GCP after GCP'.
            destruct GCP as [ms' [a [SEQ GCP]]].
            red in SEQ.
            break_match_hyp; inv SEQ.

            destruct GCP'.
            cbn in H0; auto.

            destruct H0 as [sab [a [[MS LA] GCP']]].
            subst.

            destruct GCP as [ms' [a [GCP SEQ_FIN]]].
            red in GCP.
            break_match_hyp; inv GCP.
            rename Heqs into GCP.

            red in SEQ_FIN.
            break_match_hyp; inv SEQ_FIN.

            destruct GCP' as [GCP' | GCP'];
              cbn in *; auto.

            destruct GCP' as [sab [a [[MS LA] SEQ]]].
            subst.

            rewrite Heqo0 in SEQ.
            cbn in SEQ.
            auto.
          + (* Contradiction *)
            cbn in GCP'.
            clear H0.
            cbn in GCP.
            move GCP after GCP'.
            destruct GCP as [ms' [a [SEQ GCP]]].
            red in SEQ.
            break_match_hyp; inv SEQ.

            destruct GCP'.
            cbn in H0; auto.

            destruct H0 as [sab [a [[MS LA] GCP']]].
            subst.

            destruct GCP as [ms' [a [GCP SEQ_FIN]]].
            red in GCP.
            break_match_hyp; inv GCP.
            rename Heqs into GCP.

            red in SEQ_FIN.
            break_match_hyp; inv SEQ_FIN.

            destruct GCP' as [GCP' | GCP'];
              cbn in *; auto.

            destruct GCP' as [sab [a [[MS LA] SEQ]]].
            subst.

            rewrite Heqo0 in SEQ.
            cbn in SEQ.
            auto.
          + (* Contradiction *)
            cbn in GCP'.
            clear H0.
            cbn in GCP.
            move GCP after GCP'.
            destruct GCP as [ms' [a [SEQ GCP]]].
            red in SEQ.
            break_match_hyp; inv SEQ.

            destruct GCP'.
            cbn in H0; auto.

            destruct H0 as [sab [a [[MS LA] GCP']]].
            subst.

            destruct GCP as [ms' [a [GCP SEQ_FIN]]].
            red in GCP.
            break_match_hyp; inv GCP.
            rename Heqs into GCP.

            red in SEQ_FIN.
            break_match_hyp; inv SEQ_FIN.

            destruct GCP' as [GCP' | GCP'];
              cbn in *; auto.

            destruct GCP' as [sab [a [[MS LA] SEQ]]].
            subst.

            rewrite Heqo0 in SEQ.
            cbn in SEQ.
            auto.
          + destruct x0.
            inv Hx.
            (* Should be able to conclude this with a mix of GCP' and GCP *)
            cbn in *.
            destruct GCP' as [ms' [a [SEQ_FIN GCP']]].
            red in SEQ_FIN.
            break_match_hyp; inv SEQ_FIN.
            destruct GCP' as [sab [a [GCP' SEQ_FIN]]].

            red in SEQ_FIN.
            break_match_hyp; inv SEQ_FIN.

            red in GCP'.
            break_match_hyp; inv GCP'.
            split; auto.

            destruct GCP as [ms' [a [[MS L] GCP]]].
            subst.
            destruct GCP as [ms' [a [GCP SEQ]]].
            red in GCP.
            break_match_hyp; inv GCP.
            red in SEQ.
            break_match_hyp; inv SEQ.

            clear H0 H.
            inv Heqs.
            rewrite Heqo1 in Heqo0.
            inv Heqo0.
            reflexivity.
        - intros RET.
          cbn in RET.
          destruct_err_ub_oom x; try inv RET.
          destruct x0.
          destruct RET; subst.

          red in GCP.
          destruct (Memory64BitIntptr.MMEP.MemSpec.MemHelpers.intptr_seq 0 n) eqn:SEQ_FIN; cbn in GCP.
          2: { destruct GCP as [sab [a [[] _]]]. }
          destruct GCP as [sab [a [[MS A] GCP]]]; subst.
          destruct GCP as [sab [a [GCP SEQ]]]; subst.
          destruct (map_monad
                      (fun ix : LLVMParams64BitIntptr.IP.intptr =>
                         inr
                           (LLVMParams64BitIntptr.ITOP.int_to_ptr
                              (LLVMParams64BitIntptr.PTOI.ptr_to_int a_fin +
                                 Z.of_N (LLVMParams64BitIntptr.SIZEOF.sizeof_dtyp (DTYPE_I 8)) *
                                   LLVMParams64BitIntptr.IP.to_Z ix)
                              (LLVMParams64BitIntptr.PROV.address_provenance a_fin))) l) eqn:HMAPM; cbn in GCP; try contradiction.
          destruct GCP; subst.
          red in SEQ.
          break_match_hyp; inv SEQ.

          cbn.
          exists ms. exists l.
          split.
          rewrite SEQ_FIN; cbn; auto.

          exists ms. exists l0.
          rewrite HMAPM. cbn.
          split; auto.
          rewrite Heqo; cbn; auto.
      }

      specialize (H0 _ _ NTHaddrs).
      destruct H0 as [ip [IP GEP]].
      pose proof GEP as GEP'.
      apply FinLLVM.MEM.MP.GEP.handle_gep_addr_ix in GEP.

      assert (LLVMParamsBigIntptr.IP.to_Z y = Z.of_nat i) as IPI.
      { pose proof MemoryBigIntptr.MMEP.MemSpec.MemHelpers.intptr_seq_nth _ _ _ _ _ SEQ_INF NTHips.
        replace (0 + (Z.of_nat i))%Z with (Z.of_nat i) in H0 by lia.
        eapply FiniteIntptr.BigIP.from_Z_to_Z.
        apply H0.
      }
      rewrite IPI.

      symmetry in IP.
      eapply FinLP.IP.from_Z_to_Z in IP.
      rewrite IP in GEP.

      replace (LLVMParamsBigIntptr.PTOI.ptr_to_int a_inf +
                 Z.of_N (LLVMParamsBigIntptr.SIZEOF.sizeof_dtyp (DTYPE_I 8)) * Z.of_nat i)%Z with (PTOI.ptr_to_int ptr_fin).
      2: {
        rewrite GEP.
        erewrite fin_inf_ptoi; eauto.
      }

      pose proof GEP' as GEP''.
      apply Memory64BitIntptr.GEP.handle_gep_addr_preserves_provenance in GEP'.

      erewrite inf_fin_addr_convert_provenance; eauto.
      rewrite GEP'.

      cbn.
      apply ITOP.int_to_ptr_ptr_to_int.
      reflexivity.
  Qed.

  (* Form that better matches MemPropT_fin_inf_bind *)
  Lemma fin_inf_get_consecutive_ptrs_success_exists :
    forall a_fin a_inf n ms_fin ms_fin' addrs_fin ms_inf,
      (* TODO: ADDR probably not necessary, can conclude this from ADDRS...
       *)
      InfToFinAddrConvert.addr_convert a_inf = NoOom a_fin ->
      MemState_refine_prop ms_inf ms_fin ->
      (@Memory64BitIntptr.MMEP.MemSpec.MemHelpers.get_consecutive_ptrs
         (MemPropT Memory64BitIntptr.MMEP.MMSP.MemState)
         (@MemPropT_Monad Memory64BitIntptr.MMEP.MMSP.MemState)
         (@MemPropT_RAISE_OOM Memory64BitIntptr.MMEP.MMSP.MemState)
         (@MemPropT_RAISE_ERROR Memory64BitIntptr.MMEP.MMSP.MemState) a_fin n ms_fin (success_unERR_UB_OOM (ms_fin', addrs_fin))) ->
      exists addrs_inf ms_inf',
        (@MemoryBigIntptr.MMEP.MemSpec.MemHelpers.get_consecutive_ptrs
           (MemPropT MemoryBigIntptr.MMEP.MMSP.MemState)
           (@MemPropT_Monad MemoryBigIntptr.MMEP.MMSP.MemState)
           (@MemPropT_RAISE_OOM MemoryBigIntptr.MMEP.MMSP.MemState)
           (@MemPropT_RAISE_ERROR MemoryBigIntptr.MMEP.MMSP.MemState) a_inf n ms_inf (success_unERR_UB_OOM (ms_inf', addrs_inf))) /\
          Forall2 (fun x y => InfToFinAddrConvert.addr_convert y = NoOom x) addrs_fin addrs_inf /\
          MemState_refine_prop ms_inf' ms_fin'.
  Proof.
    intros a_fin a_inf n ms_fin ms_fin' addrs_fin ms_inf ADDR_CONV MSR GCP.

    pose proof fin_inf_get_consecutive_ptrs_success_exists' a_fin a_inf n ms_fin ms_fin' addrs_fin ms_inf ADDR_CONV GCP.
    destruct H as (addrs_inf & GCP' & ADDRS).
    exists addrs_inf. exists ms_inf.
    split; auto.
    split; auto.
    apply FinMem.MMEP.get_consecutive_ptrs_MemPropT_MemState_eq in GCP; subst; auto.
  Qed.

  (* TODO: Maybe change MemState_refine to be propositional in terms of find *)

  Lemma IntMap_find_NoOom_assoc_list :
    forall {X Y} (l : list (IntMaps.IM.key * X)) (f : (IntMaps.IM.key * X) -> OOM (IntMaps.IM.key * Y)) m_elts (n : Z) (y : Y),
      SetoidList.NoDupA (IntMaps.IM.eq_key (elt:=X)) l ->
      map_monad f l = NoOom m_elts ->
      (forall '(ix, x) '(ix', y), f (ix, x) = NoOom (ix', y) -> ix = ix') ->
      IntMaps.IM.find (elt:=Y) n (IntMaps.IP.of_list m_elts) = Some y ->
      exists x, SetoidList.findA (IntMaps.IP.F.eqb n) l = Some x /\ NoOom (n, y) = f (n, x).
  Proof.
    induction l; intros f m_elts n y NODUP HMAPM F FIND.
    - cbn in *.
      inv HMAPM.
      cbn in *.
      inv FIND.
    - cbn in *.
      break_match_hyp; [|inv HMAPM].
      break_match_hyp; [|inv HMAPM].
      inv HMAPM.
      destruct a as [a_k a_v].
      destruct p as [p_k p_v].
      pose proof (F (a_k, a_v) (p_k, p_v) Heqo); subst.
      Opaque IntMaps.IM.find.
      Opaque IntMaps.IM.add.
      cbn in *.
      break_match_goal.
      + (* New element *)
        exists a_v.
        split; auto.
        unfold IntMaps.IP.F.eqb in Heqb.
        break_match_hyp; subst; try discriminate.
        unfold IntMaps.IP.uncurry in FIND.
        rewrite IntMaps.IP.F.add_eq_o in FIND; cbn; auto.
        cbn in FIND.
        inv FIND.
        auto.
      + (* Old element *)
        inversion NODUP; subst.
        rename H1 into NIN.
        rename H2 into NODUP'.

        unfold IntMaps.IP.F.eqb in Heqb.
        break_match_hyp; subst; try discriminate.
        unfold IntMaps.IP.uncurry in FIND.
        rewrite IntMaps.IP.F.add_neq_o in FIND; cbn; auto.

        eauto.
  Qed.

  Lemma IntMap_find_NoOom_elements :
    forall {X Y} (m : IntMaps.IM.t X) (f : (IntMaps.IM.key * X) -> OOM (IntMaps.IM.key * Y)) m_elts (n : Z) (y : Y),
      map_monad f (IntMaps.IM.elements (elt:=X) m) = NoOom m_elts ->
      (forall '(ix, x) '(ix', y), f (ix, x) = NoOom (ix', y) -> ix = ix') ->
      IntMaps.IM.find (elt:=Y) n (IntMaps.IP.of_list m_elts) = Some y ->
      exists x, IntMaps.IM.find (elt:=X) n m = Some x /\ NoOom (n, y) = f (n, x).
  Proof.
    intros X Y m f m_elts n y HMAPM F FIND.
    pose proof IntMaps.IP.F.elements_o.
    setoid_rewrite H.
    eapply IntMap_find_NoOom_assoc_list.
    2: {
      exact HMAPM.
    }
    all: auto.
    apply IntMaps.IM.elements_3w.
  Qed.

  Lemma read_byte_raw_lifted :
    forall mem byte_lifted addr aid,
      InfMem.MMEP.MMSP.read_byte_raw (lift_memory mem) addr = Some (byte_lifted, aid) ->
      exists byte_fin : Memory64BitIntptr.MP.BYTE_IMPL.SByte,
        Memory64BitIntptr.MMEP.MMSP.read_byte_raw mem
          addr = Some (byte_fin, aid) /\
          is_true (in_bounds addr) /\
          sbyte_refine byte_lifted byte_fin.
  Proof.
    intros mem byte_lifted addr aid READ.
    Transparent Memory64BitIntptr.MMEP.MMSP.read_byte_raw.
    Transparent MemoryBigIntptr.MMEP.MMSP.read_byte_raw.
    unfold Memory64BitIntptr.MMEP.MMSP.read_byte_raw.
    unfold MemoryBigIntptr.MMEP.MMSP.read_byte_raw in READ.

    unfold lift_memory in READ.
    rewrite IntMaps.IP.F.map_o in READ.
    apply Util.option_map_some_inv in READ.
    destruct READ as [[byte_fin aid'] [FIND BYTE]].
    exists byte_fin.
    cbn in BYTE.
    inv BYTE.
    apply find_filter_dom_true in FIND as (FIND & IN_BOUNDS).
    split; auto.
    split; auto.
    apply sbyte_refine_lifted.

    Opaque Memory64BitIntptr.MMEP.MMSP.read_byte_raw.
    Opaque MemoryBigIntptr.MMEP.MMSP.read_byte_raw.
  Qed.

  Lemma read_byte_raw_lifted_fin_inf :
    forall mem byte_fin addr aid,
      is_true (in_bounds addr) ->
      Memory64BitIntptr.MMEP.MMSP.read_byte_raw mem addr = Some (byte_fin, aid) ->
      InfMem.MMEP.MMSP.read_byte_raw (lift_memory mem) addr = Some (lift_SByte byte_fin, aid).
  Proof.
    intros mem byte_lifted addr aid IN_BOUNDS READ.
    Transparent Memory64BitIntptr.MMEP.MMSP.read_byte_raw.
    Transparent MemoryBigIntptr.MMEP.MMSP.read_byte_raw.
    unfold Memory64BitIntptr.MMEP.MMSP.read_byte_raw in READ.
    unfold MemoryBigIntptr.MMEP.MMSP.read_byte_raw.

    pose proof find_filter_dom_true in_bounds mem addr (byte_lifted, aid) as [_ FILTER].
    forward FILTER; auto.

    unfold lift_memory.
    rewrite IntMaps.IP.F.map_o.
    rewrite FILTER.
    cbn.
    reflexivity.

    Opaque Memory64BitIntptr.MMEP.MMSP.read_byte_raw.
    Opaque MemoryBigIntptr.MMEP.MMSP.read_byte_raw.
  Qed.

  Lemma access_allowed_wildcard_prov :
    forall aid,
      LLVMParamsBigIntptr.PROV.access_allowed wildcard_prov aid = true.
  Proof.
    intros aid.
    unfold LLVMParamsBigIntptr.PROV.access_allowed.
    cbn; auto.
  Qed.

  Lemma read_byte_allowed_all_preserved_preserves_aids_wildcard:
    forall ms1 ms2 ptr byte1 byte2 aid,
      InfMem.MMEP.MemSpec.read_byte_allowed_all_preserved ms1 ms2 ->
      MemoryBigIntptr.MMEP.MMSP.read_byte_raw
        (MemoryBigIntptrInfiniteSpec.MMSP.mem_state_memory ms1)
        ptr = Some (byte1, None) ->
      MemoryBigIntptr.MMEP.MMSP.read_byte_raw
        (MemoryBigIntptrInfiniteSpec.MMSP.mem_state_memory ms2)
        ptr = Some (byte2, aid) ->
      aid = None.
  Proof.
    intros ms1 ms2 addr byte1 byte2 aid RBA R1 R2.
    unfold MemoryBigIntptrInfiniteSpec.MMSP.mem_state_memory in *.

    repeat red in RBA.
    destruct (InfPROV.aid_eq_dec aid None); auto.
    destruct aid; try contradiction.
    
    remember (addr, MemoryBigIntptrInfiniteSpec.LP.PROV.allocation_id_to_prov (Some (N.succ p))) as ptr.
    assert (InfMem.MMEP.MemSpec.read_byte_allowed ms1 ptr).
    { red.
      exists None.
      split; subst.
      repeat red.
      cbn.
      rewrite R1.
      symmetry.
      apply MemoryBigIntptrInfiniteSpec.LP.PROV.aid_eq_dec_refl.
      unfold LLVMParamsBigIntptr.PROV.access_allowed.
      cbn; auto.
    }

    apply RBA in H.
    repeat red in H.
    destruct H as (aid' & ALLOC & ALLOWED).
    repeat red in ALLOC.
    subst; cbn in *.
    rewrite R2 in ALLOC.

    destruct (LLVMParamsBigIntptr.PROV.aid_eq_dec aid' (Some p)); try discriminate; subst.
    rewrite Bool.orb_false_r in ALLOWED.
    eapply N.eqb_eq in ALLOWED.
    lia.
  Qed.

  Lemma read_byte_allowed_all_preserved_preserves_aids:
    forall ms1 ms2 ptr byte1 byte2 aid1 aid2,
      InfMem.MMEP.MemSpec.read_byte_allowed_all_preserved ms1 ms2 ->
      MemoryBigIntptr.MMEP.MMSP.read_byte_raw
        (MemoryBigIntptrInfiniteSpec.MMSP.mem_state_memory ms1)
        ptr = Some (byte1, aid1) ->
      MemoryBigIntptr.MMEP.MMSP.read_byte_raw
        (MemoryBigIntptrInfiniteSpec.MMSP.mem_state_memory ms2)
        ptr = Some (byte2, aid2) ->
      aid1 = aid2.
  Proof.
    intros ms1 ms2 addr byte1 byte2 aid1 aid2 RBA R1 R2.
    unfold MemoryBigIntptrInfiniteSpec.MMSP.mem_state_memory in *.

    destruct aid1.
    2: {
      symmetry.
      eapply read_byte_allowed_all_preserved_preserves_aids_wildcard; eauto.
    }

    destruct aid2.
    2: {
      symmetry in RBA.
      eapply read_byte_allowed_all_preserved_preserves_aids_wildcard; eauto.
    }

    remember (p + p0 + 1) as p1.
    assert (p1 <> p) as PNEQ by lia.
    assert (p1 <> p0) as PNEQ0 by lia.
    clear Heqp1.

    remember (addr, MemoryBigIntptrInfiniteSpec.LP.PROV.allocation_id_to_prov (Some p)) as ptr1.
    remember (addr, MemoryBigIntptrInfiniteSpec.LP.PROV.allocation_id_to_prov (Some p0)) as ptr2.

    assert (InfMem.MMEP.MemSpec.read_byte_allowed ms1 ptr1).
    { red.
      exists (Some p).
      split; subst.
      repeat red.
      cbn.
      rewrite R1.
      symmetry.
      apply MemoryBigIntptrInfiniteSpec.LP.PROV.aid_eq_dec_refl.
      apply MemoryBigIntptrInfiniteSpec.LP.PROV.access_allowed_refl.
    }

    apply RBA in H.
    repeat red in H.
    destruct H as (aid' & ALLOC & ALLOWED).
    repeat red in ALLOC.
    subst; cbn in *.
    rewrite R2 in ALLOC.

    destruct (LLVMParamsBigIntptr.PROV.aid_eq_dec aid' (Some p0)); try discriminate; subst.
    rewrite Bool.orb_false_r in ALLOWED.
    eapply N.eqb_eq in ALLOWED.
    subst; auto.
  Qed.

  Lemma fin_inf_read_byte_raw :
    forall {m_inf m_fin ptr byte_fin aid},
      MemState_refine_prop m_inf m_fin ->
      is_true (in_bounds ptr) ->
      Memory64BitIntptr.MMEP.MMSP.read_byte_raw
        (Memory64BitIntptr.MMEP.MMSP.mem_state_memory m_fin)
        ptr = Some (byte_fin, aid) ->
      MemoryBigIntptr.MMEP.MMSP.read_byte_raw
        (MemoryBigIntptrInfiniteSpec.MMSP.mem_state_memory m_inf)
        ptr = Some (lift_SByte byte_fin, aid).
  Proof.
    intros m_inf m_fin addr byte_fin aid MSR PTR_IN_BOUNDS READ_RAW.

    destruct MSR.
    destruct H0.
    clear H1 H.
    destruct H0 as [ALLOWED RBP].
    pose proof ALLOWED as ALLOWED'.
    unfold InfMem.MMEP.MemSpec.read_byte_prop_all_preserved in RBP.
    remember (addr, MemoryBigIntptrInfiniteSpec.LP.PROV.allocation_id_to_prov aid) as ptr_inf.
    specialize (RBP ptr_inf (lift_SByte byte_fin)).
    specialize (ALLOWED ptr_inf).

    assert (InfMem.MMEP.MemSpec.read_byte_prop (lift_MemState m_fin) ptr_inf (lift_SByte byte_fin)) as RBP_INF.
    {
      repeat red.
      unfold Memory64BitIntptr.MMEP.MMSP.mem_state_memory in *.
      subst.
      unfold LLVMParamsBigIntptr.PTOI.ptr_to_int, fst.
      destruct m_fin.
      destruct ms_memory_stack.
      cbn in READ_RAW; cbn.
      erewrite read_byte_raw_lifted_fin_inf; eauto.
      cbn.
      break_inner_match_goal; cbn; eauto.
      rewrite N.eqb_refl.
      cbn; auto.
    }

    pose proof RBP_INF as RBP_FIN.
    apply RBP in RBP_FIN.

    assert (InfMem.MMEP.MemSpec.read_byte_allowed (lift_MemState m_fin) ptr_inf) as ALLOWED_INF.
    {
      red.
      exists aid.
      split.
      - repeat red.
        subst; cbn.
        destruct m_fin, ms_memory_stack.
        cbn; cbn in READ_RAW.
        erewrite read_byte_raw_lifted_fin_inf; eauto.
        symmetry.
        apply MemoryBigIntptrInfiniteSpec.LP.PROV.aid_eq_dec_refl.
      - subst; cbn.
        apply MemoryBigIntptrInfiniteSpec.LP.PROV.access_allowed_refl.
    }

    pose proof ALLOWED_INF as ALLOWED_FIN.
    apply ALLOWED in ALLOWED_FIN.

    repeat red in RBP_FIN.
    break_match_hyp; try contradiction.

    unfold MemoryBigIntptrInfiniteSpec.MMSP.mem_state_memory in *.
    subst; cbn.
    setoid_rewrite Heqo.

    destruct m.
    cbn in *.
    break_match_hyp; try contradiction; subst.

    assert (a = aid).
    { eapply read_byte_allowed_all_preserved_preserves_aids; eauto.
      destruct m_fin, ms_memory_stack.
      cbn.
      eapply read_byte_raw_lifted_fin_inf; eauto.
    }
    subst; auto.
  Qed.

  (* TODO: Move this into lemmas about primitives *)
  Lemma fin_byte_allocated_read_byte_raw :
    forall ms ptr aid,
      Memory64BitIntptr.MMEP.MemSpec.byte_allocated ms ptr aid ->
      exists byte,
        Memory64BitIntptr.MMEP.MMSP.read_byte_raw
          (Memory64BitIntptr.MMEP.MMSP.memory_stack_memory
             (Memory64BitIntptr.MMEP.MMSP.MemState_get_memory ms))
          (LLVMParams64BitIntptr.PTOI.ptr_to_int ptr) = Some (byte, aid).
  Proof.
    intros ms ptr aid ALLOC.
    cbn in ALLOC.
    repeat red in ALLOC.
    break_match_hyp; try contradiction.
    destruct m.
    subst.
    exists s.
    destruct (LLVMParams64BitIntptr.PROV.aid_eq_dec aid a) eqn:AID;
      cbn in *; subst; try discriminate.
    auto.
  Qed.

  (* TODO: Move this into lemmas about primitives *)
  Lemma inf_byte_allocated_read_byte_raw :
    forall ms ptr aid,
      MemoryBigIntptr.MMEP.MemSpec.byte_allocated ms ptr aid ->
      exists byte,
        MemoryBigIntptr.MMEP.MMSP.read_byte_raw
          (MemoryBigIntptr.MMEP.MMSP.memory_stack_memory
             (MemoryBigIntptr.MMEP.MMSP.MemState_get_memory ms))
          (LLVMParamsBigIntptr.PTOI.ptr_to_int ptr) = Some (byte, aid).
  Proof.
    intros ms ptr aid ALLOC.
    repeat red in ALLOC.
    break_match_hyp; try contradiction.
    destruct m.
    exists s.
    destruct (LLVMParamsBigIntptr.PROV.aid_eq_dec aid a) eqn:AID;
      cbn in *; subst; try discriminate.
    auto.
  Qed.

  (* TODO: Some tricky IntMap reasoning *)
  Lemma fin_inf_read_byte_raw_None :
    forall m_inf m_fin ptr,
      MemState_refine_prop m_inf m_fin ->
      Memory64BitIntptr.MMEP.MMSP.read_byte_raw
        (Memory64BitIntptr.MMEP.MMSP.mem_state_memory m_fin)
        ptr = None ->
      MemoryBigIntptr.MMEP.MMSP.read_byte_raw
        (MemoryBigIntptr.MMEP.MMSP.mem_state_memory m_inf)
        ptr = None.
  Proof.
    intros m_inf m_fin addr MSR READ_RAW.

    destruct MSR.
    destruct H0.
    clear H1 H.
    destruct H0 as [ALLOWED RBP].
    unfold InfMem.MMEP.MemSpec.read_byte_prop_all_preserved in RBP.
    remember (addr, wildcard_prov) as ptr_inf.
    specialize (ALLOWED ptr_inf).

    assert (~ InfMem.MMEP.MemSpec.read_byte_allowed (lift_MemState m_fin) ptr_inf) as ALLOWED_INF.
    { intros CONTRA.
      red in CONTRA.
      destruct CONTRA as (aid&ALLOC&ACCESS).

      apply inf_byte_allocated_read_byte_raw in ALLOC.
      destruct ALLOC as (byte&READ).

      destruct m_fin.
      cbn in READ. destruct ms_memory_stack.
      cbn in READ, READ_RAW.
      apply read_byte_raw_lifted in READ.
      destruct READ as (?&?&?).
      subst; cbn in H.
      rewrite READ_RAW in H.
      inv H.
    }

    apply not_iff_compat in ALLOWED.
    apply ALLOWED in ALLOWED_INF.
    assert (forall byte, ~ MemoryBigIntptr.MMEP.MMSP.read_byte_raw (MemoryBigIntptr.MMEP.MMSP.mem_state_memory m_inf) addr = Some byte).
    { unfold InfMem.MMEP.MemSpec.read_byte_allowed in ALLOWED_INF.
      intros [byte aid] CONTRA.
      eapply ALLOWED_INF.
      exists aid.
      split.
      - (* TODO: Split into lemma *)
        repeat red.
        unfold Memory64BitIntptr.MMEP.MMSP.mem_state_memory in *.
        unfold MemoryBigIntptr.MMEP.MMSP.mem_state_memory in *.
        subst; cbn.
        rewrite CONTRA.
        symmetry.
        apply MemoryBigIntptrInfiniteSpec.LP.PROV.aid_eq_dec_refl.
      - subst; cbn; auto.
    }

    destruct (MemoryBigIntptr.MMEP.MMSP.read_byte_raw (MemoryBigIntptr.MMEP.MMSP.mem_state_memory m_inf) addr).
    specialize (H m); contradiction.
    auto.
  Qed.

  Lemma inf_fin_read_byte_raw_None :
    forall m_inf m_fin ptr,
      MemState_refine_prop m_inf m_fin ->
      is_true (in_bounds ptr) ->
      MemoryBigIntptr.MMEP.MMSP.read_byte_raw
        (MemoryBigIntptr.MMEP.MMSP.mem_state_memory m_inf)
        ptr = None ->
      Memory64BitIntptr.MMEP.MMSP.read_byte_raw
        (Memory64BitIntptr.MMEP.MMSP.mem_state_memory m_fin)
        ptr = None.
  Proof.
    intros m_inf m_fin addr MSR BOUNDS READ_RAW.

    destruct MSR.
    destruct H0.
    clear H1 H.
    destruct H0 as [ALLOWED RBP].
    unfold InfMem.MMEP.MemSpec.read_byte_prop_all_preserved in RBP.
    remember (addr, wildcard_prov) as ptr_inf.
    specialize (ALLOWED ptr_inf).

    assert (~ InfMem.MMEP.MemSpec.read_byte_allowed m_inf ptr_inf) as ALLOWED_INF.
    { intros CONTRA.
      red in CONTRA.
      destruct CONTRA as (aid&ALLOC&ACCESS).

      apply inf_byte_allocated_read_byte_raw in ALLOC.      
      destruct ALLOC as (byte&READ).
      unfold MemoryBigIntptr.MMEP.MMSP.mem_state_memory in *.
      subst; cbn in *.
      rewrite READ_RAW in READ.
      discriminate.
    }

    apply not_iff_compat in ALLOWED.
    apply ALLOWED in ALLOWED_INF.

    assert (forall byte, ~ Memory64BitIntptr.MMEP.MMSP.read_byte_raw (Memory64BitIntptr.MMEP.MMSP.mem_state_memory m_fin) addr = Some byte).
    { unfold InfMem.MMEP.MemSpec.read_byte_allowed in ALLOWED_INF.
      intros [byte aid] CONTRA.
      eapply ALLOWED_INF.
      exists aid.
      split.
      - (* TODO: Split into lemma *)
        repeat red.
        cbn; subst.
        destruct m_fin, ms_memory_stack; cbn in CONTRA.
        cbn.
        eapply read_byte_raw_lifted_fin_inf in CONTRA; eauto.
        rewrite CONTRA.
        symmetry; apply MemoryBigIntptrInfiniteSpec.LP.PROV.aid_eq_dec_refl.
      - subst; cbn; auto.
    }

    destruct (Memory64BitIntptr.MMEP.MMSP.read_byte_raw (Memory64BitIntptr.MMEP.MMSP.mem_state_memory m_fin) addr).
    specialize (H m); contradiction.
    auto.
  Qed.

  Opaque MemoryBigIntptrInfiniteSpec.LP.PROV.allocation_id_to_prov.
  Lemma inf_read_byte_preserved_read_byte_raw :
    forall ms1 ms2 addr,
      MemoryBigIntptr.MMEP.MemSpec.read_byte_preserved ms1 ms2 ->
      MemoryBigIntptr.MMEP.MMSP.read_byte_raw (InfMem.MMEP.MMSP.mem_state_memory ms1) addr =
        MemoryBigIntptr.MMEP.MMSP.read_byte_raw (InfMem.MMEP.MMSP.mem_state_memory ms2) addr.
  Proof.
    intros ms1 ms2 addr [RBP ALLOWED].
    destruct (MemoryBigIntptr.MMEP.MMSP.read_byte_raw (InfMem.MMEP.MMSP.mem_state_memory ms1) addr) eqn:READ.
    - destruct m.
      remember (addr, MemoryBigIntptrInfiniteSpec.LP.PROV.allocation_id_to_prov a) as ptr_inf.
      pose proof RBP as ALLOWED'.
      specialize (RBP ptr_inf).
      specialize (ALLOWED ptr_inf).

      specialize (ALLOWED s).
      destruct ALLOWED.

      forward H.
      { repeat red.
        unfold InfMem.MMEP.MMSP.mem_state_memory in READ.
        subst; cbn in *.
        rewrite READ.
        cbn.
        rewrite MemoryBigIntptrInfiniteSpec.LP.PROV.access_allowed_refl.
        auto.
      }
      clear H0.
      subst.

      destruct RBP.
      clear H1.
      forward H0.
      { repeat red.
        exists a.
        split; [|subst; cbn; apply MemoryBigIntptrInfiniteSpec.LP.PROV.access_allowed_refl].

        repeat red.
        unfold InfMem.MMEP.MMSP.mem_state_memory in READ.
        subst; cbn in *.
        rewrite READ.
        symmetry; apply MemoryBigIntptrInfiniteSpec.LP.PROV.aid_eq_dec_refl.
      }

      repeat red in H0.
      destruct H0 as (?&?&?).
      pose proof H0 as BYTE_ALLOCATED.
      apply inf_byte_allocated_read_byte_raw in H0 as (byte&MS2_READ).
      repeat red in H.
      unfold InfMem.MMEP.MMSP.mem_state_memory in *.
      cbn in *.

      rewrite MS2_READ.
      break_match_hyp; try contradiction.
      destruct m; cbn in *.
      inv MS2_READ.
      rewrite H1 in H; subst.
      assert (a = x).
      { eapply read_byte_allowed_all_preserved_preserves_aids; eauto.
      }
      subst; auto.
    - remember (addr, wildcard_prov) as ptr_inf.
      specialize (RBP ptr_inf).
      clear ALLOWED.

      assert (~ MemoryBigIntptr.MMEP.MemSpec.read_byte_allowed ms1 ptr_inf) as NO_READ.
      { intros CONTRA.
        repeat red in CONTRA.
        destruct CONTRA as (?&?&?).
        repeat red in H.
        unfold InfMem.MMEP.MMSP.mem_state_memory in *.
        subst; cbn in *; rewrite READ in H.
        auto.
      }

      apply not_iff_compat in RBP.
      apply RBP in NO_READ.
      assert (forall byte, ~ MemoryBigIntptr.MMEP.MMSP.read_byte_raw (MemoryBigIntptr.MMEP.MMSP.mem_state_memory ms2) addr = Some byte).
      { unfold InfMem.MMEP.MemSpec.read_byte_allowed in NO_READ.
        intros [byte aid] CONTRA.
        eapply NO_READ.
        exists aid.
        split.
        - (* TODO: Split into lemma *)
          repeat red.
          subst; cbn in *.
          unfold MemoryBigIntptr.MMEP.MMSP.mem_state_memory in *.
          rewrite CONTRA.
          symmetry; apply MemoryBigIntptrInfiniteSpec.LP.PROV.aid_eq_dec_refl.
        - subst; cbn; auto.
      }

      destruct (MemoryBigIntptr.MMEP.MMSP.read_byte_raw (MemoryBigIntptr.MMEP.MMSP.mem_state_memory ms2) addr).
      specialize (H m); contradiction.
      auto.
  Qed.

  #[global] Instance inf_read_byte_raw_MemState_eqv_Proper :
    Proper (MemoryBigIntptr.MMEP.MemSpec.MemState_eqv ==> eq ==> eq) (fun ms => MemoryBigIntptr.MMEP.MMSP.read_byte_raw (InfMem.MMEP.MMSP.mem_state_memory ms)).
  Proof.
    unfold Proper, respectful.
    intros x y H x0 y0 H0; subst.
    destruct H, H0.
    clear H H1.
    rename H0 into RBP.
    repeat red in RBP.
    apply inf_read_byte_preserved_read_byte_raw; auto.
  Qed.

  Lemma addr_allocated_fin_addr :
    forall {m_inf m_fin addr_inf aid},
      MemState_refine_prop m_inf m_fin ->
      MemoryBigIntptr.MMEP.MMSP.addr_allocated_prop_memory addr_inf aid (InfMem.MMEP.MMSP.MemState_get_memory m_inf) ->
      (forall pr, exists ptr, FinITOP.int_to_ptr (InfPTOI.ptr_to_int addr_inf) pr = NoOom ptr).
  Proof.
    intros m_inf m_fin addr_inf aid MSR ALLOC pr.
    repeat red in ALLOC.
    break_match_hyp; try contradiction.
    destruct m.

    rewrite MemoryBigIntptrInfiniteSpec.MMSP.memory_stack_memory_mem_state_memory in Heqo.
    unfold MemState_refine_prop in MSR.
    erewrite inf_read_byte_raw_MemState_eqv_Proper in Heqo; eauto.

    destruct m_fin, ms_memory_stack; cbn in Heqo.
    apply read_byte_raw_lifted in Heqo.
    destruct Heqo as (?&?&?&?).

    pose proof (in_bounds_exists_addr (LLVMParamsBigIntptr.PTOI.ptr_to_int addr_inf) pr).
    destruct H2.
    forward H2; auto.
    destruct H2 as (?&?&?).
    exists x0.

    destruct addr_inf, x0.
    cbn in *; subst.
    apply ITOP.int_to_ptr_ptr_to_int; cbn; auto.
  Qed.

  Lemma inf_fin_read_byte_raw :
    forall {m_inf m_fin addr byte_inf aid},
      MemState_refine_prop m_inf m_fin ->
      MemoryBigIntptr.MMEP.MMSP.read_byte_raw (MemoryBigIntptrInfiniteSpec.MMSP.mem_state_memory m_inf) addr = Some (byte_inf, aid) ->
      exists byte_fin,
        Memory64BitIntptr.MMEP.MMSP.read_byte_raw (Memory64BitIntptr.MMEP.MMSP.mem_state_memory m_fin) addr = Some (byte_fin, aid) /\
          is_true (in_bounds addr) /\
          sbyte_refine byte_inf byte_fin.
  Proof.
    intros m_inf m_fin addr byte_inf aid MSR READ_RAW.
    pose proof READ_RAW as READ_RAW'.
    erewrite inf_read_byte_raw_MemState_eqv_Proper in READ_RAW'; eauto.

    destruct m_fin, ms_memory_stack; cbn in READ_RAW'.
    eapply read_byte_raw_lifted in READ_RAW'.
    cbn; eauto.
  Qed.

  (* TODO: Maybe swap MemState for memory_stack to get rid of MemState_get_memory *)
  Lemma fin_inf_addr_allocated_prop :
    forall addr_fin addr_inf ms_fin ms_inf aid,
      MemState_refine_prop ms_inf ms_fin ->
      InfToFinAddrConvert.addr_convert addr_inf = NoOom addr_fin ->
      Memory64BitIntptr.MMEP.MMSP.addr_allocated_prop_memory addr_fin aid (FinMem.MMEP.MMSP.MemState_get_memory ms_fin) ->
      MemoryBigIntptr.MMEP.MMSP.addr_allocated_prop_memory addr_inf aid (InfMem.MMEP.MMSP.MemState_get_memory ms_inf).
  Proof.
    intros addr_fin addr_inf ms_fin ms_inf aid MSR ADDR_CONV ALLOCATED.
    repeat red.
    repeat red in ALLOCATED.
    break_match_hyp; try contradiction.
    destruct m.

    eapply fin_inf_read_byte_raw in Heqo; eauto.
    2: apply in_bounds_ptr_to_int_fin.

    erewrite fin_inf_ptoi in Heqo; eauto.
    unfold MemoryBigIntptrInfiniteSpec.MMSP.mem_state_memory in *.
    rewrite Heqo.

    destruct (LLVMParams64BitIntptr.PROV.aid_eq_dec aid a); cbn in *; try discriminate; subst.
    destruct (LLVMParamsBigIntptr.PROV.aid_eq_dec a a); cbn in *; try contradiction; auto.
  Qed.

  Lemma inf_fin_addr_allocated_prop :
    forall addr_fin addr_inf ms_fin ms_inf aid,
      MemState_refine_prop ms_inf ms_fin ->
      InfToFinAddrConvert.addr_convert addr_inf = NoOom addr_fin ->
      MemoryBigIntptr.MMEP.MMSP.addr_allocated_prop_memory addr_inf aid (InfMem.MMEP.MMSP.MemState_get_memory ms_inf) ->
      Memory64BitIntptr.MMEP.MMSP.addr_allocated_prop_memory addr_fin aid (FinMem.MMEP.MMSP.MemState_get_memory ms_fin).
  Proof.
    intros addr_fin addr_inf ms_fin ms_inf aid MSR ADDR_CONV ALLOCATED.
    repeat red; repeat red in ALLOCATED.
    cbn in *.

    break_match_hyp; try contradiction.
    destruct m.

    eapply inf_fin_read_byte_raw in Heqo; eauto.
    destruct Heqo as (?&?&?).
    unfold Memory64BitIntptr.MMEP.MMSP.mem_state_memory in *.
    subst; cbn in *.
    erewrite fin_inf_ptoi; eauto.
    rewrite H.

    destruct (LLVMParamsBigIntptr.PROV.aid_eq_dec aid a); cbn in *; try discriminate; subst.
    destruct (LLVMParams64BitIntptr.PROV.aid_eq_dec a a); cbn in *; try contradiction; auto.
  Qed.

  Lemma inf_fin_addr_allocated_prop_exists :
    forall {addr_inf ms_fin ms_inf aid},
      MemState_refine_prop ms_inf ms_fin ->
      MemoryBigIntptr.MMEP.MMSP.addr_allocated_prop_memory addr_inf aid
        (InfMem.MMEP.MMSP.MemState_get_memory ms_inf) ->
      exists addr_fin,
        InfToFinAddrConvert.addr_convert addr_inf = NoOom addr_fin /\
        Memory64BitIntptr.MMEP.MMSP.addr_allocated_prop_memory addr_fin aid
          (FinMem.MMEP.MMSP.MemState_get_memory ms_fin).
  Proof.
    intros addr_inf ms_fin ms_inf aid MSR ALLOCATED.
    repeat red in ALLOCATED.

    break_match_hyp; try contradiction.
    destruct m as [byte_inf aid'].
    epose proof inf_fin_read_byte_raw MSR Heqo as [byte_fin [READ_FIN [IN_BOUNDS BYTE_REF]]].

    destruct addr_inf.
    epose proof in_bounds_exists_addr _ p.
    pose proof IN_BOUNDS as FIN_ADDR.
    apply H in FIN_ADDR; clear H.
    destruct FIN_ADDR as (addr_fin & FIN_ADDR & FIN_PROV).

    exists addr_fin.
    split.
    { unfold InfToFinAddrConvert.addr_convert.
      cbn in *; subst.
      erewrite ITOP.int_to_ptr_ptr_to_int; eauto.
    }

    repeat red.
    unfold Memory64BitIntptr.MMEP.MMSP.mem_state_memory in *.
    rewrite FIN_ADDR. cbn in *.
    rewrite READ_FIN.
    destruct (LLVMParamsBigIntptr.PROV.aid_eq_dec aid aid'); inv ALLOCATED.
    symmetry; apply LLVMParams64BitIntptr.PROV.aid_eq_dec_refl.
  Qed.

  Lemma MemState_refine_convert_memory_stack :
    forall ms_inf ms_fin,
      MemState_refine ms_inf ms_fin ->
      convert_memory_stack (MemoryBigIntptr.MMEP.MMSP.MemState_get_memory ms_inf) = NoOom (Memory64BitIntptr.MMEP.MMSP.MemState_get_memory ms_fin).
  Proof.
    intros ms_inf ms_fin REF.
    destruct ms_inf; cbn in *.
    unfold MemState_refine in REF.
    cbn in *.
    break_match_hyp; inv REF.
    cbn.
    reflexivity.
  Qed.

  Lemma MemState_refine_convert_memory :
    forall ms_inf ms_fin,
      MemState_refine ms_inf ms_fin ->
      convert_memory (MemoryBigIntptr.MMEP.MMSP.mem_state_memory ms_inf) = NoOom (Memory64BitIntptr.MMEP.MMSP.mem_state_memory ms_fin).
  Proof.
    intros ms_inf ms_fin REF.
    destruct ms_inf; cbn in *.
    unfold MemState_refine in REF.
    cbn in *.
    break_match_hyp; inv REF.
    destruct ms_memory_stack; cbn in *.
    destruct memory_stack_memory; cbn in *.
    break_match_hyp; inv Heqo.
    break_match_hyp; inv H0.
    break_match_hyp; inv H1.
    cbn in *.
    reflexivity.
  Qed.

  Lemma MemState_refine_convert_memory' :
    forall ms_inf ms_fin,
      MemState_refine ms_inf ms_fin ->
      convert_memory (MemoryBigIntptr.MMEP.MMSP.memory_stack_memory
                        (MemoryBigIntptr.MMEP.MMSP.MemState_get_memory ms_inf)) = NoOom (Memory64BitIntptr.MMEP.MMSP.memory_stack_memory
                                                                                           (Memory64BitIntptr.MMEP.MMSP.MemState_get_memory ms_fin)).
  Proof.
    intros ms_inf ms_fin REF.
    destruct ms_inf; cbn in *.
    unfold MemState_refine in REF.
    cbn in *.
    break_match_hyp; inv REF.
    destruct ms_memory_stack; cbn in *.
    destruct memory_stack_memory; cbn in *.
    break_match_hyp; inv Heqo.
    break_match_hyp; inv H0.
    break_match_hyp; inv H1.
    cbn in *.
    reflexivity.
  Qed.

  Lemma fin_inf_byte_allocated :
    forall addr_fin addr_inf ms_fin ms_inf aid,
      MemState_refine_prop ms_inf ms_fin ->
      InfToFinAddrConvert.addr_convert addr_inf = NoOom addr_fin ->
      Memory64BitIntptr.MMEP.MemSpec.byte_allocated ms_fin addr_fin aid ->
      MemoryBigIntptr.MMEP.MemSpec.byte_allocated ms_inf addr_inf aid.
  Proof.
    intros addr_fin addr_inf ms_fin ms_inf aid MSR ADDR_CONV ALLOCATED.
    eapply fin_inf_addr_allocated_prop; eauto.
  Qed.

  Lemma fin_inf_byte_allocated_exists :
    forall addr_fin ms_fin ms_inf aid,
      MemState_refine_prop ms_inf ms_fin ->
      Memory64BitIntptr.MMEP.MemSpec.byte_allocated ms_fin addr_fin aid ->
      exists addr_inf,
        InfToFinAddrConvert.addr_convert addr_inf = NoOom addr_fin /\
          MemoryBigIntptr.MMEP.MemSpec.byte_allocated ms_inf addr_inf aid.
  Proof.
    intros addr_fin ms_fin ms_inf aid MSR ALLOCATED.
    pose proof addr_convert_fin_to_inf_addr addr_fin.
    exists (fin_to_inf_addr addr_fin).
    split; auto.
    eapply fin_inf_byte_allocated; eauto.
  Qed.

  Lemma inf_fin_byte_allocated :
    forall addr_fin addr_inf ms_fin ms_inf aid,
      MemState_refine_prop ms_inf ms_fin ->
      InfToFinAddrConvert.addr_convert addr_inf = NoOom addr_fin ->
      MemoryBigIntptr.MMEP.MemSpec.byte_allocated ms_inf addr_inf aid ->
      Memory64BitIntptr.MMEP.MemSpec.byte_allocated ms_fin addr_fin aid.
  Proof.
    intros addr_fin addr_inf ms_fin ms_inf aid MSR ADDR_CONV ALLOCATED.
    eapply inf_fin_addr_allocated_prop; eauto.
  Qed.

  Lemma inf_fin_byte_allocated_exists :
    forall addr_inf ms_fin ms_inf aid,
      MemState_refine_prop ms_inf ms_fin ->
      MemoryBigIntptr.MMEP.MemSpec.byte_allocated ms_inf addr_inf aid ->
      exists addr_fin,
        InfToFinAddrConvert.addr_convert addr_inf = NoOom addr_fin /\
        Memory64BitIntptr.MMEP.MemSpec.byte_allocated ms_fin addr_fin aid.
  Proof.
    intros addr_inf ms_fin ms_inf aid MSR ALLOCATED.
    epose proof addr_allocated_fin_addr MSR ALLOCATED (InfPROV.address_provenance addr_inf)
      as [ptr RAW_CONV].
    assert (InfToFinAddrConvert.addr_convert addr_inf = NoOom ptr) as CONV.
    {
      unfold InfToFinAddrConvert.addr_convert. destruct addr_inf. cbn in *. auto.
    }

    exists ptr.
    split; auto.
    eapply inf_fin_addr_allocated_prop; eauto.
  Qed.

  Lemma fin_inf_byte_not_allocated :
    forall addr_fin addr_inf ms_fin ms_inf,
      MemState_refine_prop ms_inf ms_fin ->
      InfToFinAddrConvert.addr_convert addr_inf = NoOom addr_fin ->
      Memory64BitIntptr.MMEP.MemSpec.byte_not_allocated ms_fin addr_fin ->
      MemoryBigIntptr.MMEP.MemSpec.byte_not_allocated ms_inf addr_inf.
  Proof.
    intros addr_fin addr_inf ms_fin ms_inf MSR ADDR_CONV NALLOCATED.
    red; red in NALLOCATED.
    intros aid ALLOCATED.
    eapply inf_fin_byte_allocated in ALLOCATED; eauto.
    eapply NALLOCATED; eauto.
  Qed.

  Lemma inf_fin_byte_not_allocated :
    forall addr_fin addr_inf ms_fin ms_inf,
      MemState_refine_prop ms_inf ms_fin ->
      InfToFinAddrConvert.addr_convert addr_inf = NoOom addr_fin ->
      MemoryBigIntptr.MMEP.MemSpec.byte_not_allocated ms_inf addr_inf ->
      Memory64BitIntptr.MMEP.MemSpec.byte_not_allocated ms_fin addr_fin.
  Proof.
    intros addr_fin addr_inf ms_fin ms_inf MSR ADDR_CONV NALLOCATED.
    red; red in NALLOCATED.
    intros aid ALLOCATED.
    eapply fin_inf_byte_allocated in ALLOCATED; eauto.
    eapply NALLOCATED; eauto.
  Qed.

  Lemma inf_fin_big_address_byte_not_allocated :
    forall {addr_inf ms_fin ms_inf msg},
      MemState_refine_prop ms_inf ms_fin ->
      InfToFinAddrConvert.addr_convert addr_inf = Oom msg ->
      MemoryBigIntptr.MMEP.MemSpec.byte_not_allocated ms_inf addr_inf.
  Proof.
    intros addr_inf ms_fin ms_inf msg MSR ADDR_CONV aid ALLOCATED.
    eapply inf_fin_byte_allocated_exists in ALLOCATED; eauto.
    destruct ALLOCATED as (?&?&?).
    rewrite ADDR_CONV in H.
    discriminate.
  Qed.

  Lemma fin_inf_access_allowed :
    forall addr_fin addr_inf aid res,
      InfToFinAddrConvert.addr_convert addr_inf = NoOom addr_fin ->
      LLVMParams64BitIntptr.PROV.access_allowed
        (LLVMParams64BitIntptr.PROV.address_provenance addr_fin) aid = res ->
      LLVMParamsBigIntptr.PROV.access_allowed (LLVMParamsBigIntptr.PROV.address_provenance addr_inf) aid = res.
  Proof.
    intros addr_fin addr_inf aid res ADDR_CONV ACCESS.
    destruct addr_inf.
    cbn in *.
    pose proof ITOP.int_to_ptr_provenance _ _ _ ADDR_CONV. subst.
    unfold LLVMParams64BitIntptr.PROV.access_allowed in *.
    unfold LLVMParamsBigIntptr.PROV.access_allowed in *.
    reflexivity.
  Qed.

  Lemma inf_fin_access_allowed :
    forall addr_fin addr_inf aid res,
      InfToFinAddrConvert.addr_convert addr_inf = NoOom addr_fin ->
      LLVMParamsBigIntptr.PROV.access_allowed
        (LLVMParamsBigIntptr.PROV.address_provenance addr_inf) aid = res ->
      LLVMParams64BitIntptr.PROV.access_allowed
        (LLVMParams64BitIntptr.PROV.address_provenance addr_fin) aid = res.
  Proof.
    intros addr_fin addr_inf aid res ADDR_CONV ACCESS.
    destruct addr_inf.
    cbn in *.
    pose proof ITOP.int_to_ptr_provenance _ _ _ ADDR_CONV. subst.
    unfold LLVMParams64BitIntptr.PROV.access_allowed in *.
    unfold LLVMParamsBigIntptr.PROV.access_allowed in *.
    reflexivity.
  Qed.

  Lemma fin_inf_read_byte_allowed :
    forall addr_fin addr_inf ms_fin ms_inf,
      MemState_refine_prop ms_inf ms_fin ->
      InfToFinAddrConvert.addr_convert addr_inf = NoOom addr_fin ->
      Memory64BitIntptr.MMEP.MemSpec.read_byte_allowed ms_fin addr_fin ->
      MemoryBigIntptr.MMEP.MemSpec.read_byte_allowed ms_inf addr_inf.
  Proof.
    intros addr_fin addr_inf ms_fin ms_inf MSR ADDR_CONV READ_ALLOWED.
    red. red in READ_ALLOWED.

    destruct READ_ALLOWED as [aid [BYTE_ALLOCATED ACCESS_ALLOWED]].
    exists aid.
    split.
    - eapply fin_inf_byte_allocated; eauto.
    - eapply fin_inf_access_allowed; eauto.
  Qed.

  Lemma inf_fin_read_byte_allowed :
    forall addr_fin addr_inf ms_fin ms_inf,
      MemState_refine_prop ms_inf ms_fin ->
      InfToFinAddrConvert.addr_convert addr_inf = NoOom addr_fin ->
      MemoryBigIntptr.MMEP.MemSpec.read_byte_allowed ms_inf addr_inf ->
      Memory64BitIntptr.MMEP.MemSpec.read_byte_allowed ms_fin addr_fin.
  Proof.
    intros addr_fin addr_inf ms_fin ms_inf MSR ADDR_CONV READ_ALLOWED.
    red. red in READ_ALLOWED.

    destruct READ_ALLOWED as [aid [BYTE_ALLOCATED ACCESS_ALLOWED]].
    exists aid.
    split.
    - eapply inf_fin_byte_allocated; eauto.
    - eapply inf_fin_access_allowed; eauto.
  Qed.

  Lemma fin_inf_write_byte_allowed :
    forall addr_fin addr_inf ms_fin ms_inf,
      MemState_refine_prop ms_inf ms_fin ->
      InfToFinAddrConvert.addr_convert addr_inf = NoOom addr_fin ->
      Memory64BitIntptr.MMEP.MemSpec.write_byte_allowed ms_fin addr_fin ->
      MemoryBigIntptr.MMEP.MemSpec.write_byte_allowed ms_inf addr_inf.
  Proof.
    intros addr_fin addr_inf ms_fin ms_inf MSR ADDR_CONV WRITE_ALLOWED.
    red. red in WRITE_ALLOWED.

    destruct WRITE_ALLOWED as [aid [BYTE_ALLOCATED ACCESS_ALLOWED]].
    exists aid.
    split.
    - eapply fin_inf_byte_allocated; eauto.
    - eapply fin_inf_access_allowed; eauto.
  Qed.

  Lemma inf_fin_write_byte_allowed :
    forall addr_fin addr_inf ms_fin ms_inf,
      MemState_refine_prop ms_inf ms_fin ->
      InfToFinAddrConvert.addr_convert addr_inf = NoOom addr_fin ->
      MemoryBigIntptr.MMEP.MemSpec.write_byte_allowed ms_inf addr_inf ->
      Memory64BitIntptr.MMEP.MemSpec.write_byte_allowed ms_fin addr_fin.
  Proof.
    intros addr_fin addr_inf ms_fin ms_inf MSR ADDR_CONV WRITE_ALLOWED.
    red. red in WRITE_ALLOWED.

    destruct WRITE_ALLOWED as [aid [BYTE_ALLOCATED ACCESS_ALLOWED]].
    exists aid.
    split.
    - eapply inf_fin_byte_allocated; eauto.
    - eapply inf_fin_access_allowed; eauto.
  Qed.

  Lemma inf_fin_write_byte_allowed_exists :
    forall addr_inf ms_fin ms_inf,
      MemState_refine_prop ms_inf ms_fin ->
      MemoryBigIntptr.MMEP.MemSpec.write_byte_allowed ms_inf addr_inf ->
      exists addr_fin,
        Memory64BitIntptr.MMEP.MemSpec.write_byte_allowed ms_fin addr_fin /\
          addr_refine addr_inf addr_fin.
  Proof.
    intros addr_inf ms_fin ms_inf MSR WRITE_ALLOWED.
    red in WRITE_ALLOWED.

    destruct WRITE_ALLOWED as [aid [BYTE_ALLOCATED ACCESS_ALLOWED]].

    eapply inf_fin_byte_allocated_exists in BYTE_ALLOCATED; eauto.
    destruct BYTE_ALLOCATED as (addr_fin & ADDR_REF & BYTE_ALLOCATED).
    exists addr_fin.
    split; eauto.
    red.
    exists aid.
    split; eauto.
    eapply inf_fin_access_allowed; eauto.
  Qed.

  Lemma fin_inf_free_byte_allowed :
    forall addr_fin addr_inf ms_fin ms_inf,
      MemState_refine_prop ms_inf ms_fin ->
      InfToFinAddrConvert.addr_convert addr_inf = NoOom addr_fin ->
      Memory64BitIntptr.MMEP.MemSpec.free_byte_allowed ms_fin addr_fin ->
      MemoryBigIntptr.MMEP.MemSpec.free_byte_allowed ms_inf addr_inf.
  Proof.
    intros addr_fin addr_inf ms_fin ms_inf MSR ADDR_CONV FREE_ALLOWED.
    red. red in FREE_ALLOWED.

    destruct FREE_ALLOWED as [aid [BYTE_ALLOCATED ACCESS_ALLOWED]].
    exists aid.
    split.
    - eapply fin_inf_byte_allocated; eauto.
    - eapply fin_inf_access_allowed; eauto.
  Qed.

  Lemma inf_fin_free_byte_allowed :
    forall addr_fin addr_inf ms_fin ms_inf,
      MemState_refine_prop ms_inf ms_fin ->
      InfToFinAddrConvert.addr_convert addr_inf = NoOom addr_fin ->
      MemoryBigIntptr.MMEP.MemSpec.free_byte_allowed ms_inf addr_inf ->
      Memory64BitIntptr.MMEP.MemSpec.free_byte_allowed ms_fin addr_fin.
  Proof.
    intros addr_fin addr_inf ms_fin ms_inf MSR ADDR_CONV FREE_ALLOWED.
    red. red in FREE_ALLOWED.

    destruct FREE_ALLOWED as [aid [BYTE_ALLOCATED ACCESS_ALLOWED]].
    exists aid.
    split.
    - eapply inf_fin_byte_allocated; eauto.
    - eapply inf_fin_access_allowed; eauto.
  Qed.

  Lemma inf_fin_free_byte_allowed_exists :
    forall addr_inf ms_fin ms_inf,
      MemState_refine_prop ms_inf ms_fin ->
      MemoryBigIntptr.MMEP.MemSpec.free_byte_allowed ms_inf addr_inf ->
      exists addr_fin,
        Memory64BitIntptr.MMEP.MemSpec.free_byte_allowed ms_fin addr_fin /\
          addr_refine addr_inf addr_fin.
  Proof.
    eapply inf_fin_write_byte_allowed_exists.
  Qed.

  Lemma fin_inf_read_byte_prop_memory :
    forall addr_fin addr_inf ms_fin ms_inf byte_inf byte_fin,
      MemState_refine_prop ms_inf ms_fin ->
      InfToFinAddrConvert.addr_convert addr_inf = NoOom addr_fin ->
      sbyte_refine byte_inf byte_fin ->
      Memory64BitIntptr.MMEP.MMSP.read_byte_prop_memory addr_fin
        (Memory64BitIntptr.MMEP.MMSP.MemState_get_memory ms_fin) byte_fin ->
      MemoryBigIntptr.MMEP.MMSP.read_byte_prop_memory addr_inf
        (MemoryBigIntptr.MMEP.MMSP.MemState_get_memory ms_inf) byte_inf.
  Proof.
    intros addr_fin addr_inf ms_fin ms_inf byte_inf byte_fin MSR ADDR_CONV BYTE_REF RBP.
    repeat red in RBP.
    repeat red.
    break_match_hyp; try contradiction.
    break_match_hyp; try contradiction.
    destruct m; cbn in *; subst.
    epose proof fin_inf_read_byte_raw MSR (in_bounds_ptr_to_int_fin addr_fin) Heqo.
    erewrite fin_inf_ptoi in H; eauto.
    unfold MemoryBigIntptrInfiniteSpec.MMSP.mem_state_memory in *.
    rewrite H.
    cbn.
    erewrite inf_fin_access_allowed in Heqb; eauto.
    rewrite Heqb.
    unfold sbyte_refine in BYTE_REF.
    apply lift_SByte_convert_SByte_inverse in BYTE_REF; eauto.
  Qed.

  Lemma inf_fin_read_byte_prop_memory :
    forall addr_fin addr_inf ms_fin ms_inf byte_inf byte_fin,
      MemState_refine_prop ms_inf ms_fin ->
      InfToFinAddrConvert.addr_convert addr_inf = NoOom addr_fin ->
      sbyte_refine byte_inf byte_fin ->
      MemoryBigIntptr.MMEP.MMSP.read_byte_prop_memory addr_inf
        (MemoryBigIntptr.MMEP.MMSP.MemState_get_memory ms_inf)
        byte_inf ->
      Memory64BitIntptr.MMEP.MMSP.read_byte_prop_memory addr_fin
        (Memory64BitIntptr.MMEP.MMSP.MemState_get_memory ms_fin)
        byte_fin.
  Proof.
    intros addr_fin addr_inf ms_fin ms_inf byte_inf byte_fin MSR ADDR_CONV BYTE_REF RBP.
    repeat red in RBP.
    repeat red.
    break_match_hyp; try contradiction.
    break_match_hyp; try contradiction.
    destruct m; cbn in *; subst.
    epose proof inf_fin_read_byte_raw MSR Heqo.
    destruct H as (?&?&?&?).
    unfold Memory64BitIntptr.MMEP.MMSP.mem_state_memory in *.
    erewrite fin_inf_ptoi; eauto.
    rewrite H.
    cbn.
    erewrite fin_inf_access_allowed in Heqb; eauto.
    rewrite Heqb.
    unfold sbyte_refine in *.
    rewrite BYTE_REF in H1.
    inv H1.
    reflexivity.
  Qed.

  (* Lemma inf_fin_read_byte_prop_MemPropT_exists : *)
  (*   forall addr_inf ms_fin ms_inf byte_inf, *)
  (*     MemState_refine ms_inf ms_fin -> *)
  (*     MemoryBigIntptr.MMEP.MMSP.read_byte_MemPropT addr_inf *)
  (*       (MemoryBigIntptr.MMEP.MMSP.MemState_get_memory ms_inf) *)
  (*       (ret (MemoryBigIntptr.MMEP.MMSP.MemState_get_memory ms_inf, byte_inf)) -> *)
  (*     exists addr_fin byte_fin, *)
  (*       Memory64BitIntptr.MMEP.MMSP.read_byte_MemPropT addr_fin *)
  (*         (Memory64BitIntptr.MMEP.MMSP.MemState_get_memory ms_fin) *)
  (*         (ret (Memory64BitIntptr.MMEP.MMSP.MemState_get_memory ms_fin, byte_fin)) /\ *)
  (*         InfToFinAddrConvert.addr_convert addr_inf = NoOom addr_fin /\ *)
  (*         sbyte_refine byte_inf byte_fin. *)
  (* Proof. *)
  (*   intros addr_inf ms_fin ms_inf byte_inf MSR RBP. *)
  (*   (* TODO: make things opaque? *) *)
  (*   destruct RBP as [ms_inf' [ms_inf'' [[MS MS'] READ]]]. *)
  (*   subst. *)
  (*   destruct ms_inf eqn:MSINF. cbn in READ. *)
  (*   destruct ms_fin eqn:MSFIN. *)

  (*   break_match_hyp. *)
  (*   (* read_byte_MemPropT may have UB... Which *)
  (*                          means sbyte_refine byte_inf byte_fin might not *)
  (*                          hold because byte_fin could be any byte. *)
  (*    *) *)
  (*   - destruct m. *)
  (*     pose proof MemState_refine_convert_memory _ _ MSR as CONV_MEM. *)
  (*     pose proof inf_fin_read_byte_raw_exists CONV_MEM Heqo. *)
  (*     destruct H as [ptr_fin [byte_fin' [PTOI [H BYTE_REF]]]]. *)

  (*     unfold Memory64BitIntptr.MMEP.MMSP.mem_state_memory in H. *)
  (*     cbn in H. *)

  (*     cbn. *)
  (*     destruct addr_inf as [ptr_inf pr_inf]. *)
  (*     exfalso. *)
  (*     pose proof ITOP.int_to_ptr_ptr_to_int. *)
  (*     eapply H0. *)
  (*     cbn in *. *)
  (*     exists ( *)
  (*     exists ptr_fin. exists byte_fin'. *)
  (*     split; eauto. *)
  (*     2: { *)
  (*       split. *)
  (*       -  *)
  (*         cbn in *. *)
  (*         rewrite <- PTOI. *)
  (*     } *)
  (*     rewrite <- PTOI in H. *)
  (*     eexists. eexists. *)
  (*     split; auto. *)
  (*     rewrite H. *)
  (*     erewrite inf_fin_access_allowed; cbn; eauto. *)
  (*     break_match_goal; cbn; eauto. *)

  (*     break_match_hyp. *)
  (*     destruct READ; subst; auto. *)
  (*     unfold InfToFinAddrConvert.addr_convert; cbn. *)
  (*     unfold InfToFinAddrConvert.addr_convert; cbn. *)


  (*     red in BYTE_REF. *)
  (*     Set Nested Proofs Allowed. *)
  (*     (* TODO: Move this *) *)
  (*     Lemma lift_SByte_convert_SByte_inverse : *)
  (*       forall {b1 b2}, *)
  (*         convert_SByte b1 = NoOom b2 -> *)
  (*         lift_SByte b2 = b1. *)
  (*     Proof. *)
  (*     Admitted. *)

  (*     Lemma fin_to_inf_uvalue_injective : *)
  (*       forall uv1 uv2, *)
  (*         fin_to_inf_uvalue uv1 = fin_to_inf_uvalue uv2 -> *)
  (*         uv1 = uv2. *)
  (*     Proof. *)
  (*       intros uv1 uv2 FININF. *)
  (*       unfold fin_to_inf_uvalue in *. *)
  (*       destruct (uvalue_convert_strict_safe uv1) as (?&?&?). *)
  (*       destruct (uvalue_convert_strict_safe uv2) as (?&?&?). *)
  (*       subst. *)
  (*       rewrite e0 in e2. inv e2. *)
  (*       auto. *)
  (*     Qed. *)


  (*     apply lift_SByte_convert_SByte_inverse in BYTE_REF. *)
  (*     rewrite <- H1 in BYTE_REF. *)
  (*     apply lift_SByte_injective in BYTE_REF; subst; auto. *)

  (*     cbn in Heqb0. *)
  (*     rewrite Heqb0 in Heqb. *)
  (*     discriminate. *)
  (*   - epose proof inf_fin_read_byte_raw_None _ _ _ _ Heqo. *)
  (*     cbn. *)
  (*     eexists. eexists. *)
  (*     split; eauto. *)
  (*     erewrite fin_inf_ptoi; eauto. *)
  (*     rewrite H. *)
  (*     auto. *)

  (*     Unshelve. *)
  (*     all: clear READ. *)
  (*     + replace (Memory64BitIntptr.MMEP.MMSP.memory_stack_memory ms_memory_stack0) with (Memory64BitIntptr.MMEP.MMSP.memory_stack_memory *)
  (*                                                                                         (Memory64BitIntptr.MMEP.MMSP.MemState_get_memory ms_fin)). *)
  (*       replace (MemoryBigIntptr.MMEP.MMSP.memory_stack_memory ms_memory_stack) with (MemoryBigIntptr.MMEP.MMSP.memory_stack_memory *)
  (*                                                                                        (MemoryBigIntptr.MMEP.MMSP.MemState_get_memory ms_inf)). *)
  (*       eapply MemState_refine_convert_memory'; subst; eauto. *)
  (*       subst; cbn. auto. *)
  (*       subst; cbn. auto. *)
  (* Qed. *)

  Lemma fin_inf_read_byte_prop :
    forall {addr_fin addr_inf ms_fin ms_inf byte_inf byte_fin},
      MemState_refine_prop ms_inf ms_fin ->
      InfToFinAddrConvert.addr_convert addr_inf = NoOom addr_fin ->
      sbyte_refine byte_inf byte_fin ->
      Memory64BitIntptr.MMEP.MemSpec.read_byte_prop ms_fin addr_fin byte_fin ->
      MemoryBigIntptr.MMEP.MemSpec.read_byte_prop ms_inf addr_inf byte_inf.
  Proof.
    intros addr_fin addr_inf ms_fin ms_inf byte_inf byte_fin MSR ADDR_CONV BYTE_REF RBP.
    red. red in RBP.
    eapply fin_inf_read_byte_prop_memory; eauto.
  Qed.

  Lemma inf_fin_read_byte_prop :
    forall {addr_fin addr_inf ms_fin ms_inf byte_inf byte_fin},
      MemState_refine_prop ms_inf ms_fin ->
      InfToFinAddrConvert.addr_convert addr_inf = NoOom addr_fin ->
      sbyte_refine byte_inf byte_fin ->
      MemoryBigIntptr.MMEP.MemSpec.read_byte_prop ms_inf addr_inf byte_inf ->
      Memory64BitIntptr.MMEP.MemSpec.read_byte_prop ms_fin addr_fin byte_fin.
  Proof.
    intros addr_fin addr_inf ms_fin ms_inf byte_fin MSR ADDR_CONV BYTE_REF RBP.
    red. red in RBP.
    eapply inf_fin_read_byte_prop_memory; eauto.
  Qed.

  Lemma fin_inf_read_byte_spec :
    forall {addr_fin addr_inf ms_fin ms_inf byte_inf byte_fin},
      MemState_refine_prop ms_inf ms_fin ->
      InfToFinAddrConvert.addr_convert addr_inf = NoOom addr_fin ->
      sbyte_refine byte_inf byte_fin ->
      Memory64BitIntptr.MMEP.MemSpec.read_byte_spec ms_fin addr_fin byte_fin ->
      MemoryBigIntptr.MMEP.MemSpec.read_byte_spec ms_inf addr_inf byte_inf.
  Proof.
    intros addr_fin addr_inf ms_fin ms_inf byte_inf byte_fin MSR ADDR_CONV BYTE_REF READ_SPEC.
    destruct READ_SPEC.
    split.
    - eapply fin_inf_read_byte_allowed; eauto.
    - eapply fin_inf_read_byte_prop; eauto.
  Qed.

  Lemma fin_inf_read_byte_spec_exists :
    forall {addr_fin ms_fin ms_inf byte_fin},
      MemState_refine_prop ms_inf ms_fin ->
      Memory64BitIntptr.MMEP.MemSpec.read_byte_spec ms_fin addr_fin byte_fin ->
      exists addr_inf byte_inf,
        MemoryBigIntptr.MMEP.MemSpec.read_byte_spec ms_inf addr_inf byte_inf /\
          addr_refine addr_inf addr_fin /\
          sbyte_refine byte_inf byte_fin.
  Proof.
    intros addr_fin ms_fin ms_inf byte_fin MSR READ_SPEC.
    destruct READ_SPEC.
    exists (fin_to_inf_addr addr_fin).
    exists (lift_SByte byte_fin).

    pose proof (addr_convert_fin_to_inf_addr addr_fin).
    pose proof (sbyte_refine_lifted byte_fin).

    split; auto.

    split.
    - eapply fin_inf_read_byte_allowed; eauto.
    - eapply fin_inf_read_byte_prop; eauto.
  Qed.

  Lemma fin_inf_read_byte_spec_MemPropT' :
    forall addr_fin addr_inf ms_fin ms_inf byte_inf byte_fin,
      MemState_refine_prop ms_inf ms_fin ->
      InfToFinAddrConvert.addr_convert addr_inf = NoOom addr_fin ->
      sbyte_refine byte_inf byte_fin ->
      Memory64BitIntptr.MMEP.MemSpec.read_byte_spec_MemPropT addr_fin ms_fin (success_unERR_UB_OOM (ms_fin, byte_fin)) ->
      MemoryBigIntptr.MMEP.MemSpec.read_byte_spec_MemPropT addr_inf ms_inf (success_unERR_UB_OOM (ms_inf, byte_inf)).
  Proof.
    intros addr_fin addr_inf ms_fin ms_inf byte_inf byte_fin MSR ADDR_CONV BYTE_REF READ_SPEC.
    red. cbn.
    split; auto.
    red in READ_SPEC. cbn in READ_SPEC.
    destruct READ_SPEC.
    eapply fin_inf_read_byte_spec; eauto.
  Qed.

  (* Better form for MemPropT_fin_inf_bind *)
  Lemma fin_inf_read_byte_spec_MemPropT :
    forall {addr_fin addr_inf ms_fin ms_fin' ms_inf byte_fin},
      MemState_refine_prop ms_inf ms_fin ->
      InfToFinAddrConvert.addr_convert addr_inf = NoOom addr_fin ->
      Memory64BitIntptr.MMEP.MemSpec.read_byte_spec_MemPropT addr_fin ms_fin (success_unERR_UB_OOM (ms_fin', byte_fin)) ->
      exists byte_inf ms_inf',
        MemoryBigIntptr.MMEP.MemSpec.read_byte_spec_MemPropT addr_inf ms_inf (success_unERR_UB_OOM (ms_inf', byte_inf)) /\
          sbyte_refine byte_inf byte_fin /\
          MemState_refine_prop ms_inf' ms_fin'.
  Proof.
    intros addr_fin addr_inf ms_fin ms_fin' ms_inf byte_fin MSR ADDR_CONV READ_SPEC.

    repeat red in READ_SPEC.
    destruct READ_SPEC; subst.

    epose proof fin_inf_read_byte_spec MSR ADDR_CONV _ H0.
    do 2 eexists; split.
    repeat red.
    split; eauto.
    split; auto.
    apply sbyte_refine_lifted.

    Unshelve.
    apply sbyte_refine_lifted.
  Qed.

  Lemma fin_inf_read_bytes_spec' :
    forall a_fin a_inf n ms_fin ms_inf bytes_inf bytes_fin,
      InfToFinAddrConvert.addr_convert a_inf = NoOom a_fin ->
      MemState_refine_prop ms_inf ms_fin ->
      sbytes_refine bytes_inf bytes_fin ->
      Memory64BitIntptr.MMEP.MemSpec.read_bytes_spec a_fin n ms_fin (success_unERR_UB_OOM (ms_fin, bytes_fin)) ->
      MemoryBigIntptr.MMEP.MemSpec.read_bytes_spec a_inf n ms_inf (success_unERR_UB_OOM (ms_inf, bytes_inf)).
  Proof.
    intros a_fin a_inf n ms_fin ms_inf bytes_inf bytes_fin ADDR_CONV MEM_REF BYTES_REF READ_SPEC.

    (* TODO: Make these opaque earlier *)
    Opaque Memory64BitIntptr.MMEP.MemSpec.MemHelpers.get_consecutive_ptrs.
    Opaque MemoryBigIntptr.MMEP.MemSpec.MemHelpers.get_consecutive_ptrs.
    red. red in READ_SPEC.
    cbn in *.
    destruct READ_SPEC as (ms_fin' & addrs_fin & CONSEC & READ_SPEC).
    exists ms_inf.
    pose proof fin_inf_get_consecutive_ptrs_success_exists' a_fin a_inf n ms_fin ms_fin' addrs_fin ms_inf ADDR_CONV CONSEC as (addrs_inf & GCP & ADDRS_CONV).
    exists addrs_inf.
    split; auto.

    (* Not sure if induction is the right thing to do here *)
    generalize dependent a_fin.
    generalize dependent a_inf.
    generalize dependent n.
    generalize dependent bytes_fin.
    generalize dependent bytes_inf.
    induction ADDRS_CONV; intros bytes_inf bytes_fin BYTES_REF READ_SPEC n a_inf GCP a_fin ADDR_CONV CONSEC.
    - cbn in *.
      destruct READ_SPEC; subst; cbn.
      inv BYTES_REF.
      auto.
    - rewrite map_monad_unfold.
      cbn.

      rename l into addrs_fin.
      rename l' into addrs_inf.
      rename y into x_inf.
      rename x into x_fin.

      cbn in READ_SPEC.
      destruct READ_SPEC as [ms_fin'' [a [[MS READ_SPEC] READ_SPEC_REST]]]; subst.

      assert (ms_fin'' = ms_fin) as MSFIN.
      {
        (* TODO: make this a lemma *)
        Transparent Memory64BitIntptr.MMEP.MemSpec.MemHelpers.get_consecutive_ptrs.
        unfold Memory64BitIntptr.MMEP.MemSpec.MemHelpers.get_consecutive_ptrs in CONSEC.
        cbn in CONSEC.
        destruct CONSEC as [sab [ips [SEQ CONSEC]]].
        red in SEQ.
        break_match_hyp; inv SEQ.
        destruct CONSEC as [sab [addrs [CONSEC SEQ]]].
        red in CONSEC.
        break_match_hyp; inv CONSEC.
        red in SEQ.
        break_match_hyp; inv SEQ.                                                   auto.
        Opaque Memory64BitIntptr.MMEP.MemSpec.MemHelpers.get_consecutive_ptrs.
      }
      subst.

      pose proof READ_SPEC_REST as READ_SPEC_REST'.
      destruct READ_SPEC_REST as [ms_fin' [bytes_fin' READ_SPEC_REST]].
      destruct READ_SPEC_REST as [READ_SPEC_REST [MS BYTES_FIN]].
      subst.

      exists ms_inf. exists (lift_SByte a).
      split.
      { split; auto.
        eapply fin_inf_read_byte_spec; eauto.
        apply sbyte_refine_lifted.
      }

      assert ((exists (pre : MemoryBigIntptr.MMEP.MMSP.MemState) (post : MemoryBigIntptr.MMEP.MMSP.MemState),
                  @Within.within (MemPropT MemoryBigIntptr.MMEP.MMSP.MemState) (@MemPropT_Eq1 MemoryBigIntptr.MMEP.MMSP.MemState) err_ub_oom MemoryBigIntptr.MMEP.MMSP.MemState MemoryBigIntptr.MMEP.MMSP.MemState _ _  (InfLLVM.MEM.MMEP.MemSpec.MemHelpers.get_consecutive_ptrs a_inf n) pre
                    (ret (x_inf :: addrs_inf)) post)).
      { exists ms_inf. exists ms_inf.
        cbn. red. cbn.
        auto.
      }

      inv BYTES_REF.
      rename H4 into BYTE_REF.
      rename H5 into BYTES_REF.
      specialize (IHADDRS_CONV _ _ BYTES_REF READ_SPEC_REST).

      epose proof InfLLVM.MEM.MMEP.MemSpec.MemHelpers.get_consecutive_ptrs_cons _ _ _ _ H0.
      destruct H1 as [XA [[PTRS N] | [ptr' [ip' [len' [LEN [IP [GEP [pre [post WITHIN]]]]]]]]]].
      { subst.
        cbn in *.
        exists ms_inf. exists [].
        split; auto.
        split; auto.

        specialize (IHADDRS_CONV 0%nat a_inf).
        forward IHADDRS_CONV.
        { cbn.
          (* TODO: This should probably be a lemma *)
          Transparent MemoryBigIntptr.MMEP.MemSpec.MemHelpers.get_consecutive_ptrs.
          unfold MemoryBigIntptr.MMEP.MemSpec.MemHelpers.get_consecutive_ptrs.
          Opaque MemoryBigIntptr.MMEP.MemSpec.MemHelpers.get_consecutive_ptrs.
          cbn.
          exists ms_inf. exists [].
          split; auto.
          exists ms_inf. exists [].
          cbn.
          auto.
        }

        specialize (IHADDRS_CONV _ H).
        inv ADDRS_CONV.
        forward IHADDRS_CONV.
        { cbn.
          (* TODO: This should probably be a lemma *)
          Transparent Memory64BitIntptr.MMEP.MemSpec.MemHelpers.get_consecutive_ptrs.
          unfold Memory64BitIntptr.MMEP.MemSpec.MemHelpers.get_consecutive_ptrs.
          Opaque Memory64BitIntptr.MMEP.MemSpec.MemHelpers.get_consecutive_ptrs.
          cbn.
          exists ms_fin'. exists [].
          split; auto.
          exists ms_fin'. exists [].
          cbn.
          auto.
        }

        destruct IHADDRS_CONV; subst.
        red in BYTE_REF.
        erewrite lift_SByte_convert_SByte_inverse; eauto.
      }

      pose proof H0 as WITHIN_INF.
      destruct H0 as [pre' [post' WITHIN']].
      cbn in WITHIN'.
      red in WITHIN'.
      cbn in WITHIN'.


      subst.
      cbn in WITHIN.
      red in WITHIN.
      cbn in WITHIN.

      pose proof WITHIN as PREPOST.
      eapply MemoryBigIntptr.MMEP.get_consecutive_ptrs_MemPropT_MemState_eq in PREPOST.
      subst.

      rename l into bytes_inf'.
      exists ms_inf. exists bytes_inf'.
      split; auto.

      destruct addrs_inf as [ | a_inf' addrs_inf].
      {
        destruct addrs_fin as [ | a_fin' addrs_fin].
        {
          cbn in READ_SPEC_REST.
          destruct READ_SPEC_REST; subst.
          inv BYTES_REF.
          cbn; auto.
        }

        (* Should be a contradiction *)
        inv ADDRS_CONV.
      }

      destruct addrs_fin as [ | a_fin' addrs_fin].
      { (* Should be a contradiction *)
        inv ADDRS_CONV.
      }

      eapply IHADDRS_CONV.
      + eapply MemoryBigIntptr.MMEP.get_consecutive_ptrs_MemPropT_MemState.
        eapply WITHIN.
      + (* How do I know ptr' is safe to convert
                               to a finite pointer?

                               I know it's a_inf + 1...

                               Need to show that a_inf' is a_inf + 1
                               as well, and that it relates to a_fin'.
         *)

        (* ptr' is a_inf + 1 (AKA a_inf'). It
                               should share the same provenance as well.
         *)

        pose proof (MemoryBigIntptr.MMEP.MemSpec.MemHelpers.get_consecutive_ptrs_nth_eq1  a_inf (S len') (a_inf :: a_inf' :: addrs_inf) (M:=(MemPropT MemoryBigIntptr.MMEP.MMSP.MemState))).
        forward H0.
        { red. red.
          intros ms x0.
          split.
          - intros GCP'.
            cbn.
            (* Ideally want to use GCP to show this... *)
            assert (exists (pre : MemoryBigIntptr.MMEP.MMSP.MemState) (post : MemoryBigIntptr.MMEP.MMSP.MemState),
                       @Within.within (MemPropT MemoryBigIntptr.MMEP.MMSP.MemState) (@MemPropT_Eq1 MemoryBigIntptr.MMEP.MMSP.MemState) err_ub_oom MemoryBigIntptr.MMEP.MMSP.MemState MemoryBigIntptr.MMEP.MMSP.MemState _ _ (MemoryBigIntptr.MMEP.MemSpec.MemHelpers.get_consecutive_ptrs a_inf (S len')) pre (fmap snd x0) post).
            { exists ms. exists ms.
              red. red. red.
              destruct_err_ub_oom x0;
                cbn; auto.

              destruct x1; cbn in *.
              pose proof GCP' as GCP''.
              assert (success_unERR_UB_OOM (m, l) = @ret _ _ _ (m, l)); cbn; auto.
              rewrite H1 in GCP''.

              pose proof MemoryBigIntptr.MMEP.get_consecutive_ptrs_MemPropT_MemState_eq a_inf (S len') l ms m GCP''; subst.
              eauto.
            }

            pose proof MemoryBigIntptr.CP.CONCBASE.MemHelpers.get_consecutive_ptrs_success_always_succeeds (M:=(MemPropT MemoryBigIntptr.MMEP.MMSP.MemState)) (B:=err_ub_oom) a_inf (S len') (a_inf :: a_inf' :: addrs_inf) _ WITHIN_INF H1.
            destruct_err_ub_oom x0; cbn in *; inv H2.
            destruct x1; cbn in *; subst.
            pose proof GCP' as MM.
            apply MemoryBigIntptr.MMEP.get_consecutive_ptrs_MemPropT_MemState_eq in MM.
            subst.
            split; auto.
          - intros H1.
            cbn in H1.
            destruct_err_ub_oom x0; try inv H1.
            destruct x1.
            destruct H1.
            subst.
            pose proof WITHIN'.
            apply MemoryBigIntptr.MMEP.get_consecutive_ptrs_MemPropT_MemState_eq in H1; subst.
            eapply MemoryBigIntptr.MMEP.get_consecutive_ptrs_MemPropT_MemState.
            eapply WITHIN'.
        }

        specialize (H0 a_inf' 1%nat).
        forward H0; cbn; auto.
        destruct H0 as [ix [IX GEP_IX]].

        (* Show that ip' = ix *)
        assert (ip' = ix) as IPIX.
        {
          cbn in IX.
          inv IX.
          unfold InterpreterStackBigIntptr.LP.IP.to_Z in IP.
          auto.
        }
        subst.

        rewrite GEP in GEP_IX.
        inv GEP_IX.
        inv ADDRS_CONV.
        eauto.
      + (* Should follow from CONSEC *)

        assert ((exists (pre : FinMem.MMEP.MMSP.MemState) (post : FinMem.MMEP.MMSP.MemState),
                    @Within.within (MemPropT Memory64BitIntptr.MMEP.MMSP.MemState) (@MemPropT_Eq1 Memory64BitIntptr.MMEP.MMSP.MemState) err_ub_oom Memory64BitIntptr.MMEP.MMSP.MemState Memory64BitIntptr.MMEP.MMSP.MemState _ _ (FinLLVM.MEM.MMEP.MemSpec.MemHelpers.get_consecutive_ptrs a_fin (S len')) pre
                      (ret (x_fin :: a_fin' :: addrs_fin)) post)).
        {
          exists ms_fin'. exists ms_fin'.
          cbn. red. cbn.
          auto.
        }

        pose proof FinMem.MMEP.MemSpec.MemHelpers.get_consecutive_ptrs_cons _ _ _ _ H0.
        destruct H1.
        destruct H2.
        { destruct H2; discriminate.
        }

        destruct H2 as [ptr'' [ip [len'' [LEN [IP' [GEP'' WITHIN'']]]]]].
        (* GEP'' suggests ptr'' = a_fin' *)
        assert (ptr'' = a_fin').
        {
          subst.
          pose proof FinMem.MMEP.MemSpec.MemHelpers.get_consecutive_ptrs_cons _ _ _ _ WITHIN''.
          destruct H1.
          auto.
        }
        subst.

        destruct WITHIN'' as [pre [post'' WITHIN'']].
        cbn in WITHIN''.
        red in WITHIN''.
        cbn in WITHIN''.
        pose proof WITHIN''.
        inv LEN.
        apply FinMem.MMEP.get_consecutive_ptrs_MemPropT_MemState_eq in H1; subst.
        eapply FinMem.MMEP.get_consecutive_ptrs_MemPropT_MemState; eauto.
        eapply WITHIN''.
      + split; auto.
        red in BYTE_REF.
        erewrite lift_SByte_convert_SByte_inverse; eauto.
  Qed.

  (* Form that's better suited to MemPropT_fin_inf_bind *)
  Lemma fin_inf_read_bytes_spec :
    forall a_fin a_inf n ms_fin ms_fin' ms_inf bytes_fin,
      InfToFinAddrConvert.addr_convert a_inf = NoOom a_fin ->
      MemState_refine_prop ms_inf ms_fin ->
      Memory64BitIntptr.MMEP.MemSpec.read_bytes_spec a_fin n ms_fin (success_unERR_UB_OOM (ms_fin', bytes_fin)) ->
      exists bytes_inf ms_inf',
        MemoryBigIntptr.MMEP.MemSpec.read_bytes_spec a_inf n ms_inf (success_unERR_UB_OOM (ms_inf', bytes_inf)) /\
          sbytes_refine bytes_inf bytes_fin /\
          MemState_refine_prop ms_inf' ms_fin'.
  Proof.
    intros a_fin a_inf n ms_fin ms_fin' ms_inf bytes_fin ADDR_CONV MEM_REF READ_SPEC.

    eapply MemPropT_fin_inf_bind.
    4: apply READ_SPEC.
    all: eauto.

    { intros a_fin0 ms_fin_ma GCP.
      eapply fin_inf_get_consecutive_ptrs_success_exists; eauto.
      eapply GCP.
    }

    intros ms_inf0 ms_fin0 ms_fin'0 a_fin0 a_inf0 b_fin ADDRS MSR READ.

    eapply MemPropT_fin_inf_map_monad.
    all: eauto.
    2: {
      apply Forall2_flip in ADDRS.
      cbn in ADDRS.
      apply ADDRS.
    }

    intros a_fin1 a_inf1 b_fin0 ms_fin1 ms_inf1 ms_fin_ma MSR' CONV RBS.
    eapply fin_inf_read_byte_spec_MemPropT; eauto.
    apply CONV.
  Qed.

  Lemma fin_inf_disjoint_ptr_byte :
    forall addr_fin addr_fin' addr_inf addr_inf',
      InfToFinAddrConvert.addr_convert addr_inf = NoOom addr_fin ->
      InfToFinAddrConvert.addr_convert addr_inf' = NoOom addr_fin' ->
      Memory64BitIntptr.MMEP.MemSpec.disjoint_ptr_byte addr_fin addr_fin' <->
        MemoryBigIntptr.MMEP.MemSpec.disjoint_ptr_byte addr_inf addr_inf'.
  Proof.
    intros addr_fin addr_fin' addr_inf addr_inf' CONV CONV'.
    split; intros DISJOINT.
    - red in DISJOINT.
      red.
      unfold InfToFinAddrConvert.addr_convert in *.
      destruct addr_inf, addr_inf'.
      cbn in *.
      erewrite FinLP.ITOP.ptr_to_int_int_to_ptr in DISJOINT; [| apply CONV].
      erewrite FinLP.ITOP.ptr_to_int_int_to_ptr in DISJOINT; [| apply CONV'].
      auto.
    - red in DISJOINT.
      red.
      unfold InfToFinAddrConvert.addr_convert in *.
      destruct addr_inf, addr_inf'.
      cbn in *.
      erewrite FinLP.ITOP.ptr_to_int_int_to_ptr; [| apply CONV].
      erewrite FinLP.ITOP.ptr_to_int_int_to_ptr; [| apply CONV'].
      auto.
  Qed.

  Lemma read_byte_spec_ref_byte_is_lifted :
    forall ms_inf ms_fin addr_inf addr_fin byte_inf byte_fin,
      MemState_refine_prop ms_inf ms_fin ->
      InfToFinAddrConvert.addr_convert addr_inf = NoOom addr_fin ->
      Memory64BitIntptr.MMEP.MemSpec.read_byte_spec ms_fin addr_fin byte_fin ->
      MemoryBigIntptr.MMEP.MemSpec.read_byte_spec ms_inf addr_inf byte_inf ->
      byte_inf = lift_SByte byte_fin.
  Proof.
    intros ms_inf ms_fin addr_inf addr_fin byte_inf byte_fin MEM_REF ADDR_CONV READ_FIN READ_INF.
    destruct READ_FIN, READ_INF.
    cbn in read_byte_value, read_byte_value0.

    repeat red in read_byte_value, read_byte_value0.
    repeat (break_match_hyp; try contradiction).
    destruct m, m0; cbn in *; subst.

    epose proof fin_inf_read_byte_raw MEM_REF (in_bounds_ptr_to_int_fin addr_fin).
    forward H.
    unfold Memory64BitIntptr.MMEP.MMSP.mem_state_memory.
    eauto.
    erewrite fin_inf_ptoi in H; eauto.
    unfold MemoryBigIntptr.MMEP.MMSP.mem_state_memory in *.
    rewrite Heqo in H.
    inv H.
    reflexivity.
  Qed.

  (* TODO: Move this *)
  Lemma read_byte_allowed_read_byte_raw :
    forall {ms ptr},
      MemoryBigIntptr.MMEP.MemSpec.read_byte_allowed ms ptr ->
      exists byte aid,
        MemoryBigIntptr.MMEP.MMSP.read_byte_raw (InfMem.MMEP.MMSP.mem_state_memory ms) (LLVMParamsBigIntptr.PTOI.ptr_to_int ptr) = Some (byte, aid) /\
          InfPROV.access_allowed (InfLP.PROV.address_provenance ptr) aid = true.
  Proof.
    intros ms ptr ALLOWED.
    repeat red in ALLOWED.
    destruct ALLOWED as [aid [BYTE_ALLOCATED ALLOWED]].
    repeat red in BYTE_ALLOCATED.
    break_match_hyp; try contradiction.
    destruct m.
    exists s. exists a.
    split; auto.
    destruct (LLVMParamsBigIntptr.PROV.aid_eq_dec aid a) eqn:AID';
      subst; cbn in *; try discriminate.
    auto.
  Qed.

  (* TODO: Move and make something for both fin / inf memory *)
  Lemma read_byte_spec_read_byte_raw :
    forall {ms ptr byte},
      MemoryBigIntptr.MMEP.MemSpec.read_byte_spec ms ptr byte ->
      exists aid,
        MemoryBigIntptr.MMEP.MMSP.read_byte_raw (InfMem.MMEP.MMSP.mem_state_memory ms) (LLVMParamsBigIntptr.PTOI.ptr_to_int ptr) = Some (byte, aid) /\
          InfPROV.access_allowed (InfLP.PROV.address_provenance ptr) aid = true.
  Proof.
    intros ms ptr byte [ALLOWED READ].
    apply read_byte_allowed_read_byte_raw in ALLOWED as [byte' [aid [READ' ALLOWED]]].
    exists aid. split; auto.
    rewrite READ'.
    repeat red in READ.
    unfold InfMem.MMEP.MMSP.mem_state_memory in *.
    rewrite READ' in READ.
    cbn in *.
    rewrite ALLOWED in READ.
    subst; auto.
  Qed.

  Lemma inf_fin_read_byte_spec :
    forall {ms_inf ms_fin ptr_inf ptr_fin byte_inf},
      MemState_refine_prop ms_inf ms_fin ->
      InfToFinAddrConvert.addr_convert ptr_inf = NoOom ptr_fin ->
      MemoryBigIntptr.MMEP.MemSpec.read_byte_spec ms_inf ptr_inf byte_inf ->
      exists byte_fin,
        Memory64BitIntptr.MMEP.MemSpec.read_byte_spec ms_fin ptr_fin byte_fin /\
          sbyte_refine byte_inf byte_fin.
  Proof.
    intros ms_inf ms_fin ptr_inf ptr_fin byte_inf MEM_REF ADDR_CONV RBS.
    pose proof read_byte_spec_read_byte_raw RBS as [aid [READ_RAW_INF ALLOWED]].

    cbn in READ_RAW_INF.

    assert (LLVMParams64BitIntptr.PTOI.ptr_to_int ptr_fin = LLVMParamsBigIntptr.PTOI.ptr_to_int ptr_inf) as PTR.
    { eapply fin_inf_ptoi; eauto.
    }

    epose proof inf_fin_read_byte_raw MEM_REF READ_RAW_INF as [byte_fin [READ_BYTE_RAW_FIN [IN_BOUNDS BYTE_REF]]].

    exists byte_fin.
    split.
    { (* Read byte spec *)
      split.
      - destruct RBS.
        eapply inf_fin_read_byte_allowed; eauto.
      - destruct RBS.
        eapply inf_fin_read_byte_prop; eauto.
    }

    { (* Byte refinement *)
      auto.
    }
  Qed.

  (* TODO: Move this *)
  Lemma inf_fin_read_byte_prop_exists :
    forall {ptr_inf byte_inf ms_inf ms_fin},
      MemState_refine_prop ms_inf ms_fin ->
      InfMem.MMEP.MemSpec.read_byte_prop ms_inf ptr_inf byte_inf ->
      exists ptr_fin byte_fin,
        FinMem.MMEP.MemSpec.read_byte_prop ms_fin ptr_fin byte_fin /\
          addr_refine ptr_inf ptr_fin /\
          sbyte_refine byte_inf byte_fin.
  Proof.
    intros ptr_inf byte_inf ms_inf ms_fin MSR RBP.
    repeat red in RBP.
    repeat (break_match_hyp; try contradiction).
    destruct m; cbn in *; subst.
    pose proof Heqo as READ.
    rewrite MemoryBigIntptrInfiniteSpec.MMSP.memory_stack_memory_mem_state_memory in READ.
    erewrite inf_read_byte_raw_MemState_eqv_Proper in READ; eauto.
    destruct ms_fin, ms_memory_stack; cbn in READ.
    eapply read_byte_raw_lifted in READ.
    destruct READ as (byte_fin&READ_FIN&IN_BOUNDS&BYTE_REF).

    destruct ptr_inf.
    epose proof in_bounds_exists_addr _ p.
    pose proof IN_BOUNDS as FIN_ADDR.
    apply H in FIN_ADDR; clear H.
    destruct FIN_ADDR as (addr_fin & FIN_ADDR & FIN_PROV).

    assert (addr_refine (i, p) addr_fin) as ADDR_REF.
    { unfold addr_refine.
      destruct addr_fin. cbn in *.
      subst.
      erewrite LLVMParams64BitIntptr.ITOP.int_to_ptr_ptr_to_int; eauto.
    }

    cbn in *.

    exists addr_fin.
    exists byte_fin.
    split; eauto.

    repeat red.
    cbn.
    erewrite fin_inf_ptoi; eauto.
    cbn.    
    rewrite READ_FIN.

    erewrite inf_fin_access_allowed; eauto; cbn; auto.
  Qed.

  Lemma inf_fin_read_byte_spec_exists :
    forall {ms_inf ms_fin ptr_inf byte_inf},
      MemState_refine_prop ms_inf ms_fin ->
      MemoryBigIntptr.MMEP.MemSpec.read_byte_spec ms_inf ptr_inf byte_inf ->
      exists ptr_fin byte_fin,
        Memory64BitIntptr.MMEP.MemSpec.read_byte_spec ms_fin ptr_fin byte_fin /\
          sbyte_refine byte_inf byte_fin /\
          addr_refine ptr_inf ptr_fin.
  Proof.
    intros ms_inf ms_fin ptr_inf byte_inf MEM_REF RBS.
    pose proof read_byte_spec_read_byte_raw RBS as [aid [READ_RAW_INF ALLOWED]].

    cbn in READ_RAW_INF.

    pose proof RBS.
    destruct H.
    epose proof inf_fin_read_byte_prop_exists MEM_REF read_byte_value as (ptr_fin&byte_fin&RBP_FIN&ADDR_REF&BYTE_REF).
    exists ptr_fin. exists byte_fin.
    split; auto.

    epose proof inf_fin_read_byte_raw MEM_REF READ_RAW_INF as [byte_fin' [READ_BYTE_RAW_FIN BYTE_REF']].

    assert (LLVMParams64BitIntptr.PTOI.ptr_to_int ptr_fin = LLVMParamsBigIntptr.PTOI.ptr_to_int ptr_inf) as PTR.
    { eapply fin_inf_ptoi; eauto.
    }

    { (* Read byte spec *)
      split.
      - destruct RBS.
        eapply inf_fin_read_byte_allowed; eauto.
      - destruct RBS.
        eapply inf_fin_read_byte_prop; eauto.
    }
  Qed.

  (* TODO: Move this *)
  Lemma MemState_refine_prop_heap_preserved :
    forall ms_inf ms_fin,
      MemState_refine_prop ms_inf ms_fin ->
      InfMem.MMEP.MemSpec.heap_preserved ms_inf (lift_MemState ms_fin).
  Proof.
    intros ms_inf ms_fin MSR.
    do 2 red in MSR.
    tauto.
  Qed.

  (* TODO: Move this *)
  Lemma MemState_refine_prop_frame_stack_preserved :
    forall ms_inf ms_fin,
      MemState_refine_prop ms_inf ms_fin ->
      InfMem.MMEP.MemSpec.frame_stack_preserved ms_inf (lift_MemState ms_fin).
  Proof.
    intros ms_inf ms_fin MSR.
    do 2 red in MSR.
    tauto.
  Qed.

  (* TODO: Move this *)
  Lemma MemState_refine_prop_allocations_preserved :
    forall {ms_inf ms_fin},
      MemState_refine_prop ms_inf ms_fin ->
      InfMem.MMEP.MemSpec.allocations_preserved ms_inf (lift_MemState ms_fin).
  Proof.
    intros ms_inf ms_fin MSR.
    do 2 red in MSR.
    tauto.
  Qed.

  Lemma convert_FrameStack_OOM :
    forall fs1 fs2 s1,
      InfMem.MMEP.MMSP.frame_stack_eqv fs1 fs2 ->
      convert_FrameStack fs1 = Oom s1 ->
      exists s2,
        convert_FrameStack fs2 = Oom s2.
  Proof.
    intros fs1 fs2 s1 H H0.
  Admitted.

  (* TODO: Move this *)
  Lemma lift_FrameStack_singleton :
    forall f,
      lift_FrameStack (FinMem.MMEP.MMSP.Singleton f) = InfMem.MMEP.MMSP.Singleton (lift_Frame f).
  Proof.
    Transparent lift_FrameStack.
    intros f.
    cbn.
    reflexivity.
    Opaque lift_FrameStack.
  Qed.

  Lemma int_to_ptr_succeeds_regardless_of_provenance :
    forall {pr1 pr2 addr ptr},
      LLVMParams64BitIntptr.ITOP.int_to_ptr addr pr1 = NoOom ptr ->
      exists ptr', LLVMParams64BitIntptr.ITOP.int_to_ptr addr pr2 = NoOom ptr'.
  Proof.
    intros pr1 pr2 addr0 ptr H.
    unfold LLVMParams64BitIntptr.ITOP.int_to_ptr in *.
    break_match_hyp_inv.
    eexists; reflexivity.
  Qed.

  Lemma int_to_ptr_fails_regardless_of_provenance :
    forall {pr1 pr2 addr oom_msg},
      LLVMParams64BitIntptr.ITOP.int_to_ptr addr pr1 = Oom oom_msg ->
      LLVMParams64BitIntptr.ITOP.int_to_ptr addr pr2 = Oom oom_msg.
  Proof.
    intros pr1 pr2 addr0 oom_msg H.
    unfold LLVMParams64BitIntptr.ITOP.int_to_ptr in *.
    break_match_hyp_inv.
    reflexivity.
  Qed.

  (* TODO: Move this *)
  Lemma fin_ptr_to_inf_round_trip :
    forall ptr_fin i,
      LLVMParamsBigIntptr.PTOI.ptr_to_int (fin_to_inf_addr ptr_fin) = i ->
      forall pr,
      exists ptr_fin', FinITOP.int_to_ptr i pr = NoOom ptr_fin'.
  Proof.
    intros ptr_fin i H pr.
    unfold fin_to_inf_addr in *.
    break_match_hyp.
    cbn in *.
    subst.
    clear Heqs.
    destruct ptr_fin.
    eapply @int_to_ptr_succeeds_regardless_of_provenance with (pr1:=p) (ptr:=(i, p)).
    cbn in *.
    inv e.
    unfold FinITOP.int_to_ptr.
    cbn.
    break_match_goal.
    pose proof (Int64.unsigned_range i).
    lia.
    rewrite Int64.repr_unsigned.
    reflexivity.
  Qed.

  (* TODO: Move this *)
  Definition big_int_to_ptr (addr : Z) (pr : InfPROV.Prov) : InfAddr.addr.
    pose proof InfITOP_BIG.int_to_ptr_safe addr pr.
    break_match_hyp_inv.
    apply a.
  Defined.

  Lemma ptr_to_int_of_big_int_to_ptr :
    forall addr pr,
      LLVMParamsBigIntptr.PTOI.ptr_to_int (big_int_to_ptr addr pr) = addr.
  Proof.
    intros addr pr.
    cbn.
    break_match.
    cbn in *; auto.
  Qed.

  Lemma fin_to_inf_addr_big_int_to_ptr :
    forall addr a pr,
      LLVMParams64BitIntptr.ITOP.int_to_ptr addr pr = NoOom a ->
      fin_to_inf_addr a = big_int_to_ptr addr pr.
  Proof.
    intros addr a pr PTR.
    cbn.
    break_match.
    unfold fin_to_inf_addr.
    break_match.
    clear Heqs.
    unfold FinToInfAddrConvert.addr_convert in e.
    break_match_hyp; subst.
    cbn in e.
    inv e.
    unfold LLVMParams64BitIntptr.ITOP.int_to_ptr in PTR.
    break_match_hyp_inv.
    rewrite Int64.unsigned_repr; auto.
    unfold Int64.max_unsigned.
    lia.
  Qed.

  (* TODO: Move this *)
  Lemma In_memory_is_allocated_inf :
    forall addr byte ptr aid mem ms pr,
      In (addr, (byte, aid)) (IntMaps.IM.elements (elt:=InfMemMMSP.mem_byte) mem) ->
      MemoryBigIntptrInfiniteSpec.MMSP.mem_state_memory ms = mem ->
      ptr = big_int_to_ptr addr pr ->
      MemoryBigIntptr.MMEP.MemSpec.byte_allocated ms ptr aid.
  Proof.
    intros addr ptr byte aid mem ms pr ELEMS MEM PTR.
    repeat red.
    subst.
    unfold MemoryBigIntptrInfiniteSpec.MMSP.mem_state_memory in *.

    Transparent MemoryBigIntptr.MMEP.MMSP.read_byte_raw.
    unfold MemoryBigIntptr.MMEP.MMSP.read_byte_raw.
    Opaque MemoryBigIntptr.MMEP.MMSP.read_byte_raw.

    subst.
    rewrite ptr_to_int_of_big_int_to_ptr.

    eapply SetoidList.In_InA in ELEMS.
    eapply IntMaps.IP.F.elements_mapsto_iff in ELEMS.
    2: typeclasses eauto.
    eapply IntMaps.IP.F.find_mapsto_iff in ELEMS.
    rewrite ELEMS.
    symmetry; apply InfPROV.aid_eq_dec_refl.
  Qed.

  (* TODO: Move this *)
  Lemma In_memory_read_byte_inf :
    forall addr ptr byte aid mem ms,
      In (addr, (byte, aid)) (IntMaps.IM.elements (elt:=InfMemMMSP.mem_byte) mem) ->
      LLVMParams64BitIntptr.ITOP.int_to_ptr addr (FinPROV.allocation_id_to_prov aid) = NoOom ptr ->
      MemoryBigIntptrInfiniteSpec.MMSP.mem_state_memory ms = mem ->
      MemoryBigIntptr.MMEP.MemSpec.read_byte_spec ms (fin_to_inf_addr ptr) byte.
  Proof.
    intros addr ptr byte aid mem ms ELEMS PTR MEM.
    split.
    { red.
      exists aid.
      split.
      - eapply In_memory_is_allocated_inf; eauto.
        eapply fin_to_inf_addr_big_int_to_ptr; eauto.
      - eapply fin_inf_access_allowed.
        + apply addr_convert_fin_to_inf_addr.
        + erewrite ITOP.int_to_ptr_provenance; eauto.
          apply FinLP.PROV.access_allowed_refl.
    }

    repeat red.

    Transparent MemoryBigIntptr.MMEP.MMSP.read_byte_raw.
    unfold MemoryBigIntptr.MMEP.MMSP.read_byte_raw.
    Opaque MemoryBigIntptr.MMEP.MMSP.read_byte_raw.

    rewrite fin_to_inf_addr_ptr_to_int.
    erewrite FinLP.ITOP.ptr_to_int_int_to_ptr; eauto.
    unfold MemoryBigIntptrInfiniteSpec.MMSP.mem_state_memory in *.
    subst; cbn in *.

    eapply SetoidList.In_InA in ELEMS.
    eapply IntMaps.IP.F.elements_mapsto_iff in ELEMS.
    2: typeclasses eauto.
    eapply IntMaps.IP.F.find_mapsto_iff in ELEMS.
    rewrite ELEMS.

    cbn.

    assert (LLVMParamsBigIntptr.PROV.access_allowed
              (LLVMParamsBigIntptr.PROV.address_provenance (fin_to_inf_addr ptr)) aid = true) as ACCESS.
    { eapply fin_inf_access_allowed.
      - apply addr_convert_fin_to_inf_addr.
      - erewrite ITOP.int_to_ptr_provenance; eauto.
        apply FinLP.PROV.access_allowed_refl.
    }
    rewrite ACCESS.

    split; auto.
  Qed.

  (* TODO: Move this *)
  Lemma MemState_refine_prop_read_byte_preserved :
    forall {ms_inf ms_fin},
      MemState_refine_prop ms_inf ms_fin ->
      InfMem.MMEP.MemSpec.read_byte_preserved ms_inf (lift_MemState ms_fin).
  Proof.
    intros ms_inf ms_fin MSR.
    do 2 red in MSR.
    tauto.
  Qed.

  (* TODO: Move this, should be in MemoryModel.v with read_byte_preserved *)
  Definition read_byte_spec_preserved m1 m2 :=
    forall ptr byte, MemoryBigIntptr.MMEP.MemSpec.read_byte_spec m1 ptr byte <-> MemoryBigIntptr.MMEP.MemSpec.read_byte_spec m2 ptr byte.

  Lemma read_byte_preserved_read_byte_spec_preserved :
    forall m1 m2,
      InfMem.MMEP.MemSpec.read_byte_preserved m1 m2 ->
      read_byte_spec_preserved m1 m2.
  Proof.
    intros m1 m2.
    intros PRES.
    { destruct PRES as [ALLOWED_PRES PROP_PRES].
      red.
      intros ptr byte.
      split; intros [ALLOWED PROP].
      - split.
        + apply ALLOWED_PRES; auto.
        + apply PROP_PRES; auto.
      - split.
        + apply ALLOWED_PRES; auto.
        + apply PROP_PRES; auto.
    }
  Qed.

  Lemma MemState_refine_prop_read_byte_spec_preserved :
    forall {ms_inf : InfMem.MMEP.MMSP.MemState} {ms_fin : FinMem.MMEP.MMSP.MemState},
      MemState_refine_prop ms_inf ms_fin ->
      read_byte_spec_preserved ms_inf (lift_MemState ms_fin).
  Proof.
    intros ms_inf ms_fin MSR.
    apply read_byte_preserved_read_byte_spec_preserved.
    apply MemState_refine_prop_read_byte_preserved; auto.
  Qed.

  (* TODO: Move this *)
  Lemma read_byte_spec_lifted_memory_lifted_sbyte :
    forall {ms ptr byte},
      MemoryBigIntptr.MMEP.MemSpec.read_byte_spec (lift_MemState ms) ptr byte ->
      exists fin_byte, byte = lift_SByte fin_byte.
  Proof.
    intros ms ptr byte READ.
    destruct READ as [ALLOWED READ].

    red in ALLOWED.
    destruct ALLOWED as (aid&ALLOC&ALLOWED).
    pose proof ALLOC as READ_RAW.
    apply inf_byte_allocated_read_byte_raw in READ_RAW.
    destruct READ_RAW as (byte'&READ_RAW).

    repeat red in READ.
    rewrite READ_RAW in READ.
    cbn in *.
    rewrite ALLOWED in READ.
    subst.
    cbn in *.

    destruct ms as [[ms fss hs] msprovs].
    cbn in READ_RAW.
    eapply read_byte_raw_lifted in READ_RAW.
    destruct READ_RAW as (fin_byte&READ_RAW&IN_BOUNDS&BYTE_REF).
    exists fin_byte.
    unfold sbyte_refine in BYTE_REF.
    symmetry.
    apply lift_SByte_convert_SByte_inverse; auto.
  Qed.

  (* TODO: Move this *)
  Lemma convert_SByte_lift_SByte :
    forall byte,
      convert_SByte (lift_SByte byte) = NoOom byte.
  Proof.
    intros byte.
    unfold lift_SByte.
    destruct byte.
    cbn.
    repeat rewrite convert_fin_to_inf_uvalue_succeeds.
    reflexivity.
  Qed.

  Lemma MemState_refine_prop_in_bounds :
    forall ms_inf mem_inf ms_fin addr byte aid,
      MemState_refine_prop ms_inf ms_fin ->
      MemoryBigIntptrInfiniteSpec.MMSP.mem_state_memory ms_inf = mem_inf ->
      In (addr, (byte, aid)) (IntMaps.IM.elements (elt:=InfMemMMSP.mem_byte) mem_inf) ->
      in_bounds addr = true.
  Proof.
    intros ms_inf mem_inf ms_fin addr byte aid MSR MEM IN.
    apply MemState_refine_prop_allocations_preserved in MSR.
    red in MSR.
    remember (big_int_to_ptr addr (MemoryBigIntptrInfiniteSpec.LP.PROV.allocation_id_to_prov aid)) as a.

    specialize (MSR a aid).
    destruct MSR as (ALLOC_INF_FIN&ALLOC_FIN_INF).

    pose proof In_memory_is_allocated_inf _ _ a _ _ ms_inf (MemoryBigIntptrInfiniteSpec.LP.PROV.allocation_id_to_prov aid) IN.
    forward H; auto.
    forward H; auto.

    apply ALLOC_INF_FIN in H.
    eapply inf_fin_byte_allocated_exists in H.
    2: apply lift_MemState_refine_prop.
    destruct H as (addr_fin&ADDR_CONV&ALLOC_FIN).

    apply in_bounds_exists_addr'.
    exists addr_fin.
    erewrite fin_inf_ptoi.
    2: apply ADDR_CONV.
    subst.
    apply ptr_to_int_of_big_int_to_ptr.
  Qed.

  (* TODO: Move this *)
  Lemma byte_allocate_In_memory_inf :
    forall {ms mem ptr addr aid pr},
      MemoryBigIntptr.MMEP.MemSpec.byte_allocated ms ptr aid ->
      MemoryBigIntptrInfiniteSpec.MMSP.mem_state_memory ms = mem ->
      ptr = big_int_to_ptr addr pr ->
      exists byte, In (addr, (byte, aid)) (IntMaps.IM.elements (elt:=InfMemMMSP.mem_byte) mem).
  Proof.
    intros ms mem ptr addr0 aid pr ALLOC MEM PTR.

    repeat red in ALLOC.
    break_match_hyp; try contradiction.
    destruct m; subst.

    Transparent MemoryBigIntptr.MMEP.MMSP.read_byte_raw.
    unfold MemoryBigIntptr.MMEP.MMSP.read_byte_raw in Heqo.
    Opaque MemoryBigIntptr.MMEP.MMSP.read_byte_raw.

    rewrite ptr_to_int_of_big_int_to_ptr in Heqo.
    exists s.

    destruct (LLVMParamsBigIntptr.PROV.aid_eq_dec aid a); cbn in ALLOC; inv ALLOC.

    apply IntMaps.IP.F.find_mapsto_iff in Heqo.
    apply InfMemMMSP.InA_In.
    apply IntMaps.IM.elements_1.
    eapply Heqo.
  Qed.

  (* TODO: Move this *)
  Lemma convert_MemState_MemState_refine_prop :
    forall ms_inf ms_fin,
      convert_MemState ms_inf = NoOom ms_fin ->
      MemState_refine_prop ms_inf ms_fin.
  Proof.
    intros ms_inf ms_fin CONV.
  Admitted.

  Lemma addr_oom_not_in_bounds :
    forall ptr oom_msg,
      InfToFinAddrConvert.addr_convert ptr = Oom oom_msg ->
      in_bounds (LLVMParamsBigIntptr.PTOI.ptr_to_int ptr) = false.
  Proof.
    intros.
    unfold in_bounds.
    unfold InfToFinAddrConvert.addr_convert in *.
    destruct ptr.
    cbn.

    epose proof int_to_ptr_fails_regardless_of_provenance (pr2:=PROV.nil_prov) H.
    rewrite H0.
    reflexivity.
  Qed.

  Lemma fin_inf_big_addresses_no_byte_to_read :
    forall ms_inf ms_fin addr_inf oom_msg,
      MemState_refine_prop ms_inf ms_fin ->
      InfToFinAddrConvert.addr_convert addr_inf = Oom oom_msg ->
      MemoryBigIntptr.MMEP.MMSP.read_byte_raw (InfMem.MMEP.MMSP.mem_state_memory ms_inf) (LLVMParamsBigIntptr.PTOI.ptr_to_int addr_inf) = None.
  Proof.
    intros mem_inf mem_fin addr_inf oom_msg MEM_CONV ADDR_CONV.
    erewrite inf_read_byte_raw_MemState_eqv_Proper; eauto.
    destruct mem_fin, ms_memory_stack.
    cbn in *.

    Transparent MemoryBigIntptr.MMEP.MMSP.read_byte_raw.
    unfold MemoryBigIntptr.MMEP.MMSP.read_byte_raw.
    Opaque MemoryBigIntptr.MMEP.MMSP.read_byte_raw.

    unfold lift_memory.
    rewrite IntMaps.IP.F.map_o.
    unfold option_map.
    rewrite find_filter_dom_false; eauto.

    eapply addr_oom_not_in_bounds; eauto.
  Qed.

  (** Lemmas about writing bytes *)
  Lemma fin_inf_set_byte_memory :
    forall {addr_inf addr_fin byte_inf byte_fin ms_fin ms_fin' ms_inf},
      MemState_refine_prop ms_inf ms_fin ->
      InfToFinAddrConvert.addr_convert addr_inf = NoOom addr_fin ->
      sbyte_refine byte_inf byte_fin ->
      Memory64BitIntptr.MMEP.MemSpec.set_byte_memory ms_fin addr_fin byte_fin ms_fin' ->
      exists ms_inf',
        MemoryBigIntptr.MMEP.MemSpec.set_byte_memory ms_inf addr_inf byte_inf ms_inf' /\
          MemState_refine_prop ms_inf' ms_fin'.
  Proof.
    intros addr_inf addr_fin byte_inf byte_fin ms_fin ms_fin' ms_inf REF CONV BYTE_REF SET.

    pose proof (lift_MemState_refine_prop ms_fin') as REF'.
    auto.
    exists (lift_MemState ms_fin').

    destruct SET.
    split.
    2: {
      apply lift_MemState_refine_prop; auto.
    }

    split.
    - eapply fin_inf_read_byte_spec; eauto.
    - intros ptr' DISJOINT byte'.
      split; intros READ.
      + (* Old memory to new *)
        destruct (InfToFinAddrConvert.addr_convert ptr') eqn:CONVPTR.
        {
          (* ptr' exists in the finite space as 'a' *)
          pose proof fin_inf_disjoint_ptr_byte _ _ _ _ CONV CONVPTR as [_ DISJOINT_a].
          specialize (DISJOINT_a DISJOINT).
          specialize (old_lu a).

          (* a is disjoint from addr_fin, which means that old_lu should hold

                               If there's a byte to read in ms_fin
                               then the same byte can be read in
                               ms_fin'...

                               Then with H we can conclude...

                               MemoryBigIntptr.MMEP.MemSpec.read_byte_spec ms_inf' ptr' (lift_SByte ?byte_fin)

                               But I don't know how this relates to byte' in the goal.

           *)

          specialize (old_lu DISJOINT_a).

          pose proof inf_fin_read_byte_spec REF CONVPTR READ as [byte_fin' [READ_FIN BYTE_REF']].
          apply old_lu in READ_FIN.
          epose proof fin_inf_read_byte_spec REF' CONVPTR _ READ_FIN; eauto.
        }

        (* ptr' is out of bounds, old_lu doesn't say anything about this *)
        clear old_lu.
        eapply inf_fin_read_byte_spec_exists in READ; eauto.
        destruct READ as (?&?&?&?&?).
        rewrite H1 in CONVPTR.
        discriminate.
      + (* New memory to old *)
        destruct (InfToFinAddrConvert.addr_convert ptr') eqn:CONVPTR.
        {
          (* ptr' exists in the finite space as 'a' *)
          pose proof fin_inf_disjoint_ptr_byte _ _ _ _ CONV CONVPTR as [_ DISJOINT_a].
          specialize (DISJOINT_a DISJOINT).
          specialize (old_lu a).

          (* a is disjoint from addr_fin, which means that old_lu should hold

                               If there's a byte to read in ms_fin
                               then the same byte can be read in
                               ms_fin'...

                               Then with H we can conclude...

                               MemoryBigIntptr.MMEP.MemSpec.read_byte_spec ms_inf' ptr' (lift_SByte ?byte_fin)

                               But I don't know how this relates to byte' in the goal.
           *)

          specialize (old_lu DISJOINT_a).

          pose proof inf_fin_read_byte_spec REF' CONVPTR READ as [byte_fin' [READ_FIN BYTE_REF']].
          apply old_lu in READ_FIN.
          epose proof fin_inf_read_byte_spec REF CONVPTR _ READ_FIN; eauto.
        }

        eapply inf_fin_read_byte_spec_exists in READ; eauto.
        destruct READ as (?&?&?&?&?).
        rewrite H1 in CONVPTR.
        discriminate.

        Unshelve.
        all: auto.
  Qed.

  Lemma inf_fin_set_byte_memory :
    forall {addr_inf addr_fin byte_inf byte_fin ms_fin ms_fin' ms_inf ms_inf'},
      MemState_refine_prop ms_inf ms_fin ->
      MemState_refine_prop ms_inf' ms_fin' ->
      InfToFinAddrConvert.addr_convert addr_inf = NoOom addr_fin ->
      sbyte_refine byte_inf byte_fin ->
      MemoryBigIntptr.MMEP.MemSpec.set_byte_memory ms_inf addr_inf byte_inf ms_inf' ->
      Memory64BitIntptr.MMEP.MemSpec.set_byte_memory ms_fin addr_fin byte_fin ms_fin'.
  Proof.
    intros addr_inf addr_fin byte_inf byte_fin ms_fin ms_fin' ms_inf ms_inf'
      REF1 REF2 CONV BYTE_REF SET.

    destruct SET.
    split.
    - eapply inf_fin_read_byte_spec_exists in new_lu; eauto.
      destruct new_lu as (?&?&?&?&?).
      rewrite H1 in CONV.
      inv CONV.
      unfold sbyte_refine in BYTE_REF.
      rewrite H0 in BYTE_REF.
      inv BYTE_REF.
      auto.
    - intros ptr' DISJOINT byte'.
      split; intros READ.
      + (* Old memory to new *)
        epose proof fin_inf_read_byte_spec_exists REF1 READ
          as (addr_inf'&byte_inf'&READ_INF&ADDR_REF'&BYTE_REF').
        eapply fin_inf_disjoint_ptr_byte in DISJOINT; eauto.
        apply old_lu in READ_INF; eauto.
        eapply inf_fin_read_byte_spec_exists in READ_INF as (?&?&?&?&?);
          eauto.

        unfold sbyte_refine in *.
        unfold addr_refine in *.
        rewrite ADDR_REF' in H1; inv H1.
        rewrite BYTE_REF' in H0; inv H0.
        auto.
      + (* New memory to old *)
        epose proof fin_inf_read_byte_spec_exists REF2 READ
          as (addr_inf'&byte_inf'&READ_INF&ADDR_REF'&BYTE_REF').
        eapply fin_inf_disjoint_ptr_byte in DISJOINT; eauto.
        apply old_lu in READ_INF; eauto.
        eapply inf_fin_read_byte_spec_exists in READ_INF as (?&?&?&?&?);
          eauto.

        unfold sbyte_refine in *.
        unfold addr_refine in *.
        rewrite ADDR_REF' in H1; inv H1.
        rewrite BYTE_REF' in H0; inv H0.
        auto.
  Qed.

  Lemma MemState_in_bounds_memory_in_bounds :
    forall m,
      MemState_in_bounds m ->
      memory_in_bounds m.
  Proof.
    intros m IN_BOUNDS.
    destruct IN_BOUNDS; auto.
  Qed.

  Lemma in_in_bounds_is_in_bounds :
    forall addr m,
      memory_in_bounds m ->
      is_true (IntMaps.member addr (Memory64BitIntptr.MMEP.MMSP.mem_state_memory m)) ->
      is_true (in_bounds addr).
  Proof.
    intros addr m IN_BOUNDS IN_MEM.

    red in IN_BOUNDS.
    apply IN_BOUNDS in IN_MEM.

    apply in_bounds_exists_addr'; auto.
  Qed.

  Lemma in_memory_allocated :
    forall addr m,
      memory_in_bounds m ->
      is_true (IntMaps.member addr (Memory64BitIntptr.MMEP.MMSP.mem_state_memory m)) <->
        exists ptr aid,
          FinPTOI.ptr_to_int ptr = addr /\ FinMem.MMEP.MemSpec.byte_allocated m ptr aid.
  Proof.
    intros addr m IN_BOUNDS.
    split.
    { intros IN_MEM.

      pose proof IN_MEM as ADDR_IN_BOUNDS.
      apply in_in_bounds_is_in_bounds in ADDR_IN_BOUNDS; auto.

      apply IntMaps.member_lookup in IN_MEM.
      destruct IN_MEM as ((byte&aid)&IN_MEM).

      eapply in_bounds_exists_addr with (p:=(FinPROV.allocation_id_to_prov aid)) in ADDR_IN_BOUNDS.
      destruct ADDR_IN_BOUNDS as (ptr&PTOI&PROV).

      exists ptr. exists aid.
      split; auto.

      repeat red.
      Transparent FinMem.MMEP.MMSP.read_byte_raw.
      unfold FinMem.MMEP.MMSP.read_byte_raw.
      Opaque FinMem.MMEP.MMSP.read_byte_raw.
      unfold Memory64BitIntptr.MMEP.MMSP.mem_state_memory in *.
      subst; cbn in *.
      unfold IntMaps.lookup in *.
      rewrite IN_MEM.
      symmetry. apply FinPROV.aid_eq_dec_refl.
    }

    { intros (ptr&aid&PTOI&ALLOC).
      repeat red in ALLOC.
      break_match_hyp; try contradiction.
      destruct m0.

      Transparent Memory64BitIntptr.MMEP.MMSP.read_byte_raw.
      unfold FinMem.MMEP.MMSP.read_byte_raw in *.
      Opaque Memory64BitIntptr.MMEP.MMSP.read_byte_raw.

      unfold Memory64BitIntptr.MMEP.MMSP.mem_state_memory in *.
      eapply IntMaps.lookup_member.
      unfold IntMaps.lookup.
      subst; cbn in *.
      eauto.
    }
  Qed.

  (* TODO: Move. Probably a better name for this. *)
  Lemma IntMap_find_NoOom_assoc_list' :
    forall {X Y} (l : list (IntMaps.IM.key * X)) (f : (IntMaps.IM.key * X) -> OOM (IntMaps.IM.key * Y)) m_elts (n : Z) (x : X),
      SetoidList.NoDupA (IntMaps.IM.eq_key (elt:=X)) l ->
      map_monad f l = NoOom m_elts ->
      (forall '(ix, x) '(ix', y), f (ix, x) = NoOom (ix', y) -> ix = ix') ->
      SetoidList.findA (IntMaps.IP.F.eqb n) l = Some x ->
      exists y,
        IntMaps.IM.find (elt:=Y) n (IntMaps.IP.of_list m_elts) = Some y /\
          NoOom (n, y) = f (n, x).
  Proof.
    induction l; intros f m_elts n x NODUP HMAPM F FIND.
    - cbn in *.
      inv HMAPM.
      cbn in *.
      inv FIND.
    - cbn in *.
      break_match_hyp; inv HMAPM.
      break_match_hyp; inv H0.
      break_match_hyp; inv H1.

      rename k into a_k.
      rename x0 into a_v.
      destruct p as [p_k p_v].
      pose proof (F (a_k, a_v) (p_k, p_v) Heqo); subst.
      Opaque IntMaps.IM.find.
      Opaque IntMaps.IM.add.
      cbn in *.
      break_match_hyp.
      + (* New element *)
        inv FIND.
        unfold IntMaps.IP.F.eqb in Heqb.
        break_match_hyp; inv Heqb.
        exists p_v.
        split; auto.
        unfold IntMaps.IP.uncurry.
        cbn.
        rewrite IntMaps.IP.F.add_eq_o; cbn; auto.
      + (* Old element *)
        inversion NODUP; subst.
        rename H1 into NIN.
        rename H2 into NODUP'.

        unfold IntMaps.IP.F.eqb in Heqb.
        break_match_hyp; inv Heqb.

        unfold IntMaps.IP.uncurry.
        rewrite IntMaps.IP.F.add_neq_o; cbn; auto.
  Qed.

  (* TODO: Move. Probably a better name for this. *)
  Lemma IntMap_find_NoOom_elements' :
    forall {X Y} (m : IntMaps.IM.t X) (f : (IntMaps.IM.key * X) -> OOM (IntMaps.IM.key * Y)) m_elts (n : Z) (x : X),
      map_monad f (IntMaps.IM.elements (elt:=X) m) = NoOom m_elts ->
      (forall '(ix, x) '(ix', y), f (ix, x) = NoOom (ix', y) -> ix = ix') ->
      IntMaps.IM.find (elt:=X) n m = Some x ->
      exists y,
        IntMaps.IM.find (elt:=Y) n (IntMaps.IP.of_list m_elts) = Some y /\
          NoOom (n, y) = f (n, x).
  Proof.
    intros X Y m f m_elts n x HMAPM F FIND.

    pose proof IntMaps.IP.F.elements_o.
    setoid_rewrite H.
    epose proof IntMap_find_NoOom_assoc_list' (IntMaps.IM.elements (elt:=X) m) f m_elts n x.
    forward H0.
    {
      apply IntMaps.IM.elements_3w.
    }
    specialize (H0 HMAPM F).
    forward H0.
    {
      rewrite <- H; auto.
    }

    destruct H0 as [y [FINDY RES]].
    exists y.
    split; auto.

    rewrite <- IntMaps.IP.F.elements_o; auto.
  Qed.

  Lemma fin_inf_allocations_preserved :
    forall ms_fin ms_inf ms_fin' ms_inf',
      MemState_refine_prop ms_inf ms_fin ->
      MemState_refine_prop ms_inf' ms_fin' ->
      Memory64BitIntptr.MMEP.MemSpec.allocations_preserved ms_fin ms_fin' ->
      MemoryBigIntptr.MMEP.MemSpec.allocations_preserved ms_inf ms_inf'.
  Proof.
    intros ms_fin ms_inf ms_fin' ms_inf' REF REF' ALLOCS_PRESERVED.
    red.
    intros ptr aid.
    split; intros BYTE_ALLOCATED.
    - destruct (InfToFinAddrConvert.addr_convert ptr) eqn:PTRCONV.
      + eapply fin_inf_byte_allocated; eauto.
        red in ALLOCS_PRESERVED.
        eapply ALLOCS_PRESERVED.
        eapply inf_fin_byte_allocated; eauto.
      + (* This should be a contradiction based on ptr / BYTE_ALLOCATED *)
        exfalso.
        eapply inf_fin_big_address_byte_not_allocated.
        apply REF.
        all: eauto.
    - destruct (InfToFinAddrConvert.addr_convert ptr) eqn:PTRCONV.
      + eapply fin_inf_byte_allocated; eauto.
        red in ALLOCS_PRESERVED.
        eapply ALLOCS_PRESERVED.
        eapply inf_fin_byte_allocated; eauto.
      + (* This should be a contradiction based on ptr / BYTE_ALLOCATED *)
        exfalso.
        eapply inf_fin_big_address_byte_not_allocated.
        apply REF'.
        all: eauto.
  Qed.

  Lemma inf_fin_allocations_preserved :
    forall ms_fin ms_inf ms_fin' ms_inf',
      MemState_refine_prop ms_inf ms_fin ->
      MemState_refine_prop ms_inf' ms_fin' ->
      MemoryBigIntptr.MMEP.MemSpec.allocations_preserved ms_inf ms_inf' ->
      Memory64BitIntptr.MMEP.MemSpec.allocations_preserved ms_fin ms_fin'.
  Proof.
    intros ms_fin ms_inf ms_fin' ms_inf' REF REF' ALLOCS_PRESERVED.
    red.
    intros ptr aid.
    split; intros BYTE_ALLOCATED.
    - red in ALLOCS_PRESERVED.
      eapply fin_inf_byte_allocated in BYTE_ALLOCATED; eauto.
      2: apply addr_refine_fin_to_inf_addr.
      eapply ALLOCS_PRESERVED in BYTE_ALLOCATED.
      eapply inf_fin_byte_allocated; eauto.
      apply addr_refine_fin_to_inf_addr.
    - red in ALLOCS_PRESERVED.
      eapply fin_inf_byte_allocated in BYTE_ALLOCATED; eauto.
      2: apply addr_refine_fin_to_inf_addr.
      eapply ALLOCS_PRESERVED in BYTE_ALLOCATED.
      eapply inf_fin_byte_allocated; eauto.
      apply addr_refine_fin_to_inf_addr.
  Qed.

  Lemma inf_frame_eqv_empty_l :
    forall f,
      MemoryBigIntptr.MMEP.MMSP.frame_eqv [] f ->
      f = [].
  Proof.
    intros f EQV.
    destruct f; auto.
    red in  EQV.
    specialize (EQV a).
    destruct EQV.
    forward H0; cbn; auto.
    red in H0.
    cbn in H0.
    contradiction.
  Qed.

  Lemma inf_frame_eqv_empty_r :
    forall f,
      MemoryBigIntptr.MMEP.MMSP.frame_eqv f [] ->
      f = [].
  Proof.
    intros f EQV.
    symmetry in EQV.
    apply inf_frame_eqv_empty_l.
    auto.
  Qed.


  (*
    This version may not be true.
   *)
  (*
  Lemma find_ptr_to_int_lift_Heap_gen :
    forall h ptr b,
      IntMaps.IM.find ptr (lift_Heap h) = Some (lift_Block b) ->
        (IntMaps.IM.find ptr h) = Some b.
  Proof.
    intros.
    unfold lift_Heap in H.
    apply IntMaps.IP.F.find_mapsto_iff in H.
    apply IntMaps.IP.F.find_mapsto_iff.
    apply IntMaps.IP.F.map_mapsto_iff in H.
    destruct H as [x [EQ HX]].
    apply MapsTo_filter_dom_true in HX.
  Qed.
  *)

  (* TODO: Move this *)
  Lemma memory_stack_frame_stack_prop_lift :
    forall ms_fin fs_fin,
      FinMem.MMEP.MMSP.memory_stack_frame_stack_prop ms_fin fs_fin ->
      InfMem.MMEP.MMSP.memory_stack_frame_stack_prop (lift_memory_stack ms_fin) (lift_FrameStack fs_fin).
  Proof.
    intros ms_fin fs_fin FSP.
    red in FSP; red.
    destruct ms_fin.
    cbn in *.
    apply frame_stack_eqv_lift.
    auto.
  Qed.

  (* TODO: Move this *)
  Lemma frame_stack_preserved_lift_MemState :
    forall ms_fin ms_fin',
      FinMem.MMEP.MemSpec.frame_stack_preserved ms_fin ms_fin' ->
      InfMem.MMEP.MemSpec.frame_stack_preserved (lift_MemState ms_fin) (lift_MemState ms_fin').
  Proof.
    intros ms_fin ms_fin' FSP.
    red in FSP; red.
    destruct ms_fin, ms_fin'; cbn in *.
    intros fs.
    split; intros MSFSP.
    - red; red in MSFSP.
      red in FSP.
      rewrite <- MSFSP.
      destruct ms_memory_stack, ms_memory_stack0; cbn in *.
      apply frame_stack_eqv_lift.
      eapply FSP.
      red; cbn.
      reflexivity.
    - red; red in MSFSP.
      red in FSP.
      rewrite <- MSFSP.
      destruct ms_memory_stack, ms_memory_stack0; cbn in *.
      apply frame_stack_eqv_lift.
      eapply FSP.
      red; cbn.
      reflexivity.
  Qed.

  (* Lemma fin_inf_root_in_heap_prop_lift : *)
  (*   forall h root, *)
  (*     (exists fin_root, (fin_to_inf_addr fin_root) = root /\ FinMem.MMEP.MMSP.root_in_heap_prop h fin_root) <-> *)
  (*       InfMem.MMEP.MMSP.root_in_heap_prop (lift_Heap h) root. *)
  (* Proof. *)
  (*   intros h root. *)
  (*   unfold FinMem.MMEP.MMSP.root_in_heap_prop. *)
  (*   unfold InfMem.MMEP.MMSP.root_in_heap_prop. *)
  (*   split; intros. *)
  (*   - destruct H as [fin_root [HEQ H]]. *)
  (*     rewrite member_lift_Heap. *)
  (*     rewrite <- HEQ. *)
  (*     rewrite fin_to_inf_addr_ptr_to_int. *)
  (*     assumption. *)
  (*   - apply member_lift_Heap in H. *)
  (*     unfold FinMem.MMEP.MMSP.Heap in *. *)

  (*     apply (IntMap_member_map_keys_eq id) in H. *)
  (*     destruct root. *)
  (*     unfold LLVMParamsBigIntptr.PTOI.ptr_to_int in *. *)
  (*     cbn in H. *)
  (*     unfold FinAddr.addr. *)
  (*     unfold FiniteAddresses.Iptr. unfold Iptr in i. *)
  (* Admitted. *)

  (* Lemma memory_stack_heap_prop_lift : *)
  (*   forall ms_fin h_fin, *)
  (*     FinMem.MMEP.MMSP.memory_stack_heap_prop ms_fin h_fin -> *)
  (*     InfMem.MMEP.MMSP.memory_stack_heap_prop (lift_memory_stack ms_fin) (lift_Heap h_fin). *)
  (* Proof. *)
  (*   intros ms_fin h_fin MSH. *)
  (*   red in MSH; red. *)
  (*   destruct ms_fin. *)
  (*   cbn in *. *)
  (* Admitted. *)


  (* TODO: Move this *)
  Lemma heap_preserved_lift_MemState :
    forall ms_fin ms_fin',
      FinMem.MMEP.MemSpec.heap_preserved ms_fin ms_fin' ->
      InfMem.MMEP.MemSpec.heap_preserved (lift_MemState ms_fin) (lift_MemState ms_fin').
  Proof.
    intros ms_fin ms_fin' HP.
    red in HP.
    red.
    destruct ms_fin, ms_fin'; cbn in *.
    intros h.
    split; intros MSFSP.
    - destruct ms_memory_stack, ms_memory_stack0.
      unfold InfMem.MMEP.MMSP.memory_stack_heap_prop in *.
      unfold FinMem.MMEP.MMSP.memory_stack_heap_prop in *.
      cbn in *.
      rewrite <- MSFSP.
      eapply Heap_eqv_lift.
      eapply HP.
      red. cbn.
      reflexivity.
    - destruct ms_memory_stack, ms_memory_stack0.
      unfold InfMem.MMEP.MMSP.memory_stack_heap_prop in *.
      unfold FinMem.MMEP.MMSP.memory_stack_heap_prop in *.
      cbn in *.
      rewrite <- MSFSP.
      eapply Heap_eqv_lift.
      eapply HP.
      red; cbn.
      reflexivity.
  Qed.

  Lemma heap_preserved_lift_MemState' :
    forall ms_fin ms_fin',
      InfMem.MMEP.MemSpec.heap_preserved (lift_MemState ms_fin) (lift_MemState ms_fin') ->
      FinMem.MMEP.MemSpec.heap_preserved ms_fin ms_fin'.
  Proof.
    intros ms_fin ms_fin' HP.
    red in HP.
    red.
    destruct ms_fin, ms_fin'; cbn in *.
    intros h.
    split; intros MSFSP.
    - destruct ms_memory_stack, ms_memory_stack0.
      unfold InfMem.MMEP.MMSP.memory_stack_heap_prop in *.
      unfold FinMem.MMEP.MMSP.memory_stack_heap_prop in *.
      cbn in *.
      rewrite <- MSFSP.
      eapply Heap_eqv_lift'.
      eapply HP.
      red; cbn.
      reflexivity.
    - destruct ms_memory_stack, ms_memory_stack0.
      unfold InfMem.MMEP.MMSP.memory_stack_heap_prop in *.
      unfold FinMem.MMEP.MMSP.memory_stack_heap_prop in *.
      cbn in *.
      rewrite <- MSFSP.
      eapply Heap_eqv_lift'.
      eapply HP.
      red; cbn.
      reflexivity.
  Qed.



  Lemma convert_Frame_cons :
    forall ptr f,
      convert_Frame (ptr :: f) = a' <- InfToFinAddrConvert.addr_convert ptr;; f' <- convert_Frame f;; ret (a' :: f').
  Proof.
    intros ptr f.
    cbn.
    break_match; auto.
  Qed.

  (* Lemma frame_eqv_cons_cons : *)
  (*   forall f1 f2 a, *)
  (*     (* This isn't true... f1 could have no a, but f2 could already have an a... UGGGH. *) *)
  (*     Memory64BitIntptr.MMEP.MMSP.frame_eqv (a :: f1) (a :: f2) -> *)
  (*     Memory64BitIntptr.MMEP.MMSP.frame_eqv f1 f2. *)
  (* Proof. *)
  (* Abort. *)


  (* Lemma convert_Frame_eqv_cons_rev : *)
  (*   forall {f_inf f_fin a_inf a_fin f_fin'}, *)
  (*     convert_Frame f_inf = NoOom f_fin -> *)
  (*     InfToFinAddrConvert.addr_convert a_inf = NoOom a_fin -> *)
  (*     Memory64BitIntptr.MMEP.MMSP.frame_eqv (a_fin :: f_fin') f_fin -> *)
  (*     exists f_inf' f_fin'', *)
  (*       MemoryBigIntptr.MMEP.MMSP.frame_eqv (a_inf :: f_inf') f_inf /\ *)
  (*         convert_Frame f_inf' = NoOom f_fin'' /\ *)
  (*         Memory64BitIntptr.MMEP.MMSP.frame_eqv f_fin' f_fin''. *)
  (* Proof. *)
  (*   intros f_inf f_fin a_inf a_fin f_fin' CONV ADDR_CONV EQV. *)

  (*   Lemma convert_Frame_eqv_rev : *)
  (*   forall {f_fin' f_inf f_fin}, *)
  (*     convert_Frame f_inf = NoOom f_fin -> *)
  (*     Memory64BitIntptr.MMEP.MMSP.frame_eqv f_fin f_fin' -> *)
  (*     exists f_inf', convert_Frame f_inf' = NoOom f_fin'. *)
  (*   Proof. *)
  (*     induction f_fin'; intros f_inf f_fin CONV EQV. *)
  (*     - inv CONV. *)
  (*       exists []. *)
  (*       apply frame_eqv_empty_r in EQV. *)
  (*       subst. *)
  (*       reflexivity. *)
  (*     - assert (exists a_inf, InfToFinAddrConvert.addr_convert a_inf = NoOom a) as ADDR_CONV. *)
  (*       { *)
  (*         destruct (InfITOP.int_to_ptr (FinPTOI.ptr_to_int a) (FinPROV.address_provenance a)) eqn:PTR. *)
  (*         - exists a0. *)
  (*           unfold InfToFinAddrConvert.addr_convert. *)
  (*           destruct a0. *)
  (*           cbn in *. *)
  (*           inv PTR. *)
  (*           apply LLVMParams64BitIntptr.ITOP.int_to_ptr_ptr_to_int; auto. *)
  (*         - pose proof InfITOP_BIG.int_to_ptr_safe (FinPTOI.ptr_to_int a) (FinPROV.address_provenance a). *)
  (*           rewrite PTR in H. *)
  (*           contradiction. *)
  (*       } *)
  (*       destruct ADDR_CONV as [a_inf ADDR_CONV]. *)

  (*       assert (exists f_inf', convert_Frame f_inf' = NoOom f_fin') as (f_inf' & FINF). *)
  (*       { *)
  (*         (* Because of EQV I know that every element in *)
   (*            f_fin' is also an element of f_fin... *)

   (*            If something is an element of f_fin, then there *)
   (*            exists a convertible infinite element. *)
   (*          *) *)
  (*         admit. *)
  (*       } *)

  (*       exists (a_inf :: f_inf'). *)
  (*       rewrite convert_Frame_cons. *)
  (*       rewrite ADDR_CONV. *)
  (*       rewrite FINF. *)
  (*       cbn. *)
  (*       reflexivity. *)
  (*   Admitted. *)

  (*   symmetry in EQV. *)
  (*   pose proof convert_Frame_eqv_rev CONV EQV as (f_inf' & CONV'). *)
  (*   exists f_inf'. exists (a_fin :: f_fin'). *)
  (*   split; [|split]; auto. *)
  (*   symmetry; auto. *)
  (* Qed. *)

  (* TODO: Move this to frame library *)
  Lemma frame_eqv_cons :
    forall a f1 f2,
      MemoryBigIntptr.MMEP.MMSP.frame_eqv f1 f2 ->
      MemoryBigIntptr.MMEP.MMSP.frame_eqv (a :: f1) (a :: f2).
  Proof.
    intros a f1 f2 H.
    rewrite H.
    reflexivity.
  Qed.

  (*
  Lemma convert_Frame_cons_rev :
    forall f_inf f_fin a_fin ,
      convert_Frame f_inf = NoOom (a_fin :: f_fin) ->
      exists f_inf' a_inf,
        f_inf = a_inf :: f_inf' /\
          InfToFinAddrConvert.addr_convert a_inf = NoOom a_fin.
  Proof.
    destruct f_inf; intros f_fin a_fin CONV.
    - cbn in CONV.
      inv CONV.
    - rewrite convert_Frame_cons in CONV.
      cbn in CONV.
      break_match_hyp; inv CONV.
      break_match_hyp; inv H0.
      exists f_inf. exists a.
      split; auto.
  Qed.

  Lemma frame_eqv_Add :
    forall {a f1 f2},
      Memory64BitIntptr.MMEP.MMSP.frame_eqv (a :: f1) f2 ->
      exists f, Add a f f2.
  Proof.
  Admitted.

  Lemma convert_Frame_eqv_rev :
    forall f_inf f_inf' f_fin f_fin',
      convert_Frame f_inf = NoOom f_fin ->
      convert_Frame f_inf' = NoOom f_fin' ->
      Memory64BitIntptr.MMEP.MMSP.frame_eqv f_fin f_fin' ->
      MemoryBigIntptr.MMEP.MMSP.frame_eqv f_inf f_inf'.
  Proof.
    induction f_inf; intros f_inf' f_fin f_fin' H H0 H1.
    - cbn in *.
      inv H.

      apply frame_eqv_empty_l in H1; subst.
      destruct f_inf'; [reflexivity|].
      cbn in H0.
      break_match_hyp; inv H0.
      break_match_hyp; inv H1.
    - rewrite convert_Frame_cons in H.
      cbn in H.
      break_match_hyp; inv H.
      break_match_hyp; inv H3.

      (* Want to pull out the 'a' from f_inf'

             f_inf' â‰ˆ a :: f_inf''

             Order may be different >:C.

             exists f_inf'', Add a f_inf' f_inf''
       *)

      pose proof frame_eqv_Add H1 as [f' ADD].

      induction ADD.
      + pose proof H0.
        apply convert_Frame_cons_rev in H0.
        destruct H0 as (?&?&?&?).
        subst.
        rewrite convert_Frame_cons in H.
        cbn in H.
        rewrite H2 in H.
        break_match_hyp; inv H.

        eapply IHf_inf in Heqo1; auto.
        rewrite Heqo1.
        --
          assert (LLVMParamsBigIntptr.PTOI.ptr_to_int a = LLVMParamsBigIntptr.PTOI.ptr_to_int x0).
          { erewrite <- fin_inf_ptoi; [|exact Heqo].
            erewrite <- fin_inf_ptoi; [|exact H2].
            auto.
          }

          red. cbn.
          rewrite H.
          tauto.
        -- (* pose proof convert_Frame_eqv_cons_rev H0 Heqo H1 as (f_inf'' & f_fin'' & EQV1 & CONV & EQV2). *)
          (* rewrite <- EQV1. *)

          (* apply frame_eqv_cons. *)
          (* eapply IHf_inf; auto; eauto. *)

          (* (* QED *) *)

          (* eauto. *)
          (* reflexivity. *)
          (* red. *)
          (* rewrite EQV *)

          (* (* Probably want to use this *) *)
          (* (* Add_inv: forall [A : Type] (a : A) (l : list A), In a l -> exists l' : list A, Add a l' l *) *)

          (* (* TODO: Move this to MMSP or something *) *)
          (* Lemma frame_eqv_cons_l : *)
          (*   forall f' f a, *)
          (*     Memory64BitIntptr.MMEP.MMSP.frame_eqv (a :: f) f' -> *)
          (*     exists f'', *)
          (*       Memory64BitIntptr.MMEP.MMSP.frame_eqv f' (a :: f'') /\ *)
          (*         Memory64BitIntptr.MMEP.MMSP.frame_eqv f f''. *)
          (* Proof. *)
          (*   induction f'; intros f ptr EQV. *)
          (*   - apply frame_eqv_empty_r in EQV. *)
          (*     inv EQV. *)
  (*   - (* Unknown whether a = ptr... *)

   (*        If a = ptr, then f'' = f', and we're done. *)
   (*      *) *)
          (*     pose proof (FinLP.ADDR.eq_dec a ptr) as [EQ | NEQ]; subst. *)
          (*     + exists f'. *)
          (*       split; try reflexivity. *)
          (*       (* I guess I don't know if ptr is duplicated in ONE of f / f'... *) *)
          (* Admitted. *)

          (* apply frame_eqv_cons_l in H1. *)
          (* destruct H1 as (?&?&?). *)

          (* symmetry in H. *)
          (* apply frame_eqv_cons_l in H. *)
          (* destruct H as (?&?&?). *)

          (* rewrite <- H1 in H. *)
  Admitted.

  Lemma convert_FrameStack_eqv_rev :
    forall fs_inf fs_inf' fs_fin fs_fin',
      convert_FrameStack fs_inf = NoOom fs_fin ->
      convert_FrameStack fs_inf' = NoOom fs_fin' ->
      Memory64BitIntptr.MMEP.MMSP.frame_stack_eqv fs_fin fs_fin' ->
      MemoryBigIntptr.MMEP.MMSP.frame_stack_eqv fs_inf fs_inf'.
  Proof.
    induction fs_inf; intros fs_inf' fs_fin fs_fin' FS1 FS2 EQV.
    - cbn in FS1.
      break_match_hyp; inv FS1.
      apply Memory64BitIntptr.MMEP.MMSP.frame_stack_inv in EQV as [EQV | EQV].
      {
        destruct EQV as (?&?&?&?&?&?&?&?).
        inv H.
      }

      destruct EQV as (?&?&?&?&?).
      subst.

      destruct fs_inf'.
      2: {
        cbn in FS2.
        break_match_hyp; inv FS2.
        break_match_hyp; inv H2.
      }

      cbn in FS2.
      break_match_hyp; inv FS2.
      inv H.
  Admitted.
  *)

  Lemma fin_inf_frame_stack_preserved :
    forall ms_fin ms_inf ms_fin' ms_inf',
      MemState_refine_prop ms_inf ms_fin ->
      MemState_refine_prop ms_inf' ms_fin' ->
      Memory64BitIntptr.MMEP.MemSpec.frame_stack_preserved ms_fin ms_fin' ->
      MemoryBigIntptr.MMEP.MemSpec.frame_stack_preserved ms_inf ms_inf'.
  Proof.
    intros ms_fin ms_inf ms_fin' ms_inf' REF REF' FSP_FIN.

    apply MemState_refine_prop_frame_stack_preserved in REF, REF'.
    red in REF, REF', FSP_FIN.
    red.

    intros fs.
    split; intros FSP_INF.
    - red. red in FSP_INF.
      rewrite <- FSP_INF.
      apply REF'.
      red.
      symmetry.
      apply REF.

      pose proof frame_stack_preserved_lift_MemState ms_fin ms_fin'.
      forward H; auto.
      red in H.
      apply H.

      destruct ms_fin', ms_memory_stack; cbn.
      red. cbn.
      reflexivity.
    - red. red in FSP_INF.
      rewrite <- FSP_INF.
      apply REF.
      red.
      symmetry.
      apply REF'.

      pose proof frame_stack_preserved_lift_MemState ms_fin ms_fin'.
      forward H; auto.
      red in H.
      apply H.

      destruct ms_fin, ms_memory_stack; cbn.
      red. cbn.
      reflexivity.
  Qed.

  Lemma inf_fin_frame_stack_preserved :
    forall ms_fin ms_inf ms_fin' ms_inf',
      MemState_refine_prop ms_inf ms_fin ->
      MemState_refine_prop ms_inf' ms_fin' ->
      MemoryBigIntptr.MMEP.MemSpec.frame_stack_preserved ms_inf ms_inf' ->
      Memory64BitIntptr.MMEP.MemSpec.frame_stack_preserved ms_fin ms_fin'.
  Proof.
    intros ms_fin ms_inf ms_fin' ms_inf' REF REF' FSP_INF.

    apply MemState_refine_prop_frame_stack_preserved in REF, REF'.
    red in REF, REF', FSP_INF.
    red.

    destruct ms_fin as [[ms_fin fss_fin hs_fin] msprovs_fin].
    destruct ms_inf as [[ms_inf fss_inf hs_inf] msprovs_inf].
    destruct ms_fin' as [[ms_fin' fss_fin' hs_fin'] msprovs_fin'].
    destruct ms_inf' as [[ms_inf' fss_inf' hs_inf'] msprovs_inf'].

    intros fs.
    split; intros FSP_FIN.
    - red. red in FSP_FIN.
      cbn in *.
      unfold InfMem.MMEP.MMSP.memory_stack_frame_stack_prop in *.
      cbn in *.
      rewrite <- FSP_FIN.
      apply frame_stack_eqv_lift_inf_fin.
      apply REF'.
      red; cbn.
      symmetry.
      apply REF.
      apply FSP_INF.
      red; cbn.
      reflexivity.
    - red. red in FSP_FIN.
      cbn in *.
      unfold InfMem.MMEP.MMSP.memory_stack_frame_stack_prop in *.
      cbn in *.
      rewrite <- FSP_FIN.
      apply frame_stack_eqv_lift_inf_fin.
      apply REF.
      red; cbn.
      symmetry.
      apply REF'.
      apply FSP_INF.
      red; cbn.
      reflexivity.
  Qed.

  (* TODO: Move this *)
  Lemma convert_FrameStack_Snoc_equation :
    forall fs f,
      convert_FrameStack (MemoryBigIntptr.MMEP.MMSP.Snoc fs f) =
        f' <- convert_Frame f;;
        fs' <- convert_FrameStack fs;;
        ret (Memory64BitIntptr.MMEP.MMSP.Snoc fs' f').
  Proof.
    intros fs.
    induction fs; intros f'; cbn; auto.
  Qed.

  (* TODO: Move this *)
  Lemma convert_FrameStack_snoc :
    forall {fs_inf f_inf fs_fin f_fin},
      convert_FrameStack fs_inf = NoOom fs_fin ->
      convert_Frame f_inf = NoOom f_fin ->
      convert_FrameStack (MemoryBigIntptr.MMEP.MMSP.Snoc fs_inf f_inf) = NoOom (Memory64BitIntptr.MMEP.MMSP.Snoc fs_fin f_fin).
  Proof.
    intros fs_inf f_inf fs_fin f_fin FS F.
    rewrite convert_FrameStack_Snoc_equation.
    rewrite F, FS.
    cbn.
    reflexivity.
  Qed.

  (* SAZ TODO: try these *)
  Lemma fin_inf_heap_preserved :
    forall ms_fin ms_inf ms_fin' ms_inf',
      MemState_refine_prop ms_inf ms_fin ->
      MemState_refine_prop ms_inf' ms_fin' ->
      Memory64BitIntptr.MMEP.MemSpec.heap_preserved ms_fin ms_fin' ->
      MemoryBigIntptr.MMEP.MemSpec.heap_preserved ms_inf ms_inf'.
  Proof.
    intros ms_fin ms_inf ms_fin' ms_inf' REF REF' HP.
    apply MemState_refine_prop_heap_preserved in REF, REF'.
    red.
    intros h.
    split; intros HP_INF.
    - red. red in HP_INF.
      rewrite <- HP_INF.
      red in REF, REF'.
      unfold InfMem.MMEP.MMSP.memory_stack_heap_prop in REF'.
      apply REF'.
      red; cbn.
      symmetry.
      apply REF.
      red.

      pose proof heap_preserved_lift_MemState ms_fin ms_fin'.
      apply H.
      + assumption.
      + red. reflexivity.
    - red. red in HP_INF.
      rewrite <- HP_INF.
      red in REF, REF'.
      unfold InfMem.MMEP.MMSP.memory_stack_heap_prop in REF'.
      apply REF.
      red.
      symmetry.
      apply REF'.

      pose proof heap_preserved_lift_MemState ms_fin ms_fin'.
      apply H.
      + assumption.
      + red. reflexivity.
  Qed.

  Lemma inf_fin_heap_preserved :
    forall ms_fin ms_inf ms_fin' ms_inf',
      MemState_refine_prop ms_inf ms_fin ->
      MemState_refine_prop ms_inf' ms_fin' ->
      MemoryBigIntptr.MMEP.MemSpec.heap_preserved ms_inf ms_inf' ->
      Memory64BitIntptr.MMEP.MemSpec.heap_preserved ms_fin ms_fin'.
  Proof.
    intros ms_fin ms_inf ms_fin' ms_inf' MSR1 MSR2 PRES.
    apply MemState_refine_prop_heap_preserved in MSR1, MSR2.
    eapply heap_preserved_lift_MemState'.
    rewrite <- MSR1, <- MSR2.
    eauto.
  Qed.

  Lemma MemState_refine_prop_read_byte_allowed_all_preserved :
    forall ms_inf ms_fin,
      MemState_refine_prop ms_inf ms_fin ->
      InfMem.MMEP.MemSpec.read_byte_allowed_all_preserved ms_inf (lift_MemState ms_fin).
  Proof.
    intros ms_inf ms_fin MSR.
    do 2 red in MSR.
    tauto.
  Qed.

  Lemma fin_inf_read_byte_allowed_all_preserved :
    forall ms_fin ms_inf ms_fin' ms_inf',
      MemState_refine_prop ms_inf ms_fin ->
      MemState_refine_prop ms_inf' ms_fin' ->
      Memory64BitIntptr.MMEP.MemSpec.read_byte_allowed_all_preserved ms_fin ms_fin' ->
      MemoryBigIntptr.MMEP.MemSpec.read_byte_allowed_all_preserved ms_inf ms_inf'.
  Proof.
    intros ms_fin ms_inf ms_fin' ms_inf' REF REF' RBA.
    red.
    intros h.
    split; intros HP_INF.
    - red. red in HP_INF.
      destruct HP_INF as [aid [HA1 HA2]].
      pose proof inf_fin_byte_allocated_exists _ _ _ _ REF HA1.
      destruct H as (addr_fin & CONV & ALLOC_FIN).

      red in RBA.
      specialize (RBA addr_fin).
      destruct RBA as [RBA _].
      forward RBA.
      { red.
        exists aid.
        split; eauto.
        eapply inf_fin_access_allowed; eauto.
      }

      destruct RBA as (aid'&ALLOC&ACCESS).
      exists aid'. split; auto.
      eapply fin_inf_byte_allocated; eauto.
      eapply fin_inf_access_allowed; eauto.
    - red. red in HP_INF.
      destruct HP_INF as [aid [HA1 HA2]].
      pose proof inf_fin_byte_allocated_exists _ _ _ _ REF' HA1.
      destruct H as (addr_fin & CONV & ALLOC_FIN).

      red in RBA.
      specialize (RBA addr_fin).
      destruct RBA as [_ RBA].
      forward RBA.
      { red.
        exists aid.
        split; eauto.
        eapply inf_fin_access_allowed; eauto.
      }

      destruct RBA as (aid'&ALLOC&ACCESS).
      exists aid'. split; auto.
      eapply fin_inf_byte_allocated; eauto.
      eapply fin_inf_access_allowed; eauto.
  Qed.

  Lemma inf_fin_read_byte_allowed_all_preserved :
    forall ms_fin ms_inf ms_fin' ms_inf',
      MemState_refine_prop ms_inf ms_fin ->
      MemState_refine_prop ms_inf' ms_fin' ->
      MemoryBigIntptr.MMEP.MemSpec.read_byte_allowed_all_preserved ms_inf ms_inf' ->
      Memory64BitIntptr.MMEP.MemSpec.read_byte_allowed_all_preserved ms_fin ms_fin'.
  Proof.
    intros ms_fin ms_inf ms_fin' ms_inf' REF REF' RBA.
    red.
    intros h.
    split; intros HP_INF.
    - red. red in HP_INF.
      destruct HP_INF as [aid [HA1 HA2]].
      pose proof fin_inf_byte_allocated_exists _ _ _ _ REF HA1.
      destruct H as (addr_fin & CONV & ALLOC_FIN).

      red in RBA.
      specialize (RBA addr_fin).
      destruct RBA as [RBA _].
      forward RBA.
      { red.
        exists aid.
        split; eauto.
        eapply fin_inf_access_allowed; eauto.
      }

      destruct RBA as (aid'&ALLOC&ACCESS).
      exists aid'. split; auto.
      eapply inf_fin_byte_allocated; eauto.
      eapply inf_fin_access_allowed; eauto.
    - red. red in HP_INF.
      destruct HP_INF as [aid [HA1 HA2]].
      pose proof fin_inf_byte_allocated_exists _ _ _ _ REF' HA1.
      destruct H as (addr_fin & CONV & ALLOC_FIN).

      red in RBA.
      specialize (RBA addr_fin).
      destruct RBA as [_ RBA].
      forward RBA.
      { red.
        exists aid.
        split; eauto.
        eapply fin_inf_access_allowed; eauto.
      }

      destruct RBA as (aid'&ALLOC&ACCESS).
      exists aid'. split; auto.
      eapply inf_fin_byte_allocated; eauto.
      eapply inf_fin_access_allowed; eauto.
  Qed.

    (* SAZ: TODO - look at this one next *)
  Lemma fin_inf_read_byte_prop_all_preserved :
    forall ms_fin ms_inf ms_fin' ms_inf',
      MemState_refine_prop ms_inf ms_fin ->
      MemState_refine_prop ms_inf' ms_fin' ->
      Memory64BitIntptr.MMEP.MemSpec.read_byte_prop_all_preserved ms_fin ms_fin' ->
      MemoryBigIntptr.MMEP.MemSpec.read_byte_prop_all_preserved ms_inf ms_inf'.
  Proof.
    intros ms_fin ms_inf ms_fin' ms_inf' REF REF' RBP.
    red.
    intros ptr byte.
    split; intros RBP_INF.
    - pose proof inf_fin_read_byte_prop_exists REF RBP_INF as
        (addr_fin & byte_fin & RBP_FIN & ADDR_REF & BYTE_REF).

      apply RBP in RBP_FIN.
      eapply fin_inf_read_byte_prop; eauto.
    - pose proof inf_fin_read_byte_prop_exists REF' RBP_INF as
        (addr_fin & byte_fin & RBP_FIN & ADDR_REF & BYTE_REF).

      apply RBP in RBP_FIN.
      eapply fin_inf_read_byte_prop; eauto.
  Qed.

    (* SAZ: TODO - look at this one next *)
  Lemma fin_inf_write_byte_allowed_all_preserved :
    forall ms_fin ms_inf ms_fin' ms_inf',
      MemState_refine_prop ms_inf ms_fin ->
      MemState_refine_prop ms_inf' ms_fin' ->
      Memory64BitIntptr.MMEP.MemSpec.write_byte_allowed_all_preserved ms_fin ms_fin' ->
      MemoryBigIntptr.MMEP.MemSpec.write_byte_allowed_all_preserved ms_inf ms_inf'.
  Proof.
    intros ms_fin ms_inf ms_fin' ms_inf' REF REF' WBAP.
    red.
    intros ptr.
    split; intros WBA_INF.
    - pose proof inf_fin_write_byte_allowed_exists _ _ _ REF WBA_INF
        as (addr_fin & WBA_FIN & ADDR_REF).

      apply WBAP in WBA_FIN.
      eapply fin_inf_write_byte_allowed; eauto.
    - pose proof inf_fin_write_byte_allowed_exists _ _ _ REF' WBA_INF
        as (addr_fin & WBA_FIN & ADDR_REF).

      apply WBAP in WBA_FIN.
      eapply fin_inf_write_byte_allowed; eauto.
  Qed.

  Lemma inf_fin_write_byte_allowed_all_preserved :
    forall ms_fin ms_inf ms_fin' ms_inf',
      MemState_refine_prop ms_inf ms_fin ->
      MemState_refine_prop ms_inf' ms_fin' ->
      MemoryBigIntptr.MMEP.MemSpec.write_byte_allowed_all_preserved ms_inf ms_inf' ->
      Memory64BitIntptr.MMEP.MemSpec.write_byte_allowed_all_preserved ms_fin ms_fin'.
  Proof.
    intros ms_fin ms_inf ms_fin' ms_inf' REF REF' WBAP.
    red.
    intros ptr.
    split; intros WBA_INF.
    - red in WBAP.
      eapply fin_inf_write_byte_allowed in WBA_INF; eauto.
      2: apply addr_refine_fin_to_inf_addr.
      apply WBAP in WBA_INF.
      pose proof inf_fin_write_byte_allowed_exists _ _ _ REF' WBA_INF
        as (addr_fin & WBA_FIN & ADDR_REF).
      unfold addr_refine in *.
      rewrite addr_refine_fin_to_inf_addr in ADDR_REF.
      inv ADDR_REF.
      eauto.
    - red in WBAP.
      eapply fin_inf_write_byte_allowed in WBA_INF; eauto.
      2: apply addr_refine_fin_to_inf_addr.
      apply WBAP in WBA_INF.
      pose proof inf_fin_write_byte_allowed_exists _ _ _ REF WBA_INF
        as (addr_fin & WBA_FIN & ADDR_REF).
      unfold addr_refine in *.
      rewrite addr_refine_fin_to_inf_addr in ADDR_REF.
      inv ADDR_REF.
      eauto.
  Qed.

    (* SAZ: TODO - look at this one next *)
  Lemma fin_inf_free_byte_allowed_all_preserved :
    forall ms_fin ms_inf ms_fin' ms_inf',
      MemState_refine_prop ms_inf ms_fin ->
      MemState_refine_prop ms_inf' ms_fin' ->
      Memory64BitIntptr.MMEP.MemSpec.free_byte_allowed_all_preserved ms_fin ms_fin' ->
      MemoryBigIntptr.MMEP.MemSpec.free_byte_allowed_all_preserved ms_inf ms_inf'.
  Proof.
    eapply fin_inf_write_byte_allowed_all_preserved.
  Qed.

  Lemma inf_fin_free_byte_allowed_all_preserved :
    forall ms_fin ms_inf ms_fin' ms_inf',
      MemState_refine_prop ms_inf ms_fin ->
      MemState_refine_prop ms_inf' ms_fin' ->
      MemoryBigIntptr.MMEP.MemSpec.free_byte_allowed_all_preserved ms_inf ms_inf' ->
      Memory64BitIntptr.MMEP.MemSpec.free_byte_allowed_all_preserved ms_fin ms_fin'.
  Proof.
    eapply inf_fin_write_byte_allowed_all_preserved.
  Qed.

  Lemma used_provenance_prop_lift :
    forall ms_fin p,
      InfMem.MMEP.MMSP.used_provenance_prop (lift_MemState ms_fin) p <->
      Memory64BitIntptr.MMEP.MMSP.used_provenance_prop ms_fin p.
  Proof.
    intros ms_fin p.
    split; intros UP.
    - red; red in UP.
      destruct ms_fin.
      cbn in *.
      unfold LLVMParams64BitIntptr.PROV.provenance_lt,
        LLVMParamsBigIntptr.PROV.provenance_lt in *.
      auto.
    - red; red in UP.
      destruct ms_fin.
      cbn in *.
      unfold LLVMParams64BitIntptr.PROV.provenance_lt,
        LLVMParamsBigIntptr.PROV.provenance_lt in *.
      auto.
  Qed.

  Lemma inf_fin_used_provenance_prop :
    forall ms_inf ms_fin p,
      MemState_refine_prop ms_inf ms_fin ->
      MemoryBigIntptr.MMEP.MMSP.used_provenance_prop ms_inf p ->
      Memory64BitIntptr.MMEP.MMSP.used_provenance_prop ms_fin p.
  Proof.
    intros ms_inf ms_fin p MSR UP.
    destruct MSR.
    apply H in UP.
    apply used_provenance_prop_lift; auto.
  Qed.

  Lemma fin_inf_used_provenance_prop :
    forall ms_inf ms_fin p,
      MemState_refine_prop ms_inf ms_fin ->
      Memory64BitIntptr.MMEP.MMSP.used_provenance_prop ms_fin p ->
      MemoryBigIntptr.MMEP.MMSP.used_provenance_prop ms_inf p.
  Proof.
    intros ms_inf ms_fin p MSR UP.
    destruct MSR.
    apply H.
    apply used_provenance_prop_lift; auto.
  Qed.

  Lemma fin_inf_preserve_allocation_ids :
    forall ms_fin ms_inf ms_fin' ms_inf',
      MemState_refine_prop ms_inf ms_fin ->
      MemState_refine_prop ms_inf' ms_fin' ->
      Memory64BitIntptr.MMEP.MemSpec.preserve_allocation_ids ms_fin ms_fin' ->
      MemoryBigIntptr.MMEP.MemSpec.preserve_allocation_ids ms_inf ms_inf'.
  Proof.
    intros ms_fin ms_inf ms_fin' ms_inf' REF REF' PAIDS.
    red; red in PAIDS.
    intros p.
    specialize (PAIDS p).
    destruct PAIDS.
    split; intros UP_INF.
    - eapply inf_fin_used_provenance_prop in UP_INF; eauto.
      eapply H in UP_INF.
      eapply fin_inf_used_provenance_prop; eauto.
    - eapply inf_fin_used_provenance_prop in UP_INF; eauto.
      eapply H0 in UP_INF.
      eapply fin_inf_used_provenance_prop; eauto.
  Qed.

  Lemma inf_fin_preserve_allocation_ids :
    forall ms_fin ms_inf ms_fin' ms_inf',
      MemState_refine_prop ms_inf ms_fin ->
      MemState_refine_prop ms_inf' ms_fin' ->
      MemoryBigIntptr.MMEP.MemSpec.preserve_allocation_ids ms_inf ms_inf' ->
      Memory64BitIntptr.MMEP.MemSpec.preserve_allocation_ids ms_fin ms_fin'.
  Proof.
    intros ms_fin ms_inf ms_fin' ms_inf' REF REF' PAIDS.
    red; red in PAIDS.
    intros p.
    specialize (PAIDS p).
    destruct PAIDS.
    split; intros UP_FIN.
    - eapply fin_inf_used_provenance_prop in UP_FIN; eauto.
      eapply H in UP_FIN.
      eapply inf_fin_used_provenance_prop; eauto.
    - eapply fin_inf_used_provenance_prop in UP_FIN; eauto.
      eapply H0 in UP_FIN.
      eapply inf_fin_used_provenance_prop; eauto.
  Qed.

  #[global] Hint Resolve
    lift_MemState_refine_prop
    fin_inf_allocations_preserved
    inf_fin_allocations_preserved
    fin_inf_frame_stack_preserved
    inf_fin_frame_stack_preserved
    fin_inf_heap_preserved
    inf_fin_heap_preserved
    fin_inf_read_byte_allowed_all_preserved
    inf_fin_read_byte_allowed_all_preserved
    fin_inf_write_byte_allowed_all_preserved
    inf_fin_write_byte_allowed_all_preserved
    fin_inf_free_byte_allowed_all_preserved
    inf_fin_free_byte_allowed_all_preserved
    fin_inf_preserve_allocation_ids
    inf_fin_preserve_allocation_ids
    fin_inf_read_byte_prop_all_preserved
    : FinInf.

  Lemma fin_inf_read_byte_preserved :
    forall {ms_fin ms_inf ms_fin' ms_inf'},
      MemState_refine_prop ms_inf ms_fin ->
      MemState_refine_prop ms_inf' ms_fin' ->
      Memory64BitIntptr.MMEP.MemSpec.read_byte_preserved ms_fin ms_fin' ->
      MemoryBigIntptr.MMEP.MemSpec.read_byte_preserved ms_inf ms_inf'.
  Proof.
    intros ms_fin ms_inf ms_fin' ms_inf' MSR1 MSR2 READ.
    destruct READ.
    split; eauto with FinInf.
  Qed.

  Lemma fin_inf_write_byte_operation_invariants :
    forall addr_inf addr_fin ms_fin ms_inf ms_fin' ms_inf',
      MemState_refine_prop ms_inf ms_fin ->
      MemState_refine_prop ms_inf' ms_fin' ->
      InfToFinAddrConvert.addr_convert addr_inf = NoOom addr_fin ->
      Memory64BitIntptr.MMEP.MemSpec.write_byte_operation_invariants ms_fin ms_fin' ->
      MemoryBigIntptr.MMEP.MemSpec.write_byte_operation_invariants ms_inf ms_inf'.
  Proof.
    intros addr_inf addr_fin ms_fin ms_inf ms_fin' ms_inf' REF REF' CONV INV.
    destruct INV.
    split; eauto with FinInf.
  Qed.

  Lemma inf_fin_write_byte_operation_invariants :
    forall addr_inf addr_fin ms_fin ms_inf ms_fin' ms_inf',
      MemState_refine_prop ms_inf ms_fin ->
      MemState_refine_prop ms_inf' ms_fin' ->
      InfToFinAddrConvert.addr_convert addr_inf = NoOom addr_fin ->
      MemoryBigIntptr.MMEP.MemSpec.write_byte_operation_invariants ms_inf ms_inf' ->
      Memory64BitIntptr.MMEP.MemSpec.write_byte_operation_invariants ms_fin ms_fin'.
  Proof.
    intros addr_inf addr_fin ms_fin ms_inf ms_fin' ms_inf' REF REF' CONV INV.
    destruct INV.
    split; eauto with FinInf.
  Qed.

  Hint Resolve
    fin_inf_read_byte_preserved
    fin_inf_write_byte_operation_invariants
    : FinInf.

  (* TODO: Delete *)
  (* Lemma write_byte_spec_MemPropT_Heap_in_bounds : *)
  (*   forall ms_fin ms_fin' addr_fin byte_fin res_fin, *)
  (*     Heap_in_bounds ms_fin -> *)
  (*     Memory64BitIntptr.MMEP.MemSpec.write_byte_spec_MemPropT addr_fin byte_fin *)
  (*       ms_fin *)
  (*       (ret (ms_fin', res_fin)) -> *)
  (*     Heap_in_bounds ms_fin'. *)
  (* Proof. *)
  (*   intros ms_fin ms_fin' addr_fin byte_fin res_fin H H0. *)
  (*   unfold Heap_in_bounds in *. *)
  (*   intros. *)
  (*   specialize (H i). *)
  (*   apply H. *)
  (*   unfold Memory64BitIntptr.MMEP.MemSpec.write_byte_spec_MemPropT in H0. *)
  (*   red in H0. cbn in H0. *)
  (*   (* should follow from write_byte_spec ? *) *)
  (* Admitted. *)

  Lemma fin_inf_write_byte_spec_MemPropT :
    forall {addr_fin addr_inf ms_fin ms_fin' ms_inf byte_inf byte_fin res_fin},
      (* TODO - QUESTION - which should be declared in bounds and which should be derived to be.
         SAZ: I think that Heap_in_bounds ms_fin' should be implied by
              write_byte_spec_MemPropT
       *)
      MemState_refine_prop ms_inf ms_fin ->
      InfToFinAddrConvert.addr_convert addr_inf = NoOom addr_fin ->
      sbyte_refine byte_inf byte_fin ->
      Memory64BitIntptr.MMEP.MemSpec.write_byte_spec_MemPropT addr_fin byte_fin
        ms_fin
        (ret (ms_fin', res_fin)) ->
      exists res_inf ms_inf',
        MemoryBigIntptr.MMEP.MemSpec.write_byte_spec_MemPropT addr_inf byte_inf ms_inf (ret (ms_inf', res_inf)) /\
          res_inf = res_fin /\
          MemState_refine_prop ms_inf' ms_fin'.
  Proof.
    intros addr_fin addr_inf ms_fin ms_fin' ms_inf byte_inf byte_fin [] MSR ADDR_CONV BYTE_REF WBP.
    destruct WBP.

    pose proof fin_inf_set_byte_memory MSR ADDR_CONV BYTE_REF byte_written as (ms_inf' & SET_INF & MSR').

    exists tt. exists ms_inf'.
    split; auto.

    split; auto.
    - eapply fin_inf_write_byte_allowed; eauto.
    - eapply fin_inf_write_byte_operation_invariants; eauto.
  Qed.

  Lemma fin_inf_write_byte_spec :
    forall {addr_fin addr_inf ms_fin ms_fin' ms_inf byte_fin},
      MemState_refine_prop ms_inf ms_fin ->
      InfToFinAddrConvert.addr_convert addr_inf = NoOom addr_fin ->
      Memory64BitIntptr.MMEP.MemSpec.write_byte_spec ms_fin addr_fin byte_fin ms_fin' ->
      exists byte_inf ms_inf',
        MemoryBigIntptr.MMEP.MemSpec.write_byte_spec ms_inf addr_inf byte_inf ms_inf' /\
          sbyte_refine byte_inf byte_fin /\
          MemState_refine_prop ms_inf' ms_fin'.
  Proof.
    intros addr_fin addr_inf ms_fin ms_fin' ms_inf byte_fin MSR ADDR_CONV WBP.

    destruct WBP.

    pose proof (sbyte_refine_lifted byte_fin) as BYTE_REF.
    exists (lift_SByte byte_fin).
    pose proof fin_inf_set_byte_memory MSR ADDR_CONV BYTE_REF byte_written as (ms_inf' & SET_INF & MSR').

    exists ms_inf'.
    split; auto.

    split; auto.
    - eapply fin_inf_write_byte_allowed; eauto.
    - eapply fin_inf_write_byte_operation_invariants; eauto.
  Qed.

  (* TODO: Move this *)
  Lemma get_consecutive_ptrs_0_is_nil :
    forall ms ms' ptr res,
      @InfMem.MMEP.MemSpec.MemHelpers.get_consecutive_ptrs
        (MemPropT InfMem.MMEP.MMSP.MemState)
        (@MemPropT_Monad InfMem.MMEP.MMSP.MemState)
        (@MemPropT_RAISE_OOM InfMem.MMEP.MMSP.MemState)
        (@MemPropT_RAISE_ERROR InfMem.MMEP.MMSP.MemState)
        ptr 0 ms (success_unERR_UB_OOM (ms', res)) ->
      res = [].
  Proof.
    intros ms ms' ptr res GCP.
    Transparent InfMem.MMEP.MemSpec.MemHelpers.get_consecutive_ptrs.
    unfold InfMem.MMEP.MemSpec.MemHelpers.get_consecutive_ptrs in GCP.
    Opaque InfMem.MMEP.MemSpec.MemHelpers.get_consecutive_ptrs.

    cbn in *.
    destruct GCP as (?&?&(?&?)&?&?&?&?); subst.
    cbn in *.
    destruct H1; subst.
    cbn in *.
    destruct H2; subst.
    auto.
  Qed.

  (* TODO: Move this *)
  Lemma map_monad_MemPropT_length :
    forall {S A B} {l} {f : A -> MemPropT S B} {s1 s2 res},
      @map_monad (MemPropT S) (@MemPropT_Monad S)
        A B f l s1 (success_unERR_UB_OOM (s2, res)) ->
      length res = length l.
  Proof.
    intros S A B l.
    induction l; intros f s1 s2 res HMAPM.
    cbn in *.
    destruct HMAPM; subst; auto.

    rewrite map_monad_unfold in HMAPM.
    cbn in HMAPM.
    destruct HMAPM as (?&?&?&?&?&?&?&?).
    subst.
    apply IHl in H0.
    cbn.
    auto.
  Qed.

  (* TODO: Move this *)
  Lemma zip_cons :
    forall {X Y} (x : X) xs (y : Y) ys,
      zip (x :: xs) (y :: ys) = (x, y) :: zip xs ys.
  Proof.
    intros X Y x xs y ys.
    cbn.
    auto.
  Qed.

  (* TODO: Move this *)
  Lemma Forall2_zip :
    forall {X Y Z W} (xs : list X) (ys : list Y) (zs : list Z) (ws : list W) XY ZW,
      Forall2 XY xs ys ->
      Forall2 ZW zs ws ->
      Forall2 (fun '(x, z) '(y, w) => XY x y /\ ZW z w) (zip xs zs) (zip ys ws).
  Proof.
    intros X Y Z W xs ys zs ws XY ZW FXY FZW.
    revert zs ws ZW FZW.
    induction FXY; intros zs ws ZW FZW.
    - cbn. constructor.
    - destruct FZW.
      + cbn. constructor.
      + cbn.
        constructor; auto.
        apply IHFXY; eauto.
  Qed.

  (* TODO: Move this *)
  Lemma sbytes_refine_length :
    forall bytes_inf bytes_fin,
      sbytes_refine bytes_inf bytes_fin ->
      length bytes_inf = length bytes_fin.
  Proof.
    intros bytes_inf bytes_fin H.
    red in H.
    eapply Util.Forall2_length; eauto.
  Qed.

  Lemma fin_inf_write_bytes_spec :
    forall a_fin a_inf ms_fin ms_fin' ms_inf bytes_inf bytes_fin res_fin,
      InfToFinAddrConvert.addr_convert a_inf = NoOom a_fin ->
      MemState_refine_prop ms_inf ms_fin ->
      sbytes_refine bytes_inf bytes_fin ->
      Memory64BitIntptr.MMEP.MemSpec.write_bytes_spec a_fin bytes_fin ms_fin (success_unERR_UB_OOM (ms_fin', res_fin)) ->
      exists res_inf ms_inf',
        MemoryBigIntptr.MMEP.MemSpec.write_bytes_spec a_inf bytes_inf ms_inf (success_unERR_UB_OOM (ms_inf', res_inf)) /\
          res_inf = res_fin /\
          MemState_refine_prop ms_inf' ms_fin'.
  Proof.
    intros a_fin a_inf ms_fin ms_fin' ms_inf bytes_inf bytes_fin res_fin ADDR_CONV MEM_REF1 BYTES_REF WRITE_SPEC.

    (* TODO: Make these opaque earlier *)
    Opaque Memory64BitIntptr.MMEP.MemSpec.MemHelpers.get_consecutive_ptrs.
    Opaque MemoryBigIntptr.MMEP.MemSpec.MemHelpers.get_consecutive_ptrs.

    eapply MemPropT_fin_inf_bind.
    4: {
      apply WRITE_SPEC.
    }
    all: eauto.

    { (* MA *)
      intros a_fin0 ms_fin_ma H.
      eapply fin_inf_get_consecutive_ptrs_success_exists; eauto.
      erewrite sbytes_refine_length; eauto.
      apply H.
    }

    intros ms_inf0 ms_fin0 ms_fin'0 a_fin0 a_inf0 b_fin ADDRS MSR WRITES.
    eapply MemPropT_fin_inf_bind with
      (A_REF := Forall2 eq).
    all: eauto.

    { (* MA *)
      intros a_fin1 ms_fin_ma MAP.
      eapply MemPropT_fin_inf_map_monad with
        (A_REF := (fun '(a_inf, byte_inf) '(a_fin, byte_fin) =>
                     InfToFinAddrConvert.addr_convert a_inf = NoOom a_fin /\
                       sbyte_refine byte_inf byte_fin)).
      4: apply MAP.
      all: eauto.

      { intros a_fin2 a_inf1 b_fin0 ms_fin1 ms_inf1 ms_fin_ma0 MSR' A_REF WRITE.
        destruct a_fin2, a_inf1.
        destruct A_REF.
        eapply fin_inf_write_byte_spec_MemPropT; eauto.
      }

      cbn in ADDRS.

      apply Forall2_zip; eauto.
      apply Forall2_flip in ADDRS.
      apply ADDRS.
    }

    intros ms_inf1 ms_fin1 ms_fin'1 a_fin1 a_inf1 b_fin0 H H0 H1.
    cbn.
    do 2 eexists; split; eauto.
    destruct b_fin0; split; auto.
    cbn in H1.
    destruct H2; subst; auto.
  Qed.

  (* TODO: Move near gcp in memory model... Maybe near get_consecutive_ptrs_no_ub *)
  Lemma get_consecutive_ptrs_never_fails :
    forall ptr sz ms msg,
      Memory64BitIntptr.MMEP.MemSpec.MemHelpers.get_consecutive_ptrs (M:=(MemPropT Memory64BitIntptr.MMEP.MMSP.MemState)) ptr sz ms (raise_error msg) -> False.
  Proof.
    intros ptr sz ms msg ERR.
    Transparent Memory64BitIntptr.MMEP.MemSpec.MemHelpers.get_consecutive_ptrs.
    unfold Memory64BitIntptr.MMEP.MemSpec.MemHelpers.get_consecutive_ptrs in ERR.
    Opaque Memory64BitIntptr.MMEP.MemSpec.MemHelpers.get_consecutive_ptrs.
    repeat red in ERR.
    destruct ERR as [ERR | ERR].
    - red in ERR.
      break_match_hyp_inv.
    - destruct ERR as (?&?&?&ERR).
      repeat red in ERR.
      destruct ERR as [ERR | ERR].
      { red in ERR.
        break_match_hyp_inv.
        exfalso.
        apply map_monad_err_fail in Heqs.
        destruct Heqs as (?&?&GEP).
        cbn in GEP.
        inv GEP.
      }

      destruct ERR as (?&?&GCP&ERR).
      red in ERR.
      break_match_hyp_inv.
  Qed.

  Lemma get_consecutive_ptrs_never_ubs :
    forall ptr sz ms msg,
      Memory64BitIntptr.MMEP.MemSpec.MemHelpers.get_consecutive_ptrs (M:=(MemPropT Memory64BitIntptr.MMEP.MMSP.MemState)) ptr sz ms (raise_ub msg) -> False.
  Proof.
    intros ptr sz ms msg GCP.
    eapply withinify in GCP.

    assert ((@fmap err_ub_oom (@Functor_err_ub_oom IdentityMonad.ident IdentityMonad.Monad_ident)
               (Memory64BitIntptr.MMEP.MMSP.MemState * list LLVMParams64BitIntptr.ADDR.addr)
               (list LLVMParams64BitIntptr.ADDR.addr)
               (@snd Memory64BitIntptr.MMEP.MMSP.MemState (list LLVMParams64BitIntptr.ADDR.addr))
               (@raise_ub err_ub_oom
                  (@RAISE_UB_err_ub_oom_T IdentityMonad.ident IdentityMonad.Monad_ident)
                  (Memory64BitIntptr.MMEP.MMSP.MemState * list LLVMParams64BitIntptr.ADDR.addr) msg)) = raise_ub msg) as EQ by (cbn; auto).
    rewrite EQ in GCP.
    eapply FinLLVM.MEM.MMEP.MemSpec.MemHelpers.get_consecutive_ptrs_no_ub in GCP; auto.
  Qed.

  (* TODO: Move this *)
  Lemma fin_inf_get_consecutive_ptrs_ub :
    forall a_fin a_inf ms_fin ms_inf n_fin n_inf msg_fin msg_inf,
      Memory64BitIntptr.MMEP.MemSpec.MemHelpers.get_consecutive_ptrs (M:=(MemPropT Memory64BitIntptr.MMEP.MMSP.MemState)) a_fin n_fin ms_fin (raise_ub msg_fin) ->
      MemoryBigIntptr.MMEP.MemSpec.MemHelpers.get_consecutive_ptrs (M:=(MemPropT MemoryBigIntptr.MMEP.MMSP.MemState)) a_inf n_inf ms_inf (raise_ub msg_inf).
  Proof.
    intros a_fin a_inf ms_fin ms_inf n_fin n_inf msg_fin msg_inf H.
    eapply get_consecutive_ptrs_never_ubs in H.
    contradiction.
  Qed.

  #[global] Hint Resolve fin_inf_get_consecutive_ptrs_ub : FinInf.

  (* TODO: Move this *)
  Lemma fin_inf_get_consecutive_ptrs_error :
    forall a_fin a_inf ms_fin ms_inf n_fin n_inf msg_fin msg_inf,
      Memory64BitIntptr.MMEP.MemSpec.MemHelpers.get_consecutive_ptrs (M:=(MemPropT Memory64BitIntptr.MMEP.MMSP.MemState)) a_fin n_fin ms_fin (raise_error msg_fin) ->
      MemoryBigIntptr.MMEP.MemSpec.MemHelpers.get_consecutive_ptrs (M:=(MemPropT MemoryBigIntptr.MMEP.MMSP.MemState)) a_inf n_inf ms_inf (raise_error msg_inf).
  Proof.
    intros a_fin a_inf ms_fin ms_inf n_fin n_inf msg_fin msg_inf H.
    eapply get_consecutive_ptrs_never_fails in H.
    contradiction.
  Qed.

  #[global] Hint Resolve fin_inf_get_consecutive_ptrs_error : FinInf.

  Lemma fin_inf_read_byte_spec_MemPropT_ub :
    forall (addr_fin : LLVMParams64BitIntptr.ADDR.addr) (addr_inf : LLVMParamsBigIntptr.ADDR.addr)
      (ms_fin : FinMem.MMEP.MMSP.MemState) (ms_inf : InfMem.MMEP.MMSP.MemState)
      (msg : string),
      MemState_refine_prop ms_inf ms_fin ->
      addr_refine addr_inf addr_fin ->
      (fun ptr : LLVMParams64BitIntptr.ADDR.addr =>
         Memory64BitIntptr.MMEP.MemSpec.read_byte_spec_MemPropT ptr) addr_fin ms_fin
        (raise_ub msg) ->
      MemoryBigIntptr.MMEP.MemSpec.read_byte_spec_MemPropT addr_inf ms_inf (raise_ub msg).
  Proof.
    intros addr_fin addr_inf ms_fin ms_inf msg MSR ADDR_REF READ.
    cbn in *.
    intros CONTRA.
    eapply inf_fin_read_byte_allowed in CONTRA; eauto.
  Qed.

  #[global] Hint Resolve fin_inf_read_byte_spec_MemPropT_ub : FinInf.

  (* One iffy case is if ptr_fin is at the edge of memory, then
     /maybe/ the write could succeed in the infinite case, and walk off
     the edge in the finite case. This should be ruled out by the
     refinement between ms_inf_start and ms_fin_start, however.
   *)
  Lemma inf_fin_write_byte_spec_exists :
    forall {ms_inf_start ms_inf_final ms_fin_start ptr_inf ptr_fin byte_inf byte_fin},
      MemState_refine_prop ms_inf_start ms_fin_start ->
      sbyte_refine byte_inf byte_fin ->
      addr_refine ptr_inf ptr_fin ->
      MemoryBigIntptr.MMEP.MemSpec.write_byte_spec ms_inf_start ptr_inf byte_inf ms_inf_final ->
      exists ms_fin_final,
        Memory64BitIntptr.MMEP.MemSpec.write_byte_spec ms_fin_start ptr_fin byte_fin ms_fin_final /\
          addr_refine ptr_inf ptr_fin /\
          MemState_refine_prop ms_inf_final ms_fin_final.
  Proof.
    intros ms_inf_start ms_inf_final ms_fin_start ptr_inf ptr_fin byte_inf byte_fin MSR BYTES ADDR_REF WRITE.
    destruct WRITE.

    pose proof inf_fin_write_byte_allowed_exists _ _ _ MSR byte_write_succeeds.
    destruct H as (ptr_fin' & byte_write_succeeds_fin & REF).
    unfold addr_refine in REF.
    rewrite ADDR_REF in REF.
    symmetry in REF; inv REF.

    destruct (convert_MemState ms_inf_final) as [ms_fin_final | ] eqn:MS_FIN_FINAL.
    2: {
      exfalso.

      destruct ms_fin_start as [[ms_fin fss_fin hs_fin] msprovs_fin].
      destruct ms_inf_start as [[ms_inf fss_inf hs_inf] msprovs_inf].
      destruct ms_inf_final as [[ms_inf' fss_inf' hs_inf'] msprovs_inf'].

      unfold convert_MemState in MS_FIN_FINAL.
      cbn in MS_FIN_FINAL.
      repeat break_match_hyp_inv.
      { (* convert_Heap OOM *)
        (* This shouldn't happen because write_byte_spec does not touch the heap *)
        clear - Heqo Heqo2 Heqo1 MSR write_byte_invariants.
        destruct write_byte_invariants.

        apply MemState_refine_prop_heap_preserved in MSR.
        red in write_byte_op_preserves_heap, MSR.
        cbn in *.
        unfold MemoryBigIntptr.MMEP.MMSP.memory_stack_heap_prop,
          MemoryBigIntptr.MMEP.MMSP.memory_stack_frame_stack_prop in *.
        cbn in *.

        (* Block failed to convert, which means there's an out of
           bounds address in the block... *)
        apply map_monad_OOM_fail in Heqo2.
        destruct Heqo2 as ((root&block)&?&?).
        break_match_hyp_inv.

        apply map_monad_OOM_fail in Heqo0.
        destruct Heqo0 as (bad_addr&IN_BLOCK&BAD_CONV).

        (* IN_FIN should be a contradiction because lift_Heap should filter out bad elements *)

        destruct (MSR hs_inf) as [EQV _]; forward EQV; [red; cbn; reflexivity|].
        destruct (write_byte_op_preserves_heap hs_inf) as [EQV2 _]; forward EQV2; [red; cbn; reflexivity|].

        pose proof every_int_has_big_ptr root as (root_ptr&ROOT_PTR).
        pose proof ptr_in_heap_prop_intmap_elements_inf ROOT_PTR H IN_BLOCK as IN_HEAP.

        rewrite EQV2, <- EQV in IN_HEAP.
        apply ptr_in_heap_prop_lift_inv in IN_HEAP.
        destruct IN_HEAP as (root_fin & ptr_fin & ROOT_CONV & BAD_CONV' & IN_HEAP).
        rewrite BAD_CONV in BAD_CONV'.
        inv BAD_CONV'.
      }

      { (* convert_FrameStack OOM *)
        (* Framestack is preserved, so this shouldn't OOM *)
        apply MemState_refine_prop_frame_stack_preserved in MSR.
        red in MSR.
        destruct write_byte_invariants.
        clear - MSR write_byte_op_preserves_frame_stack Heqo.
        red in write_byte_op_preserves_frame_stack.
        cbn in *.
        unfold MemoryBigIntptr.MMEP.MemSpec.cannot_pop,
          MemoryBigIntptr.MMEP.MMSP.memory_stack_heap_prop,
          MemoryBigIntptr.MMEP.MMSP.memory_stack_frame_stack_prop in *.
        cbn in *.

        destruct (MSR fss_inf) as [EQV _]; forward EQV; [red; cbn; reflexivity|].
        destruct (write_byte_op_preserves_frame_stack fss_inf) as [EQV' _]; forward EQV'; [red; cbn; reflexivity|].
        red in EQV, EQV'.
        cbn in EQV, EQV'.

        rewrite <- EQV in EQV'.
        eapply convert_FrameStack_OOM in EQV'; eauto.
        destruct EQV'.
        pose proof convert_FrameStack_lift fss_fin.
        destruct H0 as (?&?&?).
        rewrite H in H0; discriminate.
      }

      { (* convert_memory OOM *)
        apply map_monad_OOM_fail in Heqo.
        destruct Heqo as ((addr&(byte&aid))&MEM_ELEMS&CONV).
        repeat break_match_hyp_inv.

        { (* convert_mem_byte OOM *)
          (* The byte can only be a byte from the previous memory
             (which is safe) or the newly written byte, which is also
             safe
           *)
          clear - MSR byte_written write_byte_invariants Heqo Heqo1 BYTES ADDR_REF MEM_ELEMS.
          rename Heqo into A.
          rename Heqo1 into CONV_BYTE.
          epose proof (@int_to_ptr_succeeds_regardless_of_provenance _ (FinPROV.allocation_id_to_prov aid) _ _ A).
          clear a A.
          destruct H as (a&A).

          pose proof fin_to_inf_addr_big_int_to_ptr _ _ _ A.
          pose proof (InfMem.MMEP.disjoint_ptr_byte_dec ptr_inf (fin_to_inf_addr a)) as [DISJOINT | NDISJOINT].
          { (* Pointers are disjoint, byte is the same as the old byte... *)
            destruct byte_written.
            specialize (old_lu _ DISJOINT byte).
            destruct old_lu.

            forward H1.
            { eapply In_memory_read_byte_inf; eauto.
            }

            eapply inf_fin_read_byte_spec_exists in H1; eauto.
            destruct H1 as (?&?&?&?&?).
            red in H2.
            setoid_rewrite CONV_BYTE in H2.
            discriminate.
          }

          { (* Pointers aren't disjoint, so byte = byte_inf *)
            destruct byte_written.
            eapply In_memory_read_byte_inf with (ms:={|
                                                       InfMemMMSP.ms_memory_stack :=
                                                         {|
                                                           InfMemMMSP.memory_stack_memory := ms_inf';
                                                           InfMemMMSP.memory_stack_frame_stack := fss_inf';
                                                           InfMemMMSP.memory_stack_heap := hs_inf'
                                                         |};
                                                       InfMemMMSP.ms_provenance := msprovs_inf'
                                                     |}) in MEM_ELEMS; eauto.
            destruct MEM_ELEMS.
            destruct new_lu.
            repeat red in read_byte_value.
            move read_byte_value0 before read_byte_value.
            repeat red in read_byte_value0.
            cbn in *.
            apply Classical_Prop.NNPP in NDISJOINT.
            rewrite <- NDISJOINT in read_byte_value.
            break_match_hyp; try contradiction.
            break_match_hyp; try contradiction.
            break_match_hyp; try contradiction.
            destruct m; cbn in *; subst; auto.
            rewrite BYTES in CONV_BYTE.
            discriminate.
          }
        }

        { (* Address conversion OOM *)
          (* May need to make sure this is in bounds *)
          (* If convert_memory OOMs on address conversion...

             That means there was an address allocated in the infinite
             memory that was out of the finite range...

             This should be a contradiction with MSR.
           *)
          destruct write_byte_invariants.
          assert (exists byte, In (addr, (byte, aid)) (IntMaps.IM.elements (elt:=InfMemMMSP.mem_byte) ms_inf)) as MEM_ELEMS'.
          { eapply @byte_allocate_In_memory_inf with
              (ms:={|
                     InfMemMMSP.ms_memory_stack :=
                       {|
                         InfMemMMSP.memory_stack_memory := ms_inf;
                         InfMemMMSP.memory_stack_frame_stack := fss_inf;
                         InfMemMMSP.memory_stack_heap := hs_inf
                       |};
                     InfMemMMSP.ms_provenance := msprovs_inf
                   |}); eauto.

            eapply In_memory_is_allocated_inf with
              (ms:={|
                     InfMemMMSP.ms_memory_stack :=
                       {|
                         InfMemMMSP.memory_stack_memory := ms_inf';
                         InfMemMMSP.memory_stack_frame_stack := fss_inf';
                         InfMemMMSP.memory_stack_heap := hs_inf'
                       |};
                     InfMemMMSP.ms_provenance := msprovs_inf'
                   |})
              in MEM_ELEMS; eauto.

            apply write_byte_op_preserves_allocations.
            eauto.
          }

          destruct MEM_ELEMS' as (byte' & IN_BOUNDS).
          eapply MemState_refine_prop_in_bounds
            with (ms_inf:=
                    {|
                      InfMemMMSP.ms_memory_stack :=
                        {|
                          InfMemMMSP.memory_stack_memory := ms_inf;
                          InfMemMMSP.memory_stack_frame_stack := fss_inf;
                          InfMemMMSP.memory_stack_heap := hs_inf
                        |};
                      InfMemMMSP.ms_provenance := msprovs_inf
                    |}) in IN_BOUNDS; cbn; eauto.

          unfold in_bounds in IN_BOUNDS.
          rewrite Heqo in IN_BOUNDS.
          discriminate.
        }
      }
    }

    pose proof convert_MemState_MemState_refine_prop ms_inf_final ms_fin_final MS_FIN_FINAL as MSR_FINAL.

    exists ms_fin_final.
    split; eauto.
    split; eauto.
    - eapply inf_fin_set_byte_memory; eauto.
    - eapply inf_fin_write_byte_operation_invariants; eauto.
      Unshelve.
      apply InfPROV.nil_prov.
  Qed.

  Lemma fin_inf_write_byte_spec_MemPropT_ub :
    forall (addr_fin : LLVMParams64BitIntptr.ADDR.addr) (addr_inf : LLVMParamsBigIntptr.ADDR.addr)
      (ms_fin : FinMem.MMEP.MMSP.MemState) (ms_inf : InfMem.MMEP.MMSP.MemState)
      byte_fin byte_inf
      (msg : string),
      MemState_refine_prop ms_inf ms_fin ->
      sbyte_refine byte_inf byte_fin ->
      addr_refine addr_inf addr_fin ->
      (fun ptr : LLVMParams64BitIntptr.ADDR.addr =>
         Memory64BitIntptr.MMEP.MemSpec.write_byte_spec_MemPropT ptr byte_fin) addr_fin ms_fin
        (raise_ub msg) ->
      MemoryBigIntptr.MMEP.MemSpec.write_byte_spec_MemPropT addr_inf byte_inf ms_inf (raise_ub msg).
  Proof.
    intros addr_fin addr_inf ms_fin ms_inf byte_fin byte_inf msg MSR BYTE_REF ADDR_REF WRITE.

    cbn in *.
    intros CONTRA.
    eapply inf_fin_write_byte_allowed in CONTRA; eauto.
  Qed.

  #[global] Hint Resolve fin_inf_write_byte_spec_MemPropT_ub : FinInf.

  Lemma fin_inf_write_byte_spec_MemPropT_error :
    forall (addr_fin : LLVMParams64BitIntptr.ADDR.addr) (addr_inf : LLVMParamsBigIntptr.ADDR.addr)
      (ms_fin : FinMem.MMEP.MMSP.MemState) (ms_inf : InfMem.MMEP.MMSP.MemState)
      byte_fin byte_inf
      (msg : string),
      MemState_refine_prop ms_inf ms_fin ->
      sbyte_refine byte_inf byte_fin ->
      addr_refine addr_inf addr_fin ->
      (fun ptr : LLVMParams64BitIntptr.ADDR.addr =>
         Memory64BitIntptr.MMEP.MemSpec.write_byte_spec_MemPropT ptr byte_fin) addr_fin ms_fin
        (raise_error msg) ->
      MemoryBigIntptr.MMEP.MemSpec.write_byte_spec_MemPropT addr_inf byte_inf ms_inf (raise_error msg).
  Proof.
    intros addr_fin addr_inf ms_fin ms_inf byte_fin byte_inf msg MSR BYTE_REF ADDR_REF WRITE.
    cbn in *; auto.
  Qed.

  #[global] Hint Resolve fin_inf_write_byte_spec_MemPropT_error : FinInf.

  (* TODO: Move this *)
  (* TODO: Can we make msg_fin / msg_inf work? *)
  Lemma fin_inf_read_bytes_spec_ub' :
    forall (a_fin : FinAddr.addr) (a_inf : InfAddr.addr) (n : nat)
      (ms_fin : FinMem.MMEP.MMSP.MemState) (ms_inf : InfMem.MMEP.MMSP.MemState)
      msg,
      InfToFinAddrConvert.addr_convert a_inf = NoOom a_fin ->
      MemState_refine_prop ms_inf ms_fin ->
      Memory64BitIntptr.MMEP.MemSpec.read_bytes_spec a_fin n ms_fin
        (raise_ub msg) ->
      MemoryBigIntptr.MMEP.MemSpec.read_bytes_spec a_inf n ms_inf
        (raise_ub msg).
  Proof.
    intros a_fin a_inf n ms_fin ms_inf msg CONV MSR READ.
    red; red in READ.
    eapply MemPropT_fin_inf_bind_ub.
    5: apply READ.
    all: eauto with FinInf.

    2: {
      intros ms_inf0 ms_fin0 ptrs_fin ptrs_inf msg' PTRS MSR' GCP READ'.
      eapply MemPropT_fin_inf_map_monad_ub.
      5: apply READ'.
      all: eauto with FinInf.
      intros a_fin0 a_inf0 b_fin ms_fin1 ms_inf1 ms_fin_ma H H0 H1.
      eapply fin_inf_read_byte_spec_MemPropT; eauto.
      apply H1.
    }

    intros a_fin0 ms_fin_ma GCP.
    eapply fin_inf_get_consecutive_ptrs_success_exists in GCP; eauto.
    destruct GCP as (addrs_inf & ms_inf' & GCP & ADDRS & MSR').
    exists addrs_inf. exists ms_inf'.
    split; auto.
    split; eauto.

    eapply Forall2_flip; eauto.

    Unshelve.
    all: eauto.
  Qed.

  Lemma fin_inf_read_bytes_spec_err :
    forall (a_fin : FinAddr.addr) (a_inf : InfAddr.addr) (n : nat)
      (ms_fin : FinMem.MMEP.MMSP.MemState) (ms_inf : InfMem.MMEP.MMSP.MemState)
      msg,
      InfToFinAddrConvert.addr_convert a_inf = NoOom a_fin ->
      MemState_refine_prop ms_inf ms_fin ->
      Memory64BitIntptr.MMEP.MemSpec.read_bytes_spec a_fin n ms_fin
        (raise_error msg) ->
      MemoryBigIntptr.MMEP.MemSpec.read_bytes_spec a_inf n ms_inf
        (raise_error msg).
  Proof.
    intros a_fin a_inf n ms_fin ms_inf msg CONV MSR READ.
    red; red in READ.
    eapply MemPropT_fin_inf_bind_error.
    5: apply READ.
    all: eauto with FinInf.

    2: {
      intros ms_inf0 ms_fin0 ptrs_fin ptrs_inf msg' PTRS MSR' GCP READ'.
      eapply MemPropT_fin_inf_map_monad_error.
      5: apply READ'.
      all: eauto with FinInf.
      intros a_fin0 a_inf0 b_fin ms_fin1 ms_inf1 ms_fin_ma H H0 H1.
      eapply fin_inf_read_byte_spec_MemPropT; eauto.
      apply H0.
      apply H1.
    }

    intros a_fin0 ms_fin_ma GCP.
    eapply fin_inf_get_consecutive_ptrs_success_exists in GCP; eauto.
    destruct GCP as (addrs_inf & ms_inf' & GCP & ADDRS & MSR').
    exists addrs_inf. exists ms_inf'.
    split; auto.
    split; eauto.

    eapply Forall2_flip; eauto.

    Unshelve.
    all: eauto.
  Qed.

  (* TODO: Move this to memory model so it applies for both infinite / finite *)
  (* TODO: Somewhat unclear if we should allow the messages to be distinct... *)
  (** If reading bytes at the source causes UB, then the memcpy contains UB *)
  Lemma memcpy_spec_read_ub :
    forall src_addr dst_addr len align volatile ms msg
      (READ: MemoryBigIntptr.MMEP.MemSpec.read_bytes_spec src_addr (Z.to_nat len) ms (raise_ub msg)),
      MemoryBigIntptr.MMEP.MemSpec.memcpy_spec src_addr dst_addr len align volatile ms (raise_ub msg).
  Proof.
    intros src_addr dst_addr len align volatile ms msg READ.
    repeat red.
    break_match; [cbn; auto|].
    break_match; [|cbn; auto].
    left; auto.
  Qed.

  Lemma fin_inf_write_bytes_spec_ub :
    forall a_fin a_inf ms_fin ms_inf bytes_inf bytes_fin msg,
      InfToFinAddrConvert.addr_convert a_inf = NoOom a_fin ->
      MemState_refine_prop ms_inf ms_fin ->
      sbytes_refine bytes_inf bytes_fin ->
      Memory64BitIntptr.MMEP.MemSpec.write_bytes_spec a_fin bytes_fin ms_fin (raise_ub msg) ->
      MemoryBigIntptr.MMEP.MemSpec.write_bytes_spec a_inf bytes_inf ms_inf (raise_ub msg).
  Proof.
    intros a_fin a_inf ms_fin ms_inf bytes_inf bytes_fin msg ADDR_CONV MEM_REF1 BYTES_REF WRITE_SPEC.

    (* TODO: Make these opaque earlier *)
    Opaque Memory64BitIntptr.MMEP.MemSpec.MemHelpers.get_consecutive_ptrs.
    Opaque MemoryBigIntptr.MMEP.MemSpec.MemHelpers.get_consecutive_ptrs.

    red; red in WRITE_SPEC.

    eapply MemPropT_fin_inf_bind_ub.
    5: apply WRITE_SPEC.
    all: eauto with FinInf.

    { (* MA *)
      intros a_fin0 ms_fin_ma H.
      eapply fin_inf_get_consecutive_ptrs_success_exists; eauto.
      erewrite sbytes_refine_length; eauto.
      apply H.
    }

    intros ms_inf0 ms_fin0 a_fin0 a_inf0 msg0 ADDRS MSR GCP WRITES.

    eapply MemPropT_fin_inf_bind_ub with
      (A_REF := Forall2 eq).
    5: apply WRITES.
    all: eauto with FinInf.

    { (* MA *)
      intros a_fin1 ms_fin_ma MAP.
      eapply MemPropT_fin_inf_map_monad with
        (A_REF := (fun '(a_inf, byte_inf) '(a_fin, byte_fin) =>
                     InfToFinAddrConvert.addr_convert a_inf = NoOom a_fin /\
                       sbyte_refine byte_inf byte_fin)).
      4: apply MAP.
      all: eauto.

      { intros a_fin2 a_inf1 b_fin0 ms_fin1 ms_inf1 ms_fin_ma0 MSR' A_REF WRITE.
        destruct a_fin2, a_inf1.
        destruct A_REF.
        eapply fin_inf_write_byte_spec_MemPropT; eauto.
      }

      cbn in ADDRS.

      apply Forall2_zip; eauto.
      apply Forall2_flip in ADDRS.
      apply ADDRS.
    }

    intros msg1 MAP.
    eapply MemPropT_fin_inf_map_monad_ub with
      (A_REF := (fun '(a_inf, byte_inf) '(a_fin, byte_fin) =>
                   InfToFinAddrConvert.addr_convert a_inf = NoOom a_fin /\
                     sbyte_refine byte_inf byte_fin)).
    5: apply MAP.
    all: eauto with FinInf.

    2: {
      intros a_fin1 a_inf1 ms_fin1 ms_inf1 msg2 H H0 H1.
      destruct a_inf1, a_fin1.
      destruct H0.
      eapply fin_inf_write_byte_spec_MemPropT_ub; eauto.
    }

    2: {
      eapply Forall2_zip; eauto.
      eapply Forall2_flip; eauto.
    }

    intros a_fin1 a_inf1 b_fin ms_fin1 ms_inf1 ms_fin_ma H H0 H1.
    destruct a_inf1, a_fin1.
    destruct H0.
    eapply fin_inf_write_byte_spec_MemPropT; eauto.

    Unshelve.
    all: exact ms_fin.
  Qed.

  Lemma fin_inf_write_bytes_spec_error :
    forall a_fin a_inf ms_fin ms_inf bytes_inf bytes_fin msg,
      InfToFinAddrConvert.addr_convert a_inf = NoOom a_fin ->
      MemState_refine_prop ms_inf ms_fin ->
      sbytes_refine bytes_inf bytes_fin ->
      Memory64BitIntptr.MMEP.MemSpec.write_bytes_spec a_fin bytes_fin ms_fin (raise_error msg) ->
      MemoryBigIntptr.MMEP.MemSpec.write_bytes_spec a_inf bytes_inf ms_inf (raise_error msg).
  Proof.
    intros a_fin a_inf ms_fin ms_inf bytes_inf bytes_fin msg ADDR_CONV MEM_REF1 BYTES_REF WRITE_SPEC.

    (* TODO: Make these opaque earlier *)
    Opaque Memory64BitIntptr.MMEP.MemSpec.MemHelpers.get_consecutive_ptrs.
    Opaque MemoryBigIntptr.MMEP.MemSpec.MemHelpers.get_consecutive_ptrs.

    red; red in WRITE_SPEC.

    eapply MemPropT_fin_inf_bind_error.
    5: apply WRITE_SPEC.
    all: eauto with FinInf.

    { (* MA *)
      intros a_fin0 ms_fin_ma H.
      eapply fin_inf_get_consecutive_ptrs_success_exists; eauto.
      erewrite sbytes_refine_length; eauto.
      apply H.
    }

    intros ms_inf0 ms_fin0 a_fin0 a_inf0 msg0 ADDRS MSR GCP WRITES.

    eapply MemPropT_fin_inf_bind_error with
      (A_REF := Forall2 eq).
    5: apply WRITES.
    all: eauto with FinInf.

    { (* MA *)
      intros a_fin1 ms_fin_ma MAP.
      eapply MemPropT_fin_inf_map_monad with
        (A_REF := (fun '(a_inf, byte_inf) '(a_fin, byte_fin) =>
                     InfToFinAddrConvert.addr_convert a_inf = NoOom a_fin /\
                       sbyte_refine byte_inf byte_fin)).
      4: apply MAP.
      all: eauto.

      { intros a_fin2 a_inf1 b_fin0 ms_fin1 ms_inf1 ms_fin_ma0 MSR' A_REF WRITE.
        destruct a_fin2, a_inf1.
        destruct A_REF.
        eapply fin_inf_write_byte_spec_MemPropT; eauto.
      }

      cbn in ADDRS.

      apply Forall2_zip; eauto.
      apply Forall2_flip in ADDRS.
      apply ADDRS.
    }

    intros msg1 MAP.
    eapply MemPropT_fin_inf_map_monad_error with
      (A_REF := (fun '(a_inf, byte_inf) '(a_fin, byte_fin) =>
                   InfToFinAddrConvert.addr_convert a_inf = NoOom a_fin /\
                     sbyte_refine byte_inf byte_fin)).
    5: apply MAP.
    all: eauto with FinInf.

    2: {
      intros a_fin1 a_inf1 ms_fin1 ms_inf1 msg2 H H0 H1.
      destruct a_inf1, a_fin1.
      destruct H0.
      eapply fin_inf_write_byte_spec_MemPropT_error; eauto.
    }

    2: {
      eapply Forall2_zip; eauto.
      eapply Forall2_flip; eauto.
    }

    intros a_fin1 a_inf1 b_fin ms_fin1 ms_inf1 ms_fin_ma H H0 H1.
    destruct a_inf1, a_fin1.
    destruct H0.
    eapply fin_inf_write_byte_spec_MemPropT; eauto.

    Unshelve.
    all: exact ms_fin.
  Qed.

  (* TODO: Move this to somewhere it can
     be instantiated for all memory model
     instances
   *)
  Lemma read_bytes_spec_MemState_eq :
    forall a sz ms ms' res,
      Memory64BitIntptr.MMEP.MemSpec.read_bytes_spec a sz ms (ret (ms', res)) ->
      ms = ms'.
  Proof.
    intros a sz ms ms' res READ.
    red in READ.
    cbn in *.
    destruct READ as [sab [a0 [GCP HMAPM]]].
    apply Memory64BitIntptr.MMEP.get_consecutive_ptrs_MemPropT_MemState_eq in GCP. subst.
    generalize dependent res.
    induction a0; intros res HMAPM.
    - cbn in *.
      destruct HMAPM; subst; auto.
    - rewrite map_monad_unfold in HMAPM.
      cbn in *.
      destruct HMAPM as [sab0 [a' [[MS READ] HMAPM]]]; subst.
      destruct HMAPM as [sab [a'' [HMAPM [MS RES]]]]; subst.
      eapply IHa0.
      eapply HMAPM.
  Qed.

  Lemma handle_memcpy_fin_inf :
    forall {args args0 ms_fin ms_fin' ms_inf res_fin},
      MemState_refine_prop ms_inf ms_fin ->
      Forall2 DVCInfFin.dvalue_refine_strict args0 args ->
      Memory64BitIntptr.MMEP.MemSpec.handle_memcpy_prop args ms_fin (ret (ms_fin', res_fin)) ->
      exists (res_inf : unit) (ms_inf' : MemoryBigIntptr.MMEP.MMSP.MemState),
        MemoryBigIntptr.MMEP.MemSpec.handle_memcpy_prop args0 ms_inf (ret (ms_inf', res_inf)) /\
          res_inf = res_fin /\
          MemState_refine_prop ms_inf' ms_fin'.
  Proof.
    intros args args0 ms_fin ms_fin' ms_inf res_fin MSR ARGS HANDLER.

    (* Handler *)
    repeat (destruct ARGS;
            [solve [ inversion HANDLER
                   | red in HANDLER;
                     repeat break_match_hyp; inversion HANDLER
               ]
            |
           ]).
    red in HANDLER.
    repeat break_match_hyp; try inversion HANDLER; subst.
    { (* 32 bit memcpy *)
      inversion ARGS; subst.
      clear ARGS.
      rewrite DVCInfFin.dvalue_refine_strict_equation in H, H0, H1, H2, H3.

      apply dvalue_convert_strict_addr_inv in H as (a' & H & X); subst.
      apply dvalue_convert_strict_addr_inv in H0 as (a0' & H0 & X0); subst.
      apply dvalue_convert_strict_i32_inv in H1.
      apply dvalue_convert_strict_i32_inv in H2; subst.
      apply dvalue_convert_strict_i1_inv in H3; subst.

      unfold MemoryBigIntptr.MMEP.MemSpec.handle_memcpy_prop.
      unfold MemoryBigIntptr.MMEP.MemSpec.memcpy_spec.
      red in HANDLER.

      assert (LLVMParams64BitIntptr.Events.DV.unsigned x4 = LLVMParamsBigIntptr.Events.DV.unsigned x4) as X4.
      { reflexivity.
      }
      rewrite <- X4; clear X4.

      destruct res_fin.
      break_match_hyp.
      {
        exists tt. exists (lift_MemState ms_fin').
        split; auto.
        split; auto.
        apply lift_MemState_refine_prop.
      }

      erewrite <- fin_inf_no_overlap; eauto.
      repeat erewrite <- fin_inf_ptoi; eauto.
      break_match_goal.
      { eapply MemPropT_fin_inf_bind.
        4: apply HANDLER.
        all: eauto.

        { (* MA *)
          intros a_fin ms_fin_ma H1.
          eapply fin_inf_read_bytes_spec; eauto.
          apply H1.
        }

        intros ms_inf0 ms_fin0 ms_fin'0 a_fin a_inf b_fin BYTES MSR' WRITE.
        cbn in BYTES.
        eapply fin_inf_write_bytes_spec; eauto.
      }

      exists tt. exists (lift_MemState ms_fin').
      split; auto.
      split; auto.
      apply lift_MemState_refine_prop.
    }

    { (* 64 bit memcpy *)
      inversion ARGS; subst.
      clear ARGS.
      rewrite DVCInfFin.dvalue_refine_strict_equation in H, H0, H1, H2, H3.

      apply dvalue_convert_strict_addr_inv in H as (a' & H & X); subst.
      apply dvalue_convert_strict_addr_inv in H0 as (a0' & H0 & X0); subst.
      apply dvalue_convert_strict_i64_inv in H1.
      apply dvalue_convert_strict_i64_inv in H2; subst.
      apply dvalue_convert_strict_i1_inv in H3; subst.

      unfold MemoryBigIntptr.MMEP.MemSpec.handle_memcpy_prop.
      unfold MemoryBigIntptr.MMEP.MemSpec.memcpy_spec.
      red in HANDLER.

      assert (LLVMParams64BitIntptr.Events.DV.unsigned x4 = LLVMParamsBigIntptr.Events.DV.unsigned x4) as X4.
      { reflexivity.
      }
      rewrite <- X4; clear X4.

      destruct res_fin.
      break_match_hyp.
      {
        exists tt. exists (lift_MemState ms_fin').
        split; auto.
        split; auto.
        apply lift_MemState_refine_prop.
      }

      erewrite <- fin_inf_no_overlap; eauto.
      repeat erewrite <- fin_inf_ptoi; eauto.
      break_match_goal.
      { eapply MemPropT_fin_inf_bind.
        4: apply HANDLER.
        all: eauto.

        { (* MA *)
          intros a_fin ms_fin_ma H1.
          eapply fin_inf_read_bytes_spec; eauto.
          apply H1.
        }

        intros ms_inf0 ms_fin0 ms_fin'0 a_fin a_inf b_fin BYTES MSR' WRITE.
        cbn in BYTES.
        eapply fin_inf_write_bytes_spec; eauto.
      }

      exists tt. exists (lift_MemState ms_fin').
      split; auto.
      split; auto.
      apply lift_MemState_refine_prop.
    }

    { (* iptr memcpy *)
      inversion ARGS; subst.
      clear ARGS.
      rewrite DVCInfFin.dvalue_refine_strict_equation in H, H0, H1, H2, H3.

      apply dvalue_convert_strict_addr_inv in H as (a' & H & X); subst.
      apply dvalue_convert_strict_addr_inv in H0 as (a0' & H0 & X0); subst.
      apply dvalue_convert_strict_iptr_inv in H1 as (x4' & H1 & X4); subst.
      apply dvalue_convert_strict_iptr_inv in H2 as (x5' & H2 & X5); subst.
      apply dvalue_convert_strict_i1_inv in H3; subst.

      unfold MemoryBigIntptr.MMEP.MemSpec.handle_memcpy_prop.
      unfold MemoryBigIntptr.MMEP.MemSpec.memcpy_spec.
      red in HANDLER.

      assert (LLVMParams64BitIntptr.IP.to_Z x4 = LLVMParamsBigIntptr.IP.to_Z x4') as X4.
      { unfold LLVMParams64BitIntptr.IP.to_Z, LLVMParamsBigIntptr.IP.to_Z.
        unfold InterpreterStackBigIntptr.LP.IP.to_Z in *.
        erewrite IP.from_Z_to_Z; eauto.
      }
      rewrite <- X4; clear X4.

      destruct res_fin.
      break_match_hyp.
      {
        exists tt. exists (lift_MemState ms_fin').
        split; auto.
        split; auto.
        apply lift_MemState_refine_prop.
      }

      erewrite <- fin_inf_no_overlap; eauto.
      repeat erewrite <- fin_inf_ptoi; eauto.
      break_match_goal.
      { eapply MemPropT_fin_inf_bind.
        4: apply HANDLER.
        all: eauto.

        { (* MA *)
          intros a_fin ms_fin_ma H3.
          eapply fin_inf_read_bytes_spec; eauto.
          apply H3.
        }

        intros ms_inf0 ms_fin0 ms_fin'0 a_fin a_inf b_fin BYTES MSR' WRITE.
        cbn in BYTES.
        eapply fin_inf_write_bytes_spec; eauto.
      }

      exists tt. exists (lift_MemState ms_fin').
      split; auto.
      split; auto.
      apply lift_MemState_refine_prop.
    }
  Qed.




        (* TODO: Move this somewhere I can use it for both fin / inf *)
      #[global] Instance inf_frame_stack_preserved_symmetric :
        Symmetric InfMem.MMEP.MemSpec.frame_stack_preserved.
      Proof.
        intros x y FSP.
        red; red in FSP.
        intros fs. split; intros FS.
        apply FSP; auto.
        apply FSP; auto.
      Qed.

      (* TODO: Move this to where it can work for fin / inf *)
      Lemma frame_stack_eqv_snoc :
        forall fs1 fs2 f1 f2,
          MemoryBigIntptr.MMEP.MMSP.frame_stack_eqv fs1 fs2 ->
          MemoryBigIntptr.MMEP.MMSP.frame_eqv f1 f2 ->
          MemoryBigIntptr.MMEP.MMSP.frame_stack_eqv
            (InfMemMMSP.Snoc fs1 f1)
            (InfMemMMSP.Snoc fs2 f2).
      Proof.
        intros fs1 fs2 f1 f2 H H0.
        rewrite H.
        rewrite H0.
        reflexivity.
      Qed.


  (* TODO: Move this *)
  Lemma mem_push_spec_fin_inf :
    forall {m_fin_start m_fin_final m_inf_start m_inf_final},
      MemState_refine_prop m_inf_start m_fin_start ->
      MemState_refine_prop m_inf_final m_fin_final ->
      Memory64BitIntptr.MMEP.MemSpec.mempush_spec m_fin_start m_fin_final ->
      MemoryBigIntptr.MMEP.MemSpec.mempush_spec m_inf_start m_inf_final.
  Proof.
    intros m_fin_start m_fin_final m_inf_start m_inf_final MSR MSR' [FRESH INVARIANTS].

    split; cbn in *.
    - (* Fresh frame *)
      clear INVARIANTS.
      intros fs1 fs2 f MSFSP EMPTY PUSH.

      (* When I pop, I get a framestack that's equivalent to fs2... *)
      unfold MemoryBigIntptr.MMEP.MMSP.memory_stack_frame_stack_prop, Memory64BitIntptr.MMEP.MMSP.memory_stack_frame_stack_prop in *.
      cbn in *.

      apply MemState_refine_prop_frame_stack_preserved in MSR, MSR'.

      destruct PUSH.
      red in can_pop.
      destruct fs2; try contradiction.
      cbn in new_frame.

      rewrite <- new_frame.
      rewrite can_pop.
      rewrite <- MSFSP.

      pose proof InfMem.MMEP.empty_frame_eqv _ _ EMPTY MemoryBigIntptr.MMEP.empty_frame_nil as FNIL.
      rewrite FNIL.


      assert (Memory64BitIntptr.MMEP.MemSpec.push_frame_stack_spec
        (Memory64BitIntptr.MMEP.MMSP.memory_stack_frame_stack
           (Memory64BitIntptr.MMEP.MMSP.MemState_get_memory m_fin_start)) []
        (Memory64BitIntptr.MMEP.MMSP.Snoc
           (Memory64BitIntptr.MMEP.MMSP.memory_stack_frame_stack
              (Memory64BitIntptr.MMEP.MMSP.MemState_get_memory m_fin_start)) [])) as PUSH_FIN.
      { split; cbn; reflexivity.
      }

      specialize (FRESH
                    (Memory64BitIntptr.MMEP.MMSP.memory_stack_frame_stack
                       (Memory64BitIntptr.MMEP.MMSP.MemState_get_memory m_fin_start))
                    (Memory64BitIntptr.MMEP.MMSP.Snoc
                       (Memory64BitIntptr.MMEP.MMSP.memory_stack_frame_stack
                          (Memory64BitIntptr.MMEP.MMSP.MemState_get_memory m_fin_start)) [])
                    []
                 ).
      forward FRESH; try reflexivity.
      forward FRESH.
      apply Memory64BitIntptr.MMEP.empty_frame_nil.
      specialize (FRESH PUSH_FIN).

      apply FinMemMMSP.frame_stack_inv in FRESH.
      destruct FRESH as [FRESH | FRESH].
      2: {
        destruct FRESH as (?&?&?&?&?).
        discriminate.
      }

      destruct FRESH as (?&?&?&?&?&?&?&?).
      inv H0.

      destruct m_fin_final. destruct ms_memory_stack.
      cbn in *; subst.
      rewrite lift_FrameStack_snoc in MSR'.
      repeat red in MSR'; cbn in MSR'.
      unfold InfMem.MMEP.MMSP.memory_stack_frame_stack_prop at 2 in MSR'.
      unfold InfMem.MMEP.MMSP.memory_stack_frame_stack in MSR'.

      red in MSR.
      pose proof MSFSP.
      apply MSR in H.


      destruct m_inf_final. destruct ms_memory_stack.
      specialize (MSR' memory_stack_frame_stack).
      cbn in *.
      destruct MSR' as [MSR1' MSR2'].
      unfold InfMem.MMEP.MMSP.memory_stack_frame_stack_prop in *.
      cbn in *.
      forward MSR1'.
      reflexivity.

      apply InfMem.MMEP.MMSP.frame_stack_inv in MSR1'.
      destruct MSR1' as [MSR1' | MSR1'].
      2: {
        destruct MSR1' as (?&?&?&?&?).
        discriminate.
      }

      destruct MSR1' as (?&?&?&?&?&?&?&?).
      inv H0.

      apply frame_eqv_empty_r in H2; subst.
      apply inf_frame_eqv_empty_r in FNIL; subst.
      apply inf_frame_eqv_empty_l in new_frame; subst.
      cbn in H5.
      apply inf_frame_eqv_empty_l in H5; subst.

      apply frame_stack_eqv_snoc.
      2: {
        cbn; reflexivity.
      }

      rewrite <- H4.
      apply frame_stack_eqv_lift in H1.
      rewrite H1.

      rewrite MSFSP.
      destruct m_fin_start. destruct ms_memory_stack.
      replace (Memory64BitIntptr.MMEP.MMSP.memory_stack_frame_stack
          (Memory64BitIntptr.MMEP.MMSP.MemState_get_memory
             {|
               FinMemMMSP.ms_memory_stack :=
                 {|
                   FinMemMMSP.memory_stack_memory := memory_stack_memory1;
                   FinMemMMSP.memory_stack_frame_stack := memory_stack_frame_stack;
                   FinMemMMSP.memory_stack_heap := memory_stack_heap1
                 |};
               FinMemMMSP.ms_provenance := ms_provenance1
             |})) with memory_stack_frame_stack by reflexivity.
      cbn in *.
      auto.
    - (* mempush_operation_invariants *)
      destruct INVARIANTS.
      split; cbn in *.
      + split; destruct mempush_op_reads.
        * eapply fin_inf_read_byte_allowed_all_preserved; eauto.
        * eapply fin_inf_read_byte_prop_all_preserved; eauto.
      + eapply fin_inf_write_byte_allowed_all_preserved; eauto.
      + eapply fin_inf_free_byte_allowed_all_preserved; eauto.
      + eapply fin_inf_allocations_preserved; eauto.
      + eapply fin_inf_preserve_allocation_ids; eauto.
      + eapply fin_inf_heap_preserved; eauto.
  Qed.

  (* TODO: Move this *)
  Lemma convert_Frame_cons_equation :
    forall {f a},
      convert_Frame (a :: f) =
        a' <- InfToFinAddrConvert.addr_convert a;;
        f' <- convert_Frame f;;
        NoOom (a' :: f').
  Proof.
    intros f a.
    induction f; cbn; auto.
  Qed.

  (* TODO: Move this *)
  Lemma fin_inf_ptr_in_frame_prop :
    forall {f_inf f_fin ptr_inf},
      InfMem.MMEP.MMSP.frame_eqv (lift_Frame f_fin) f_inf ->
      MemoryBigIntptr.MMEP.MMSP.ptr_in_frame_prop f_inf ptr_inf ->
      exists ptr_fin,
        InfToFinAddrConvert.addr_convert ptr_inf = NoOom ptr_fin /\
          Memory64BitIntptr.MMEP.MMSP.ptr_in_frame_prop f_fin ptr_fin.
  Proof.
    induction f_inf; intros f_fin ptr_inf F PTR.
    - cbn in *. contradiction.
    - cbn in F.
      red in F.
      apply F in PTR.
      red in PTR.
      apply in_map_iff in PTR as (?&?&?).
      apply in_map_iff in H0 as (?&?&?).
      subst.

      destruct x0.
      unfold fin_to_inf_addr in *.
      destruct (FinToInfAddrConvertSafe.addr_convert_succeeds (i, p)).
      apply FinToInfAddrConvertSafe.addr_convert_safe in e.
      destruct x.
      cbn in *.
      destruct ptr_inf; cbn in *; subst.
      pose proof int_to_ptr_succeeds_regardless_of_provenance e (pr2:=p1) as (?&?).
      exists x.
      split; auto.

      red.
      apply in_map_iff.
      exists (i, p). split; auto.
      erewrite ITOP.ptr_to_int_int_to_ptr; eauto.
      erewrite ITOP.ptr_to_int_int_to_ptr; eauto.
  Qed.

  (* TODO: Move this *)
  Lemma inf_fin_ptr_in_frame_prop :
    forall {f_inf f_fin ptr_fin},
      convert_Frame f_inf = NoOom f_fin ->
      Memory64BitIntptr.MMEP.MMSP.ptr_in_frame_prop f_fin ptr_fin ->
      exists ptr_inf,
        InfToFinAddrConvert.addr_convert ptr_inf = NoOom ptr_fin /\
          MemoryBigIntptr.MMEP.MMSP.ptr_in_frame_prop f_inf ptr_inf.
  Proof.
    induction f_inf; intros f_fin ptr_inf F PTR.
    - cbn in *.
      inv F.
      cbn in *.
      contradiction.
   - rewrite convert_Frame_cons_equation in F.
     cbn in F.
     break_match_hyp; inv F.
     break_match_hyp; inv H0.
     pose proof PTR as PTR'.
     red in PTR.
     cbn in PTR.
     destruct PTR.
     + destruct ptr_inf.
       destruct a.
       cbn in *; subst.
       destruct a0.
       unfold LLVMParams64BitIntptr.PTOI.ptr_to_int in H.
       cbn in *.
       exists (i0, p).
       cbn.
       split; auto.
       unfold FinITOP.int_to_ptr in *.
       break_match_hyp; inv Heqo.
       rewrite Int64.unsigned_repr in H.
       2: {
         apply Bool.orb_false_elim in Heqb.
         destruct Heqb.
         apply Z.ltb_nlt in H0.
         rewrite Z.geb_leb in H1.
         apply Z.leb_gt in H1.
         unfold Int64.max_unsigned.
         lia.
       }
       subst.

       rewrite Int64.repr_unsigned.
       auto.
     + specialize (IHf_inf f ptr_inf eq_refl).
       forward IHf_inf.
       {
         red. auto.
       }

       destruct IHf_inf as (?&?&?).
       exists x.
       split; auto.
       red.
       cbn.
       right.
       auto.
  Qed.

  (* TODO: Move this *)
  Lemma fin_inf_ptr_in_current_frame :
    forall {ms_inf ms_fin ptr_inf},
      MemState_refine_prop ms_inf ms_fin ->
      MemoryBigIntptr.MMEP.MemSpec.ptr_in_current_frame ms_inf ptr_inf ->
      exists ptr_fin,
        InfToFinAddrConvert.addr_convert ptr_inf = NoOom ptr_fin /\
          Memory64BitIntptr.MMEP.MemSpec.ptr_in_current_frame ms_fin ptr_fin.
  Proof.
    intros ms_inf ms_fin ptr_inf MSR PTR.
    destruct ms_inf as [[ms_inf fss_inf hs_inf] msprovs_inf].

    apply MemState_refine_prop_frame_stack_preserved in MSR.
    red in PTR.
    red in MSR.
    unfold InfMem.MMEP.MMSP.memory_stack_frame_stack_prop in *.
    cbn in *.
    specialize (MSR fss_inf).
    specialize (PTR fss_inf).
    destruct MSR as [MSR _].
    forward MSR; [red; cbn; reflexivity|].
    forward PTR; [reflexivity|].

    destruct fss_inf.
    { (* Single frame *)
      cbn in *.
      specialize (PTR f).
      forward PTR; [reflexivity|].

      destruct ms_fin as [[ms_fin fss_fin hs_fin] msprovs_fin].
      cbn in *.

      unfold Memory64BitIntptr.MMEP.MemSpec.ptr_in_current_frame, Memory64BitIntptr.MMEP.MMSP.memory_stack_frame_stack_prop.
      cbn.

      apply InfMem.MMEP.MMSP.frame_stack_inv in MSR.
      destruct MSR as [MSR | MSR].
      {
        destruct MSR as (?&?&?&?&?&?&?&?).
        discriminate.
      }

      destruct MSR as (?&?&?&?&?).
      inv H0.
      destruct fss_fin; inv H.
      red in H1; cbn in H1.
      rewrite <- H1 in PTR.

      eapply fin_inf_ptr_in_frame_prop in PTR; eauto.
      2: {
        rewrite lift_FrameStack_singleton.
        reflexivity.
      }

      destruct PTR as (ptr_fin & CONV & PTR).
      exists ptr_fin.
      split; auto.

      intros fs H f0 H0.
      rewrite <- H in H0.
      cbn in H0.
      rewrite H0.
      auto.
    }

    { (* Multiple frames *)
      cbn in *.
      specialize (PTR f).
      forward PTR; [reflexivity|].

      destruct ms_fin as [[ms_fin fss_fin hs_fin] msprovs_fin].
      cbn in *.

      unfold Memory64BitIntptr.MMEP.MemSpec.ptr_in_current_frame, Memory64BitIntptr.MMEP.MMSP.memory_stack_frame_stack_prop.
      cbn.

      apply InfMem.MMEP.MMSP.frame_stack_inv in MSR.
      destruct MSR as [MSR | MSR].
      2: {
        destruct MSR as (?&?&?&?&?).
        discriminate.
      }

      destruct MSR as (?&?&?&?&?&?&?&?).
      inv H0.
      destruct fss_fin; inv H.
      rewrite <- H2 in PTR.

      eapply fin_inf_ptr_in_frame_prop in PTR; eauto.
      2: {
        rewrite lift_FrameStack_snoc.
        reflexivity.
      }

      destruct PTR as (ptr_fin & CONV & PTR).
      exists ptr_fin.
      split; auto.

      intros fs H f0 H0.
      rewrite <- H in H0.
      cbn in H0.
      rewrite H0.
      auto.
    }
  Qed.

  (* TODO: Move this *)
  Lemma inf_fin_ptr_in_current_frame :
    forall {ms_inf ms_fin ptr_fin},
      MemState_refine_prop ms_inf ms_fin ->
      Memory64BitIntptr.MMEP.MemSpec.ptr_in_current_frame ms_fin ptr_fin ->
      exists ptr_inf,
        InfToFinAddrConvert.addr_convert ptr_inf = NoOom ptr_fin /\
          MemoryBigIntptr.MMEP.MemSpec.ptr_in_current_frame ms_inf ptr_inf.
  Proof.
    intros ms_inf ms_fin ptr_inf MSR PTR.
    destruct ms_inf as [[ms_inf fss_inf hs_inf] msprovs_inf].
    destruct ms_fin as [[ms_fin fss_fin hs_fin] msprovs_fin].

    apply MemState_refine_prop_frame_stack_preserved in MSR.
    red in PTR.
    red in MSR.
    unfold InfMem.MMEP.MMSP.memory_stack_frame_stack_prop in *.
    cbn in *.
    specialize (MSR fss_inf).
    specialize (PTR fss_fin).
    destruct MSR as [MSR _].
    forward MSR; [red; cbn; reflexivity|].
    forward PTR; [red; cbn; reflexivity|].

    destruct fss_fin.
    { (* Single frame *)
      cbn in *.
      specialize (PTR f).
      forward PTR; [reflexivity|].

      unfold MemoryBigIntptr.MMEP.MemSpec.ptr_in_current_frame, MemoryBigIntptr.MMEP.MMSP.memory_stack_frame_stack_prop.
      cbn.

      apply InfMem.MMEP.MMSP.frame_stack_inv in MSR.
      destruct MSR as [MSR | MSR].
      {
        destruct MSR as (?&?&?&?&?&?&?&?).
        discriminate.
      }

      destruct MSR as (?&?&?&?&?).
      inv H0.
      inv H.

      red in PTR.
      apply in_map_iff in PTR as (?&?&?).
      destruct ptr_inf.
      remember (fin_to_inf_addr x).
      destruct x.
      unfold LLVMParams64BitIntptr.PTOI.ptr_to_int in *.
      cbn in *.
      inv H.

      exists (Int64.unsigned i, p).
      split; auto.
      cbn.
      unfold FinITOP.int_to_ptr.
      break_match.
      {
        pose proof Integers.Int64.unsigned_range i.
        lia.
      }
      rewrite Int64.repr_unsigned.
      auto.

      intros fs H f0 H3.
      rewrite <- H in H3.
      cbn in H3.
      rewrite H3.
      rewrite <- H1.
      red. cbn.

      apply in_map_iff.
      exists (Int64.unsigned i, p0).
      split; auto.

      apply in_map_iff.
      exists (i0, p0).
      split; auto.
      unfold fin_to_inf_addr.
      break_match_goal.
      clear Heqs.
      apply FinToInfAddrConvertSafe.addr_convert_safe in e.
      destruct x.
      cbn in *.
      unfold FinITOP.int_to_ptr in *.
      break_match_hyp; inv e.
      rewrite Int64.unsigned_repr in H4.
      2: {
        unfold Int64.max_unsigned.
        lia.
      }

      subst.
      auto.
    }

    { (* Multiple frames *)
      specialize (PTR f).
      forward PTR; [cbn; reflexivity|].

      unfold MemoryBigIntptr.MMEP.MemSpec.ptr_in_current_frame, MemoryBigIntptr.MMEP.MMSP.memory_stack_frame_stack_prop.
      cbn.

      apply InfMem.MMEP.MMSP.frame_stack_inv in MSR.
      destruct MSR as [MSR | MSR].
      2: {
        destruct MSR as (?&?&?&?&?).
        discriminate.
      }

      destruct MSR as (?&?&?&?&?&?&?&?).
      inv H0.
      inv H.

      red in PTR.
      apply in_map_iff in PTR as (?&?&?).
      destruct ptr_inf.
      remember (fin_to_inf_addr x).
      destruct x.
      unfold LLVMParams64BitIntptr.PTOI.ptr_to_int in *.
      cbn in *.
      inv H.

      exists (Int64.unsigned i, p).
      split; auto.
      cbn.
      unfold FinITOP.int_to_ptr.
      break_match.
      {
        pose proof Integers.Int64.unsigned_range i.
        lia.
      }
      rewrite Int64.repr_unsigned.
      auto.

      intros fs H f0 H4.
      rewrite <- H in H4.
      cbn in H4.
      rewrite H4.
      rewrite <- H2.
      red. cbn.

      apply in_map_iff.
      exists (Int64.unsigned i, p0).
      split; auto.

      apply in_map_iff.
      exists (i0, p0).
      split; auto.
      unfold fin_to_inf_addr.
      break_match_goal.
      clear Heqs.
      apply FinToInfAddrConvertSafe.addr_convert_safe in e.
      destruct x.
      cbn in *.
      unfold FinITOP.int_to_ptr in *.
      break_match_hyp; inv e.
      rewrite Int64.unsigned_repr in H5.
      2: {
        unfold Int64.max_unsigned.
        lia.
      }

      subst.
      auto.
    }
  Qed.

  Lemma fin_inf_ptr_not_in_current_frame :
    forall {ms_inf ms_fin ptr_inf ptr_fin},
      MemState_refine_prop ms_inf ms_fin ->
      FinToInfAddrConvert.addr_convert ptr_fin = NoOom ptr_inf ->
      ~ Memory64BitIntptr.MMEP.MemSpec.ptr_in_current_frame ms_fin ptr_fin ->
      ~ MemoryBigIntptr.MMEP.MemSpec.ptr_in_current_frame ms_inf ptr_inf.
  Proof.
    intros ms_inf ms_fin ptr_inf ptr_fin MSR ADDR_CONV PTR_NIN_FRAME PTR_IN_FRAME.
    eapply PTR_NIN_FRAME.
    eapply fin_inf_ptr_in_current_frame in PTR_IN_FRAME; eauto.
    destruct PTR_IN_FRAME as (?&?&?).
    pose proof FinToInfAddrConvertSafe.addr_convert_safe _ _ ADDR_CONV.
    rewrite H in H1.
    inv H1.
    auto.
  Qed.

  Lemma inf_fin_ptr_not_in_current_frame :
    forall {ms_inf ms_fin ptr_inf ptr_fin},
      MemState_refine_prop ms_inf ms_fin ->
      InfToFinAddrConvert.addr_convert ptr_inf = NoOom ptr_fin ->
      ~ MemoryBigIntptr.MMEP.MemSpec.ptr_in_current_frame ms_inf ptr_inf ->
      ~ Memory64BitIntptr.MMEP.MemSpec.ptr_in_current_frame ms_fin ptr_fin.
  Proof.
    intros ms_inf ms_fin ptr_inf ptr_fin MSR ADDR_CONV PTR_NIN_FRAME PTR_IN_FRAME.
    eapply PTR_NIN_FRAME.
    eapply inf_fin_ptr_in_current_frame in PTR_IN_FRAME; eauto.
    destruct PTR_IN_FRAME as (?&?&?).
    pose proof InfToFinAddrConvert.addr_convert_injective _ _ _ ADDR_CONV H.
    subst.
    auto.
  Qed.

  (* TODO: Move this *)
  Lemma mem_pop_spec_fin_inf :
    forall {m_fin_start m_fin_final m_inf_start m_inf_final},
      MemState_refine_prop m_inf_start m_fin_start ->
      MemState_refine_prop m_inf_final m_fin_final ->
      Memory64BitIntptr.MMEP.MemSpec.mempop_spec m_fin_start m_fin_final ->
      MemoryBigIntptr.MMEP.MemSpec.mempop_spec m_inf_start m_inf_final.
  Proof.
    intros m_fin_start m_fin_final m_inf_start m_inf_final MSR1 MSR2 [BYTES_FREED NON_FRAME_BYTES_PRESERVED NON_FRAME_BYTES_READ POP_FRAME INVARIANTS].

    split.
    - (* Bytes freed *)
      clear NON_FRAME_BYTES_PRESERVED NON_FRAME_BYTES_READ POP_FRAME INVARIANTS.
      cbn in *.
      intros ptr PTR.

      (* ptr is in the current frame, which has a finite refinement,
         so there should be a finite version of ptr as well *)
      pose proof fin_inf_ptr_in_current_frame MSR1 PTR as (ptr_fin&PTR_CONV&PTR_FIN).
      eapply fin_inf_byte_not_allocated; eauto.
    - (* NON_FRAME_BYTES_PRESERVED *)
      clear - MSR1 MSR2 NON_FRAME_BYTES_PRESERVED.
      intros ptr aid PTR.

      destruct (InfToFinAddrConvert.addr_convert ptr) eqn:PTR_CONV.
      2: {
        pose proof inf_fin_big_address_byte_not_allocated MSR1 PTR_CONV.
        pose proof inf_fin_big_address_byte_not_allocated MSR2 PTR_CONV.
        split; intros.
        - exfalso. eapply H; eauto.
        - exfalso. eapply H0; eauto.
      }

      eapply inf_fin_ptr_not_in_current_frame in PTR; eauto.

      specialize (NON_FRAME_BYTES_PRESERVED a aid PTR).

      split; intros BYTE_ALLOCATED.
      + eapply inf_fin_byte_allocated in BYTE_ALLOCATED; eauto.
        apply NON_FRAME_BYTES_PRESERVED in BYTE_ALLOCATED.
        eapply fin_inf_byte_allocated; eauto.
      + eapply inf_fin_byte_allocated in BYTE_ALLOCATED; eauto.
        apply NON_FRAME_BYTES_PRESERVED in BYTE_ALLOCATED.
        eapply fin_inf_byte_allocated; eauto.
    - (* NON_FRAME_BYTES_READ *)
      clear - MSR1 MSR2 NON_FRAME_BYTES_READ.
      intros ptr byte PTR.

      destruct (InfToFinAddrConvert.addr_convert ptr) eqn:PTR_CONV.
      2: {
        pose proof inf_fin_big_address_byte_not_allocated MSR1 PTR_CONV.
        pose proof inf_fin_big_address_byte_not_allocated MSR2 PTR_CONV.
        split; intros.
        - exfalso.
          destruct H1.
          destruct read_byte_allowed_spec.
          destruct H1.
          eapply H; eauto.
        - exfalso.
          destruct H1.
          destruct read_byte_allowed_spec.
          destruct H1.
          eapply H0; eauto.
      }

      split; intros READ.
      + pose proof inf_fin_read_byte_spec MSR1 PTR_CONV READ as [byte_fin [READ_FIN BYTE_REF]].
        red in BYTE_REF.

        eapply inf_fin_ptr_not_in_current_frame in PTR; eauto.
        specialize (NON_FRAME_BYTES_READ a byte_fin PTR).
        eapply NON_FRAME_BYTES_READ in READ_FIN.
        eapply fin_inf_read_byte_spec; eauto.
      + pose proof inf_fin_read_byte_spec MSR2 PTR_CONV READ as [byte_fin [READ_FIN BYTE_REF]].
        red in BYTE_REF.

        eapply inf_fin_ptr_not_in_current_frame in PTR; eauto.
        specialize (NON_FRAME_BYTES_READ a byte_fin PTR).
        eapply NON_FRAME_BYTES_READ in READ_FIN.
        eapply fin_inf_read_byte_spec; eauto.
    - (* POP_FRAME *)
      clear - MSR1 MSR2 POP_FRAME.
      intros fs1 fs2 FSP POP.
      red; red in FSP.
      cbn in *.

      red in POP.
      destruct fs1; try contradiction.
      rewrite <- POP.

      destruct m_fin_start. destruct ms_memory_stack.
      destruct m_inf_start. destruct ms_memory_stack.
      cbn in *.
      destruct memory_stack_frame_stack0.
      apply MemoryBigIntptrInfiniteSpec.MMSP.frame_stack_eqv_sing_snoc_inv in FSP; contradiction.
      pose proof FSP as F.
      apply MemoryBigIntptrInfiniteSpec.MMSP.frame_stack_snoc_inv_fs in FSP.
      apply MemoryBigIntptrInfiniteSpec.MMSP.frame_stack_snoc_inv_f in F.

      rewrite <- FSP.
      apply MemState_refine_prop_frame_stack_preserved in MSR1, MSR2.
      cbn in *. red in MSR1, MSR2.
      cbn in MSR1, MSR2.
      unfold InfMem.MMEP.MMSP.memory_stack_frame_stack_prop in *.
      cbn in *.

      destruct m_inf_final. destruct ms_memory_stack.
      destruct m_fin_final. destruct ms_memory_stack.
      cbn in *.

      specialize (MSR2 memory_stack_frame_stack1).
      destruct MSR2 as [MSR2 _].
      forward MSR2; [red; cbn; reflexivity|].
      red in MSR2. rewrite <- MSR2.

      specialize (MSR1 (InfMem.MMEP.MMSP.Snoc memory_stack_frame_stack0 f0)).
      destruct MSR1 as [MSR1 _].
      forward MSR1; [red; cbn; reflexivity|].

      destruct memory_stack_frame_stack.
      {
        cbn in MSR1.
        apply MemoryBigIntptrInfiniteSpec.MMSP.frame_stack_eqv_sing_snoc_inv in MSR1; contradiction.
      }
      rewrite lift_FrameStack_snoc in MSR1.
      apply MemoryBigIntptrInfiniteSpec.MMSP.frame_stack_snoc_inv_fs in MSR1.
      rewrite <- MSR1.

      unfold Memory64BitIntptr.MMEP.MMSP.memory_stack_frame_stack_prop in *.
      cbn in *.

      specialize (POP_FRAME (FinMem.MMEP.MMSP.Snoc memory_stack_frame_stack f1) memory_stack_frame_stack).
      forward POP_FRAME; [red; cbn; reflexivity|].
      forward POP_FRAME; [red; cbn; reflexivity|].
      red in POP_FRAME; cbn in POP_FRAME.
      eapply frame_stack_eqv_lift.
      auto.
    - (* mempop_operation_invariants *)
      destruct INVARIANTS.
      split; cbn in *.
      + eapply fin_inf_preserve_allocation_ids; eauto.
      + eapply fin_inf_heap_preserved; eauto.
  Qed.

  (* TODO: Move this *)
  Lemma mem_pop_spec_inf_fin :
    forall {m_fin_start m_fin_final m_inf_start m_inf_final},
      MemState_refine_prop m_inf_start m_fin_start ->
      MemState_refine_prop m_inf_final m_fin_final ->
      MemoryBigIntptr.MMEP.MemSpec.mempop_spec m_inf_start m_inf_final ->
      Memory64BitIntptr.MMEP.MemSpec.mempop_spec m_fin_start m_fin_final.
  Proof.
    intros m_fin_start m_fin_final m_inf_start m_inf_final MSR1 MSR2 [BYTES_FREED NON_FRAME_BYTES_PRESERVED NON_FRAME_BYTES_READ POP_FRAME INVARIANTS].

    split.
    - (* Bytes freed *)
      clear NON_FRAME_BYTES_PRESERVED NON_FRAME_BYTES_READ POP_FRAME INVARIANTS.
      cbn in *.
      intros ptr PTR.

      (* ptr is in the current frame, which has a finite refinement,
         so there should be a finite version of ptr as well *)
      pose proof inf_fin_ptr_in_current_frame MSR1 PTR as (ptr_fin&PTR_CONV&PTR_FIN).
      eapply inf_fin_byte_not_allocated; eauto.
    - (* NON_FRAME_BYTES_PRESERVED *)
      clear - MSR1 MSR2 NON_FRAME_BYTES_PRESERVED.
      intros ptr aid PTR.

      pose proof (FinToInfAddrConvertSafe.addr_convert_succeeds ptr) as (ptr_inf & PTR_CONV).
      eapply fin_inf_ptr_not_in_current_frame in PTR; eauto.
      specialize (NON_FRAME_BYTES_PRESERVED ptr_inf aid PTR).
      pose proof FinToInfAddrConvertSafe.addr_convert_safe _ _ PTR_CONV as PTR_CONV'.

      split; intros BYTE_ALLOCATED.
      + eapply fin_inf_byte_allocated in BYTE_ALLOCATED; eauto.
        apply NON_FRAME_BYTES_PRESERVED in BYTE_ALLOCATED.
        eapply inf_fin_byte_allocated; eauto.
      + eapply fin_inf_byte_allocated in BYTE_ALLOCATED; eauto.
        apply NON_FRAME_BYTES_PRESERVED in BYTE_ALLOCATED.
        eapply inf_fin_byte_allocated; eauto.
    - (* NON_FRAME_BYTES_READ *)
      clear - MSR1 MSR2 NON_FRAME_BYTES_READ.
      intros ptr byte PTR.

      pose proof (FinToInfAddrConvertSafe.addr_convert_succeeds ptr) as (ptr_inf & PTR_CONV).
      pose proof FinToInfAddrConvertSafe.addr_convert_safe _ _ PTR_CONV as PTR_CONV'.
      eapply fin_inf_ptr_not_in_current_frame in PTR; eauto.

      split; intros READ.
      + pose proof fin_inf_read_byte_spec_exists MSR1 READ as [addr_inf [byte_inf [READ_INF [ADDR_REF BYTE_REF]]]].
        red in BYTE_REF.
        red in ADDR_REF.
        pose proof InfToFinAddrConvert.addr_convert_injective _ _ _ ADDR_REF PTR_CONV'.
        subst.

        specialize (NON_FRAME_BYTES_READ ptr_inf byte_inf PTR).
        eapply NON_FRAME_BYTES_READ in READ_INF.
        eapply inf_fin_read_byte_spec in READ_INF; eauto.
        destruct READ_INF as (?&?&?).
        red in H0.
        rewrite BYTE_REF in H0; inv H0.
        auto.
      + pose proof fin_inf_read_byte_spec_exists MSR2 READ as [addr_inf [byte_inf [READ_INF [ADDR_REF BYTE_REF]]]].
        red in BYTE_REF.
        red in ADDR_REF.
        pose proof InfToFinAddrConvert.addr_convert_injective _ _ _ ADDR_REF PTR_CONV'.
        subst.

        specialize (NON_FRAME_BYTES_READ ptr_inf byte_inf PTR).
        eapply NON_FRAME_BYTES_READ in READ_INF.
        eapply inf_fin_read_byte_spec in READ_INF; eauto.
        destruct READ_INF as (?&?&?).
        red in H0.
        rewrite BYTE_REF in H0; inv H0.
        auto.
    - (* POP_FRAME *)
      clear - MSR1 MSR2 POP_FRAME.
      intros fs1 fs2 FSP POP.

      red; red in FSP.
      cbn in *.

      red in POP.
      destruct fs1; try contradiction.
      rewrite <- POP.

      destruct m_fin_start. destruct ms_memory_stack.
      destruct m_inf_start. destruct ms_memory_stack.
      cbn in *.
      destruct memory_stack_frame_stack.
      apply Memory64BitIntptr.MMEP.MMSP.frame_stack_eqv_sing_snoc_inv in FSP; contradiction.
      pose proof FSP as F.
      apply Memory64BitIntptr.MMEP.MMSP.frame_stack_snoc_inv_fs in FSP.
      apply Memory64BitIntptr.MMEP.MMSP.frame_stack_snoc_inv_f in F.

      rewrite <- FSP.
      apply MemState_refine_prop_frame_stack_preserved in MSR1, MSR2.
      Opaque lift_FrameStack.
      cbn in *. red in MSR1, MSR2.
      cbn in MSR1, MSR2.
      unfold InfMem.MMEP.MMSP.memory_stack_frame_stack_prop in *.
      cbn in *.

      destruct m_inf_final. destruct ms_memory_stack.
      destruct m_fin_final. destruct ms_memory_stack.
      cbn in *.

      rewrite FSP, POP.

      eapply frame_stack_eqv_lift_inf_fin.
      eapply MSR2.


      rewrite lift_FrameStack_snoc in MSR1.
      specialize (MSR1 (InfMemMMSP.Snoc (lift_FrameStack memory_stack_frame_stack) (lift_Frame f0))).
      destruct MSR1 as [_ MSR1].
      forward MSR1; [red; cbn; reflexivity|].
      red in MSR1; setoid_rewrite MSR1 in POP_FRAME.

      eapply POP_FRAME. reflexivity.
      red.
      eapply frame_stack_eqv_lift.
      rewrite FSP, POP.
      reflexivity.
    - (* mempop_operation_invariants *)
      destruct INVARIANTS.
      split; cbn in *.
      + eapply inf_fin_preserve_allocation_ids; eauto.
      + eapply inf_fin_heap_preserved; eauto.
  Qed.

  (* TODO: Move this *)
  Lemma mem_pop_spec_inf_fin_exists :
    forall {m_fin_start m_inf_start m_inf_final},
      MemState_refine_prop m_inf_start m_fin_start ->
      ~ MemoryBigIntptr.MMEP.MemSpec.cannot_pop m_inf_start ->
      MemoryBigIntptr.MMEP.MemSpec.mempop_spec m_inf_start m_inf_final ->
      exists m_fin_final,
        Memory64BitIntptr.MMEP.MemSpec.mempop_spec m_fin_start m_fin_final /\
          MemState_refine_prop m_inf_final m_fin_final.
  Proof.
    intros m_fin_start m_inf_start m_inf_final MSR CAN_POP [BYTES_FREED NON_FRAME_BYTES_PRESERVED NON_FRAME_BYTES_READ POP_FRAME INVARIANTS].

    destruct (convert_MemState m_inf_final) as [m_fin_final | ] eqn:MS_FIN_FINAL.
    2: {
      exfalso.

      destruct m_fin_start as [[ms_fin fss_fin hs_fin] msprovs_fin].
      destruct m_inf_start as [[ms_inf fss_inf hs_inf] msprovs_inf].
      destruct m_inf_final as [[ms_inf' fss_inf' hs_inf'] msprovs_inf'].

      unfold convert_MemState in MS_FIN_FINAL.
      cbn in MS_FIN_FINAL.
      repeat break_match_hyp_inv.
      { (* convert_Heap OOM *)
        (* This shouldn't happen because mempop does not touch the heap *)
        clear - Heqo2 Heqo Heqo1 MSR INVARIANTS.
        destruct INVARIANTS.
        clear mempop_op_allocation_ids.

        apply MemState_refine_prop_heap_preserved in MSR.
        red in mempop_heap_preserved, MSR.
        cbn in *.
        unfold MemoryBigIntptr.MMEP.MMSP.memory_stack_heap_prop,
          MemoryBigIntptr.MMEP.MMSP.memory_stack_frame_stack_prop in *.
        cbn in *.

        (* Block failed to convert, which means there's an out of
           bounds address in the block... *)
        apply map_monad_OOM_fail in Heqo2.
        destruct Heqo2 as ((root&block)&?&?).
        break_match_hyp_inv.

        apply map_monad_OOM_fail in Heqo0.
        destruct Heqo0 as (bad_addr&IN_BLOCK&BAD_CONV).

        (* IN_FIN should be a contradiction because lift_Heap should filter out bad elements *)
        destruct (MSR hs_inf) as [EQV _]; forward EQV; [red; cbn; reflexivity|].
        destruct (mempop_heap_preserved hs_inf) as [EQV2 _]; forward EQV2; [red; cbn; reflexivity|].

        pose proof every_int_has_big_ptr root as (root_ptr&ROOT_PTR).
        pose proof ptr_in_heap_prop_intmap_elements_inf ROOT_PTR H IN_BLOCK as IN_HEAP.

        rewrite EQV2, <- EQV in IN_HEAP.
        apply ptr_in_heap_prop_lift_inv in IN_HEAP.
        destruct IN_HEAP as (root_fin & ptr_fin & ROOT_CONV & BAD_CONV' & IN_HEAP).
        rewrite BAD_CONV in BAD_CONV'.
        inv BAD_CONV'.
      }

      { (* convert_FrameStack OOM *)
        (* mempop only removes things from the framestack, so the new framestack should not OOM. *)
        apply MemState_refine_prop_frame_stack_preserved in MSR.
        red in MSR.
        clear - MSR CAN_POP POP_FRAME Heqo.
        cbn in POP_FRAME.
        unfold MemoryBigIntptr.MMEP.MemSpec.cannot_pop,
          MemoryBigIntptr.MMEP.MMSP.memory_stack_heap_prop,
          MemoryBigIntptr.MMEP.MMSP.memory_stack_frame_stack_prop in *.
        cbn in *.

        specialize (POP_FRAME fss_inf).
        destruct fss_inf as [f_inf | fss_inf f_inf].
        { (* Singleton... Cannot pop? *)
          eapply CAN_POP.
          intros fs1 fs2 EQV CONTRA.
          rewrite <- EQV in CONTRA.
          red in CONTRA.
          auto.
        }

        clear CAN_POP.

        specialize (POP_FRAME fss_inf).
        forward POP_FRAME; [reflexivity|].
        forward POP_FRAME; [red; reflexivity|].

        destruct (MSR (InfMem.MMEP.MMSP.Snoc fss_inf f_inf)) as [MSR' _];
          forward MSR'; [red; cbn; reflexivity|].
        red in MSR'.
        rewrite <- POP_FRAME in MSR'.

        apply InfMemMMSP.frame_stack_inv in MSR' as [MSR' | MSR'].
        2: {
          (* Singleton case is contradiction *)
          destruct MSR' as (?&?&?&?&?&?).
          inv H0.
        }

        destruct MSR' as (?&?&?&?&?&?&?&?).
        symmetry in H0; inv H0.

        destruct fss_fin; [inv H|].
        rewrite lift_FrameStack_snoc in H.
        symmetry in H; inv H.

        clear POP_FRAME MSR.
        generalize dependent fss_inf.
        generalize dependent fss_fin.
        induction fss_inf'; intros fss_fin H1 fss_inf.
        { (* Singleton *)
          cbn in Heqo.
          break_match_hyp_inv.

          apply InfMemMMSP.frame_stack_inv in H1 as [H1 | H1].
          { (* Snoc is contradiction *)
            destruct H1 as (?&?&?&?&?&?&?).
            inv H0.
          }

          destruct H1 as (?&?&?&?&?).
          symmetry in H0; inv H0.
          destruct fss_fin as [fs_fin | fss_fin fs_fin].
          2: {
            rewrite lift_FrameStack_snoc in H.
            inv H.
          }

          rewrite lift_FrameStack_singleton in H.
          inv H.

          apply map_monad_OOM_fail in Heqo0.
          destruct Heqo0 as (?&?&?).

          red in H1.
          specialize (H1 x).
          destruct H1.
          forward H3.
          red.
          apply in_map; auto.

          red in H3.
          apply in_map_iff in H3.
          destruct H3 as (?&?&?).
          apply in_map_iff in H4.
          destruct H4 as (?&?&?).
          subst.
          destruct x.
          cbn in *.
          destruct x1.

          eapply fin_ptr_to_inf_round_trip with (pr:=p) in H3.
          destruct H3 as (?&?).
          rewrite H0 in H3; inv H3.
        }

        apply InfMemMMSP.frame_stack_inv in H1 as [H1 | H1].
        2: { (* Singleton is contradiction *)
          destruct H1 as (?&?&?&?&?).
          inv H0.
        }

        destruct H1 as (?&?&?&?&?&?&?&?).
        subst.
        destruct fss_fin as [fs_fin | fss_fin fs_fin].
        { rewrite lift_FrameStack_singleton in H.
          inv H.
        }
        rewrite lift_FrameStack_snoc in H.
        symmetry in H; inv H.
        symmetry in H0; inv H0.

        rewrite convert_FrameStack_Snoc_equation in Heqo.
        cbn in Heqo.
        repeat break_match_hyp_inv; eauto.

        { (* Singleton *)
          apply map_monad_OOM_fail in Heqo0.
          destruct Heqo0 as (?&?&?).

          red in H3.
          specialize (H3 x).
          destruct H3.
          forward H4.
          red.
          apply in_map; auto.

          red in H4.
          apply in_map_iff in H4.
          destruct H4 as (?&?&?).
          apply in_map_iff in H5.
          destruct H5 as (?&?&?).
          subst.
          destruct x.
          cbn in *.
          destruct x1.

          eapply fin_ptr_to_inf_round_trip with (pr:=p) in H4.
          destruct H4 as (?&?).
          rewrite H0 in H4; inv H4.
        }
      }

      { (* convert_memory OOM *)
        apply map_monad_OOM_fail in Heqo.
        destruct Heqo as ((addr&(byte&aid))&MEM_ELEMS&CONV).
        repeat break_match_hyp_inv.

        { (* convert_mem_byte OOM *)
          (* We only remove bytes from the map, so if they were good
             before with MSR, they should be good now *)
          (* May be some read_byte_raw lemmas that can help here *)
          (* Will likely need to use NON_FRAME_BYTES_PRESERVED and BYTES_FREED *)
          clear - MSR BYTES_FREED NON_FRAME_BYTES_PRESERVED NON_FRAME_BYTES_READ Heqo Heqo1 MEM_ELEMS.
          rename Heqo into A.
          rename Heqo1 into CONV_BYTE.
          epose proof (@int_to_ptr_succeeds_regardless_of_provenance _ (FinPROV.allocation_id_to_prov aid) _ _ A).
          clear a A.
          destruct H as (a&A).

          specialize (NON_FRAME_BYTES_READ (fin_to_inf_addr a) byte).
          forward NON_FRAME_BYTES_READ.
          { (* Pointer cannot be in frame because the byte isn't freed in MEM_ELEMS *)
            intros CONTRA.
            apply BYTES_FREED in CONTRA.
            red in CONTRA.
            eapply (CONTRA aid).
            Opaque big_int_to_ptr.
            eapply In_memory_is_allocated_inf; eauto.
            eapply fin_to_inf_addr_big_int_to_ptr; eauto.
          }

          destruct NON_FRAME_BYTES_READ as [_ NON_FRAME_BYTES_READ].
          forward NON_FRAME_BYTES_READ.
          eapply In_memory_read_byte_inf; eauto.

          pose NON_FRAME_BYTES_READ as READ.
          apply (MemState_refine_prop_read_byte_spec_preserved MSR) in READ.

          (* Using READ I want to be able to conclude that byte is a lifted SByte... *)
          apply read_byte_spec_lifted_memory_lifted_sbyte in READ.
          destruct READ as (fin_byte & LIFT_BYTE).
          subst.

          rewrite convert_SByte_lift_SByte in CONV_BYTE.
          inv CONV_BYTE.
        }

        { (* Address conversion OOM *)
          (* May need to make sure this is in bounds *)
          (* If convert_memory OOMs on address conversion...

             That means there was an address allocated in the infinite
             memory that was out of the finite range...

             This should be a contradiction with MSR.
           *)

          (* addr is a physical address in ms_inf'...
             addr cannot be converted to a finite pointer (it must be out of bounds)

             ms_inf' is the result of running pop...

             Pop should only remove addresses, so if the address was
             in bounds for ms_inf, it should be in bounds for ms_inf'
             as well.
           *)
          assert (exists byte, In (addr, (byte, aid)) (IntMaps.IM.elements (elt:=InfMemMMSP.mem_byte) ms_inf)) as MEM_ELEMS'.
          { (* Should hold because pop only removes things... *)
            remember (big_int_to_ptr addr (MemoryBigIntptrInfiniteSpec.LP.PROV.allocation_id_to_prov aid)) as a.

            pose proof In_memory_is_allocated_inf _ _ a _ _ {|
                    InfMemMMSP.ms_memory_stack :=
                      {|
                        InfMemMMSP.memory_stack_memory := ms_inf';
                        InfMemMMSP.memory_stack_frame_stack := fss_inf';
                        InfMemMMSP.memory_stack_heap := hs_inf'
                      |};
                    InfMemMMSP.ms_provenance := msprovs_inf'
                       |}
              (MemoryBigIntptrInfiniteSpec.LP.PROV.allocation_id_to_prov aid) MEM_ELEMS.
            forward H; cbn; auto.
            forward H; auto.

            assert (~ MemoryBigIntptr.MMEP.MemSpec.ptr_in_current_frame {|
                        InfMemMMSP.ms_memory_stack :=
                          {|
                            InfMemMMSP.memory_stack_memory := ms_inf;
                            InfMemMMSP.memory_stack_frame_stack := fss_inf;
                            InfMemMMSP.memory_stack_heap := hs_inf
                          |};
                        InfMemMMSP.ms_provenance := msprovs_inf
                      |} a) as NIN_FRAME.
            { intros NIN_FRAME.
              apply BYTES_FREED in NIN_FRAME.
              red in NIN_FRAME.
              apply NIN_FRAME in H; auto.
            }

            eapply NON_FRAME_BYTES_PRESERVED in NIN_FRAME.
            apply NIN_FRAME in H.

            epose proof byte_allocate_In_memory_inf H as IN.
            forward IN; cbn; auto.
            forward IN; cbn; eauto.
          }

          destruct MEM_ELEMS' as (byte' & IN_BOUNDS).
          eapply MemState_refine_prop_in_bounds
            with (ms_inf:=
                    {|
                      InfMemMMSP.ms_memory_stack :=
                        {|
                          InfMemMMSP.memory_stack_memory := ms_inf;
                          InfMemMMSP.memory_stack_frame_stack := fss_inf;
                          InfMemMMSP.memory_stack_heap := hs_inf
                        |};
                      InfMemMMSP.ms_provenance := msprovs_inf
                    |}) in IN_BOUNDS; cbn; eauto.

          unfold in_bounds in IN_BOUNDS.
          rewrite Heqo in IN_BOUNDS.
          discriminate.
        }
      }
    }

    (* Main lemma *)
    pose proof convert_MemState_MemState_refine_prop m_inf_final m_fin_final MS_FIN_FINAL as MSR_FINAL.

    exists m_fin_final.
    split; auto.
    split.
    - (* bytes_freed *)
      intros ptr IN_FRAME.

      epose proof inf_fin_ptr_in_current_frame MSR IN_FRAME as
        (ptr_inf & PTR_CONV & IN_FRAME_INF).

      eapply inf_fin_byte_not_allocated; eauto.
    - (* non_frame_bytes_preserved *)
      intros ptr aid NIN_FRAME.
      pose proof FinToInfAddrConvertSafe.addr_convert_succeeds ptr as (ptr_inf & ADDR_CONV).
      pose proof FinToInfAddrConvertSafe.addr_convert_safe _ _ ADDR_CONV as ADDR_CONV'.
      epose proof fin_inf_ptr_not_in_current_frame MSR ADDR_CONV NIN_FRAME as NIN_FRAME_INF.

      specialize (NON_FRAME_BYTES_PRESERVED ptr_inf aid NIN_FRAME_INF).
      split; intros ALLOC.
      + eapply inf_fin_byte_allocated; eauto.
        apply NON_FRAME_BYTES_PRESERVED.
        eapply fin_inf_byte_allocated; eauto.
      + eapply inf_fin_byte_allocated; eauto.
        apply NON_FRAME_BYTES_PRESERVED.
        eapply fin_inf_byte_allocated; eauto.
    - (* non_frame_bytes_read *)
      intros ptr byte NIN_FRAME.
      pose proof FinToInfAddrConvertSafe.addr_convert_succeeds ptr as (ptr_inf & ADDR_CONV).
      pose proof FinToInfAddrConvertSafe.addr_convert_safe _ _ ADDR_CONV as ADDR_CONV'.
      epose proof fin_inf_ptr_not_in_current_frame MSR ADDR_CONV NIN_FRAME as NIN_FRAME_INF.

      specialize (NON_FRAME_BYTES_READ ptr_inf (lift_SByte byte) NIN_FRAME_INF).
      split; intros ALLOC.
      + eapply fin_inf_read_byte_spec in ALLOC; eauto.
        2: {
          apply convert_SByte_lift_SByte.
        }
        eapply NON_FRAME_BYTES_READ in ALLOC.
        eapply inf_fin_read_byte_spec in ALLOC; eauto.
        destruct ALLOC as (byte_fin&RBS&BYTE).
        red in BYTE.
        apply lift_SByte_convert_SByte_inverse in BYTE.
        apply lift_SByte_injective in BYTE.
        subst.
        auto.
      + eapply fin_inf_read_byte_spec in ALLOC; eauto.
        2: {
          apply convert_SByte_lift_SByte.
        }
        eapply NON_FRAME_BYTES_READ in ALLOC.
        eapply inf_fin_read_byte_spec in ALLOC; eauto.
        destruct ALLOC as (byte_fin&RBS&BYTE).
        red in BYTE.
        apply lift_SByte_convert_SByte_inverse in BYTE.
        apply lift_SByte_injective in BYTE.
        subst.
        auto.
    - (* pop_frame *)
      clear - MSR MSR_FINAL CAN_POP POP_FRAME.

      intros fs1 fs2 FSP POP.
      red; red in FSP.
      red in POP.
      destruct fs1 as [f1 | fs1 f1]; try contradiction.

      destruct m_fin_start as [[ms_fin fss_fin hs_fin] msprovs_fin].
      destruct m_fin_final as [[ms_fin' fss_fin' hs_ifin'] msprovs_fin'].
      destruct m_inf_start as [[ms_inf fss_inf hs_inf] msprovs_inf].
      destruct m_inf_final as [[ms_inf' fss_inf' hs_inf'] msprovs_inf'].

      cbn in *.
      apply MemState_refine_prop_frame_stack_preserved in MSR, MSR_FINAL.
      red in MSR, MSR_FINAL.
      unfold MemoryBigIntptr.MMEP.MMSP.memory_stack_frame_stack_prop in *.
      cbn in *.

      apply FinMemMMSP.frame_stack_inv in FSP as [FSP | FSP].
      2: { (* Singleton is contradiction *)
        destruct FSP as (?&?&?&?&?).
        inv H0.
      }

      destruct FSP as (fs1' & fs2' & f2 & f3 & FSS_FIN & SNOC & FS_EQV & F_EQV).
      symmetry in SNOC; inv SNOC.

      specialize (MSR fss_inf).
      destruct MSR as [MSR _]; forward MSR; [red; cbn; reflexivity|].

      apply InfMemMMSP.frame_stack_inv in MSR as [MSR | MSR].
      2: { (* Singleton is contradiction *)
        destruct MSR as (?&?&?&?&?).
        rewrite lift_FrameStack_snoc in H.
        inv H.
      }

      destruct MSR as (?&?&?&?&?&?&?&?); subst.
      rewrite lift_FrameStack_snoc in H.
      symmetry in H; inv H.


      specialize (POP_FRAME (InfMemMMSP.Snoc x0 x2) x0).
      forward POP_FRAME; [reflexivity|].
      forward POP_FRAME; [red; reflexivity|].

      specialize (MSR_FINAL x0).
      destruct MSR_FINAL as [MSR_FINAL _]; forward MSR_FINAL; auto.

      rewrite <- POP, <- FS_EQV.
      eapply frame_stack_eqv_lift_inf_fin.
      red in MSR_FINAL; rewrite MSR_FINAL, H1.
      reflexivity.
    - (* mempop_invariants *)
      clear - MSR MSR_FINAL INVARIANTS.
      destruct INVARIANTS.
      split.
      + (* Preserve allocation ids *)
        eapply inf_fin_preserve_allocation_ids; eauto.
      + (* Heap preserved *)
        eapply inf_fin_heap_preserved; eauto.

        Unshelve.
        apply InfAddr.null.
  Qed.

  (* TODO: Move this *)
  Lemma dvalue_fin_to_inf_to_fin :
    forall d,
      DVCInfFin.dvalue_convert_strict (fin_to_inf_dvalue d) = NoOom d.
  Proof.
    intros d.
    pose proof fin_to_inf_dvalue_refine_strict d.
    auto.
  Qed.

  (* TODO: Move this *)
  Lemma uvalue_fin_to_inf_to_fin :
    forall u,
      DVCInfFin.uvalue_convert_strict (fin_to_inf_uvalue u) = NoOom u.
  Proof.
    intros u.
    pose proof fin_to_inf_uvalue_refine_strict u.
    auto.
  Qed.

  Set Nested Proofs Allowed.

  (* TODO: delete *)
  (* Lemma Heap_in_bounds_fresh_sid : *)
  (*   forall ms_fin ms_fin' sid_fin, *)
  (*     Heap_in_bounds ms_fin -> *)
  (*     fresh_sid ms_fin (ret (ms_fin', sid_fin)) -> *)
  (*     Heap_in_bounds ms_fin'. *)
  (* Proof. *)
  (*   intros ms_fin ms_fin' sid_fin H H0. *)
  (*   unfold fresh_sid in H0. *)
  (*   cbn in H0. *)
  (*   (* SAZ: It seems like we should add Heap_in_bounds_preserved in many places. *) *)
  (* Admitted. *)

  Lemma fin_inf_sbyte_to_extractbyte :
    forall byte uv dt idx sid,
      FinMem.MP.BYTE_IMPL.sbyte_to_extractbyte byte = LLVMParams64BitIntptr.Events.DV.UVALUE_ExtractByte uv dt idx sid ->
      InfMem.MP.BYTE_IMPL.sbyte_to_extractbyte (lift_SByte byte) = LLVMParamsBigIntptr.Events.DV.UVALUE_ExtractByte (fin_to_inf_uvalue uv) dt idx sid.
  Proof.
    intros byte uv dt idx sid H.
    unfold FinMem.MP.BYTE_IMPL.sbyte_to_extractbyte in H.
  Admitted.

  (* TODO: Move *)
  Lemma lift_SByte_sbyte_sid :
    forall byte sid,
      FinMem.MMEP.MMSP.MemByte.sbyte_sid byte = inr sid ->
      InfMem.MMEP.MMSP.MemByte.sbyte_sid (lift_SByte byte) = inr sid.
  Proof.
    intros byte sid H.
    unfold FinMem.MMEP.MMSP.MemByte.sbyte_sid in H.
    unfold InfMem.MMEP.MMSP.MemByte.sbyte_sid.

    break_match_hyp_inv.
    apply fin_inf_sbyte_to_extractbyte in Hequ.
    rewrite Hequ.
    reflexivity.
  Qed.

  Lemma used_store_id_fin_inf :
    forall ms_inf ms_fin sid,
      MemState_refine_prop ms_inf ms_fin ->
      FinMem.MMEP.MemSpec.used_store_id_prop ms_fin sid <->
        InfMem.MMEP.MemSpec.used_store_id_prop ms_inf sid.
  Proof.
    intros ms_inf ms_fin sid MSR.
    split; intros USED.
    {
      cbn in *.
      red; red in USED.
      destruct USED as [ptr [byte [READ BYTE]]].

      pose proof FinToInfAddrConvertSafe.addr_convert_succeeds ptr as [ptr_inf CONV].
      pose proof FinToInfAddrConvertSafe.addr_convert_safe ptr ptr_inf CONV as CONV_INF.
      exists ptr_inf. exists (lift_SByte byte).
      split.
      - eapply fin_inf_read_byte_prop; eauto.
        apply sbyte_refine_lifted.
      - apply lift_SByte_sbyte_sid; auto.
    }
    {
      cbn in *.
      red; red in USED.
      destruct USED as [ptr [byte [READ BYTE]]].

      pose proof inf_fin_read_byte_prop_exists MSR READ as (ptr_fin&byte_fin&READ_FIN&ADDR_REFINE&BYTE_REFINE).
      exists ptr_fin. exists byte_fin.
      split; auto.

      unfold sbyte_refine, convert_SByte in BYTE_REFINE.
      break_match_hyp; cbn in BYTE_REFINE.
      break_match_hyp; inv BYTE_REFINE.
      
      unfold FinMem.MMEP.MMSP.MemByte.sbyte_sid.
      unfold InfMem.MMEP.MMSP.MemByte.sbyte_sid in *.
      rewrite InfLLVM.MEM.Byte.sbyte_to_extractbyte_of_uvalue_sbyte in BYTE.
      inv BYTE.
      rewrite FinLLVM.MEM.Byte.sbyte_to_extractbyte_of_uvalue_sbyte.
      reflexivity.
    }
  Qed.

  Lemma used_store_id_lift_MemState :
    forall ms_fin sid,
      FinMem.MMEP.MemSpec.used_store_id_prop ms_fin sid <->
        InfMem.MMEP.MemSpec.used_store_id_prop (lift_MemState ms_fin) sid.
  Proof.
    intros ms_fin sid.
    split; intros USED.
    {
      cbn in *.
      red; red in USED.
      destruct USED as [ptr [byte [READ BYTE]]].

      pose proof FinToInfAddrConvertSafe.addr_convert_succeeds ptr as [ptr_inf CONV].
      pose proof FinToInfAddrConvertSafe.addr_convert_safe ptr ptr_inf CONV as CONV_INF.
      exists ptr_inf. exists (lift_SByte byte).
      split.
      - eapply fin_inf_read_byte_prop; eauto.
        apply lift_MemState_refine_prop; auto.
        apply sbyte_refine_lifted.
      - destruct byte. cbn.

        unfold FinMem.MMEP.MMSP.MemByte.sbyte_sid in *.
        unfold InfMem.MMEP.MMSP.MemByte.sbyte_sid in *.
        rewrite FinLLVM.MEM.Byte.sbyte_to_extractbyte_of_uvalue_sbyte in BYTE.
        inv BYTE.
        rewrite InfLLVM.MEM.Byte.sbyte_to_extractbyte_of_uvalue_sbyte.
        reflexivity.
    }
    {
      cbn in *.
      red; red in USED.
      destruct USED as [ptr [byte [READ BYTE]]].

      pose proof (lift_MemState_refine_prop ms_fin) as MSR.
      pose proof inf_fin_read_byte_prop_exists MSR READ as (ptr_fin&byte_fin&READ_FIN&ADDR_REFINE&BYTE_REFINE).
      exists ptr_fin. exists byte_fin.
      split; auto.

      unfold sbyte_refine, convert_SByte in BYTE_REFINE.
      break_match_hyp; cbn in BYTE_REFINE.
      break_match_hyp; inv BYTE_REFINE.

      (* TODO: Need lemmas about sbyte_sid *)
      unfold FinMem.MMEP.MMSP.MemByte.sbyte_sid, InfMem.MMEP.MMSP.MemByte.sbyte_sid in *.
      break_match_hyp; inv BYTE.

      unfold FinMem.MMEP.MMSP.MemByte.sbyte_sid in *.
      unfold InfMem.MMEP.MMSP.MemByte.sbyte_sid in *.
      rewrite InfLLVM.MEM.Byte.sbyte_to_extractbyte_of_uvalue_sbyte in Hequ0.
      inv Hequ0.
      rewrite FinLLVM.MEM.Byte.sbyte_to_extractbyte_of_uvalue_sbyte.
      reflexivity.
    }
  Qed.

  (* TODO: Move this somewhere I can use it for both fin / inf *)
  Lemma used_store_id_read_byte_preserved_fin :
    forall ms1 ms2 sid,
      FinMem.MMEP.MemSpec.read_byte_preserved ms1 ms2 ->
      FinMem.MMEP.MemSpec.used_store_id_prop ms1 sid <-> FinMem.MMEP.MemSpec.used_store_id_prop ms2 sid.
  Proof.
    intros ms1 ms2 sid RBP.
    split; intros [addr [byte [RB SID]]].
    - red.
      exists addr. exists byte.
      split; auto.
      apply RBP. auto.
    - red.
      exists addr. exists byte.
      split; auto.
      apply RBP. auto.
  Qed.

  (* TODO: Move this somewhere I can use it for both fin / inf *)
  #[global] Instance fin_read_byte_allowed_all_preserved_symmetric :
    Symmetric FinMem.MMEP.MemSpec.read_byte_allowed_all_preserved.
  Proof.
    intros x y RBA.
    red; red in RBA.
    intros ptr. split; intros RA.
    apply RBA; auto.
    apply RBA; auto.
  Qed.

  (* TODO: Move this somewhere I can use it for both fin / inf *)
  #[global] Instance fin_read_byte_prop_all_preserved_symmetric :
    Symmetric FinMem.MMEP.MemSpec.read_byte_prop_all_preserved.
  Proof.
    red.
    intros x y RBP.
    red; red in RBP.
    intros ptr byte. split; intros RB.
    apply RBP; auto.
    apply RBP; auto.
  Qed.

  (* TODO: Move this somewhere I can use it for both fin / inf *)
  #[global] Instance fin_read_byte_preserved_symmetric :
    Symmetric FinMem.MMEP.MemSpec.read_byte_preserved.
  Proof.
    red.
    intros x y H.
    destruct H.
    red.
    split; symmetry; auto.
  Qed.

  Lemma fresh_sid_fin_inf :
    forall (ms_inf : MemoryBigIntptr.MMEP.MMSP.MemState)
      (ms_fin ms_fin' : Memory64BitIntptr.MMEP.MMSP.MemState) (sid_fin : MemPropT.store_id),
      MemState_refine_prop ms_inf ms_fin ->
      fresh_sid ms_fin (ret (ms_fin', sid_fin)) ->
      exists sid_inf ms_inf',
        @fresh_sid (MemPropT MemoryBigIntptr.MMEP.MMSP.MemState) _  ms_inf (ret (ms_inf', sid_inf)) /\
          sid_inf = sid_fin /\
          MemState_refine_prop ms_inf' ms_fin'.
  Proof.
    intros ms_inf ms_fin ms_fin' sid_fin MSR FRESH.
    pose proof MSR as MSR'.
    cbn in *.
    red in MSR.
    exists sid_fin.
    exists (lift_MemState ms_fin).
    cbn.
    destruct MSR as (?&?&?&?&?&?&?&?).
    destruct FRESH as (?&?&?&?&?&?&?&?).
    split.
    { split; [|split; [|split; [|split; [|split; [|split; [|split]]]]]]; auto.
      intros USED.
      apply used_store_id_lift_MemState in USED.
      apply f.

      eapply used_store_id_read_byte_preserved_fin; eauto.
      symmetry; auto.
      eapply fin_inf_heap_preserved; eauto.

      red.
      red.
      split; [|split; [|split; [|split; [|split; [|split]]]]];
        eauto with FinInf.
    }

    split; auto.
    split; [|split; [|split; [|split; [|split; [|split]]]]];
      eauto with FinInf.
    Unshelve.
    apply InfMem.MMEP.initial_heap.
  Qed.

  Lemma fin_inf_extend_provenance :
    forall pr ms_fin ms_fin' ms_inf ms_inf',
      MemState_refine_prop ms_inf ms_fin ->
      MemState_refine_prop ms_inf' ms_fin' ->
      FinMem.MMEP.MemSpec.extend_provenance ms_fin pr ms_fin' ->
      InfMem.MMEP.MemSpec.extend_provenance ms_inf pr ms_inf'.
  Proof.
    intros pr ms_fin ms_fin' ms_inf ms_inf' MSR1 MSR2 [OLD NEW].
    split.
    - intros pr0 H.
      eapply fin_inf_used_provenance_prop; eauto.
      eapply inf_fin_used_provenance_prop in H.
      2: eauto.
      eauto.
    - clear OLD.
      destruct NEW as [UNUSED USED].
      split.
      + intros UP.
        apply UNUSED.
        eapply inf_fin_used_provenance_prop; eauto.
      + eapply fin_inf_used_provenance_prop; eauto.
  Qed.

  #[global] Hint Resolve fin_inf_extend_provenance : FinInf.

  (* TODO: Move this, prove this *)
  Lemma fresh_provenance_fin_inf :
    forall (ms_inf : MemoryBigIntptr.MMEP.MMSP.MemState)
      (ms_fin ms_fin' : Memory64BitIntptr.MMEP.MMSP.MemState) (pr_fin : LLVMParamsBigIntptr.PROV.Provenance),
      MemState_refine_prop ms_inf ms_fin ->
      fresh_provenance ms_fin (ret (ms_fin', pr_fin)) ->
      exists pr_inf ms_inf',
        @fresh_provenance _ (MemPropT MemoryBigIntptr.MMEP.MMSP.MemState) _  ms_inf (ret (ms_inf', pr_inf)) /\
          pr_inf = pr_fin /\
          MemState_refine_prop ms_inf' ms_fin'.
  Proof.
    intros ms_inf ms_fin ms_fin' pr_fin MSR FRESH.
    exists pr_fin.
    exists (lift_MemState ms_fin').
    split; eauto with FinInf.

    cbn in *.
    destruct FRESH as (?&?&?&?&?&?&?).
    split; [|split; [|split; [|split; [|split; [|split]]]]]; eauto with FinInf.
  Qed.

  #[global] Hint Resolve fresh_provenance_fin_inf : FinInf.

  (* TODO: Move this / put it somewhere I get it for fin / inf *)
  Lemma generate_num_undef_bytes_h_succ_inv :
    forall sz start_ix t sid bytes_fin,
      Memory64BitIntptr.MMEP.MemSpec.MemHelpers.generate_num_undef_bytes_h start_ix (N.succ sz) t sid = NoOom bytes_fin ->
      exists byte bytes_fin',
        Memory64BitIntptr.MMEP.MemSpec.MemHelpers.generate_num_undef_bytes_h (N.succ start_ix) sz t sid = NoOom bytes_fin' /\
          (uvalue_sbyte (UVALUE_Undef t) t start_ix sid = byte) /\
          bytes_fin = byte :: bytes_fin'.
  Proof.
    induction sz using N.peano_rect; intros start_ix t sid bytes_fin GEN.
    unfold Memory64BitIntptr.MMEP.MemSpec.MemHelpers.generate_num_undef_bytes_h in *.
    - cbn in *.
      inv GEN.
      do 2 eexists.
      split; eauto.
    - unfold Memory64BitIntptr.MMEP.MemSpec.MemHelpers.generate_num_undef_bytes_h in GEN.

      pose proof @N.recursion_succ (N -> OOM (list SByte)) eq (fun _ : N => ret [])
        (fun (_ : N) (mf : N -> OOM (list SByte)) (x : N) =>
           rest_bytes <- mf (N.succ x);;
           ret (uvalue_sbyte (UVALUE_Undef t) t x sid :: rest_bytes))
        eq_refl.
      forward H.
      { unfold Proper, respectful.
        intros x y H0 x0 y0 H1; subst.
        reflexivity.
      }
      specialize (H (N.succ sz)).
      rewrite H in GEN.
      clear H.

      cbn in *.
      break_match_hyp; inv GEN.

      specialize (IHsz (N.succ start_ix) t sid l Heqo).
      destruct IHsz as (byte&bytes_fin'&GEN'&BYTE&BYTES).
      subst.

      eexists.
      eexists.
      split; eauto.
  Qed.

  (* TODO: Move this / put it somewhere I get it for fin / inf (get rid of this version) *)
  Lemma generate_num_undef_bytes_h_succ_inv_inf :
    forall sz start_ix t sid bytes_inf,
      MemoryBigIntptr.MMEP.MemSpec.MemHelpers.generate_num_undef_bytes_h start_ix (N.succ sz) t sid = NoOom bytes_inf ->
      exists byte bytes_inf',
        MemoryBigIntptr.MMEP.MemSpec.MemHelpers.generate_num_undef_bytes_h (N.succ start_ix) sz t sid = NoOom bytes_inf' /\
          (MemoryBigIntptr.Byte.uvalue_sbyte (LLVMParamsBigIntptr.Events.DV.UVALUE_Undef t) t
             start_ix sid) = byte /\
          bytes_inf = byte :: bytes_inf'.
  Proof.
    induction sz using N.peano_rect; intros start_ix t sid bytes_fin GEN.
    unfold Memory64BitIntptr.MMEP.MemSpec.MemHelpers.generate_num_undef_bytes_h in *.
    - cbn in *.
      inv GEN.
      do 2 eexists.
      split; eauto.
    - unfold Memory64BitIntptr.MMEP.MemSpec.MemHelpers.generate_num_undef_bytes_h in GEN.

      pose proof @N.recursion_succ (N -> OOM (list InfMem.MP.BYTE_IMPL.SByte)) eq (fun _ : N => ret [])
        (fun (_ : N) (mf : N -> OOM (list InfMem.MP.BYTE_IMPL.SByte)) (x : N) =>
           rest_bytes <- mf (N.succ x);;
           ret (MemoryBigIntptr.Byte.uvalue_sbyte (LLVMParamsBigIntptr.Events.DV.UVALUE_Undef t) t
                  x sid :: rest_bytes))
        eq_refl.
      forward H.
      { unfold Proper, respectful.
        intros x y H0 x0 y0 H1; subst.
        reflexivity.
      }
      specialize (H (N.succ sz)).
      unfold MemoryBigIntptr.MMEP.MemSpec.MemHelpers.generate_num_undef_bytes_h in GEN.
      rewrite H in GEN.
      clear H.

      cbn in *.
      break_match_hyp; inv GEN.

      specialize (IHsz (N.succ start_ix) t sid l Heqo).
      destruct IHsz as (byte&bytes_fin'&GEN'&BYTE&BYTES).
      inv BYTE.

      eexists.
      eexists.
      split; eauto.
  Qed.

  (* TODO: Move this *)
  Lemma generate_num_undef_bytes_h_fin_inf :
    forall sz start_ix t sid bytes_fin,
      Memory64BitIntptr.MMEP.MemSpec.MemHelpers.generate_num_undef_bytes_h start_ix sz t sid = NoOom bytes_fin ->
      exists bytes_inf,
        MemoryBigIntptr.MMEP.MemSpec.MemHelpers.generate_num_undef_bytes_h start_ix sz t sid = NoOom bytes_inf /\
          sbytes_refine bytes_inf bytes_fin.
  Proof.
    induction sz using N.peano_ind; intros start_ix t sid bytes_fin GEN.
    - cbn in *. inv GEN.
      exists [].
      split; auto.
      red.
      auto.
    - cbn in GEN.
      pose proof GEN as GEN'.
      apply generate_num_undef_bytes_h_succ_inv in GEN'.
      destruct GEN' as (byte&bytes_fin'&GEN'&BYTE&BYTES).
      subst.
      cbn in *.

      specialize (IHsz _ t sid bytes_fin' GEN') as (bytes_inf&GEN_INF&BYTES_REF).
      exists (MemoryBigIntptr.Byte.uvalue_sbyte (LLVMParamsBigIntptr.Events.DV.UVALUE_Undef t) t start_ix sid :: bytes_inf).
      split.
      + setoid_rewrite MemoryBigIntptrInfiniteSpecHelpers.generate_num_undef_bytes_h_cons.
        cbn.
        setoid_rewrite GEN_INF.
        reflexivity.
        eauto.
      + red.
        eapply Forall2_cons; eauto.
        red.
        unfold convert_SByte.
        break_match_goal.
        unfold MemoryBigIntptr.Byte.uvalue_sbyte in *.
        inv Heqs.
        cbn in *.
        cbn.
        unfold InterpreterStackBigIntptr.LP.IP.to_Z.
        reflexivity.
  Qed.

  (* TODO: Move this *)
  Lemma generate_num_undef_bytes_fin_inf :
    forall sz t sid bytes_fin,
      Memory64BitIntptr.MMEP.MemSpec.MemHelpers.generate_num_undef_bytes sz t sid = NoOom bytes_fin ->
      exists bytes_inf,
        MemoryBigIntptr.MMEP.MemSpec.MemHelpers.generate_num_undef_bytes sz t sid = NoOom bytes_inf /\
          sbytes_refine bytes_inf bytes_fin.
  Proof.
    intros sz t sid bytes_fin H.
    eapply generate_num_undef_bytes_h_fin_inf; eauto.
  Qed.

  (* TODO: Move this *)
  Lemma generate_undef_bytes_fin_inf :
    forall {t sid bytes_fin},
      Memory64BitIntptr.MMEP.MemSpec.MemHelpers.generate_undef_bytes t sid = NoOom bytes_fin ->
      exists bytes_inf,
        MemoryBigIntptr.MMEP.MemSpec.MemHelpers.generate_undef_bytes t sid = NoOom bytes_inf /\
          sbytes_refine bytes_inf bytes_fin.
  Proof.
    intros t sid bytes_fin GEN.
    unfold Memory64BitIntptr.MMEP.MemSpec.MemHelpers.generate_undef_bytes in GEN.
    eapply generate_num_undef_bytes_fin_inf in GEN.
    eauto.
  Qed.

  (* TODO: Move to list utilities *)
  Lemma Forall2_repeatN :
    forall {X Y} (x : X) (y : Y) n (P : X -> Y -> Prop),
      P x y ->
      Forall2 P (repeatN n x) (repeatN n y).
  Proof.
    intros X Y x y n P H.
    induction n using N.peano_ind.
    - cbn; auto.
    - repeat rewrite repeatN_succ.
      constructor; auto.
  Qed.

  (* TODO: Move this *)
  Lemma Forall2_concat :
    forall {X Y} xs ys (P : X -> Y -> Prop),
      Forall2 (Forall2 P) xs ys ->
      Forall2 P (concat xs) (concat ys).
  Proof.
    intros X Y xs ys P ALL.
    induction ALL.
    - cbn; auto.
    - cbn.
      apply Forall2_app; auto.
  Qed.

  Lemma block_is_free_fin_inf :
    forall {ms_fin ms_inf addr_fin addrs_fin addr_inf addrs_inf len pr},
      MemState_refine_prop ms_inf ms_fin ->
      InfToFinAddrConvert.addr_convert addr_inf = NoOom addr_fin ->
      Forall2 (fun addr_inf addr_fin => InfToFinAddrConvert.addr_convert addr_inf = NoOom addr_fin) addrs_inf addrs_fin ->
      Memory64BitIntptr.MMEP.MemSpec.block_is_free ms_fin len pr addr_fin addrs_fin ->
      MemoryBigIntptr.MMEP.MemSpec.block_is_free ms_inf len pr addr_inf addrs_inf.
  Proof.
    intros ms_fin ms_inf addr_fin addrs_fin addr_inf addrs_inf len pr MSR ADDR_CONV ADDRS_CONV BLOCK_FREE.
    destruct BLOCK_FREE.
    split.
    - eapply fin_inf_get_consecutive_ptrs_success; eauto.
      eapply Forall2_flip.
      unfold Util.flip, flip.
      eauto.
      apply block_is_free_consecutive.
    - erewrite inf_fin_addr_convert_provenance; eauto.
    - intros ptr H.
      apply In_Nth in H. destruct H.
      eapply Util.Forall2_Nth_left in ADDRS_CONV; eauto.
      destruct ADDRS_CONV as (?&?&?).

      pose proof Util.Nth_In H0.

      specialize (block_is_free_ptrs_provenance _ H2).

      erewrite inf_fin_addr_convert_provenance; eauto.
    - intros ptr H.
      apply In_Nth in H. destruct H.
      eapply Util.Forall2_Nth_left in ADDRS_CONV; eauto.
      destruct ADDRS_CONV as (?&?&?).

      pose proof Util.Nth_In H0.

      specialize (block_is_free_bytes_are_free _ H2).

      eapply fin_inf_byte_not_allocated; eauto.
  Qed.

  #[global] Hint Resolve block_is_free_fin_inf : FinInf.

  Lemma find_free_block_fin_inf :
    forall {ms_fin_start ms_fin_final ms_inf_start len res_fin pr},
      MemState_refine_prop ms_inf_start ms_fin_start ->
      Memory64BitIntptr.MMEP.MemSpec.find_free_block len pr ms_fin_start (ret (ms_fin_final, res_fin)) ->
      exists res_inf ms_inf_final,
        MemoryBigIntptr.MMEP.MemSpec.find_free_block len pr ms_inf_start (ret (ms_inf_final, res_inf)) /\
          (fun '(addr_inf, addrs_inf) '(addr_fin, addrs_fin) =>
             InfToFinAddrConvert.addr_convert addr_inf = NoOom addr_fin /\
               Forall2 (fun addr_inf addr_fin => InfToFinAddrConvert.addr_convert addr_inf = NoOom addr_fin) addrs_inf addrs_fin) res_inf res_fin /\
          MemState_refine_prop ms_inf_final ms_fin_final.
  Proof.
    intros ms_fin_start ms_fin_final ms_inf_start len [addr_fin addrs_fin] pr MSR FIND_FREE_BLOCK.


    pose proof FinToInfAddrConvertSafe.addr_convert_succeeds addr_fin as (addr_inf & CONV_FIN).
    apply FinToInfAddrConvertSafe.addr_convert_safe in CONV_FIN as CONV_INF.

    cbn in FIND_FREE_BLOCK.
    destruct FIND_FREE_BLOCK; subst.

    (* TODO: Move to listutils *)
    Lemma Forall2_map :
      forall {A B C} (R : B -> C -> Prop) (f : A -> B) (l1 : list A) (l2 : list C),
        Forall2 (fun a b => R (f a) b) l1 l2 ->
        Forall2 R (map f l1) l2.
    Proof.
      intros A B C R f l1 l2 ALL.
      induction ALL; cbn; auto.
    Qed.

    remember (map fin_to_inf_addr addrs_fin) as addrs_inf.
    assert (Forall2
              (fun (addr_inf0 : InfAddr.addr) (addr_fin0 : FinAddr.addr) =>
                 InfToFinAddrConvert.addr_convert addr_inf0 = NoOom addr_fin0) addrs_inf addrs_fin) as ADDRS.
    {
      clear H0; subst.
      induction addrs_fin; cbn; auto.

      apply Forall2_cons.
      { unfold fin_to_inf_addr.
        break_match_goal.
        clear Heqs.
        apply FinToInfAddrConvertSafe.addr_convert_safe in e.
        auto.
      }

      eapply IHaddrs_fin.
    }

    eapply @block_is_free_fin_inf with (addrs_inf:=map fin_to_inf_addr addrs_fin) in H0; eauto.
    2: {
      subst; apply ADDRS.
    }


    exists (addr_inf, addrs_inf).
    exists ms_inf_start.
    split.
    2: {
      split; auto.
    }

    red; cbn.
    split; subst; auto.
  Qed.

  #[global] Hint Resolve find_free_block_fin_inf : FinInf.

  (* TODO: Move this *)
  Lemma MemState_refine_prop_preserve_allocation_ids :
    forall ms_inf ms_fin,
      MemState_refine_prop ms_inf ms_fin ->
      InfMem.MMEP.MemSpec.preserve_allocation_ids ms_inf (lift_MemState ms_fin).
  Proof.
    intros ms_inf ms_fin MSR.
    destruct MSR.
    tauto.
  Qed.

  (* TODO: move this... *)
  Lemma provenance_to_allocation_id_fin_inf :
    forall pr,
      FinPROV.provenance_to_allocation_id pr = InfPROV.provenance_to_allocation_id pr.
  Proof.
    intros pr.
    reflexivity.
  Qed.

  Lemma extend_allocations_fin_inf :
    forall {ms_inf_start ms_fin_start ms_inf_final ms_fin_final addrs_fin addrs_inf pr},
      MemState_refine_prop ms_inf_start ms_fin_start ->
      MemState_refine_prop ms_inf_final ms_fin_final ->
      Forall2 addr_refine addrs_inf addrs_fin ->
      Memory64BitIntptr.MMEP.MemSpec.extend_allocations ms_fin_start addrs_fin pr ms_fin_final ->
      MemoryBigIntptr.MMEP.MemSpec.extend_allocations ms_inf_start addrs_inf pr ms_inf_final.
  Proof.
    intros ms_inf_start ms_fin_start ms_inf_final ms_fin_final addrs_fin addrs_inf pr MSR1 MSR2 ADDRS EXTEND.
    destruct EXTEND.

    split.
    - (* New bytes allocated *)
      intros ptr IN.
      apply In_Nth in IN as (i&IN).
      pose proof Util.Forall2_Nth_left IN ADDRS as (ptr_fin & NTH_FIN & REF).

      apply Util.Nth_In in NTH_FIN.
      rewrite provenance_to_allocation_id_fin_inf in extend_allocations_bytes_now_allocated.

      eapply fin_inf_byte_allocated; eauto.
    - (* Old allocations preserved *)
      intros ptr aid DISJOINT.
      split; intros ALLOC.
      { destruct (InfToFinAddrConvert.addr_convert ptr) eqn:CONV.
        { (* ptr in finite range *)
          specialize (extend_allocations_old_allocations_preserved a aid).
          forward extend_allocations_old_allocations_preserved.
          {
            intros p IN.
            apply In_Nth in IN as (i&IN).
            pose proof Util.Forall2_Nth_right IN ADDRS as (ptr_inf & NTH_INF & REF).

            eapply fin_inf_disjoint_ptr_byte; eauto.
            eapply DISJOINT.
            apply Util.Nth_In in NTH_INF.
            auto.
          }

          eapply fin_inf_byte_allocated; eauto.
          apply extend_allocations_old_allocations_preserved.
          eapply inf_fin_byte_allocated; eauto.
        }

        { (* Big pointer, shouldn't be allocated. *)
          exfalso.
          eapply inf_fin_big_address_byte_not_allocated.
          3: eauto.
          all: eauto.
        }
      }

      { destruct (InfToFinAddrConvert.addr_convert ptr) eqn:CONV.
        { (* ptr in finite range *)
          specialize (extend_allocations_old_allocations_preserved a aid).
          forward extend_allocations_old_allocations_preserved.
          {
            intros p IN.
            apply In_Nth in IN as (i&IN).
            pose proof Util.Forall2_Nth_right IN ADDRS as (ptr_inf & NTH_INF & REF).

            eapply fin_inf_disjoint_ptr_byte; eauto.
            eapply DISJOINT.
            apply Util.Nth_In in NTH_INF.
            auto.
          }

          eapply fin_inf_byte_allocated; eauto.
          apply extend_allocations_old_allocations_preserved.
          eapply inf_fin_byte_allocated; eauto.
        }

        { (* Big pointer, shouldn't be allocated. *)
          exfalso.
          eapply inf_fin_big_address_byte_not_allocated.
          3: eauto.
          all: eauto.
        }
      }
  Qed.

  Lemma extend_read_byte_allowed_fin_inf :
    forall {ms_inf_start ms_fin_start ms_inf_final ms_fin_final addrs_fin addrs_inf},
      MemState_refine_prop ms_inf_start ms_fin_start ->
      MemState_refine_prop ms_inf_final ms_fin_final ->
      Forall2 addr_refine addrs_inf addrs_fin ->
      Memory64BitIntptr.MMEP.MemSpec.extend_read_byte_allowed ms_fin_start addrs_fin ms_fin_final ->
      MemoryBigIntptr.MMEP.MemSpec.extend_read_byte_allowed ms_inf_start addrs_inf ms_inf_final.
  Proof.
    intros ms_inf_start ms_fin_start ms_inf_final ms_fin_final addrs_fin addrs_inf MSR1 MSR2 ADDRS EXTEND.
    destruct EXTEND.

    split.
    - (* New reads *)
      intros ptr IN.
      apply In_Nth in IN as (i&IN).
      pose proof Util.Forall2_Nth_left IN ADDRS as (ptr_fin & NTH_FIN & REF).

      apply Util.Nth_In in NTH_FIN.

      eapply fin_inf_read_byte_allowed; eauto.
    - (* Old reads preserved *)
      intros ptr DISJOINT.
      split; intros ALLOC.
      { destruct (InfToFinAddrConvert.addr_convert ptr) eqn:CONV.
        { (* ptr in finite range *)
          specialize (extend_read_byte_allowed_old_reads a).
          forward extend_read_byte_allowed_old_reads.
          {
            intros p IN.
            apply In_Nth in IN as (i&IN).
            pose proof Util.Forall2_Nth_right IN ADDRS as (ptr_inf & NTH_INF & REF).

            eapply fin_inf_disjoint_ptr_byte; eauto.
            eapply DISJOINT.
            apply Util.Nth_In in NTH_INF.
            auto.
          }

          eapply fin_inf_read_byte_allowed; eauto.
          apply extend_read_byte_allowed_old_reads.
          eapply inf_fin_read_byte_allowed; eauto.
        }

        { (* Big pointer, shouldn't be allocated. *)
          exfalso.
          destruct ALLOC as (?&?&?).
          eapply inf_fin_big_address_byte_not_allocated.
          3: eauto.
          all: eauto.
        }
      }

      { destruct (InfToFinAddrConvert.addr_convert ptr) eqn:CONV.
        { (* ptr in finite range *)
          specialize (extend_read_byte_allowed_old_reads a).
          forward extend_read_byte_allowed_old_reads.
          {
            intros p IN.
            apply In_Nth in IN as (i&IN).
            pose proof Util.Forall2_Nth_right IN ADDRS as (ptr_inf & NTH_INF & REF).

            eapply fin_inf_disjoint_ptr_byte; eauto.
            eapply DISJOINT.
            apply Util.Nth_In in NTH_INF.
            auto.
          }

          eapply fin_inf_read_byte_allowed; eauto.
          apply extend_read_byte_allowed_old_reads.
          eapply inf_fin_read_byte_allowed; eauto.
        }

        { (* Big pointer, shouldn't be allocated. *)
          exfalso.
          destruct ALLOC as (?&?&?).
          eapply inf_fin_big_address_byte_not_allocated.
          3: eauto.
          all: eauto.
        }
      }
  Qed.

  Lemma extend_reads_fin_inf :
    forall {ms_inf_start ms_fin_start ms_inf_final ms_fin_final addrs_fin addrs_inf bytes_inf bytes_fin},
      MemState_refine_prop ms_inf_start ms_fin_start ->
      MemState_refine_prop ms_inf_final ms_fin_final ->
      Forall2 addr_refine addrs_inf addrs_fin ->
      sbytes_refine bytes_inf bytes_fin ->
      Memory64BitIntptr.MMEP.MemSpec.extend_reads ms_fin_start addrs_fin bytes_fin ms_fin_final ->
      MemoryBigIntptr.MMEP.MemSpec.extend_reads ms_inf_start addrs_inf bytes_inf ms_inf_final.
  Proof.
    intros ms_inf_start ms_fin_start ms_inf_final ms_fin_final addrs_fin addrs_inf bytes_inf bytes_fin MSR1 MSR2 ADDRS BYTES EXTEND.
    destruct EXTEND.

    split.
    - (* New reads *)
      intros p ix byte NTH1 NTH2.
      pose proof Util.Forall2_Nth_left NTH1 ADDRS as (ptr_fin & NTH_FIN & REF_ADDR).
      pose proof Util.Forall2_Nth_left NTH2 BYTES as (byte_fin & NTH_FIN_BYTE & REF_BYTE).

      eapply fin_inf_read_byte_prop; eauto.
    - (* Old reads preserved *)
      intros ptr byte DISJOINT.
      split; intros READ.
      { (* ptr in finite range *)
        pose proof READ as READ'.
        eapply inf_fin_read_byte_prop_exists in READ' as (ptr_fin&byte_fin&READ'&ADDR_REF&BYTE_REF); eauto.
        specialize (extend_reads_old_reads ptr_fin byte_fin).
        forward extend_reads_old_reads.
        {
          intros p IN.
          apply In_Nth in IN as (i&IN).
          pose proof Util.Forall2_Nth_right IN ADDRS as (ptr_inf & NTH_INF & REF).

          eapply fin_inf_disjoint_ptr_byte; eauto.
          eapply DISJOINT.
          apply Util.Nth_In in NTH_INF.
          auto.
        }

        eapply fin_inf_read_byte_prop; eauto.
        apply extend_reads_old_reads.
        eapply inf_fin_read_byte_prop; eauto.
      }
      { (* ptr in finite range *)
        pose proof READ as READ'.
        eapply inf_fin_read_byte_prop_exists in READ' as (ptr_fin&byte_fin&READ'&ADDR_REF&BYTE_REF); eauto.
        specialize (extend_reads_old_reads ptr_fin byte_fin).
        forward extend_reads_old_reads.
        {
          intros p IN.
          apply In_Nth in IN as (i&IN).
          pose proof Util.Forall2_Nth_right IN ADDRS as (ptr_inf & NTH_INF & REF).

          eapply fin_inf_disjoint_ptr_byte; eauto.
          eapply DISJOINT.
          apply Util.Nth_In in NTH_INF.
          auto.
        }

        eapply fin_inf_read_byte_prop; eauto.
        apply extend_reads_old_reads.
        eapply inf_fin_read_byte_prop; eauto.
      }
  Qed.

  Lemma extend_write_byte_allowed_fin_inf :
    forall {ms_inf_start ms_fin_start ms_inf_final ms_fin_final addrs_fin addrs_inf},
      MemState_refine_prop ms_inf_start ms_fin_start ->
      MemState_refine_prop ms_inf_final ms_fin_final ->
      Forall2 addr_refine addrs_inf addrs_fin ->
      Memory64BitIntptr.MMEP.MemSpec.extend_write_byte_allowed ms_fin_start addrs_fin ms_fin_final ->
      MemoryBigIntptr.MMEP.MemSpec.extend_write_byte_allowed ms_inf_start addrs_inf ms_inf_final.
  Proof.
    intros ms_inf_start ms_fin_start ms_inf_final ms_fin_final addrs_fin addrs_inf MSR1 MSR2 ADDRS EXTEND.
    destruct EXTEND.

    split.
    - (* New writes *)
      intros ptr IN.
      apply In_Nth in IN as (i&IN).
      pose proof Util.Forall2_Nth_left IN ADDRS as (ptr_fin & NTH_FIN & REF).

      apply Util.Nth_In in NTH_FIN.

      eapply fin_inf_write_byte_allowed; eauto.
    - (* Old writes preserved *)
      intros ptr DISJOINT.
      split; intros ALLOC.
      { destruct (InfToFinAddrConvert.addr_convert ptr) eqn:CONV.
        { (* ptr in finite range *)
          specialize (extend_write_byte_allowed_old_writes a).
          forward extend_write_byte_allowed_old_writes.
          {
            intros p IN.
            apply In_Nth in IN as (i&IN).
            pose proof Util.Forall2_Nth_right IN ADDRS as (ptr_inf & NTH_INF & REF).

            eapply fin_inf_disjoint_ptr_byte; eauto.
            eapply DISJOINT.
            apply Util.Nth_In in NTH_INF.
            auto.
          }

          eapply fin_inf_write_byte_allowed; eauto.
          apply extend_write_byte_allowed_old_writes.
          eapply inf_fin_read_byte_allowed; eauto.
        }

        { (* Big pointer, shouldn't be allocated. *)
          exfalso.
          destruct ALLOC as (?&?&?).
          eapply inf_fin_big_address_byte_not_allocated.
          3: eauto.
          all: eauto.
        }
      }

      { destruct (InfToFinAddrConvert.addr_convert ptr) eqn:CONV.
        { (* ptr in finite range *)
          specialize (extend_write_byte_allowed_old_writes a).
          forward extend_write_byte_allowed_old_writes.
          {
            intros p IN.
            apply In_Nth in IN as (i&IN).
            pose proof Util.Forall2_Nth_right IN ADDRS as (ptr_inf & NTH_INF & REF).

            eapply fin_inf_disjoint_ptr_byte; eauto.
            eapply DISJOINT.
            apply Util.Nth_In in NTH_INF.
            auto.
          }

          eapply fin_inf_write_byte_allowed; eauto.
          apply extend_write_byte_allowed_old_writes.
          eapply inf_fin_read_byte_allowed; eauto.
        }

        { (* Big pointer, shouldn't be allocated. *)
          exfalso.
          destruct ALLOC as (?&?&?).
          eapply inf_fin_big_address_byte_not_allocated.
          3: eauto.
          all: eauto.
        }
      }
  Qed.

  Lemma extend_free_byte_allowed_fin_inf :
    forall {ms_inf_start ms_fin_start ms_inf_final ms_fin_final addrs_fin addrs_inf},
      MemState_refine_prop ms_inf_start ms_fin_start ->
      MemState_refine_prop ms_inf_final ms_fin_final ->
      Forall2 addr_refine addrs_inf addrs_fin ->
      Memory64BitIntptr.MMEP.MemSpec.extend_free_byte_allowed ms_fin_start addrs_fin ms_fin_final ->
      MemoryBigIntptr.MMEP.MemSpec.extend_free_byte_allowed ms_inf_start addrs_inf ms_inf_final.
  Proof.
    intros ms_inf_start ms_fin_start ms_inf_final ms_fin_final addrs_fin addrs_inf MSR1 MSR2 ADDRS EXTEND.
    destruct EXTEND.

    split.
    - (* New bytes *)
      intros ptr IN.
      apply In_Nth in IN as (i&IN).
      pose proof Util.Forall2_Nth_left IN ADDRS as (ptr_fin & NTH_FIN & REF).

      apply Util.Nth_In in NTH_FIN.

      eapply fin_inf_free_byte_allowed; eauto.
    - (* Old free bytes preserved *)
      intros ptr DISJOINT.
      split; intros ALLOC.
      { destruct (InfToFinAddrConvert.addr_convert ptr) eqn:CONV.
        { (* ptr in finite range *)
          specialize (extend_free_byte_allowed_old a).
          forward extend_free_byte_allowed_old.
          {
            intros p IN.
            apply In_Nth in IN as (i&IN).
            pose proof Util.Forall2_Nth_right IN ADDRS as (ptr_inf & NTH_INF & REF).

            eapply fin_inf_disjoint_ptr_byte; eauto.
            eapply DISJOINT.
            apply Util.Nth_In in NTH_INF.
            auto.
          }

          eapply fin_inf_free_byte_allowed; eauto.
          apply extend_free_byte_allowed_old.
          eapply inf_fin_read_byte_allowed; eauto.
        }

        { (* Big pointer, shouldn't be allocated. *)
          exfalso.
          destruct ALLOC as (?&?&?).
          eapply inf_fin_big_address_byte_not_allocated.
          3: eauto.
          all: eauto.
        }
      }

      { destruct (InfToFinAddrConvert.addr_convert ptr) eqn:CONV.
        { (* ptr in finite range *)
          specialize (extend_free_byte_allowed_old a).
          forward extend_free_byte_allowed_old.
          {
            intros p IN.
            apply In_Nth in IN as (i&IN).
            pose proof Util.Forall2_Nth_right IN ADDRS as (ptr_inf & NTH_INF & REF).

            eapply fin_inf_disjoint_ptr_byte; eauto.
            eapply DISJOINT.
            apply Util.Nth_In in NTH_INF.
            auto.
          }

          eapply fin_inf_free_byte_allowed; eauto.
          apply extend_free_byte_allowed_old.
          eapply inf_fin_read_byte_allowed; eauto.
        }

        { (* Big pointer, shouldn't be allocated. *)
          exfalso.
          destruct ALLOC as (?&?&?).
          eapply inf_fin_big_address_byte_not_allocated.
          3: eauto.
          all: eauto.
        }
      }
  Qed.

  (* TODO: Move to where this applies for both fin / inf *)
  Lemma add_ptr_to_frame_commutative :
    forall a b f1 f2 f2' f3,
      MemoryBigIntptr.MMEP.MemSpec.add_ptr_to_frame f1 a f2 ->
      MemoryBigIntptr.MMEP.MemSpec.add_ptr_to_frame f2 b f3 ->
      MemoryBigIntptr.MMEP.MemSpec.add_ptr_to_frame f1 b f2' ->
      MemoryBigIntptr.MMEP.MemSpec.add_ptr_to_frame f2' a f3.
  Proof.
    intros a b f1 f2 f2' f3 F1_a_F2 F2_b_F3 F1_b_F2'.

    destruct F1_a_F2 as [F1_a_F2_old F1_a_F2_new].
    destruct F2_b_F3 as [F2_b_F3_old F2_b_F3_new].
    destruct F1_b_F2' as [F1_b_F2'_old F1_b_F2'_new].

    split.
    - intros ptr' H.
      specialize (F1_a_F2_old _ H).
      destruct (InfMem.MMEP.disjoint_ptr_byte_dec b ptr').
      2: {
        (* b = ptr' *)
        apply Classical_Prop.NNPP in n.
        red; red in F2_b_F3_new.
        unfold MemoryBigIntptr.MMEP.MMSP.ptr_in_frame_prop in *.
        rewrite <- n.
        auto.
      }

      specialize (F2_b_F3_old _ d).
      specialize (F1_b_F2'_old _ d).
      split; intros IN_FRAME.
      + apply F2_b_F3_old.
        apply F1_b_F2'_old in IN_FRAME.
        apply F1_a_F2_old; auto.
      + apply F1_b_F2'_old.
        apply F2_b_F3_old in IN_FRAME.
        apply F1_a_F2_old; auto.
    - destruct (InfMem.MMEP.disjoint_ptr_byte_dec b a).
      2: {
        (* a = b *)
        apply Classical_Prop.NNPP in n.
        unfold MemoryBigIntptr.MMEP.MMSP.ptr_in_frame_prop in *.
        rewrite <- n.
        auto.
      }

      apply F2_b_F3_old; auto.
  Qed.

  (* TODO: Move this, make available for fin / inf *)
  Lemma add_ptr_to_frame_stack_commutative :
    forall a b fs1 fs2 fs2' fs3,
      MemoryBigIntptr.MMEP.MemSpec.add_ptr_to_frame_stack fs1 a fs2 ->
      MemoryBigIntptr.MMEP.MemSpec.add_ptr_to_frame_stack fs2 b fs3 ->
      MemoryBigIntptr.MMEP.MemSpec.add_ptr_to_frame_stack fs1 b fs2' ->
      MemoryBigIntptr.MMEP.MemSpec.add_ptr_to_frame_stack fs2' a fs3.
  Proof.
    intros a b fs1 fs2 fs2' fs3 FS1_a_FS2 FS2_b_FS3 FS1_b_FS2'.
    red.
    intros f H.

    destruct fs1, fs2.
    - red in FS1_b_FS2'.
      specialize (FS1_b_FS2' f0).
      forward FS1_b_FS2'; [cbn; reflexivity|].
      destruct FS1_b_FS2' as (f' & F' & PEEK & POP).

      red in FS1_a_FS2.
      specialize (FS1_a_FS2 f0).
      forward FS1_a_FS2; [cbn; reflexivity|].
      destruct FS1_a_FS2 as (?&?&?&?).

      red in FS2_b_FS3.
      specialize (FS2_b_FS3 f1).
      forward FS2_b_FS3; [cbn; reflexivity|].
      destruct FS2_b_FS3 as (?&?&?&?).

      cbn in H1.
      rewrite <- H1 in H3.
      epose proof add_ptr_to_frame_commutative _ _ _ _ _ _ H0 H3 F'.

      destruct fs2'; cbn in *.
      + rewrite PEEK, <- H in H6.
        exists x0.
        split; auto.
      + rewrite PEEK, <- H in H6.
        exists x0.
        split; auto.
        split; auto.
        intros fs1_pop.
        destruct fs3; cbn in *.
        symmetry. apply POP.
        split; intros EQV.
        * apply H5.
          apply POP in EQV; auto.
        * apply POP.
          apply H5 in EQV; auto.
    - red in FS1_b_FS2'.
      specialize (FS1_b_FS2' f0).
      forward FS1_b_FS2'; [cbn; reflexivity|].
      destruct FS1_b_FS2' as (f' & F' & PEEK & POP).

      red in FS1_a_FS2.
      specialize (FS1_a_FS2 f0).
      forward FS1_a_FS2; [cbn; reflexivity|].
      destruct FS1_a_FS2 as (?&?&?&?).

      red in FS2_b_FS3.
      specialize (FS2_b_FS3 f1).
      forward FS2_b_FS3; [cbn; reflexivity|].
      destruct FS2_b_FS3 as (?&?&?&?).

      cbn in H1.
      rewrite <- H1 in H3.
      epose proof add_ptr_to_frame_commutative _ _ _ _ _ _ H0 H3 F'.

      destruct fs2'; cbn in *.
      + rewrite PEEK, <- H in H6.
        exists x0.
        split; auto.
        split; auto.
        intros fs1_pop.
        destruct fs3; cbn in *; auto.
        split; intros EQV; try contradiction.
        apply H5 in EQV.
        apply H2 in EQV; auto.
      + rewrite PEEK, <- H in H6.
        exists x0.
        split; auto.
        split; auto.
        intros fs1_pop.
        destruct fs3; cbn in *; auto.
        symmetry. apply POP.
        split; intros EQV.
        * apply POP in EQV; contradiction.
        * apply H5 in EQV; auto.
          apply H2 in EQV; contradiction.
    - red in FS1_b_FS2'.
      specialize (FS1_b_FS2' f0).
      forward FS1_b_FS2'; [cbn; reflexivity|].
      destruct FS1_b_FS2' as (f' & F' & PEEK & POP).

      red in FS1_a_FS2.
      specialize (FS1_a_FS2 f0).
      forward FS1_a_FS2; [cbn; reflexivity|].
      destruct FS1_a_FS2 as (?&?&?&?).

      red in FS2_b_FS3.
      specialize (FS2_b_FS3 f1).
      forward FS2_b_FS3; [cbn; reflexivity|].
      destruct FS2_b_FS3 as (?&?&?&?).

      cbn in H1.
      rewrite <- H1 in H3.
      epose proof add_ptr_to_frame_commutative _ _ _ _ _ _ H0 H3 F'.

      destruct fs2'; cbn in *.
      + rewrite PEEK, <- H in H6.
        exists x0.
        split; auto.
      + rewrite PEEK, <- H in H6.
        exists x0.
        split; auto.
        split; auto.
        intros fs1_pop.
        split; intros EQV.
        * apply POP in EQV.
          apply H2 in EQV; contradiction.
        * apply H5 in EQV; contradiction.
    - red in FS1_b_FS2'.
      specialize (FS1_b_FS2' f0).
      forward FS1_b_FS2'; [cbn; reflexivity|].
      destruct FS1_b_FS2' as (f' & F' & PEEK & POP).

      red in FS1_a_FS2.
      specialize (FS1_a_FS2 f0).
      forward FS1_a_FS2; [cbn; reflexivity|].
      destruct FS1_a_FS2 as (?&?&?&?).

      red in FS2_b_FS3.
      specialize (FS2_b_FS3 f1).
      forward FS2_b_FS3; [cbn; reflexivity|].
      destruct FS2_b_FS3 as (?&?&?&?).

      cbn in H1.
      rewrite <- H1 in H3.
      epose proof add_ptr_to_frame_commutative _ _ _ _ _ _ H0 H3 F'.

      destruct fs2'; cbn in *.
      + rewrite PEEK, <- H in H6.
        exists x0.
        split; auto.
        split; auto.
        intros fs1_pop.
        destruct fs3; cbn in *; auto.
        split; intros EQV; try contradiction.
        split; intros EQV; try contradiction.
        apply H5 in EQV.
        apply H2 in EQV.
        apply POP in EQV.
        auto.
      + rewrite PEEK, <- H in H6.
        exists x0.
        split; auto.
        split; auto.
        intros fs1_pop.
        split; intros EQV.
        * apply H5.
          apply POP in EQV.
          apply H2.
          auto.
        * apply POP.
          apply H5 in EQV.
          apply H2; auto.
  Qed.

  (* TODO: Move this, make available for fin / inf *)
  Lemma add_ptrs_to_frame_stack_cons_inv :
    forall fs1 fs2 a addrs,
      MemoryBigIntptr.MMEP.MemSpec.add_ptrs_to_frame_stack fs1 (a :: addrs) fs2 ->
      exists fs',
        MemoryBigIntptr.MMEP.MemSpec.add_ptr_to_frame_stack fs1 a fs' /\
          MemoryBigIntptr.MMEP.MemSpec.add_ptrs_to_frame_stack fs' addrs fs2.
  Proof.
    intros fs1 fs2 a addrs ADD_PTRS.
    cbn in ADD_PTRS.

    generalize dependent a.
    generalize dependent fs1.
    generalize dependent fs2.
    generalize dependent addrs.
    induction addrs; intros fs2 fs1 ptr ADD_PTRS.
    - destruct fs1.
      + cbn in *.
  Abort.

  Lemma add_ptr_to_frame_stack_exists :
    forall fs1 addr_fin, exists fs2,
      Memory64BitIntptr.MMEP.MemSpec.add_ptr_to_frame_stack fs1 addr_fin fs2.
  Proof.
    intros.
    unfold Memory64BitIntptr.MMEP.MemSpec.add_ptr_to_frame_stack.
    destruct fs1.
    - exists (Memory64BitIntptr.MMEP.MMSP.Singleton (addr_fin::f)).
      intros.
      simpl in H.
          exists (addr_fin :: f0).
          split.
          -- constructor.
             ++ intros.
                split; intros HP.
                ** red in H0.
                   red in HP.
                   red.
                   simpl.
                   right.
                   apply HP.
                ** cbn in HP.
                   destruct HP.
                   apply H0 in H1. contradiction.
                   apply H1.
             ++ cbn. left. reflexivity.
          -- split.
             ++ simpl. constructor; intros; red.
                ** red in H0.
                   destruct H0 as [H0|H0].
                   --- left. assumption.
                   --- right.
                       apply H. apply H0.
                ** red in H0.
                   destruct H0 as [H0|H0].
                   --- left. assumption.
                   --- right.
                       apply H. apply H0.
             ++ intros.
                simpl. tauto.
    - exists (Memory64BitIntptr.MMEP.MMSP.Snoc fs1 (addr_fin::f)).
      intros.
      simpl in H.
      exists (addr_fin :: f0).
      split.
      -- constructor.
         ++ intros.
            split; intros HP.
            ** red in H0.
               red in HP.
               red.
               simpl.
               right.
               apply HP.
            ** cbn in HP.
               destruct HP.
               apply H0 in H1. contradiction.
               apply H1.
         ++ cbn. left. reflexivity.
      -- split.
         ++ simpl. constructor; intros; red.
            ** red in H0.
               destruct H0 as [H0|H0].
               --- left. assumption.
               --- right.
                   apply H. apply H0.
            ** red in H0.
               destruct H0 as [H0|H0].
               --- left. assumption.
               --- right.
                   apply H. apply H0.
         ++ intros.
            simpl. tauto.
  Qed.
            
  Lemma add_ptrs_exists :
    forall fs1 addrs_fin, exists fs2,
      Memory64BitIntptr.MMEP.MemSpec.add_ptrs_to_frame_stack fs1 addrs_fin fs2.
  Proof.
    intros.
    induction addrs_fin.
    - exists fs1. simpl. reflexivity.
    - destruct IHaddrs_fin as [fs2' HF].
      simpl.
      specialize (add_ptr_to_frame_stack_exists fs2' a) as [fs2_fin HF2].
      exists fs2_fin. exists fs2'. tauto.
  Qed.


  (* In (LLVMParams64BitIntptr.PTOI.ptr_to_int ptr_fin) *)
  (*   (map LLVMParamsBigIntptr.PTOI.ptr_to_int (lift_Frame f')) -> *)
  (*    In ptr_fin (lift_Frame f') *)
       
  Lemma add_ptr_to_frame_lift : 
    forall x y (H : addr_refine x y) f f' if',
      Memory64BitIntptr.MMEP.MemSpec.add_ptr_to_frame f y f' ->
      MemoryBigIntptr.MMEP.MemSpec.add_ptr_to_frame (lift_Frame f) x if' ->
      MemoryBigIntptr.MMEP.MMSP.frame_eqv (lift_Frame f') if'.
  Proof.
    intros x y H f.
    apply fin_to_inf_addr_conv_inf in H.
    rewrite <- H. clear x H.

    red.
    intros.
    split; intros.
    - apply ptr_in_frame_prop_lift_inv in H1.
      destruct H1 as [ptr_fin [EQ HI]].
      apply fin_to_inf_addr_conv_inf in EQ.
      subst.
      destruct H0.
      
      specialize (Memory64BitIntptr.MMEP.add_ptr_to_frame_inv y ptr_fin _ _ H HI) as [[HL HD]| HR].
      + apply old_frame_lu.
        * red. intro.
          do 2 rewrite fin_to_inf_addr_ptr_to_int in H0.
          apply HD.
          assumption.
        * apply ptr_in_frame_prop_lift.
          assumption.
      + red.
        red in new_frame_lu.
        rewrite fin_to_inf_addr_ptr_to_int in *.
        rewrite <- HR.
        assumption.
        
    - destruct H.
      specialize (MemoryBigIntptr.MMEP.add_ptr_to_frame_inv _ _ _ _ H0 H1) as [[HL HD]| HR].
      + apply ptr_in_frame_prop_lift_inv in HL.
        destruct HL as [ptr_fin [EQ HF]].
        apply fin_to_inf_addr_conv_inf in EQ. subst.
        red.
        rewrite fin_to_inf_addr_ptr_to_int.
        apply old_frame_lu in HF.
        * apply ptr_in_frame_prop_lift in HF.
          red in HF.
          rewrite fin_to_inf_addr_ptr_to_int in HF.
          assumption.
        * red in HD.
          red. intro C.
          apply HD.
          rewrite fin_to_inf_addr_ptr_to_int.
          rewrite fin_to_inf_addr_ptr_to_int.
          assumption.
      + rewrite fin_to_inf_addr_ptr_to_int in HR.
        apply ptr_in_frame_prop_lift in new_frame_lu.
        red in new_frame_lu.
        rewrite fin_to_inf_addr_ptr_to_int in new_frame_lu.
        rewrite HR in new_frame_lu.
        red.
        assumption.
  Qed.
            
  #[global]
    Instance Proper_frame_stack_Singleton_Inf : Proper (InfMem.MMEP.MMSP.frame_eqv ==> InfMem.MMEP.MMSP.frame_stack_eqv) (InfMemMMSP.Singleton).
  Proof.
    do 3 red.
    intros x y H f n.
    split; intros.
    - destruct n.
      cbn in *.
      eapply transitivity. symmetry. apply H. assumption.
      cbn in *. auto.
    - destruct n.
      cbn in *.
      eapply transitivity. apply H. assumption.
      cbn in *. auto.
  Qed.

  #[global]
    Instance Proper_lift_Frame : Proper (FinMem.MMEP.MMSP.frame_eqv ==> InfMem.MMEP.MMSP.frame_eqv) lift_Frame.
  Proof.
    do 3 red.
    intros.
    apply frame_eqv_lift. assumption.
  Qed.      

  #[global]
  Instance Proper_lift_FrameStack : Proper (FinMem.MMEP.MMSP.frame_stack_eqv ==> InfMem.MMEP.MMSP.frame_stack_eqv) lift_FrameStack.
  Proof.
    do 3 red.
    apply frame_stack_eqv_lift.
  Qed.

  (* SAZ: This one and the next one could be combined earlier in the development *)
  Lemma add_ptr_to_frame_stack_Snoc_Singleton_contra :
    forall fs1 f1 f2 x,
  MemoryBigIntptr.MMEP.MemSpec.add_ptr_to_frame_stack
    (InfMemMMSP.Snoc fs1 f1) x (MemoryBigIntptr.MMEP.MMSP.Singleton f2) -> False.
  Proof.
    intros.
    assert (MemoryBigIntptr.MMEP.MMSP.peek_frame_stack_prop (InfMemMMSP.Snoc fs1 f1) f1) as EQ.
    { red. reflexivity. }
    apply H in EQ.
    destruct EQ as [if' [HI1' [HI2' HI3']]].
    specialize (HI3' fs1).
    assert (MemoryBigIntptr.MMEP.MMSP.pop_frame_stack_prop (InfMemMMSP.Snoc fs1 f1) fs1).
    { red. reflexivity. }
    apply HI3' in H0.
    inversion H0.
  Qed.


  Lemma fin_add_ptr_to_frame_stack_Snoc_Singleton_contra :
    forall fs1 f1 f2 x,
  Memory64BitIntptr.MMEP.MemSpec.add_ptr_to_frame_stack
    (FinMemMMSP.Snoc fs1 f1) x (Memory64BitIntptr.MMEP.MMSP.Singleton f2) -> False.
  Proof.
    intros.
    assert (Memory64BitIntptr.MMEP.MMSP.peek_frame_stack_prop (FinMemMMSP.Snoc fs1 f1) f1) as EQ.
    { red. reflexivity. }
    apply H in EQ.
    destruct EQ as [if' [HI1' [HI2' HI3']]].
    specialize (HI3' fs1).
    assert (Memory64BitIntptr.MMEP.MMSP.pop_frame_stack_prop (FinMemMMSP.Snoc fs1 f1) fs1).
    { red. reflexivity. }
    apply HI3' in H0.
    inversion H0.
  Qed.

  
  Lemma frame_stack_lift_add_ptr:
    forall (x : InfAddr.addr) (y : FinAddr.addr),
      addr_refine x y ->
      forall (fs1 fs2 : Memory64BitIntptr.MMEP.MMSP.FrameStack) (ifs : MemoryBigIntptr.MMEP.MMSP.FrameStack),
        MemoryBigIntptr.MMEP.MemSpec.add_ptr_to_frame_stack (lift_FrameStack fs1) x ifs ->
        Memory64BitIntptr.MMEP.MemSpec.add_ptr_to_frame_stack fs1 y fs2 ->
        MemoryBigIntptr.MMEP.MMSP.frame_stack_eqv (lift_FrameStack fs2) ifs.
  Proof.
    Transparent lift_FrameStack.
    Transparent lift_Frame.
    intros x y H fs1 fs2 ifs HI2 HF2.
    destruct fs1.
    - simpl in *.
      forward (HI2 (lift_Frame f)). simpl. reflexivity.
      forward (HF2 f). simpl. reflexivity.
      destruct fs2; simpl in *.
      + destruct ifs; simpl in *.
        * destruct HI2 as [if' [HI1' [HI2' HI3']]].
          destruct HF2 as [f' [HF1' [HF2' HF3']]].
          specialize (add_ptr_to_frame_lift x y H _ _ _ HF1' HI1') as EQ.
          rewrite <- HI2'.
          rewrite <- EQ.
          rewrite HF2'.
          reflexivity.
        * destruct HI2 as [if' [HI1' [HI2' HI3']]].
          destruct HF2 as [f' [HF1' [HF2' HF3']]].
          specialize (HI3' ifs).
          assert (MemoryBigIntptr.MMEP.MMSP.frame_stack_eqv ifs ifs) as IF by reflexivity.
          apply HI3' in IF.
          inversion IF.
      + destruct HF2 as [f' [HF1' [HF2' HF3']]].
        specialize (HF3' fs2).
        assert (Memory64BitIntptr.MMEP.MMSP.frame_stack_eqv fs2 fs2) as IF by reflexivity.
        apply HF3' in IF.
        inversion IF.
    - simpl in *.
      destruct ifs; simpl in *.
      + apply add_ptr_to_frame_stack_Snoc_Singleton_contra in HI2.
        inversion HI2.
      + apply InfMem.MMEP.add_ptr_to_frame_stack_eqv_S in HI2.
        destruct HI2.
        destruct fs2.
        * apply fin_add_ptr_to_frame_stack_Snoc_Singleton_contra in HF2.
          inversion HF2.
        * simpl. 
          apply FinMem.MMEP.add_ptr_to_frame_stack_eqv_S in HF2.
          destruct HF2.
          specialize (add_ptr_to_frame_lift x y H _ _ _ H2 H0) as EQ.
          rewrite <- H1.
          rewrite <- H3.
          rewrite <- EQ.
          reflexivity.
  Qed.
          
  Lemma frame_stack_lift_add_ptrs:
    forall (addrs_fin : list FinAddr.addr) (addrs_inf : list InfAddr.addr),
      Forall2 addr_refine addrs_inf addrs_fin ->
      forall fs1 fs2 : Memory64BitIntptr.MMEP.MMSP.FrameStack,
        forall ifs2 : MemoryBigIntptr.MMEP.MMSP.FrameStack,
          MemoryBigIntptr.MMEP.MemSpec.add_ptrs_to_frame_stack (lift_FrameStack fs1) addrs_inf ifs2 ->
          Memory64BitIntptr.MMEP.MemSpec.add_ptrs_to_frame_stack fs1 addrs_fin fs2 ->
          MemoryBigIntptr.MMEP.MMSP.frame_stack_eqv (lift_FrameStack fs2) ifs2.
  Proof.
    intros addrs_fin addrs_inf HA.
    induction HA.
    - intros fs1 fs2 ifs2 H1 H2.  simpl in *. rewrite <- H1. apply frame_stack_eqv_lift. symmetry. assumption.
    - intros fs1 fs2 ifs2 H1 H2. simpl in *.
      destruct H1 as [ifs [HI1 HI2]].
      destruct H2 as [fs [HF1 HF2]].
      specialize (IHHA _ _ _ HI1 HF1).
      rewrite <- IHHA in HI2.
      eapply frame_stack_lift_add_ptr; eauto.
  Qed.
  
  (* SAZ: try this eventually *)
  Lemma extend_stack_frame_fin_inf :
    forall {ms_inf_start ms_fin_start ms_fin_final addrs_fin addrs_inf},
      MemState_refine_prop ms_inf_start ms_fin_start ->
      Forall2 addr_refine addrs_inf addrs_fin ->
      Memory64BitIntptr.MMEP.MemSpec.extend_stack_frame ms_fin_start addrs_fin ms_fin_final ->
      MemoryBigIntptr.MMEP.MemSpec.extend_stack_frame ms_inf_start addrs_inf (lift_MemState ms_fin_final).
  Proof.
    intros ms_inf_start ms_fin_start ms_fin_final addrs_fin addrs_inf MSR1 ADDRS EXTEND.
    red in EXTEND.
    red.
    intros fs1 fs2 MSFSP ADD_PTRS.
    red.
    apply MSR1 in MSFSP. clear MSR1.
    destruct ms_fin_start, ms_memory_stack.
    cbn in *.
    specialize (EXTEND memory_stack_frame_stack).
    unfold Memory64BitIntptr.MMEP.MMSP.memory_stack_frame_stack_prop in *.
    unfold InfMem.MMEP.MMSP.memory_stack_frame_stack_prop in *.
    cbn in *.
    destruct ms_fin_final. destruct ms_memory_stack. cbn in *.
    clear ms_inf_start memory_stack_memory memory_stack_heap ms_provenance memory_stack_memory0 memory_stack_heap0 ms_provenance0.
    specialize (add_ptrs_exists memory_stack_frame_stack addrs_fin) as [ms2 HM].
    rename memory_stack_frame_stack into ms1.
    forward (EXTEND ms2). reflexivity.
    specialize (EXTEND HM).
    rewrite EXTEND.
    clear EXTEND.
    clear memory_stack_frame_stack0.
    rewrite <- MSFSP in ADD_PTRS.
    clear MSFSP.
    eapply frame_stack_lift_add_ptrs; eauto.
  Qed.    

  (*
   (* SAZ: try this eventually *)
  Lemma extend_stack_frame_fin_inf' :
    forall {ms_inf_start ms_fin_start ms_inf_final ms_fin_final addrs_fin addrs_inf},
      MemState_refine_prop ms_inf_start ms_fin_start ->
      MemState_refine_prop ms_inf_final ms_fin_final ->
      Forall2 addr_refine addrs_inf addrs_fin ->
      Memory64BitIntptr.MMEP.MemSpec.extend_stack_frame ms_fin_start addrs_fin ms_fin_final ->
      MemoryBigIntptr.MMEP.MemSpec.extend_stack_frame ms_inf_start addrs_inf ms_inf_final.
  Proof.
    intros ms_inf_start ms_fin_start ms_inf_final ms_fin_final
      addrs_fin addrs_inf MSR1 MSR2 ADDRS EXTEND.
    red in EXTEND.
    red.

    (* induction addrs_inf; intros fs1 fs2 MSFSP ADD_PTRS. *)
    (* - cbn in *. *)
    (*   destruct ms_fin_start. destruct ms_memory_stack. *)
    (*   destruct ms_inf_start. destruct ms_memory_stack. *)
    (*   cbn in *. *)
    (*   unfold InfMem.MMEP.MMSP.memory_stack_frame_stack_prop, Memory64BitIntptr.MMEP.MMSP.memory_stack_frame_stack_prop in *. *)
    (*   cbn in *. *)
    (*   rewrite <- ADD_PTRS. *)
    (*   inv ADDRS. *)
    (*   cbn in *. *)

    (*   rewrite <- MSFSP. *)
    (*   apply MSR2. *)

    (*   destruct ms_fin_final. destruct ms_memory_stack. *)
    (*   unfold InfMem.MMEP.MMSP.memory_stack_frame_stack_prop, Memory64BitIntptr.MMEP.MMSP.memory_stack_frame_stack_prop in *. *)
    (*   cbn in *. *)

    (*   rewrite MSFSP. *)
    (*   apply frame_stack_eqv_lift. *)
    (*   eapply EXTEND. *)
    (*   reflexivity. *)
    (*   reflexivity. *)

    (* - cbn in *. *)
    (*   red. *)
    (*   rewrite <- ADD_PTRS. *)
    (*   eapply MemState_refine_prop_frame_stack_preserved in MSFSP; eauto. *)
    (*   eapply MemState_refine_prop_frame_stack_preserved; eauto. *)
    (*   apply memory_stack_frame_stack_prop_lift_inv in MSFSP. *)
    (*   destruct MSFSP as (?&?&?&?&?); subst. *)
    (*   red in H1. *)
    (*   destruct ms_fin_start. destruct ms_memory_stack. *)
    (*   destruct ms_inf_start. destruct ms_memory_stack. *)
    (*   destruct x. *)
    (*   cbn in *. *)

    (*   assert (FinMem.MMEP.MMSP.frame_stack_eqv memory_stack_frame_stack1 memory_stack_frame_stack). *)
    (*   { admit. *)
    (*   } *)

    (*   unfold Memory64BitIntptr.MMEP.MMSP.memory_stack_frame_stack_prop in *. *)
    (*   cbn in *. *)

    (*   specialize (EXTEND x0 x0). *)
    (*   unfold Memory *)
    (*   red in MSFSP. *)
    (*   apply MSFSP. *)



    (* apply memory_stack_frame_stack_prop_lift_inv in MSFSP. *)
    (* destruct MSFSP as (?&?&?&?&?); subst. *)
    (* rename x into ms_fin_start'. *)

    (* destruct ms_fin_start. destruct ms_memory_stack. *)
    (* destruct ms_inf_start. destruct ms_memory_stack. *)
    (* cbn in *. *)
    (* unfold InfMem.MMEP.MMSP.memory_stack_frame_stack_prop, Memory64BitIntptr.MMEP.MMSP.memory_stack_frame_stack_prop in *. *)
    (* cbn in *. *)

    

    (* destruct ms_fin_start'; cbn in *. *)
    (* setoid_rewrite <- H1 in ADD_PTRS. *)
    (* inversion H. *)

    (* generalize dependent addrs_fin. *)
    (* generalize dependent fs2. *)
    (* generalize dependent fs1. *)
    (* induction addrs_inf; intros fs1 MSFSP fs2 ADD_PTRS addrs_fin ADDRS EXTEND. *)
    (* - cbn in *. *)
    (*   rewrite <- ADD_PTRS. *)
    (*   inv ADDRS. *)
    (*   cbn in *. *)

    (*   rewrite <- MSFSP. *)
    (*   apply MSR2. *)

    (*   destruct ms_fin_final. destruct ms_memory_stack. *)
    (*   cbn in *. *)

    (*   apply frame_stack_eqv_lift. *)
    (*   eapply EXTEND. *)
    (*   reflexivity. *)
    (*   reflexivity. *)
    (* - cbn in ADD_PTRS. *)
    (*   destruct ADD_PTRS as (fs'&ADD_PTRS&ADD_PTR). *)

    (*   inv ADDRS. *)
    (*   rename l' into addrs_fin. *)

    (*   clear MSR1. *)
    (*   specialize (MSR2 (InfMem.MMEP.MMSP.memory_stack_frame_stack *)
    (*                       (InfMem.MMEP.MMSP.MemState_get_memory ms_inf_final))). *)
    (*   destruct MSR2 as [MSR2 _]. *)
    (*   forward MSR2. reflexivity. *)

    (*   specialize (IHaddrs_inf _ MSFSP _ ADD_PTRS _ H3). *)
    (*   forward IHaddrs_inf. *)
    (*   admit. *)

    (*   rewrite IHaddrs_inf. *)
    (*   specialize (MSR1 memory_stack_frame_stack0). *)
    (*   destruct MSR1 as [MSR1 _]. *)
    (*   forward MSR1. reflexivity. *)

      
        
    (*   epose proof (EXTEND memory_stack_frame_stack). *)

    (*   epose proof (IHaddrs_inf _ _ _ _ _ H3). *)
    (*   forward H. *)
    (*   { intros fs0 fs3 H0 H2. *)
    (*     setoid_rewrite <- H2. *)
    (*   } *)


    (*   eapply IHaddrs_inf. *)
    (*   3: eauto. *)
    (*   eauto. *)

    (*   all: eauto. *)
    (*   admit. *)
    (*   admit. *)
    (*   admit. *)
  Admitted.
*)

  (* TODO: DELETE *)
  (* TODO: Not currently true, but will be once heap_preserved is modified *)
  (* Lemma heap_preserved_heap_in_bounds : *)
  (*   forall {ms_fin_start ms_fin_final}, *)
  (*     Memory64BitIntptr.MMEP.MemSpec.heap_preserved ms_fin_start ms_fin_final -> *)
  (*     Heap_in_bounds ms_fin_final. *)
  (* Proof. *)
  (* Admitted. *)

  (* Lemma MemState_refine_prop_heap_in_bounds : *)
  (*   forall {ms_inf_start ms_fin_start}, *)
  (*     MemState_refine_prop ms_inf_start ms_fin_start -> *)
  (*     Heap_in_bounds ms_fin_start. *)
  (* Proof. *)
  (*   intros ms_inf_start ms_fin_start REF. *)
  (*   destruct REF; tauto. *)
  (* Qed. *)

  Lemma allocate_bytes_post_conditions_fin_inf :
    forall {ms_fin_start ms_fin_final ms_inf_start bytes_fin addr_fin addrs_fin bytes_inf pr},
      MemState_refine_prop ms_inf_start ms_fin_start ->
      (Forall2 sbyte_refine) bytes_inf bytes_fin ->
      Memory64BitIntptr.MMEP.MemSpec.allocate_bytes_post_conditions ms_fin_start bytes_fin pr ms_fin_final addr_fin addrs_fin ->
      exists addr_inf addrs_inf ms_inf_final,
        MemoryBigIntptr.MMEP.MemSpec.allocate_bytes_post_conditions ms_inf_start bytes_inf pr ms_inf_final addr_inf addrs_inf /\
          addr_refine addr_inf addr_fin /\
          Forall2 addr_refine addrs_inf addrs_fin /\
          MemState_refine_prop ms_inf_final ms_fin_final.
  Proof.
    intros ms_fin_start ms_fin_final ms_inf_start bytes_fin addr_fin addrs_fin bytes_inf pr MSR BYTES ALLOC.
    destruct ALLOC.

    exists (fin_to_inf_addr addr_fin).
    exists (map fin_to_inf_addr addrs_fin).
    exists (lift_MemState ms_fin_final).

    assert (Forall2 addr_refine (map fin_to_inf_addr addrs_fin) addrs_fin) as ADDRS.
    {
      clear - addrs_fin.
      induction addrs_fin; cbn; auto.
      constructor; auto.
      apply addr_refine_fin_to_inf_addr.
    }

    (* assert (Heap_in_bounds ms_fin_final) as HIB_FINAL. *)
    (* { *)
    (*   eapply heap_preserved_heap_in_bounds; eauto. *)
    (*   eapply MemState_refine_prop_heap_in_bounds; eauto. *)
    (* } *)

    split.
    2: {
      split; [|split]; auto.
      - apply addr_refine_fin_to_inf_addr.
      - apply lift_MemState_refine_prop; auto.
    }

    split; intros; try reflexivity; try intuition.
    - eapply fin_inf_preserve_allocation_ids in H; eauto.
      apply lift_MemState_refine_prop; auto.
      red. symmetry. eapply allocate_bytes_provenances_preserved.
    - eapply fin_inf_preserve_allocation_ids in H; eauto.
      apply lift_MemState_refine_prop; auto.
    - eapply extend_allocations_fin_inf; eauto.
      apply lift_MemState_refine_prop; auto.
    - eapply extend_read_byte_allowed_fin_inf; eauto.
      apply lift_MemState_refine_prop; auto.
    - eapply extend_reads_fin_inf; eauto.
      apply lift_MemState_refine_prop; auto.
    - eapply extend_write_byte_allowed_fin_inf; eauto.
      apply lift_MemState_refine_prop; auto.
    - eapply extend_stack_frame_fin_inf; eauto.
    - eapply fin_inf_heap_preserved; eauto.
      apply lift_MemState_refine_prop; auto.
  Qed.

  Lemma allocate_bytes_post_conditions_MemPropT_fin_inf :
    forall {ms_fin_start ms_fin_final ms_inf_start bytes_fin addr_fin addrs_fin res_fin bytes_inf pr},
      MemState_refine_prop ms_inf_start ms_fin_start ->
      (Forall2 sbyte_refine) bytes_inf bytes_fin ->
      Memory64BitIntptr.MMEP.MemSpec.allocate_bytes_post_conditions_MemPropT bytes_fin
        pr addr_fin addrs_fin ms_fin_start (ret (ms_fin_final, res_fin)) ->
      exists res_inf ms_inf_final,
        MemoryBigIntptr.MMEP.MemSpec.allocate_bytes_post_conditions_MemPropT bytes_inf pr (fst res_inf) (snd res_inf) ms_inf_start (ret (ms_inf_final, res_inf)) /\
          (addr_refine Ã— (Forall2 addr_refine)) res_inf res_fin /\
          MemState_refine_prop ms_inf_final ms_fin_final.
  Proof.
    intros ms_fin_start ms_fin_final ms_inf_start bytes_fin addr_fin addrs_fin res_fin bytes_inf pr MSR BYTES ALLOC.
    repeat red in ALLOC.
    destruct res_fin.
    destruct ALLOC.
    destruct H0; subst.
    rename a into addr_fin.
    rename l into addrs_fin.

    eapply allocate_bytes_post_conditions_fin_inf in H; eauto.
    destruct H as (?&?&?&?&?&?&?).
    exists (x, x0). exists x1.
    split; auto.
    split; auto.
  Qed.

  (* This version assures the structure of res... *)
  Lemma allocate_bytes_post_conditions_MemPropT_fin_inf' :
    forall {ms_fin_start ms_fin_final ms_inf_start bytes_fin addr_fin addrs_fin bytes_inf pr},
      MemState_refine_prop ms_inf_start ms_fin_start ->
      (Forall2 sbyte_refine) bytes_inf bytes_fin ->
      Memory64BitIntptr.MMEP.MemSpec.allocate_bytes_post_conditions_MemPropT bytes_fin
        pr addr_fin addrs_fin ms_fin_start (ret (ms_fin_final, (addr_fin, addrs_fin))) ->
      exists addr_inf addrs_inf ms_inf_final,
        MemoryBigIntptr.MMEP.MemSpec.allocate_bytes_post_conditions_MemPropT bytes_inf pr addr_inf addrs_inf ms_inf_start (ret (ms_inf_final, (addr_inf, addrs_inf))) /\
          (addr_refine Ã— (Forall2 addr_refine)) (addr_inf, addrs_inf) (addr_fin, addrs_fin) /\
          MemState_refine_prop ms_inf_final ms_fin_final.
  Proof.
    intros ms_fin_start ms_fin_final ms_inf_start bytes_fin addr_fin addrs_fin bytes_inf pr MSR BYTES ALLOC.
    repeat red in ALLOC.
    destruct ALLOC.
    destruct H0; subst.

    eapply allocate_bytes_post_conditions_fin_inf in H; eauto.
    destruct H as (?&?&?&?&?&?&?).
    exists x, x0, x1.
    split; auto.
    split; auto.
  Qed.

  Lemma allocate_bytes_with_pr_spec_MemPropT_fin_inf :
    forall {ms_fin_start ms_fin_final ms_inf_start bytes_fin addr_fin bytes_inf pr},
      MemState_refine_prop ms_inf_start ms_fin_start ->
      (Forall2 sbyte_refine) bytes_inf bytes_fin ->
      Memory64BitIntptr.MMEP.MemSpec.allocate_bytes_with_pr_spec_MemPropT bytes_fin pr ms_fin_start (ret (ms_fin_final, addr_fin)) ->
      exists addr_inf ms_inf_final,
        MemoryBigIntptr.MMEP.MemSpec.allocate_bytes_with_pr_spec_MemPropT bytes_inf pr ms_inf_start (ret (ms_inf_final, addr_inf)) /\
          addr_refine addr_inf addr_fin /\
          MemState_refine_prop ms_inf_final ms_fin_final.
  Proof.
    intros ms_fin_start ms_fin_final ms_inf_start bytes_fin addr_fin bytes_inf pr MSR BYTES ALLOC.
    (* assert (Heap_in_bounds ms_fin_start) as HIB. *)
    (* { apply MSR. } *)
    unfold MemoryBigIntptr.MMEP.MemSpec.allocate_bytes_with_pr_spec_MemPropT.
    eapply MemPropT_fin_inf_bind.
    4: {
      apply ALLOC.
    }
    all: eauto.

    { (* MA: find_free_block *)
      intros a_fin ms_fin_ma H.
      eapply find_free_block_fin_inf; eauto.
      eapply Util.Forall2_length in BYTES.
      rewrite BYTES.
      apply H.
    }

    (* K: allocate_bytes_post_conditions *)
    intros ms_inf ms_fin ms_fin' [addr_fin' addrs_fin] [addr_inf addrs_inf] b_fin [ADDR_CONV ADDRS_CONV] MSR' ALLOC_POST.

    eapply MemPropT_fin_inf_bind.
    all: eauto.

    { (* allocate_bytes_post_conditions_MemPropT *)
      intros a_fin ms_fin_ma H.
      epose proof allocate_bytes_post_conditions_MemPropT_fin_inf MSR' BYTES H.
      destruct H0 as (?&?&?&?&?).
      cbn in *.
      exists x. exists x0.
      split; eauto.
      destruct x.
      cbn in *.
      destruct H0 as (?&?&?).
      assert (addr_inf = a).
      { destruct a_fin.
        destruct H1.
        cbn in fst_rel.
        red in fst_rel.
        destruct H as (?&?&?); subst.
        eapply InfToFinAddrConvert.addr_convert_injective; eauto.
      }
      assert (addrs_inf = l).
      { destruct a_fin.
        destruct H1.
        cbn in snd_rel.
        destruct H as (?&?&?); subst.
        clear - ADDRS_CONV snd_rel.
        generalize dependent l.
        induction ADDRS_CONV; intros l'' snd_rel.
        - inv snd_rel; auto.
        - inv snd_rel.
          erewrite IHADDRS_CONV; eauto.
          red in H3.
          assert (x=x0).
          eapply InfToFinAddrConvert.addr_convert_injective; eauto.
          subst.
          reflexivity.
      }
      subst.
      split; auto.
    }

    intros ms_inf0 ms_fin0 ms_fin'0 a_fin a_inf b_fin0 H H0 H1 H2.
    destruct H2; subst.
    do 2 eexists.
    split; cbn; eauto.
  Qed.

  Lemma allocate_bytes_spec_MemPropT_fin_inf :
    forall {ms_fin_start ms_fin_final ms_inf_start bytes_fin addr_fin bytes_inf},
      MemState_refine_prop ms_inf_start ms_fin_start ->
      (Forall2 sbyte_refine) bytes_inf bytes_fin ->
      Memory64BitIntptr.MMEP.MemSpec.allocate_bytes_spec_MemPropT
        bytes_fin ms_fin_start (ret (ms_fin_final, addr_fin)) ->
      exists addr_inf ms_inf_final,
        MemoryBigIntptr.MMEP.MemSpec.allocate_bytes_spec_MemPropT
          bytes_inf ms_inf_start (ret (ms_inf_final, addr_inf)) /\
          addr_refine addr_inf addr_fin /\
          MemState_refine_prop ms_inf_final ms_fin_final.
  Proof.
    intros ms_fin_start ms_fin_final ms_inf_start bytes_fin addr_fin bytes_inf MSR BYTES_REF ALLOCA_FIN.

    eapply MemPropT_fin_inf_bind.
    4: apply ALLOCA_FIN.
    all: eauto.

    { (* MA: fresh_provenance *)
      intros a_fin ms_fin_ma H.
      eapply fresh_provenance_fin_inf; eauto.
    }

    intros ms_inf ms_fin ms_fin' a_fin a_inf b_fin H H0 H1.
    cbn in H; subst.
    eapply allocate_bytes_with_pr_spec_MemPropT_fin_inf; eauto.
  Qed.

  Lemma allocate_bytes_post_conditions_MemPropT_fin_inf_ub :
    forall bytes_inf bytes_fin pr ptr_fin ptrs_fin ptr_inf ptrs_inf msg ms_fin ms_inf,
      MemState_refine_prop ms_inf ms_fin ->
      sbytes_refine bytes_inf bytes_fin ->
      Memory64BitIntptr.MMEP.MemSpec.allocate_bytes_post_conditions_MemPropT bytes_fin pr ptr_fin ptrs_fin ms_fin (raise_ub msg) ->
      MemoryBigIntptr.MMEP.MemSpec.allocate_bytes_post_conditions_MemPropT bytes_inf pr ptr_inf ptrs_inf ms_inf (raise_ub msg).
  Proof.
    intros bytes_inf bytes_fin pr ptr_fin ptrs_fin ptr_inf ptrs_inf msg ms_fin ms_inf MSR BYTES_REF ALLOC.
    cbn in *; auto.
  Qed.

  #[global] Hint Resolve allocate_bytes_post_conditions_MemPropT_fin_inf_ub : FinInf.
  Lemma allocate_bytes_with_pr_spec_MemPropT_fin_inf_ub :
    forall bytes_fin bytes_inf ms_inf ms_fin pr msg,
      sbytes_refine bytes_inf bytes_fin ->
      MemState_refine_prop ms_inf ms_fin ->
      Memory64BitIntptr.MMEP.MemSpec.allocate_bytes_with_pr_spec_MemPropT bytes_fin pr ms_fin (raise_ub msg) ->
      MemoryBigIntptr.MMEP.MemSpec.allocate_bytes_with_pr_spec_MemPropT bytes_inf pr ms_inf (raise_ub msg).
  Proof.
    intros bytes_fin bytes_inf ms_inf ms_fin pr msg BYTES_REF MSR ALLOC.
    red; red in ALLOC.

    eapply MemPropT_fin_inf_bind_ub.
    5: apply ALLOC.
    all: eauto with FinInf.

    { intros a_fin ms_fin_ma H.
      eapply find_free_block_fin_inf; eauto.
      erewrite sbytes_refine_length; eauto.
    }

    intros ms_inf0 ms_fin0
      [ptr_fin ptrs_fin] [ptr_inf ptrs_inf]
      msg0 [ADDR_REF ADDRS_REF] MSR' FIND_FREE POST.

    eapply MemPropT_fin_inf_bind_ub.
    5: apply POST.
    all: eauto with FinInf.

    intros [ptr_fin' ptrs_fin'] ms_fin_ma ALLOC'.
    pose proof ALLOC' as [_ [PTR_FIN PTRS_FIN]]; subst.
    eapply allocate_bytes_post_conditions_MemPropT_fin_inf in ALLOC'; eauto.
    destruct ALLOC' as ((ptr_inf'&ptrs_inf')&ms_inf_ma&POST'&REFS&MSR'').
    cbn in POST'.
    exists (ptr_inf, ptrs_inf).
    exists ms_inf_ma.

    destruct POST' as [POST' _].
    pose proof REFS as [ADDR_REF' ADDRS_REF'].
    cbn in ADDR_REF', ADDRS_REF'.

    assert (ptr_inf = ptr_inf') as PTR_INF.
    { eapply InfToFinAddrConvert.addr_convert_injective; eauto.
    }
    subst.

    assert (ptrs_inf = ptrs_inf') as PTRS_INF.
    { clear - ADDRS_REF ADDRS_REF'.
      generalize dependent ptrs_inf'.
      induction ADDRS_REF; intros ptrs_inf' ADDRS_REF'.
      - inv ADDRS_REF'; auto.
      - inv ADDRS_REF'.
        assert (x = x0).
        eapply InfToFinAddrConvert.addr_convert_injective; eauto.
        subst.

        assert (l = l0).
        eapply IHADDRS_REF; eauto.
        subst.
        reflexivity.
    }
    subst.

    split; eauto.
    split; eauto.

    Unshelve.
    all: eauto.
  Qed.

  #[global] Hint Resolve allocate_bytes_with_pr_spec_MemPropT_fin_inf_ub : FinInf.

  Lemma allocate_bytes_spec_MemPropT_fin_inf_ub :
    forall bytes_fin bytes_inf ms_inf ms_fin msg,
      sbytes_refine bytes_inf bytes_fin ->
      MemState_refine_prop ms_inf ms_fin ->
      Memory64BitIntptr.MMEP.MemSpec.allocate_bytes_spec_MemPropT bytes_fin ms_fin (raise_ub msg) ->
      MemoryBigIntptr.MMEP.MemSpec.allocate_bytes_spec_MemPropT bytes_inf ms_inf (raise_ub msg).
  Proof.
    intros bytes_fin bytes_inf ms_inf ms_fin msg BYTES_REF MSR ALLOC.
    red in ALLOC; red.

    eapply MemPropT_fin_inf_bind_ub.
    5: apply ALLOC.
    all: eauto with FinInf.

    intros ms_inf0 ms_fin0 a_fin a_inf msg0 H MSR' FRESH ALLOC'; subst.
    eapply allocate_bytes_with_pr_spec_MemPropT_fin_inf_ub; eauto.

    Unshelve.
    all: eauto.
  Qed.

  #[global] Hint Resolve allocate_bytes_spec_MemPropT_fin_inf_ub : FinInf.

  Lemma allocate_dtyp_spec_fin_inf :
    forall {t num_elements ms_fin_start ms_fin_final ms_inf_start addr_fin},
      MemState_refine_prop ms_inf_start ms_fin_start ->
      Memory64BitIntptr.MMEP.MemSpec.allocate_dtyp_spec t num_elements ms_fin_start (ret (ms_fin_final, addr_fin)) ->
      exists addr_inf ms_inf_final,
        MemoryBigIntptr.MMEP.MemSpec.allocate_dtyp_spec t num_elements ms_inf_start (ret (ms_inf_final, addr_inf)) /\
          addr_refine addr_inf addr_fin /\
          MemState_refine_prop ms_inf_final ms_fin_final.
  Proof.
    intros t num_elements ms_fin_start ms_fin_final ms_inf_start addr_fin MSR ALLOCA.

    eapply MemPropT_fin_inf_bind with (A_REF:=eq).
    4: apply ALLOCA.
    all: eauto.

    { (* MA: Assert *)
      intros [] ms_fin_ma ASSERT.
      repeat red in ASSERT.
      destruct ASSERT; subst.
      exists tt.
      exists ms_inf_start.
      split; cbn; auto.
    }

    intros ms_inf_assert ms_fin_assert ms_fin_assert' [] [] b_fin_assert _ MSR_ASSERT ASSERT POST_ASSERT.

    eapply MemPropT_fin_inf_bind.
    4: apply POST_ASSERT.
    all: eauto.

    { (* MA: fresh_sid *)
      intros a_fin ms_fin_ma FRESH_SID.
      eapply fresh_sid_fin_inf; eauto.
    }

    intros ms_inf_sid ms_fin_sid ms_fin' sid sid' b_fin SID MSR_SID K.
    cbn in SID; subst.

    eapply MemPropT_fin_inf_bind with (A_REF:=Forall2 sbytes_refine).
    all: eauto.

    { (* MA: generating undef bytes *)
      intros a_fin ms_fin_ma GEN_BYTE_BLOCKS.
      eapply MemPropT_fin_inf_map_monad with
        (B_REF:=sbytes_refine)
        (A_REF:=(fun (a_inf : MemPropT MemoryBigIntptr.MMEP.MMSP.MemState (list MemoryBigIntptr.MP.BYTE_IMPL.SByte)) (a_fin : MemPropT Memory64BitIntptr.MMEP.MMSP.MemState (list Memory64BitIntptr.MP.BYTE_IMPL.SByte)) =>
                   forall ms_inf ms_fin ms_fin' bytes_fin,
                     a_fin ms_fin (ret (ms_fin', bytes_fin)) ->
                     exists bytes_inf ms_inf',
                       a_inf ms_inf (ret (ms_inf', bytes_inf)) /\
                         sbytes_refine bytes_inf bytes_fin /\
                         ms_inf = ms_inf' /\
                         ms_fin = ms_fin')).
      4: apply GEN_BYTE_BLOCKS.
      all: eauto.

      {
        intros a_fin0 a_inf b_fin0 ms_fin ms_inf ms_fin_ma0 H H0 H1.
        unfold id in *.
        specialize (H0 ms_inf _ _ _ H1) as (?&?&?&?&?&?).
        subst.
        do 2 eexists.
        split; eauto.
      }

      apply Forall2_repeatN.
      intros ms_inf ms_fin ms_fin'0 bytes_fin H.
      red in H.
      break_match_hyp; inv H.
      rename l into bytes_fin.
      rename Heqo into GEN_FIN.
      apply generate_undef_bytes_fin_inf in GEN_FIN as (bytes_inf&GEN_INF&BYTES_REF).
      exists bytes_inf. exists ms_inf.
      split; auto.
      cbn. red.
      rewrite GEN_INF.
      cbn.
      auto.
    }

    intros ms_inf ms_fin ms_fin'0 a_fin a_inf b_fin0 BYTE_BLOCKS_REF MSR_GEN GEN_UNDEF ALLOCA_BYTES.
    eapply allocate_bytes_spec_MemPropT_fin_inf; eauto.
    apply Forall2_concat; auto.
  Qed.

  Lemma allocate_dtyp_spec_fin_inf_ub :
    forall t num_elements ms_inf ms_fin msg,
      MemState_refine_prop ms_inf ms_fin ->
      Memory64BitIntptr.MMEP.MemSpec.allocate_dtyp_spec t num_elements ms_fin (raise_ub msg) ->
      MemoryBigIntptr.MMEP.MemSpec.allocate_dtyp_spec t num_elements ms_inf (raise_ub msg).
  Proof.
    intros t num_elements ms_inf ms_fin msg MSR ALLOC.
    red in ALLOC.
    red.

    eapply MemPropT_fin_inf_bind_ub with (A_REF:=eq).
    5: apply ALLOC.
    all: eauto.

    { (* MA: Assert *)
      intros [] ms_fin_ma ASSERT.
      repeat red in ASSERT.
      destruct ASSERT; subst.
      exists tt.
      exists ms_inf.
      split; cbn; auto.
    }

    intros ms_inf_assert ms_fin_assert [] [] msg_assert _ MSR_ASSERT ASSERT.

    eapply MemPropT_fin_inf_bind_ub; eauto.
    { intros a_fin ms_fin_ma H.
      eapply fresh_sid_fin_inf; eauto.
    }

    intros ms_inf0 ms_fin0 a_fin a_inf msg0 SID MSR' FRESH ALLOC'.
    cbn in SID; subst.

    eapply MemPropT_fin_inf_bind_ub with
      (A_REF := fun a_inf a_fin => sbytes_refine (concat a_inf) (concat a_fin)).
    5: apply ALLOC'.
    all: eauto with FinInf.

    2: {
      intros msg1 H.
      eapply MemPropT_fin_inf_repeatMN_ub.
      4: apply H.
      all: eauto with FinInf.

      { intros res_fin ms_fin1 ms_inf1 ms_fin_ma H0 H1.
        unfold lift_OOM in *.
        break_match_hyp; cbn in H1; try contradiction.
        destruct H1; subst.

        pose proof generate_undef_bytes_fin_inf Heqo.
        destruct H1 as (?&?&?).
        rewrite H1.
        exists x. exists ms_inf1.
        split; eauto.
        cbn.
        split; auto.
      }

      intros ms_fin1 ms_inf1 msg2 H0 H1.
      red; red in H1.
      break_match_hyp; cbn in H1; try contradiction.
    }

    intros a_fin0 ms_fin_ma REPEAT.
    eapply MemPropT_fin_inf_repeatMN in REPEAT; eauto.

    { destruct REPEAT as (res_inf&ms_inf_final&REPEAT&ALL&MSR'').
      exists res_inf. exists ms_inf_final.
      split; eauto.
      split; eauto.
      eapply Forall2_concat; eauto.
    }

    intros res_fin ms_fin1 ms_inf1 ms_fin_ma0 MSR'' GEN.
    red in GEN.
    break_match_hyp; cbn in GEN; try contradiction.
    destruct GEN; subst.

    eapply generate_undef_bytes_fin_inf in Heqo.
    destruct Heqo as (bytes_inf&GEN&BYTES_REF).
    rewrite GEN.
    cbn.
    exists bytes_inf.
    exists ms_inf1.
    tauto.

    Unshelve.
    all: eauto.
  Qed.

  #[global] Hint Resolve allocate_dtyp_spec_fin_inf_ub : FinInf.

  (* TODO: Move this *)
  Lemma handle_alloca_fin_inf :
    forall {t num_elements align ms_fin_start ms_fin_final ms_inf_start d},
      MemState_refine_prop ms_inf_start ms_fin_start ->
      Memory64BitIntptr.MMEP.MemSpec.handle_memory_prop
        LLVMParams64BitIntptr.Events.DV.dvalue
        (LLVMParams64BitIntptr.Events.Alloca t num_elements align) ms_fin_start (ret (ms_fin_final, d)) ->
      exists d_inf ms_inf_final,
        MemoryBigIntptr.MMEP.MemSpec.handle_memory_prop DVCInfFin.DV1.dvalue
          (InterpreterStackBigIntptr.LP.Events.Alloca t num_elements align) ms_inf_start
          (ret (ms_inf_final, d_inf)) /\
          DVC1.dvalue_refine_strict d_inf d /\
          MemState_refine_prop ms_inf_final ms_fin_final.
  Proof.
    intros t num_elements align ms_fin_start ms_fin_final ms_inf_start d MSR HANDLE.

    eapply MemPropT_fin_inf_bind.
    4: apply HANDLE.
    all: eauto.

    { (* MA: allocate_dtyp_spec *)
      intros a_fin ms_fin_ma H.
      eapply allocate_dtyp_spec_fin_inf; eauto.
    }

    intros ms_inf ms_fin ms_fin' a_fin a_inf b_fin ADDR_REF MSR' H H0.
    cbn in H0.
    destruct H0; subst.
    cbn in ADDR_REF.

    cbn.
    do 2 eexists; split; eauto.
    split; auto.

    rewrite DVCInfFin.dvalue_refine_strict_equation.
    cbn.
    rewrite ADDR_REF.
    reflexivity.
  Qed.

  Lemma root_in_heap_prop_lifted_fin_inf :
    forall {h_fin ptr_inf ptr_fin},
      addr_refine ptr_inf ptr_fin ->
      Memory64BitIntptr.MMEP.MMSP.root_in_heap_prop h_fin ptr_fin ->
      MemoryBigIntptr.MMEP.MMSP.root_in_heap_prop (lift_Heap h_fin) ptr_inf.
  Proof.
    intros h_fin ptr_inf ptr_fin ADDR_REF ROOT.
    pose proof addr_refine_fin_to_inf_addr ptr_fin.
    red in H, ADDR_REF.
    pose proof InfToFinAddrConvert.addr_convert_injective _ _ _ ADDR_REF H.
    subst.
    apply root_in_heap_prop_lift; eauto.
  Qed.

  Lemma root_in_heap_prop_lifted_fin_inf_transitive :
    forall {h_fin h_inf ptr_inf ptr_fin},
      InfMem.MMEP.MMSP.heap_eqv h_inf (lift_Heap h_fin) ->
      addr_refine ptr_inf ptr_fin ->
      Memory64BitIntptr.MMEP.MMSP.root_in_heap_prop h_fin ptr_fin ->
      MemoryBigIntptr.MMEP.MMSP.root_in_heap_prop h_inf ptr_inf.
  Proof.
    intros h_fin h_inf ptr_inf ptr_fin EQV ADDR_REF ROOT.
    rewrite EQV.
    eapply root_in_heap_prop_lifted_fin_inf; eauto.
  Qed.

  Lemma root_in_memstate_heap_fin_inf :
    forall {ms_inf ms_fin ptr_inf ptr_fin},
      MemState_refine_prop ms_inf ms_fin ->
      addr_refine ptr_inf ptr_fin ->
      Memory64BitIntptr.MMEP.MemSpec.root_in_memstate_heap ms_fin ptr_fin ->
      MemoryBigIntptr.MMEP.MemSpec.root_in_memstate_heap ms_inf ptr_inf.
  Proof.
    intros ms_inf ms_fin ptr_inf ptr_fin MSR ADDR_REF ROOT.
    destruct ms_inf; destruct ms_memory_stack.
    destruct ms_fin; destruct ms_memory_stack.
    apply MemState_refine_prop_heap_preserved in MSR.
    red; red in MSR; red in ROOT.
    cbn in *.
    unfold InfMem.MMEP.MMSP.memory_stack_heap_prop, Memory64BitIntptr.MMEP.MMSP.memory_stack_heap_prop in *; cbn in *.

    intros h H.
    eapply root_in_heap_prop_lifted_fin_inf_transitive; eauto.
    2: {
      eapply ROOT.
      reflexivity.
    }

    apply MSR in H.
    symmetry; auto.
  Qed.

  Lemma root_in_heap_prop_lifted_inf_fin :
    forall {h_fin ptr_inf ptr_fin},
      addr_refine ptr_inf ptr_fin ->
      MemoryBigIntptr.MMEP.MMSP.root_in_heap_prop (lift_Heap h_fin) ptr_inf ->
      Memory64BitIntptr.MMEP.MMSP.root_in_heap_prop h_fin ptr_fin.
  Proof.
    intros h_fin ptr_inf ptr_fin ADDR_REF ROOT.
    pose proof addr_refine_fin_to_inf_addr ptr_fin.
    red in H, ADDR_REF.
    pose proof InfToFinAddrConvert.addr_convert_injective _ _ _ ADDR_REF H.
    subst.
    apply root_in_heap_prop_lift_inv in ROOT.
    destruct ROOT as (?&?&?).
    rewrite addr_convert_fin_to_inf_addr in H0.
    inv H0.
    auto.
  Qed.

  Lemma root_in_heap_prop_lifted_inf_fin_transitive :
    forall {h_fin h_inf ptr_inf ptr_fin},
      InfMem.MMEP.MMSP.heap_eqv h_inf (lift_Heap h_fin) ->
      addr_refine ptr_inf ptr_fin ->
      MemoryBigIntptr.MMEP.MMSP.root_in_heap_prop h_inf ptr_inf ->
      Memory64BitIntptr.MMEP.MMSP.root_in_heap_prop h_fin ptr_fin.
  Proof.
    intros h_fin h_inf ptr_inf ptr_fin EQV ADDR_REF ROOT.
    rewrite EQV in ROOT.
    eapply root_in_heap_prop_lifted_inf_fin; eauto.
  Qed.

  Lemma root_in_memstate_heap_inf_fin :
    forall {ms_inf ms_fin ptr_inf ptr_fin},
      MemState_refine_prop ms_inf ms_fin ->
      addr_refine ptr_inf ptr_fin ->
      MemoryBigIntptr.MMEP.MemSpec.root_in_memstate_heap ms_inf ptr_inf ->
      Memory64BitIntptr.MMEP.MemSpec.root_in_memstate_heap ms_fin ptr_fin.
  Proof.
    intros ms_inf ms_fin ptr_inf ptr_fin MSR ADDR_REF ROOT.
    destruct ms_inf; destruct ms_memory_stack.
    destruct ms_fin; destruct ms_memory_stack.
    apply MemState_refine_prop_heap_preserved in MSR.
    red; red in MSR; red in ROOT.
    cbn in *.
    unfold InfMem.MMEP.MMSP.memory_stack_heap_prop, Memory64BitIntptr.MMEP.MMSP.memory_stack_heap_prop in *; cbn in *.

    intros h H.
    eapply root_in_heap_prop_lifted_inf_fin_transitive; eauto.
    2: {
      eapply ROOT.
      reflexivity.
    }

    apply MSR.
    apply Heap_eqv_lift; auto.
  Qed.

  Lemma ptr_in_memstate_heap_fin_inf :
    forall {ms_inf ms_fin root_inf root_fin ptr_inf ptr_fin},
      MemState_refine_prop ms_inf ms_fin ->
      addr_refine root_inf root_fin ->
      addr_refine ptr_inf ptr_fin ->
      Memory64BitIntptr.MMEP.MemSpec.ptr_in_memstate_heap ms_fin root_fin ptr_fin ->
      MemoryBigIntptr.MMEP.MemSpec.ptr_in_memstate_heap ms_inf root_inf ptr_inf.
  Proof.
    intros ms_inf ms_fin root_inf root_fin ptr_inf ptr_fin MSR ROOT_REF PTR_REF IN_HEAP.
    destruct ms_inf; destruct ms_memory_stack.
    destruct ms_fin; destruct ms_memory_stack.
    apply MemState_refine_prop_heap_preserved in MSR.
    red; red in MSR; red in IN_HEAP.
    cbn in *.
    unfold InfMem.MMEP.MMSP.memory_stack_heap_prop, Memory64BitIntptr.MMEP.MMSP.memory_stack_heap_prop in *; cbn in *.

    intros h H.
    specialize (MSR memory_stack_heap).
    destruct MSR as [MSR _].
    forward MSR; [red; reflexivity|].
    rewrite <- MSR in H.
    rewrite <- H.

    replace root_inf with (fin_to_inf_addr root_fin).
    2: {
      unfold fin_to_inf_addr.
      break_match_goal.
      clear Heqs.
      apply FinToInfAddrConvertSafe.addr_convert_safe in e.
      eapply InfToFinAddrConvert.addr_convert_injective; eauto.
    }
    replace ptr_inf with (fin_to_inf_addr ptr_fin).
    2: {
      unfold fin_to_inf_addr.
      break_match_goal.
      clear Heqs.
      apply FinToInfAddrConvertSafe.addr_convert_safe in e.
      eapply InfToFinAddrConvert.addr_convert_injective; eauto.
    }

    apply ptr_in_heap_prop_lift.
    apply IN_HEAP.
    reflexivity.
  Qed.

  Lemma ptr_in_memstate_heap_inf_fin :
    forall {ms_inf ms_fin root_inf root_fin ptr_inf ptr_fin},
      MemState_refine_prop ms_inf ms_fin ->
      addr_refine root_inf root_fin ->
      addr_refine ptr_inf ptr_fin ->
      MemoryBigIntptr.MMEP.MemSpec.ptr_in_memstate_heap ms_inf root_inf ptr_inf ->
      Memory64BitIntptr.MMEP.MemSpec.ptr_in_memstate_heap ms_fin root_fin ptr_fin.
  Proof.
    intros ms_inf ms_fin root_inf root_fin ptr_inf ptr_fin MSR ROOT_REF PTR_REF IN_HEAP.
    destruct ms_inf; destruct ms_memory_stack.
    destruct ms_fin; destruct ms_memory_stack.
    apply MemState_refine_prop_heap_preserved in MSR.
    red; red in MSR; red in IN_HEAP.
    cbn in *.
    unfold InfMem.MMEP.MMSP.memory_stack_heap_prop, Memory64BitIntptr.MMEP.MMSP.memory_stack_heap_prop in *; cbn in *.

    intros h H.
    specialize (IN_HEAP memory_stack_heap).
    forward IN_HEAP; [reflexivity|].
    rewrite <- H.

    specialize (MSR memory_stack_heap).
    destruct MSR as [MSR _].
    forward MSR; [red; reflexivity|].
    rewrite <- MSR in IN_HEAP.

    pose proof ptr_in_heap_prop_lift_inv IN_HEAP as (root_fin'&ptr_fin'&ROOT_FIN_REF&PTR_FIN_REF&IN_HEAP_FIN).
    rewrite PTR_REF in PTR_FIN_REF.
    inv PTR_FIN_REF.
    rename ptr_fin' into ptr_fin.
    rewrite ROOT_REF in ROOT_FIN_REF.
    inv ROOT_FIN_REF.
    eauto.
  Qed.

  Lemma ptr_in_memstate_heap_inf_fin_exists :
    forall {ms_inf ms_fin root_inf root_fin ptr_inf},
      MemState_refine_prop ms_inf ms_fin ->
      addr_refine root_inf root_fin ->
      MemoryBigIntptr.MMEP.MemSpec.ptr_in_memstate_heap ms_inf root_inf ptr_inf ->
      exists ptr_fin,
        addr_refine ptr_inf ptr_fin /\
        Memory64BitIntptr.MMEP.MemSpec.ptr_in_memstate_heap ms_fin root_fin ptr_fin.
  Proof.
    intros ms_inf ms_fin root_inf root_fin ptr_inf MSR ROOT_REF IN_HEAP.
    destruct ms_inf; destruct ms_memory_stack.
    destruct ms_fin; destruct ms_memory_stack.
    apply MemState_refine_prop_heap_preserved in MSR.
    red in MSR; red in IN_HEAP.
    cbn in *.
    unfold Memory64BitIntptr.MMEP.MemSpec.ptr_in_memstate_heap, InfMem.MMEP.MMSP.memory_stack_heap_prop, Memory64BitIntptr.MMEP.MMSP.memory_stack_heap_prop in *; cbn in *.

    specialize (MSR memory_stack_heap).
    destruct MSR as [MSR _].
    forward MSR; [red; reflexivity|].

    specialize (IN_HEAP (lift_Heap memory_stack_heap0)).
    forward IN_HEAP; [symmetry; auto|].

    (* TODO: Probably could split some of this into a separate lemma *)
    pose proof (ptr_in_heap_prop_lift_inv IN_HEAP) as (?&?&?&?&?).
    rewrite ROOT_REF in H.
    inv H.
    exists x0.
    split; auto.
    intros h H2.
    rewrite <- H2; auto.
  Qed.

  Lemma ptr_not_in_memstate_heap_fin_inf :
    forall {ms_inf : InfMem.MMEP.MMSP.MemState} {ms_fin : FinMem.MMEP.MMSP.MemState}
      {root_inf : InfAddr.addr} {root_fin : FinAddr.addr} {ptr_inf : InfAddr.addr}
      {ptr_fin : FinAddr.addr},
      MemState_refine_prop ms_inf ms_fin ->
      addr_refine root_inf root_fin ->
      addr_refine ptr_inf ptr_fin ->
      ~ Memory64BitIntptr.MMEP.MemSpec.ptr_in_memstate_heap ms_fin root_fin ptr_fin ->
      ~ MemoryBigIntptr.MMEP.MemSpec.ptr_in_memstate_heap ms_inf root_inf ptr_inf.
  Proof.
    intros ms_inf ms_fin root_inf root_fin ptr_inf ptr_fin MSR ADDR_REF1 ADDR_REF2 NPTR.
    intros PTR.
    eapply ptr_in_memstate_heap_inf_fin in PTR; eauto.
  Qed.

  Lemma add_ptr_to_heap_lift_Heap :
    forall {root_inf ptr_inf root_fin ptr_fin h_fin_start h2},
      MemoryBigIntptr.MMEP.MemSpec.add_ptr_to_heap (lift_Heap h_fin_start) root_inf ptr_inf h2 ->
      addr_refine root_inf root_fin ->
      addr_refine ptr_inf ptr_fin ->
      exists h2_fin,
        Memory64BitIntptr.MMEP.MemSpec.add_ptr_to_heap h_fin_start root_fin ptr_fin h2_fin /\
          MemoryBigIntptr.MMEP.MMSP.heap_eqv (lift_Heap h2_fin) h2.
  Proof.
    intros root_inf ptr_inf root_fin ptr_fin h_fin_start h2 ADD_PTR REF1 REF2.
    exists (IntMaps.add_with (FinPTOI.ptr_to_int root_fin) ptr_fin ret cons h_fin_start).
    split.
    { split.
      - intros ptr' DISJOINT.
        red in DISJOINT.
        { split; intros IN_HEAP; red in IN_HEAP.
          + break_match_hyp; try contradiction.
            red; cbn.
            unfold IntMaps.add_with.
            break_inner_match_goal; rewrite IntMaps.IP.F.add_eq_o; eauto;
              setoid_rewrite Heqo in Heqo0; inv Heqo0.
            cbn.
            right; auto.
          + break_match_hyp; try contradiction.
            red; cbn.
            unfold IntMaps.add_with in *.
            break_match_hyp; rewrite IntMaps.IP.F.add_eq_o in Heqo; eauto; inv Heqo.
            2: {
              break_match_goal.
              setoid_rewrite Heqo0 in Heqo.
              discriminate.

              cbn in IN_HEAP.
              destruct IN_HEAP as [IN_HEAP | []].
              contradiction.
            }

            break_match_goal.
            * setoid_rewrite Heqo0 in Heqo; inv Heqo.
              cbn in IN_HEAP.
              destruct IN_HEAP; auto; contradiction.
            * setoid_rewrite Heqo0 in Heqo; inv Heqo.
        }
      - intros root' H ptr'.
        split; intros IN_HEAP; red in IN_HEAP.
        + break_match_hyp; try contradiction.
          red; cbn.
          unfold IntMaps.add_with.
          break_inner_match_goal; rewrite IntMaps.IP.F.add_neq_o; eauto.
          2: {
            break_match_goal;
            setoid_rewrite Heqo in Heqo1; inv Heqo1.
            auto.
          }

          break_match_goal;
            setoid_rewrite Heqo in Heqo1; inv Heqo1.
          auto.
        + break_match_hyp; try contradiction.
          red; cbn.
          unfold IntMaps.add_with in *.
          break_match_hyp; rewrite IntMaps.IP.F.add_neq_o in Heqo; eauto; inv Heqo.
          2: {
            break_match_goal;
            setoid_rewrite Heqo in H1; inv H1.
            auto.
          }

          break_match_goal;
            setoid_rewrite Heqo in H1; inv H1.
          auto.
      - intros root' H.
        split; intros IN_HEAP; red in IN_HEAP;
          eapply IntMaps.member_lookup in IN_HEAP;
          destruct IN_HEAP as (b&IN_HEAP).
        + eapply IntMaps.lookup_member with (v:=b).
          unfold IntMaps.add_with.
          break_inner_match_goal; rewrite IntMaps.IP.F.add_neq_o; eauto.
        + eapply IntMaps.lookup_member with (v:=b).
          unfold IntMaps.add_with in *.
          break_match_hyp; rewrite IntMaps.IP.F.add_neq_o in IN_HEAP; eauto; inv Heqo.
      - red.
        unfold IntMaps.add_with.
        break_inner_match_goal; rewrite IntMaps.IP.F.add_eq_o; eauto;
          cbn; auto.
      - red.
        unfold IntMaps.add_with.
        break_inner_match_goal;
          eapply IntMaps.lookup_member;
          rewrite IntMaps.IP.F.add_eq_o;
          cbn; auto.
    }

    (* Heap equivalence *)
    split.
    - intros root.
      pose proof (MemoryBigIntptr.MMEP.disjoint_ptr_byte_dec root_inf root) as [NEQ_ROOT | EQ_ROOT].
      { split; intros IN_HEAP.
        eapply IntMaps.member_lookup in IN_HEAP;
          destruct IN_HEAP as (b&IN_HEAP).
        - destruct ADD_PTR.
          specialize (old_heap_roots _ NEQ_ROOT).
          destruct old_heap_roots.

          eapply H.

          unfold IntMaps.add_with in *.
          break_match_hyp.
          + unfold lift_Heap in *.
            rewrite IntMaps.IP.F.map_o in IN_HEAP.
            unfold option_map in *.
            break_match_hyp_inv.
            apply find_filter_dom_true in Heqo0.
            destruct Heqo0.
            rewrite IntMaps.IP.F.add_neq_o in H1; eauto.
            2: {
              intros CONTRA.
              apply NEQ_ROOT.
              erewrite fin_inf_ptoi in CONTRA; eauto.
            }

            red.
            eapply IntMaps.lookup_member with (v:=lift_Block b0).
            rewrite IntMaps.IP.F.map_o.
            unfold option_map.
            pose proof (conj H1 H2).
            eapply find_filter_dom_true in H3.
            rewrite H3.
            reflexivity.
          + unfold lift_Heap in *.
            rewrite IntMaps.IP.F.map_o in IN_HEAP.
            unfold option_map in *.
            break_match_hyp_inv.
            apply find_filter_dom_true in Heqo0.
            destruct Heqo0.
            rewrite IntMaps.IP.F.add_neq_o in H1; eauto.
            2: {
              intros CONTRA.
              apply NEQ_ROOT.
              erewrite fin_inf_ptoi in CONTRA; eauto.
            }

            red.
            eapply IntMaps.lookup_member with (v:=lift_Block b0).
            rewrite IntMaps.IP.F.map_o.
            unfold option_map.
            pose proof (conj H1 H2).
            eapply find_filter_dom_true in H3.
            rewrite H3.
            reflexivity.
        - destruct ADD_PTR.
          specialize (old_heap_roots _ NEQ_ROOT).
          destruct old_heap_roots.
          specialize (H0 IN_HEAP).
          eapply IntMaps.member_lookup in H0.
          destruct H0 as (b&ROOT).

          unfold lift_Heap in *.
          rewrite IntMaps.IP.F.map_o in ROOT.
          unfold option_map in *.
          break_match_hyp_inv.
          apply find_filter_dom_true in Heqo.
          destruct Heqo.

          unfold IntMaps.add_with in *.
          break_match_goal.
          + red.

            destruct (IntMaps.IM.find (elt:=FinMemMMSP.Block) (LLVMParamsBigIntptr.PTOI.ptr_to_int root)
                        (IntMaps.add (FinPTOI.ptr_to_int root_fin) (ptr_fin :: l) h_fin_start)) eqn:HFIND.
            2:{ exfalso.
                rewrite IntMaps.IP.F.add_neq_o in HFIND; eauto.
                2: {
                  intros CONTRA.
                  apply NEQ_ROOT.
                  erewrite fin_inf_ptoi in CONTRA; eauto.
                }
                setoid_rewrite HFIND in H0.
                discriminate.
            }

            pose proof (conj HFIND H1).
            apply find_filter_dom_true in H2.
            
            eapply IntMaps.lookup_member.
            unfold lift_Heap.
            rewrite IntMaps.IP.F.map_o.
            unfold option_map in *.
            rewrite H2.
            reflexivity.
          + red.
            destruct (IntMaps.IM.find (elt:=FinMemMMSP.Block) (LLVMParamsBigIntptr.PTOI.ptr_to_int root)
                        (IntMaps.add (FinPTOI.ptr_to_int root_fin) (ret ptr_fin) h_fin_start)) eqn:HFIND.
            2:{ exfalso.
                rewrite IntMaps.IP.F.add_neq_o in HFIND; eauto.
                2: {
                  intros CONTRA.
                  apply NEQ_ROOT.
                  erewrite fin_inf_ptoi in CONTRA; eauto.
                }
                setoid_rewrite HFIND in H0.
                discriminate.
            }

            pose proof (conj HFIND H1).
            apply find_filter_dom_true in H2.
            
            eapply IntMaps.lookup_member.
            unfold lift_Heap.
            rewrite IntMaps.IP.F.map_o.
            unfold option_map in *.
            rewrite H2.
            reflexivity.
      }

      { apply Classical_Prop.NNPP in EQ_ROOT.
        split; intros IN_HEAP.
        - destruct ADD_PTR.
          red; red in new_heap_root.
          rewrite <- EQ_ROOT.
          auto.
        - red.
          erewrite <- fin_inf_ptoi in EQ_ROOT; eauto.
          rewrite EQ_ROOT.
          unfold IntMaps.add_with.
          break_match_goal.
          + unfold lift_Heap.
            eapply IntMaps.lookup_member.
            rewrite IntMaps.IP.F.map_o.
            unfold option_map.
            pose proof @IntMaps.IP.F.add_eq_o
              _ h_fin_start (LLVMParamsBigIntptr.PTOI.ptr_to_int root) _ (ptr_fin :: l) eq_refl.
            pose proof in_bounds_exists_addr' (LLVMParamsBigIntptr.PTOI.ptr_to_int root).
            destruct H0.
            forward H1.
            exists root_fin.
            auto.

            pose proof (conj H H1).
            apply find_filter_dom_true in H2.
            setoid_rewrite H2.
            reflexivity.
          + unfold lift_Heap.
            eapply IntMaps.lookup_member.
            rewrite IntMaps.IP.F.map_o.
            unfold option_map.
            pose proof @IntMaps.IP.F.add_eq_o
              _ h_fin_start (LLVMParamsBigIntptr.PTOI.ptr_to_int root) _ (ret ptr_fin) eq_refl.
            pose proof in_bounds_exists_addr' (LLVMParamsBigIntptr.PTOI.ptr_to_int root).
            destruct H0.
            forward H1.
            exists root_fin.
            auto.

            pose proof (conj H H1).
            apply find_filter_dom_true in H2.
            setoid_rewrite H2.
            reflexivity.
      }
    - intros root ptr.
      pose proof (MemoryBigIntptr.MMEP.disjoint_ptr_byte_dec root_inf root) as [NEQ_ROOT | EQ_ROOT].
      { destruct ADD_PTR.
        specialize (old_heap_lu_different_root _ NEQ_ROOT).

        split; intros IN_HEAP.
        - eapply old_heap_lu_different_root.
          red; red in IN_HEAP;
          break_match_hyp; try contradiction;
          unfold lift_Heap in *.

          rewrite IntMaps.IP.F.map_o in Heqo.
          unfold option_map in Heqo.
          break_match_hyp_inv.
          apply find_filter_dom_true in Heqo0.
          destruct Heqo0 as [FIND IN_BOUNDS].          
          unfold IntMaps.add_with in *.
          rewrite IntMaps.IP.F.map_o.
          unfold option_map.

          break_match_hyp.
          + rewrite IntMaps.IP.F.add_neq_o in FIND; eauto.
            2: {
              intros CONTRA.
              apply NEQ_ROOT.
              erewrite fin_inf_ptoi in CONTRA; eauto.
            }

            pose proof (conj FIND IN_BOUNDS).
            apply find_filter_dom_true in H.
            rewrite H.
            auto.
          + rewrite IntMaps.IP.F.add_neq_o in FIND; eauto.
            2: {
              intros CONTRA.
              apply NEQ_ROOT.
              erewrite fin_inf_ptoi in CONTRA; eauto.
            }

            pose proof (conj FIND IN_BOUNDS).
            apply find_filter_dom_true in H.
            rewrite H.
            auto.
        - eapply old_heap_lu_different_root in IN_HEAP;
          red; red in IN_HEAP;
          break_match_hyp; try contradiction;
            unfold lift_Heap in *.
          unfold IntMaps.add_with.
          break_inner_match.
          + rewrite IntMaps.IP.F.map_o in *.
            unfold option_map in *.
            break_match_hyp_inv.
            apply find_filter_dom_true in Heqo1.
            destruct Heqo1 as [FIND IN_BOUNDS].
            erewrite <- IntMaps.IP.F.add_neq_o
              with (x:=FinPTOI.ptr_to_int root_fin)
                   (e:=(ptr_fin :: l))
              in FIND.
            2: {
              intros CONTRA.
              apply NEQ_ROOT.
              erewrite fin_inf_ptoi in CONTRA; eauto.
            }

            pose proof (conj FIND IN_BOUNDS).
            apply find_filter_dom_true in H.
            break_inner_match_goal;
              setoid_rewrite H in Heqo; inv Heqo.
            auto.
          + rewrite IntMaps.IP.F.map_o in *.
            unfold option_map in *.
            break_match_hyp_inv.
            apply find_filter_dom_true in Heqo1.
            destruct Heqo1 as [FIND IN_BOUNDS].
            erewrite <- IntMaps.IP.F.add_neq_o
              with (x:=FinPTOI.ptr_to_int root_fin)
                   (e:=[ptr_fin])
              in FIND.
            2: {
              intros CONTRA.
              apply NEQ_ROOT.
              erewrite fin_inf_ptoi in CONTRA; eauto.
            }

            pose proof (conj FIND IN_BOUNDS).
            apply find_filter_dom_true in H.
            break_inner_match_goal;
              setoid_rewrite H in Heqo; inv Heqo.
            auto.
      }

      { destruct ADD_PTR.
        apply Classical_Prop.NNPP in EQ_ROOT.
        assert (LLVMParams64BitIntptr.PTOI.ptr_to_int root_fin = LLVMParamsBigIntptr.PTOI.ptr_to_int root) as EQ_ROOT_FIN.
        { erewrite <- fin_inf_ptoi in EQ_ROOT; eauto.
        }

        pose proof (MemoryBigIntptr.MMEP.disjoint_ptr_byte_dec ptr_inf ptr) as [NEQ_PTR | EQ_PTR].
        { split; intros IN_HEAP.
          - red.
            rewrite <- EQ_ROOT.
            eapply old_heap_lu; eauto.
            red; red in IN_HEAP.
            unfold lift_Heap in *.
            unfold IntMaps.add_with in *.
            break_match_hyp; try contradiction.
            rewrite IntMaps.IP.F.map_o in *.
            unfold option_map.
            pose proof in_bounds_exists_addr' (LLVMParams64BitIntptr.PTOI.ptr_to_int root_fin).
            destruct H.
            forward H0.
            exists root_fin; auto.
            clear H.
            rename H0 into IN_BOUNDS.
            unfold option_map in *.
            break_match_hyp_inv.
            break_match_hyp.
            + apply find_filter_dom_true in Heqo0.
              destruct Heqo0.
              rewrite <- EQ_ROOT_FIN in H.
              rewrite IntMaps.IP.F.add_eq_o in H; eauto.
              inv H.

              pose proof (conj Heqo IN_BOUNDS).
              apply find_filter_dom_true in H.
              break_inner_match_goal;
                setoid_rewrite EQ_ROOT in Heqo0;
                rewrite <- EQ_ROOT_FIN in Heqo0;
                setoid_rewrite H in Heqo0; inv Heqo0.
              cbn in IN_HEAP.
              destruct IN_HEAP.
              { rewrite fin_to_inf_addr_ptr_to_int in H1.
                exfalso; apply NEQ_PTR.
                erewrite fin_inf_ptoi in H1; eauto.
              }
              auto.
            + (* Root may be new... *)
              eapply find_filter_dom_true in Heqo0.
              destruct Heqo0.
              rewrite <- EQ_ROOT_FIN in H.
              rewrite IntMaps.IP.F.add_eq_o in H; eauto.
              inv H.
              cbn in IN_HEAP.
              destruct IN_HEAP as [IN_HEAP | []].
              rewrite fin_to_inf_addr_ptr_to_int in IN_HEAP.
              exfalso.
              apply NEQ_PTR.
              erewrite <- fin_inf_ptoi; eauto.
          - red in IN_HEAP.
            rewrite <- EQ_ROOT in IN_HEAP.
            eapply old_heap_lu in IN_HEAP; eauto.
            red; red in IN_HEAP.
            rewrite <- EQ_ROOT_FIN.
            rewrite EQ_ROOT in IN_HEAP.
            rewrite <- EQ_ROOT_FIN in IN_HEAP.
            unfold lift_Heap in *.
            unfold IntMaps.add_with in *.
            rewrite IntMaps.IP.F.map_o in *.
            break_match_hyp; try contradiction.
            unfold option_map in *.
            break_match_hyp_inv.

            pose proof in_bounds_exists_addr' (LLVMParams64BitIntptr.PTOI.ptr_to_int root_fin).
            destruct H.
            forward H0.
            exists root_fin.
            auto.
            clear H. rename H0 into IN_BOUNDS.

            break_inner_match_goal.
            + pose proof @IntMaps.IP.F.add_eq_o
              _ h_fin_start (LLVMParams64BitIntptr.PTOI.ptr_to_int root_fin) _ (ptr_fin :: l) eq_refl.
              pose proof (conj H IN_BOUNDS).
              apply find_filter_dom_true in H0.
              break_inner_match_goal;
                setoid_rewrite H0 in Heqo1; inv Heqo1.

              pose proof (conj Heqo IN_BOUNDS).
              apply find_filter_dom_true in H1.
              setoid_rewrite Heqo0 in H1; inv H1.
              cbn.
              right.
              apply IN_HEAP.
            + apply find_filter_dom_true in Heqo0.
              destruct Heqo0.
              setoid_rewrite H in Heqo; inv Heqo.
        }

        { apply Classical_Prop.NNPP in EQ_PTR.
          split; intros IN_HEAP.
          - red.
            rewrite <- EQ_ROOT.
            rewrite <- EQ_PTR.
            apply new_heap_lu.
          - unfold lift_Heap.
            unfold IntMaps.add_with.
            red.
            rewrite <- EQ_PTR.

            pose proof in_bounds_exists_addr' (LLVMParams64BitIntptr.PTOI.ptr_to_int root_fin).
            destruct H.
            forward H0.
            exists root_fin.
            auto.
            clear H. rename H0 into IN_BOUNDS.

            break_inner_match_goal.
            + rewrite IntMaps.IP.F.map_o in *.
              unfold option_map.
              pose proof @IntMaps.IP.F.add_eq_o
              _ h_fin_start (LLVMParams64BitIntptr.PTOI.ptr_to_int root_fin) _ (ptr_fin :: l) eq_refl.

              pose proof (conj H IN_BOUNDS).
              apply find_filter_dom_true in H0.
              rewrite <- EQ_ROOT_FIN.
              break_inner_match_goal;
                setoid_rewrite H0 in Heqo0; inv Heqo0.
              cbn.
              left.
              rewrite fin_to_inf_addr_ptr_to_int.
              erewrite fin_inf_ptoi; eauto.
            + rewrite IntMaps.IP.F.map_o in *.
              unfold option_map.
              pose proof @IntMaps.IP.F.add_eq_o
              _ h_fin_start (LLVMParams64BitIntptr.PTOI.ptr_to_int root_fin) _ (ret ptr_fin) eq_refl.

              pose proof (conj H IN_BOUNDS).
              apply find_filter_dom_true in H0.
              rewrite <- EQ_ROOT_FIN.
              break_inner_match_goal;
                setoid_rewrite H0 in Heqo0; inv Heqo0.
              cbn.
              left.
              rewrite fin_to_inf_addr_ptr_to_int.
              erewrite fin_inf_ptoi; eauto.
        }        
      }
  Qed.

  Lemma add_ptrs_to_heap'_lift_Heap :
    forall {root_inf ptrs_inf root_fin ptrs_fin h_fin_start h2},
      MemoryBigIntptr.MMEP.MemSpec.add_ptrs_to_heap' (lift_Heap h_fin_start) root_inf ptrs_inf h2 ->
      addr_refine root_inf root_fin ->
      Forall2 addr_refine ptrs_inf ptrs_fin ->
      exists h2_fin,
        Memory64BitIntptr.MMEP.MemSpec.add_ptrs_to_heap' h_fin_start root_fin ptrs_fin h2_fin /\
          MemoryBigIntptr.MMEP.MMSP.heap_eqv (lift_Heap h2_fin) h2.
  Proof.
    intros root_inf ptrs_inf root_fin ptrs_fin h_fin_start h2 ADD_PTRS ROOT ADDRS.
    generalize dependent h2.
    induction ADDRS; intros h2 ADD_PTRS.
    - cbn in *.
      exists h_fin_start; split; cbn; eauto.
      reflexivity.
    - cbn in ADD_PTRS.
      destruct ADD_PTRS as (h' & ADD_PTRS & ADD_PTR).
      apply IHADDRS in ADD_PTRS.
      destruct ADD_PTRS as (h'_fin & ADD_PTRS & EQV).
      rewrite <- EQV in ADD_PTR.
      eapply add_ptr_to_heap_lift_Heap in ADD_PTR; eauto.
      destruct ADD_PTR as (h2_fin & ADD_PTR & EQV').
      exists h2_fin.
      split; cbn; eauto.
  Qed.

  (* SAZ: Look at this one too *)
  Lemma extend_heap_fin_inf :
    forall {ms_inf_start ms_fin_start ms_inf_final ms_fin_final addrs_fin addrs_inf},
      MemState_refine_prop ms_inf_start ms_fin_start ->
      MemState_refine_prop ms_inf_final ms_fin_final ->
      Forall2 addr_refine addrs_inf addrs_fin ->
      Memory64BitIntptr.MMEP.MemSpec.extend_heap ms_fin_start addrs_fin ms_fin_final ->
      MemoryBigIntptr.MMEP.MemSpec.extend_heap ms_inf_start addrs_inf ms_inf_final.
  Proof.
    intros ms_inf_start ms_fin_start ms_inf_final ms_fin_final
      addrs_fin addrs_inf MSR1 MSR2 ADDRS EXTEND.
    red in EXTEND.
    red.

    intros h1 h2 MSFSP ADD_PTRS.
    red.

    apply MemState_refine_prop_heap_preserved in MSR1, MSR2.

    red in MSR1, MSR2.
    apply MSR1 in MSFSP.

    destruct ms_fin_start. destruct ms_memory_stack.
    rename memory_stack_heap into h_fin_start.
    destruct ms_inf_start. destruct ms_memory_stack.
    rename memory_stack_heap into h_inf_start.
    destruct ms_fin_final. destruct ms_memory_stack.
    rename memory_stack_heap into h_fin_final.
    destruct ms_inf_final. destruct ms_memory_stack.
    rename memory_stack_heap into h_inf_final.
    cbn in *.

    red in MSFSP.
    unfold InfMem.MMEP.MMSP.memory_stack_heap_prop, Memory64BitIntptr.MMEP.MMSP.memory_stack_heap_prop in *.
    cbn in *.
    unfold InfMem.MMEP.MemSpec.heap_preserved_memory,
      InfMem.MMEP.MMSP.memory_stack_heap_prop in *.
    cbn in *.

    rewrite <- MSFSP in ADD_PTRS.
    clear h1 MSFSP.
    red in ADD_PTRS.
    destruct ADDRS.
    - specialize (EXTEND h_fin_start h_fin_start).
      forward EXTEND; [reflexivity|].
      forward EXTEND; [cbn; reflexivity|].
      cbn in ADD_PTRS.
      apply Heap_eqv_lift in EXTEND.
      rewrite <- ADD_PTRS.
      setoid_rewrite <- EXTEND.
      symmetry.
      apply MSR2.
      reflexivity.
    - cbn in *.
      destruct ADD_PTRS as (h' & ADD_PTRS & ADD_PTR).
      (* A lemma about add_ptr_to_heap would probably help *)

      eapply MSR2.
      eapply add_ptrs_to_heap'_lift_Heap in ADD_PTRS; eauto.
      destruct ADD_PTRS as (h'_fin & ADD_PTRS & EQV).
      rewrite <- EQV in ADD_PTR.
      eapply add_ptr_to_heap_lift_Heap in ADD_PTR; eauto.
      destruct ADD_PTR as (h2_fin & ADD_PTR & EQV').
      rewrite <- EQV'.

      eapply Heap_eqv_lift.
      eapply EXTEND; eauto.
      reflexivity.
  Qed.      

  Lemma malloc_bytes_post_conditions_fin_inf :
    forall {ms_fin_start ms_fin_final ms_inf_start bytes_fin addr_fin addrs_fin bytes_inf pr},
      MemState_refine_prop ms_inf_start ms_fin_start ->
      (Forall2 sbyte_refine) bytes_inf bytes_fin ->
      Memory64BitIntptr.MMEP.MemSpec.malloc_bytes_post_conditions ms_fin_start bytes_fin pr ms_fin_final addr_fin addrs_fin ->
      exists addr_inf addrs_inf ms_inf_final,
        MemoryBigIntptr.MMEP.MemSpec.malloc_bytes_post_conditions ms_inf_start bytes_inf pr ms_inf_final addr_inf addrs_inf /\
          addr_refine addr_inf addr_fin /\
          Forall2 addr_refine addrs_inf addrs_fin /\
          MemState_refine_prop ms_inf_final ms_fin_final.
  Proof.
    intros ms_fin_start ms_fin_final ms_inf_start bytes_fin addr_fin addrs_fin bytes_inf pr MSR BYTES ALLOC.
    destruct ALLOC.

    exists (fin_to_inf_addr addr_fin).
    exists (map fin_to_inf_addr addrs_fin).
    exists (lift_MemState ms_fin_final).

    assert (Forall2 addr_refine (map fin_to_inf_addr addrs_fin) addrs_fin) as ADDRS.
    {
      clear - addrs_fin.
      induction addrs_fin; cbn; auto.
      constructor; auto.
      apply addr_refine_fin_to_inf_addr.
    }

    (* assert (Heap_in_bounds ms_fin_final) as HIB_FINAL. *)
    (* { *)
    (*   eapply extend_heap_heap_in_bounds; eauto. *)
    (*   eapply MemState_refine_prop_heap_in_bounds; eauto. *)
    (* } *)

    split.
    2: {
      split; [|split]; auto.
      - apply addr_refine_fin_to_inf_addr.
      - apply lift_MemState_refine_prop; auto.
    }

    split; intros; try reflexivity; try intuition.
    - eapply fin_inf_preserve_allocation_ids in H; eauto.
      apply lift_MemState_refine_prop; auto.
      red. symmetry. eapply malloc_bytes_provenances_preserved.
    - eapply fin_inf_preserve_allocation_ids in H; eauto.
      apply lift_MemState_refine_prop; auto.
    - eapply extend_allocations_fin_inf; eauto.
      apply lift_MemState_refine_prop; auto.
    - eapply extend_read_byte_allowed_fin_inf; eauto.
      apply lift_MemState_refine_prop; auto.
    - eapply extend_reads_fin_inf; eauto.
      apply lift_MemState_refine_prop; auto.
    - eapply extend_write_byte_allowed_fin_inf; eauto.
      apply lift_MemState_refine_prop; auto.
    - eapply extend_free_byte_allowed_fin_inf; eauto.
      apply lift_MemState_refine_prop; auto.
    - eapply fin_inf_frame_stack_preserved; eauto.
      apply lift_MemState_refine_prop; auto.
    - eapply extend_heap_fin_inf; eauto.
      apply lift_MemState_refine_prop; auto.
  Qed.

  Lemma malloc_bytes_post_conditions_MemPropT_fin_inf :
    forall {ms_fin_start ms_fin_final ms_inf_start bytes_fin addr_fin addrs_fin res_fin bytes_inf pr},
      MemState_refine_prop ms_inf_start ms_fin_start ->
      (Forall2 sbyte_refine) bytes_inf bytes_fin ->
      Memory64BitIntptr.MMEP.MemSpec.malloc_bytes_post_conditions_MemPropT bytes_fin pr addr_fin addrs_fin ms_fin_start (ret (ms_fin_final, res_fin)) ->
      exists res_inf ms_inf_final,
        MemoryBigIntptr.MMEP.MemSpec.malloc_bytes_post_conditions_MemPropT bytes_inf pr (fst res_inf) (snd res_inf) ms_inf_start (ret (ms_inf_final, res_inf)) /\
          (addr_refine Ã— (Forall2 addr_refine)) res_inf res_fin /\
          MemState_refine_prop ms_inf_final ms_fin_final.
  Proof.
    intros ms_fin_start ms_fin_final ms_inf_start bytes_fin addr_fin addrs_fin res_fin bytes_inf pr MSR BYTES ALLOC.
    repeat red in ALLOC.
    destruct res_fin.
    destruct ALLOC.
    destruct H0; subst.
    rename a into addr_fin.
    rename l into addrs_fin.

    eapply malloc_bytes_post_conditions_fin_inf in H; eauto.
    destruct H as (?&?&?&?&?&?&?).
    exists (x, x0). exists x1.
    split; auto.
    split; auto.
  Qed.

  (* TODO: Move this *)
  Lemma dvalue_refine_strict_i1_r_inv :
    forall v_inf x_fin,
      DVC1.dvalue_refine_strict v_inf (DVC1.DV2.DVALUE_I1 x_fin) ->
      exists x_inf,
        v_inf = DVC1.DV1.DVALUE_I1 x_inf /\
          LLVMParamsBigIntptr.Events.DV.unsigned x_inf = LLVMParams64BitIntptr.Events.DV.unsigned x_fin.
  Proof.
    intros v_inf x_fin REF.
    rewrite DVC1.dvalue_refine_strict_equation in REF.
    apply dvalue_convert_strict_i1_inv in REF.
    exists x_fin; tauto.
  Qed.

  (* TODO: Move this *)
  Lemma dvalue_refine_strict_i8_r_inv :
    forall v_inf x_fin,
      DVC1.dvalue_refine_strict v_inf (DVC1.DV2.DVALUE_I8 x_fin) ->
      exists x_inf,
        v_inf = DVC1.DV1.DVALUE_I8 x_inf /\
          LLVMParamsBigIntptr.Events.DV.unsigned x_inf = LLVMParams64BitIntptr.Events.DV.unsigned x_fin.
  Proof.
    intros v_inf x_fin REF.
    rewrite DVC1.dvalue_refine_strict_equation in REF.
    apply dvalue_convert_strict_i8_inv in REF.
    exists x_fin; tauto.
  Qed.

  (* TODO: Move this *)
  Lemma dvalue_refine_strict_i32_r_inv :
    forall v_inf x_fin,
      DVC1.dvalue_refine_strict v_inf (DVC1.DV2.DVALUE_I32 x_fin) ->
      exists x_inf,
        v_inf = DVC1.DV1.DVALUE_I32 x_inf /\
          LLVMParamsBigIntptr.Events.DV.unsigned x_inf = LLVMParams64BitIntptr.Events.DV.unsigned x_fin.
  Proof.
    intros v_inf x_fin REF.
    rewrite DVC1.dvalue_refine_strict_equation in REF.
    apply dvalue_convert_strict_i32_inv in REF.
    exists x_fin; tauto.
  Qed.

  (* TODO: Move this *)
  Lemma dvalue_refine_strict_i64_r_inv :
    forall v_inf x_fin,
      DVC1.dvalue_refine_strict v_inf (DVC1.DV2.DVALUE_I64 x_fin) ->
      exists x_inf,
        v_inf = DVC1.DV1.DVALUE_I64 x_inf /\
          LLVMParamsBigIntptr.Events.DV.unsigned x_inf = LLVMParams64BitIntptr.Events.DV.unsigned x_fin.
  Proof.
    intros v_inf x_fin REF.
    rewrite DVC1.dvalue_refine_strict_equation in REF.
    apply dvalue_convert_strict_i64_inv in REF.
    exists x_fin; tauto.
  Qed.

  (* TODO: Move this *)
  Lemma dvalue_refine_strict_iptr_r_inv :
    forall v_inf x_fin,
      DVC1.dvalue_refine_strict v_inf (DVC1.DV2.DVALUE_IPTR x_fin) ->
      exists x_inf,
        v_inf = DVC1.DV1.DVALUE_IPTR x_inf /\
          IP.from_Z (InterpreterStackBigIntptr.LP.IP.to_Z x_inf) = NoOom x_fin.
  Proof.
    intros v_inf x_fin REF.
    rewrite DVC1.dvalue_refine_strict_equation in REF.
    apply dvalue_convert_strict_iptr_inv in REF as (x&?&?).
    exists x; tauto.
  Qed.

  Lemma malloc_bytes_with_pr_spec_MemPropT_fin_inf :
    forall {ms_fin_start ms_fin_final ms_inf_start bytes_fin addr_fin bytes_inf pr},
      MemState_refine_prop ms_inf_start ms_fin_start ->
      (Forall2 sbyte_refine) bytes_inf bytes_fin ->
      Memory64BitIntptr.MMEP.MemSpec.malloc_bytes_with_pr_spec_MemPropT bytes_fin pr ms_fin_start (ret (ms_fin_final, addr_fin)) ->
      exists addr_inf ms_inf_final,
        MemoryBigIntptr.MMEP.MemSpec.malloc_bytes_with_pr_spec_MemPropT bytes_inf pr ms_inf_start (ret (ms_inf_final, addr_inf)) /\
          addr_refine addr_inf addr_fin /\
          MemState_refine_prop ms_inf_final ms_fin_final.
  Proof.
    intros ms_fin_start ms_fin_final ms_inf_start bytes_fin addr_fin bytes_inf pr MSR BYTES ALLOC.
    unfold MemoryBigIntptr.MMEP.MemSpec.malloc_bytes_with_pr_spec_MemPropT.
    eapply MemPropT_fin_inf_bind.
    4: apply ALLOC.
    all: eauto.

    { (* MA: find_free_block *)
      intros a_fin ms_fin_ma H.
      eapply find_free_block_fin_inf; eauto.
      eapply Util.Forall2_length in BYTES.
      rewrite BYTES.
      apply H.
    }

    (* K: malloc_bytes_post_conditions *)
    intros ms_inf ms_fin ms_fin' [addr_fin' addrs_fin] [addr_inf addrs_inf] b_fin [ADDR_CONV ADDRS_CONV] MSR' ALLOC_POST.

    eapply MemPropT_fin_inf_bind.
    all: eauto.

    { (* allocate_bytes_post_conditions_MemPropT *)
      intros a_fin ms_fin_ma H.
      epose proof malloc_bytes_post_conditions_MemPropT_fin_inf MSR' BYTES H.
      destruct H0 as (?&?&?&?&?).
      cbn in *.
      exists x. exists x0.
      split; eauto.
      destruct x.
      cbn in *.
      destruct H0 as (?&?&?).
      assert (addr_inf = a).
      { destruct a_fin.
        destruct H1.
        cbn in fst_rel.
        red in fst_rel.
        destruct H as (?&?&?); subst.
        eapply InfToFinAddrConvert.addr_convert_injective; eauto.
      }
      assert (addrs_inf = l).
      { destruct a_fin.
        destruct H1.
        cbn in snd_rel.
        destruct H as (?&?&?); subst.
        clear - ADDRS_CONV snd_rel.
        generalize dependent l.
        induction ADDRS_CONV; intros l'' snd_rel.
        - inv snd_rel; auto.
        - inv snd_rel.
          erewrite IHADDRS_CONV; eauto.
          red in H3.
          assert (x=x0).
          eapply InfToFinAddrConvert.addr_convert_injective; eauto.
          subst.
          reflexivity.
      }
      subst.
      split; auto.
    }

    intros ms_inf0 ms_fin0 ms_fin'0 a_fin a_inf b_fin0 ADDRS_REF MSR'' H1 H2.
    destruct H2; subst.
    do 2 eexists.
    split; cbn; eauto.
  Qed.

  Lemma handle_malloc_fin_inf :
    forall {ms_fin_start ms_fin_final ms_inf_start addr_fin args_fin args_inf},
      MemState_refine_prop ms_inf_start ms_fin_start ->
      Forall2 DVC1.dvalue_refine_strict args_inf args_fin ->
      Memory64BitIntptr.MMEP.MemSpec.handle_malloc_prop args_fin ms_fin_start (ret (ms_fin_final, addr_fin)) ->
      exists addr_inf ms_inf_final,
        MemoryBigIntptr.MMEP.MemSpec.handle_malloc_prop args_inf ms_inf_start (ret (ms_inf_final, addr_inf)) /\
          addr_refine addr_inf addr_fin /\
          MemState_refine_prop ms_inf_final ms_fin_final.
  Proof.
    intros ms_fin_start ms_fin_final ms_inf_start addr_fin args_fin args_inf MSR ARGS HANDLE.

    red in HANDLE.
    repeat (break_match_hyp; try contradiction).

    { (* I1 *)
      inv ARGS.
      inv H3.
      rename x0 into x_inf.
      rename x into x_fin.

      apply dvalue_refine_strict_i1_r_inv in H2 as (?&?&?); subst.

      eapply MemPropT_fin_inf_bind.
      4: apply HANDLE.
      all: eauto.

      { (* MA: fresh_sid *)
        intros a_fin ms_fin_ma FRESH.
        eapply fresh_sid_fin_inf; eauto.
      }

      intros ms_inf ms_fin ms_fin' a_fin a_inf b_fin SID MSR_SID HANDLE'.
      cbn in SID; subst.

      eapply MemPropT_fin_inf_bind.
      all: eauto.

      { (* MA: generate_num_undef_bytes *)
        intros a_fin0 ms_fin_ma GEN.
        red in GEN.
        break_match_hyp; inv GEN.
        rename Heqo into GEN.
        eapply generate_num_undef_bytes_fin_inf in GEN as (bytes_inf&GEN&BYTES_REF).
        exists bytes_inf. exists ms_inf.
        split; eauto.
        red.
        rewrite H0.
        rewrite GEN.
        cbn.
        auto.
      }

      intros ms_inf0 ms_fin0 ms_fin'0 a_fin0 a_inf b_fin0 BYTES_REF MSR_GEN HANDLE''.
      eapply MemPropT_fin_inf_bind.
      all: eauto.

      { (* MA: fresh_provenance *)
        intros a_fin1 ms_fin_ma FRESH_PR.
        eapply fresh_provenance_fin_inf; eauto.
      }

      intros ms_inf1 ms_fin1 ms_fin'1 a_fin1 a_inf0 b_fin1 PR MSR_PR HANDLE'''.
      cbn in PR; subst.
      eapply malloc_bytes_with_pr_spec_MemPropT_fin_inf; eauto.
    }

    { (* I8 *)
      inv ARGS.
      inv H3.
      rename x0 into x_inf.
      rename x into x_fin.

      apply dvalue_refine_strict_i8_r_inv in H2 as (?&?&?); subst.

      eapply MemPropT_fin_inf_bind.
      4: apply HANDLE.
      all: eauto.

      { (* MA: fresh_sid *)
        intros a_fin ms_fin_ma FRESH.
        eapply fresh_sid_fin_inf; eauto.
      }

      intros ms_inf ms_fin ms_fin' a_fin a_inf b_fin SID MSR_SID HANDLE'.
      cbn in SID; subst.

      eapply MemPropT_fin_inf_bind.
      all: eauto.

      { (* MA: generate_num_undef_bytes *)
        intros a_fin0 ms_fin_ma GEN.
        red in GEN.
        break_match_hyp; inv GEN.
        rename Heqo into GEN.
        eapply generate_num_undef_bytes_fin_inf in GEN as (bytes_inf&GEN&BYTES_REF).
        exists bytes_inf. exists ms_inf.
        split; eauto.
        red.
        rewrite H0.
        rewrite GEN.
        cbn.
        auto.
      }

      intros ms_inf0 ms_fin0 ms_fin'0 a_fin0 a_inf b_fin0 BYTES_REF MSR_GEN HANDLE''.
      eapply MemPropT_fin_inf_bind.
      all: eauto.

      { (* MA: fresh_provenance *)
        intros a_fin1 ms_fin_ma FRESH_PR.
        eapply fresh_provenance_fin_inf; eauto.
      }

      intros ms_inf1 ms_fin1 ms_fin'1 a_fin1 a_inf0 b_fin1 PR MSR_PR HANDLE'''.
      cbn in PR; subst.
      eapply malloc_bytes_with_pr_spec_MemPropT_fin_inf; eauto.
    }

    { (* I32 *)
      inv ARGS.
      inv H3.
      rename x0 into x_inf.
      rename x into x_fin.

      apply dvalue_refine_strict_i32_r_inv in H2 as (?&?&?); subst.

      eapply MemPropT_fin_inf_bind.
      4: apply HANDLE.
      all: eauto.

      { (* MA: fresh_sid *)
        intros a_fin ms_fin_ma FRESH.
        eapply fresh_sid_fin_inf; eauto.
      }

      intros ms_inf ms_fin ms_fin' a_fin a_inf b_fin SID MSR_SID HANDLE'.
      cbn in SID; subst.

      eapply MemPropT_fin_inf_bind.
      all: eauto.

      { (* MA: generate_num_undef_bytes *)
        intros a_fin0 ms_fin_ma GEN.
        red in GEN.
        break_match_hyp; inv GEN.
        rename Heqo into GEN.
        eapply generate_num_undef_bytes_fin_inf in GEN as (bytes_inf&GEN&BYTES_REF).
        exists bytes_inf. exists ms_inf.
        split; eauto.
        red.
        rewrite H0.
        rewrite GEN.
        cbn.
        auto.
      }

      intros ms_inf0 ms_fin0 ms_fin'0 a_fin0 a_inf b_fin0 BYTES_REF MSR_GEN HANDLE''.
      eapply MemPropT_fin_inf_bind.
      all: eauto.

      { (* MA: fresh_provenance *)
        intros a_fin1 ms_fin_ma FRESH_PR.
        eapply fresh_provenance_fin_inf; eauto.
      }

      intros ms_inf1 ms_fin1 ms_fin'1 a_fin1 a_inf0 b_fin1 PR MSR_PR HANDLE'''.
      cbn in PR; subst.
      eapply malloc_bytes_with_pr_spec_MemPropT_fin_inf; eauto.
    }

    { (* I64 *)
      inv ARGS.
      inv H3.
      rename x0 into x_inf.
      rename x into x_fin.

      apply dvalue_refine_strict_i64_r_inv in H2 as (?&?&?); subst.

      eapply MemPropT_fin_inf_bind.
      4: apply HANDLE.
      all: eauto.

      { (* MA: fresh_sid *)
        intros a_fin ms_fin_ma FRESH.
        eapply fresh_sid_fin_inf; eauto.
      }

      intros ms_inf ms_fin ms_fin' a_fin a_inf b_fin SID MSR_SID HANDLE'.
      cbn in SID; subst.

      eapply MemPropT_fin_inf_bind.
      all: eauto.

      { (* MA: generate_num_undef_bytes *)
        intros a_fin0 ms_fin_ma GEN.
        red in GEN.
        break_match_hyp; inv GEN.
        rename Heqo into GEN.
        eapply generate_num_undef_bytes_fin_inf in GEN as (bytes_inf&GEN&BYTES_REF).
        exists bytes_inf. exists ms_inf.
        split; eauto.
        red.
        rewrite H0.
        rewrite GEN.
        cbn.
        auto.
      }

      intros ms_inf0 ms_fin0 ms_fin'0 a_fin0 a_inf b_fin0 BYTES_REF MSR_GEN HANDLE''.
      eapply MemPropT_fin_inf_bind.
      all: eauto.

      { (* MA: fresh_provenance *)
        intros a_fin1 ms_fin_ma FRESH_PR.
        eapply fresh_provenance_fin_inf; eauto.
      }

      intros ms_inf1 ms_fin1 ms_fin'1 a_fin1 a_inf0 b_fin1 PR MSR_PR HANDLE'''.
      cbn in PR; subst.
      eapply malloc_bytes_with_pr_spec_MemPropT_fin_inf; eauto.
    }

    { (* IPTR *)
      inv ARGS.
      inv H3.
      rename x0 into x_inf.
      rename x into x_fin.

      apply dvalue_refine_strict_iptr_r_inv in H2 as (?&?&?); subst.

      eapply MemPropT_fin_inf_bind.
      4: apply HANDLE.
      all: eauto.

      { (* MA: fresh_sid *)
        intros a_fin ms_fin_ma FRESH.
        eapply fresh_sid_fin_inf; eauto.
      }

      intros ms_inf ms_fin ms_fin' a_fin a_inf b_fin SID MSR_SID HANDLE'.
      cbn in SID; subst.

      eapply MemPropT_fin_inf_bind.
      all: eauto.

      { (* MA: generate_num_undef_bytes *)
        intros a_fin0 ms_fin_ma GEN.
        red in GEN.
        break_match_hyp; inv GEN.
        rename Heqo into GEN.
        eapply generate_num_undef_bytes_fin_inf in GEN as (bytes_inf&GEN&BYTES_REF).
        exists bytes_inf. exists ms_inf.
        split; eauto.
        red.
        rewrite <- InfLP.IP.to_Z_to_unsigned.
        rewrite <- FiniteIntptr.IP64Bit.to_Z_to_unsigned in GEN.
        erewrite fin_inf_from_Z_to_Z in GEN.
        3: apply H0.
        2: apply InfLP.IP.to_Z_from_Z.
        rewrite GEN.
        cbn.
        auto.
      }

      intros ms_inf0 ms_fin0 ms_fin'0 a_fin0 a_inf b_fin0 BYTES_REF MSR_GEN HANDLE''.
      eapply MemPropT_fin_inf_bind.
      all: eauto.

      { (* MA: fresh_provenance *)
        intros a_fin1 ms_fin_ma FRESH_PR.
        eapply fresh_provenance_fin_inf; eauto.
      }

      intros ms_inf1 ms_fin1 ms_fin'1 a_fin1 a_inf0 b_fin1 PR MSR_PR HANDLE'''.
      cbn in PR; subst.
      eapply malloc_bytes_with_pr_spec_MemPropT_fin_inf; eauto.
    }
  Qed.

  Lemma dvalue_refine_strict_addr_r_inv:
  forall (v_inf : DVC1.DV1.dvalue) ptr_fin,
  DVC1.dvalue_refine_strict v_inf (DVC1.DV2.DVALUE_Addr ptr_fin) ->
  exists ptr_inf,
    v_inf = DVC1.DV1.DVALUE_Addr ptr_inf /\
      addr_refine ptr_inf ptr_fin.
  Proof.
    intros v_inf ptr_fin REF.
    rewrite DVC1.dvalue_refine_strict_equation in REF.
    apply dvalue_convert_strict_addr_inv in REF.
    destruct REF as (?&?&?).
    exists x; tauto.
  Qed.

  (* TODO: Move this *)
  Definition heap_refine h_inf h_fin : Prop :=
    InfMemMMSP.heap_eqv h_inf (lift_Heap h_fin).

  Lemma free_block_prop_fin_inf :
    forall {h_fin_start h_fin_final h_inf_start h_inf_final ptr_fin ptr_inf},
      addr_refine ptr_inf ptr_fin ->
      heap_refine h_inf_start h_fin_start ->
      heap_refine h_inf_final h_fin_final ->
      Memory64BitIntptr.MMEP.MemSpec.free_block_prop h_fin_start ptr_fin h_fin_final ->
      MemoryBigIntptr.MMEP.MemSpec.free_block_prop h_inf_start ptr_inf h_inf_final.
  Proof.
    intros h_fin_start h_fin_final h_inf_start h_inf_final ptr_fin ptr_inf ADDR_REF HEAP_START_REF HEAP_FINAL_REF FREE_BLOCK.
    destruct FREE_BLOCK.
    split.
    - clear - ADDR_REF HEAP_START_REF HEAP_FINAL_REF free_block_ptrs_freed.
      intros ptr IN CONTRA.

      red in HEAP_FINAL_REF, HEAP_START_REF.
      rewrite HEAP_START_REF in IN.
      rewrite HEAP_FINAL_REF in CONTRA.

      eapply ptr_in_heap_prop_lift_inv in IN as (?&?&?&?&?); eauto.
      eapply ptr_in_heap_prop_lift_inv in CONTRA as (?&?&?&?&?); eauto.
      rewrite ADDR_REF in H; inv H.
      rewrite ADDR_REF in H2; inv H2.
      rewrite H0 in H3; inv H3.
      eapply free_block_ptrs_freed; eauto.
    - clear - ADDR_REF HEAP_START_REF HEAP_FINAL_REF free_block_root_freed.
      intros CONTRA.
      eapply free_block_root_freed.

      red in HEAP_FINAL_REF, HEAP_START_REF.
      rewrite HEAP_FINAL_REF in CONTRA.
      eapply root_in_heap_prop_lift_inv in CONTRA.
      destruct CONTRA as (?&?&?).
      rewrite ADDR_REF in H.
      inv H.
      eauto.
    - clear - ADDR_REF HEAP_START_REF HEAP_FINAL_REF free_block_disjoint_preserved.
      intros ptr root' DISJOINT.
      split; intros IN.
      {
        red in HEAP_FINAL_REF, HEAP_START_REF.
        rewrite HEAP_START_REF in IN.
        rewrite HEAP_FINAL_REF.

        eapply ptr_in_heap_prop_lift_inv in IN as (root_fin&?&?&?&?); eauto.

        assert (fin_to_inf_addr x = ptr) as PTR_FIN.
        {
          unfold fin_to_inf_addr.
          break_match_goal.
          clear Heqs.
          apply FinToInfAddrConvertSafe.addr_convert_safe in e.
          eapply InfToFinAddrConvert.addr_convert_injective; eauto.
        }

        assert (fin_to_inf_addr root_fin = root') as ROOT_FIN.
        {
          unfold fin_to_inf_addr.
          break_match_goal.
          clear Heqs.
          apply FinToInfAddrConvertSafe.addr_convert_safe in e.
          eapply InfToFinAddrConvert.addr_convert_injective; eauto.
        }
        subst.

        eapply fin_inf_disjoint_ptr_byte in DISJOINT; eauto.
        eapply ptr_in_heap_prop_lift.
        specialize (free_block_disjoint_preserved x root_fin DISJOINT).
        destruct free_block_disjoint_preserved.
        eauto.
      }

      {
        red in HEAP_FINAL_REF, HEAP_START_REF.
        rewrite HEAP_FINAL_REF in IN.
        rewrite HEAP_START_REF.

        eapply ptr_in_heap_prop_lift_inv in IN as (root_fin&?&?&?&?); eauto.

        assert (fin_to_inf_addr x = ptr) as PTR_FIN.
        {
          unfold fin_to_inf_addr.
          break_match_goal.
          clear Heqs.
          apply FinToInfAddrConvertSafe.addr_convert_safe in e.
          eapply InfToFinAddrConvert.addr_convert_injective; eauto.
        }

        assert (fin_to_inf_addr root_fin = root') as ROOT_FIN.
        {
          unfold fin_to_inf_addr.
          break_match_goal.
          clear Heqs.
          apply FinToInfAddrConvertSafe.addr_convert_safe in e.
          eapply InfToFinAddrConvert.addr_convert_injective; eauto.
        }
        subst.


        eapply fin_inf_disjoint_ptr_byte in DISJOINT; eauto.
        eapply ptr_in_heap_prop_lift.
        specialize (free_block_disjoint_preserved x root_fin DISJOINT).
        destruct free_block_disjoint_preserved; eauto.
      }
    - clear - ADDR_REF HEAP_START_REF HEAP_FINAL_REF free_block_disjoint_roots.
      intros root' DISJOINT.

      split; intros IN.
      {
        red in HEAP_FINAL_REF, HEAP_START_REF.
        rewrite HEAP_START_REF in IN.
        rewrite HEAP_FINAL_REF.

        eapply root_in_heap_prop_lift_inv in IN as (root_fin&?&?).
        assert (fin_to_inf_addr root_fin = root').
        {
          unfold fin_to_inf_addr.
          break_match_goal.
          clear Heqs.
          apply FinToInfAddrConvertSafe.addr_convert_safe in e.
          eapply InfToFinAddrConvert.addr_convert_injective; eauto.
        }
        subst.

        eapply root_in_heap_prop_lifted_fin_inf.
        apply addr_refine_fin_to_inf_addr.

        eapply fin_inf_disjoint_ptr_byte in DISJOINT; eauto.

        subst.
        specialize (free_block_disjoint_roots root_fin DISJOINT).
        destruct free_block_disjoint_roots.
        auto.
      }

      {
        red in HEAP_FINAL_REF, HEAP_START_REF.
        rewrite HEAP_FINAL_REF in IN.
        rewrite HEAP_START_REF.

        eapply root_in_heap_prop_lift_inv in IN as (root_fin&?&?).
        assert (fin_to_inf_addr root_fin = root').
        {
          unfold fin_to_inf_addr.
          break_match_goal.
          clear Heqs.
          apply FinToInfAddrConvertSafe.addr_convert_safe in e.
          eapply InfToFinAddrConvert.addr_convert_injective; eauto.
        }
        subst.

        eapply root_in_heap_prop_lifted_fin_inf.
        apply addr_refine_fin_to_inf_addr.

        eapply fin_inf_disjoint_ptr_byte in DISJOINT; eauto.

        subst.
        specialize (free_block_disjoint_roots root_fin DISJOINT).
        destruct free_block_disjoint_roots.
        auto.
      }
  Qed.

  Lemma fin_to_inf_addr_injective :
    forall ptr1 ptr2,
      fin_to_inf_addr ptr1 = fin_to_inf_addr ptr2 ->
      ptr1 = ptr2.
  Proof.
    intros ptr1 ptr2 H.
    unfold fin_to_inf_addr in *.
    do 2 destruct FinToInfAddrConvertSafe.addr_convert_succeeds in H.
    subst.
    eapply FinToInfAddrConvert.addr_convert_injective; eauto.
  Qed.

  Lemma free_block_prop_inf_fin :
    forall {h_fin_start h_fin_final h_inf_start h_inf_final ptr_fin ptr_inf},
      addr_refine ptr_inf ptr_fin ->
      heap_refine h_inf_start h_fin_start ->
      heap_refine h_inf_final h_fin_final ->
      MemoryBigIntptr.MMEP.MemSpec.free_block_prop h_inf_start ptr_inf h_inf_final ->
      Memory64BitIntptr.MMEP.MemSpec.free_block_prop h_fin_start ptr_fin h_fin_final.
  Proof.
    intros h_fin_start h_fin_final h_inf_start h_inf_final ptr_fin ptr_inf ADDR_REF HEAP_START_REF HEAP_FINAL_REF FREE_BLOCK.
    destruct FREE_BLOCK.
    split.
    - clear - ADDR_REF HEAP_START_REF HEAP_FINAL_REF free_block_ptrs_freed.
      intros ptr IN CONTRA.

      apply ptr_in_heap_prop_lift in IN, CONTRA.
      erewrite fin_to_inf_addr_conv_inf in IN, CONTRA; eauto.
      setoid_rewrite HEAP_START_REF in free_block_ptrs_freed.
      setoid_rewrite HEAP_FINAL_REF in free_block_ptrs_freed.
      eapply free_block_ptrs_freed; eauto.
    - clear - ADDR_REF HEAP_START_REF HEAP_FINAL_REF free_block_root_freed.
      intros CONTRA.
      eapply free_block_root_freed.

      red in HEAP_FINAL_REF, HEAP_START_REF.
      rewrite HEAP_FINAL_REF.
      eapply root_in_heap_prop_lift in CONTRA.
      erewrite fin_to_inf_addr_conv_inf in CONTRA; eauto.
    - clear - ADDR_REF HEAP_START_REF HEAP_FINAL_REF free_block_disjoint_preserved.
      intros ptr root' DISJOINT.
      split; intros IN.
      {
        red in HEAP_FINAL_REF, HEAP_START_REF.
        setoid_rewrite HEAP_START_REF in free_block_disjoint_preserved.
        setoid_rewrite HEAP_FINAL_REF in free_block_disjoint_preserved.

        eapply ptr_in_heap_prop_lift in IN.
        eapply free_block_disjoint_preserved in IN.
        2: {
          eapply fin_inf_disjoint_ptr_byte; eauto.
          apply addr_refine_fin_to_inf_addr.
        }

        eapply ptr_in_heap_prop_lift_inv in IN.
        destruct IN as (?&?&?&?&?).
        apply fin_to_inf_addr_conv_inf in H, H0.

        apply fin_to_inf_addr_injective in H, H0; subst.
        auto.
      }

      {
        red in HEAP_FINAL_REF, HEAP_START_REF.
        setoid_rewrite HEAP_START_REF in free_block_disjoint_preserved.
        setoid_rewrite HEAP_FINAL_REF in free_block_disjoint_preserved.

        eapply ptr_in_heap_prop_lift in IN.
        eapply free_block_disjoint_preserved in IN.
        2: {
          eapply fin_inf_disjoint_ptr_byte; eauto.
          apply addr_refine_fin_to_inf_addr.
        }

        eapply ptr_in_heap_prop_lift_inv in IN.
        destruct IN as (?&?&?&?&?).
        apply fin_to_inf_addr_conv_inf in H, H0.

        apply fin_to_inf_addr_injective in H, H0; subst.
        auto.
      }
    - clear - ADDR_REF HEAP_START_REF HEAP_FINAL_REF free_block_disjoint_roots.
      intros root' DISJOINT.

      split; intros IN.
      {
        red in HEAP_FINAL_REF, HEAP_START_REF.
        setoid_rewrite HEAP_START_REF in free_block_disjoint_roots.
        setoid_rewrite HEAP_FINAL_REF in free_block_disjoint_roots.

        eapply root_in_heap_prop_lift in IN.
        eapply free_block_disjoint_roots in IN.
        2: {
          eapply fin_inf_disjoint_ptr_byte; eauto.
          apply addr_refine_fin_to_inf_addr.
        }

        eapply root_in_heap_prop_lift_inv in IN.
        destruct IN as (?&?&?).
        apply fin_to_inf_addr_conv_inf in H.
        apply fin_to_inf_addr_injective in H; subst.
        auto.
      }

      {
        red in HEAP_FINAL_REF, HEAP_START_REF.
        setoid_rewrite HEAP_START_REF in free_block_disjoint_roots.
        setoid_rewrite HEAP_FINAL_REF in free_block_disjoint_roots.

        eapply root_in_heap_prop_lift in IN.
        eapply free_block_disjoint_roots in IN.
        2: {
          eapply fin_inf_disjoint_ptr_byte; eauto.
          apply addr_refine_fin_to_inf_addr.
        }

        eapply root_in_heap_prop_lift_inv in IN.
        destruct IN as (?&?&?).
        apply fin_to_inf_addr_conv_inf in H.
        apply fin_to_inf_addr_injective in H; subst.
        auto.
      }
  Qed.

  Lemma handle_free_spec_fin_inf :
    forall {ms_fin_start ms_fin_final ms_inf_start ptr_fin ptr_inf},
      MemState_refine_prop ms_inf_start ms_fin_start ->
      addr_refine ptr_inf ptr_fin ->
      Memory64BitIntptr.MMEP.MemSpec.free_preconditions ms_fin_start ptr_fin ->
      Memory64BitIntptr.MMEP.MemSpec.free_spec ms_fin_start ptr_fin ms_fin_final ->
      exists (ms_inf_final : MemoryBigIntptr.MMEP.MMSP.MemState),
        MemoryBigIntptr.MMEP.MemSpec.free_spec ms_inf_start ptr_inf ms_inf_final /\
          MemState_refine_prop ms_inf_final ms_fin_final.
  Proof.
    intros ms_fin_start ms_fin_final ms_inf_start ptr_fin ptr_inf MSR PTR_REF FREE_PRE FREE.
    destruct FREE, FREE_PRE.

    exists (lift_MemState ms_fin_final).

    split.
    2: apply lift_MemState_refine_prop.

    split.
    - intros ptr H.
      { destruct (InfToFinAddrConvert.addr_convert ptr) eqn:CONV.
        { (* ptr in finite range *)
          eapply ptr_in_memstate_heap_inf_fin in H; eauto.
          apply free_bytes_freed in H.
          eapply fin_inf_byte_not_allocated in H; eauto.
          apply lift_MemState_refine_prop; auto.
        }

        { (* Big pointer, shouldn't be allocated. *)
          exfalso.
          eapply ptr_in_memstate_heap_inf_fin_exists in H; eauto.
          destruct H as (?&?&?).
          apply free_block_allocated in H0.
          destruct H0 as (?&?).
          epose proof fin_inf_byte_allocated_exists _ _ _ _ MSR H0 as (?&?&?).
          red in H.
          rewrite CONV in H.
          discriminate.
        }
      }
    - intros ptr aid H.
      { destruct (InfToFinAddrConvert.addr_convert ptr) eqn:CONV.
        { (* ptr in finite range *)
          split; intros ALLOC.
          - eapply fin_inf_byte_allocated; eauto.
            apply lift_MemState_refine_prop; auto.
            apply free_non_block_bytes_preserved.
            + intros CONTRA.
              eapply ptr_in_memstate_heap_fin_inf in CONTRA; eauto.
            + eapply inf_fin_byte_allocated; eauto.
          - eapply fin_inf_byte_allocated; eauto.
            apply free_non_block_bytes_preserved.
            + intros CONTRA.
              eapply ptr_in_memstate_heap_fin_inf in CONTRA; eauto.
            + eapply inf_fin_byte_allocated; eauto.
              apply lift_MemState_refine_prop; auto.
        }

        { (* Big pointer, shouldn't be allocated. *)
          split; intros ALLOC.
          - eapply inf_fin_byte_allocated_exists in ALLOC; eauto.
            destruct ALLOC as (?&?&?).
            rewrite CONV in H0; discriminate.
          - eapply inf_fin_byte_allocated_exists in ALLOC; eauto.
            destruct ALLOC as (?&?&?).
            rewrite CONV in H0; discriminate.
            apply lift_MemState_refine_prop; auto.
        }
      }
    - intros ptr byte H.
      { destruct (InfToFinAddrConvert.addr_convert ptr) eqn:CONV.
        { (* ptr in finite range *)
          split; intros RBS.
          - pose proof inf_fin_read_byte_spec MSR CONV RBS as (byte_fin&RBS_FIN&BYTE_REF).
            eapply free_non_frame_bytes_read in RBS_FIN.
            2: {
              intros CONTRA.
              eapply ptr_in_memstate_heap_fin_inf in CONTRA; eauto.
            }
            eapply fin_inf_read_byte_spec; eauto.
            apply lift_MemState_refine_prop; auto.
          - pose proof (lift_MemState_refine_prop ms_fin_final) as MSR'.
            epose proof inf_fin_read_byte_spec MSR' CONV RBS as (byte_fin&RBS_FIN&BYTE_REF).
            eapply free_non_frame_bytes_read in RBS_FIN.
            2: {
              intros CONTRA.
              eapply ptr_in_memstate_heap_fin_inf in CONTRA; eauto.
            }
            eapply fin_inf_read_byte_spec; eauto.
        }

        { (* Big pointer, shouldn't be allocated. *)
          split; intros ALLOC.
          - eapply inf_fin_read_byte_spec_exists in ALLOC; eauto.
            destruct ALLOC as (?&?&?&?&?).
            red in H2.
            rewrite CONV in H2; discriminate.
          - eapply inf_fin_read_byte_spec_exists in ALLOC; eauto.
            destruct ALLOC as (?&?&?&?&?).
            red in H2.
            rewrite CONV in H2; discriminate.
            apply lift_MemState_refine_prop; auto.
        }
      }
    - clear - PTR_REF MSR free_block.
      intros h1 h2 H1 H2.
      cbn.

      apply MemState_refine_prop_heap_preserved in MSR.
      red in MSR.

      destruct ms_fin_start. destruct ms_memory_stack.
      rename memory_stack_heap into h_fin_start.
      destruct ms_inf_start. destruct ms_memory_stack.
      rename memory_stack_heap into h_inf_start.
      destruct ms_fin_final. destruct ms_memory_stack.
      rename memory_stack_heap into h_fin_final.
      cbn in *.
      unfold Memory64BitIntptr.MMEP.MMSP.memory_stack_heap_prop, MemoryBigIntptr.MMEP.MMSP.memory_stack_heap_prop in *.
      cbn in *.
      cbn in *.

      eapply free_block_prop_fin_inf; eauto.
      3: {
        eapply free_block; reflexivity.
      }

      { red.
        symmetry.
        apply MSR; auto.
      }

      { red.
        symmetry.
        auto.
      }
    - (* Free operation invariants *)
      clear - MSR free_invariants.
      destruct free_invariants.
      split.
      + eapply fin_inf_preserve_allocation_ids; eauto.
        apply lift_MemState_refine_prop; auto.
      + eapply fin_inf_frame_stack_preserved; eauto.
        apply lift_MemState_refine_prop; auto.
  Qed.

  Lemma handle_free_preconditions_fin_inf :
    forall {ms_fin_start ms_inf_start ptr_fin ptr_inf},
      MemState_refine_prop ms_inf_start ms_fin_start ->
      addr_refine ptr_inf ptr_fin ->
      Memory64BitIntptr.MMEP.MemSpec.free_preconditions ms_fin_start ptr_fin ->
      MemoryBigIntptr.MMEP.MemSpec.free_preconditions ms_inf_start ptr_inf.
  Proof.
    intros ms_fin_start ms_inf_start ptr_fin ptr_inf MSR PTR_REF FREE_PRE.
    destruct FREE_PRE.

    split.
    - eapply root_in_memstate_heap_fin_inf; eauto.
    - destruct free_was_allocated.
      eapply fin_inf_byte_allocated in H; eauto.
    - intros ptr H.
      { destruct (InfToFinAddrConvert.addr_convert ptr) eqn:CONV.
        { (* ptr in finite range *)
          eapply ptr_in_memstate_heap_inf_fin in H; eauto.
          apply free_block_allocated in H.
          destruct H.
          eapply fin_inf_byte_allocated in H; eauto.
        }

        { (* Big pointer, shouldn't be allocated. *)
          exfalso.
          eapply ptr_in_memstate_heap_inf_fin_exists in H; eauto.
          destruct H as (?&?&?).
          apply free_block_allocated in H0.
          destruct H0 as (?&?).
          epose proof fin_inf_byte_allocated_exists _ _ _ _ MSR H0 as (?&?&?).
          red in H.
          rewrite CONV in H.
          discriminate.
        }
      }
  Qed.

  Lemma handle_free_fin_inf :
    forall {ms_fin_start ms_fin_final ms_inf_start res_fin args_fin args_inf},
      MemState_refine_prop ms_inf_start ms_fin_start ->
      Forall2 DVC1.dvalue_refine_strict args_inf args_fin ->
      Memory64BitIntptr.MMEP.MemSpec.handle_free_prop args_fin ms_fin_start (ret (ms_fin_final, res_fin)) ->
      exists res_inf ms_inf_final,
        MemoryBigIntptr.MMEP.MemSpec.handle_free_prop args_inf ms_inf_start (ret (ms_inf_final, res_inf)) /\
          res_inf = res_fin /\
          MemState_refine_prop ms_inf_final ms_fin_final.
  Proof.
    intros ms_fin_start ms_fin_final ms_inf_start res_fin args_fin args_inf MSR ARGS HANDLE.
    red in HANDLE.
    destruct args_fin; try contradiction; inv ARGS.
    destruct d; try contradiction.
    destruct args_fin; try contradiction.
    inv H3.
    rename H2 into ADDR.
    rename x into inf_addr.
    rename a into ptr_fin.

    apply dvalue_refine_strict_addr_r_inv in ADDR as (ptr_inf&PTR&PTR_REF);
      subst.
    cbn in *.
    destruct HANDLE as [FREE_PRE HANDLE].

    epose proof handle_free_spec_fin_inf MSR PTR_REF FREE_PRE HANDLE.
    destruct res_fin.
    exists tt.
    destruct H as (ms_inf_final&?&?).
    exists ms_inf_final; auto.
    split; eauto.
    split; eauto.
    eapply handle_free_preconditions_fin_inf; eauto.
  Qed.

  Lemma handle_free_fin_inf_error :
    forall {ms_fin_start ms_inf_start msg_fin args_fin args_inf},
      MemState_refine_prop ms_inf_start ms_fin_start ->
      Forall2 DVC1.dvalue_refine_strict args_inf args_fin ->
      Memory64BitIntptr.MMEP.MemSpec.handle_free_prop args_fin ms_fin_start (raise_error msg_fin) ->
      exists msg_inf,
        MemoryBigIntptr.MMEP.MemSpec.handle_free_prop args_inf ms_inf_start (raise_error msg_inf).
  Proof.
    intros ms_fin_start ms_inf_start msg_fin args_fin args_inf MSR ARGS HANDLE.

    repeat (destruct ARGS;
            try solve [cbn in *; eauto];
            match goal with
            | H: DVCInfFin.dvalue_refine_strict ?x _ |- _ =>
                destruct x;
                cbn in H;
                inv H;
                try solve [cbn in *; eauto]
            end).
    all: repeat break_match_hyp_inv.
    all: destruct ARGS; [|cbn in *; eauto].
    eauto.
    Unshelve.
    exact (""%string).
  Qed.

  (* TODO: Lemma about lifting intrinsic handlers *)
  (* TODO: Move this *)
  Lemma handle_intrinsic_fin_inf :
    forall {t f args args0 ms_fin ms_fin' ms_inf d_fin}
      (ARGS: Forall2 DVCInfFin.dvalue_refine_strict args0 args),
      MemState_refine_prop ms_inf ms_fin ->
      Memory64BitIntptr.MMEP.MemSpec.handle_intrinsic_prop
        LLVMParams64BitIntptr.Events.DV.dvalue
        (LLVMParams64BitIntptr.Events.Intrinsic t f args) ms_fin (ret (ms_fin', d_fin)) ->
      exists d_inf ms_inf',
        MemoryBigIntptr.MMEP.MemSpec.handle_intrinsic_prop DVCInfFin.DV1.dvalue
          (InterpreterStackBigIntptr.LP.Events.Intrinsic t f args0) ms_inf
          (ret (ms_inf', d_inf)) /\
          DVC1.dvalue_refine_strict d_inf d_fin /\
          MemState_refine_prop ms_inf' ms_fin'.
  Proof.
    intros t f args args0 ms_fin ms_fin' ms_inf d_fin ARGS MSR INTRINSIC.

    red in INTRINSIC.
    unfold MemoryBigIntptr.MMEP.MemSpec.handle_intrinsic_prop.
    break_match.
    { (* Memcpy *)
      eapply MemPropT_fin_inf_bind.
      4: apply INTRINSIC.
      all: eauto.

      { (* MA *)
        intros a_fin ms_fin_ma MEMCPY.
        eapply handle_memcpy_fin_inf; eauto.
      }

      intros ms_inf0 ms_fin0 ms_fin'0 a_fin a_inf b_fin _ MSR' HANDLE EQV.
      cbn in EQV.
      destruct EQV; subst.

      cbn.
      exists LLVMParamsBigIntptr.Events.DV.DVALUE_None.
      exists ms_inf0.
      split; auto.
      split; auto.
      rewrite DVCInfFin.dvalue_refine_strict_equation.
      reflexivity.
    }

    break_match.
    { (* Malloc *)
      eapply MemPropT_fin_inf_bind.
      4: apply INTRINSIC.
      all: eauto.

      { (* MA: handle_malloc_prop *)
        intros a_fin ms_fin_ma HANDLE_MALLOC.
        eapply handle_malloc_fin_inf; eauto.
      }

      intros ms_inf0 ms_fin0 ms_fin'0 a_fin a_inf b_fin H H0 H1 H2.
      cbn in H, H2.
      destruct H2; subst.
      do 2 eexists; cbn; split; auto.
      split; auto.
      rewrite DVC1.dvalue_refine_strict_equation.
      cbn.
      rewrite H.
      auto.
    }

    break_match.
    { (* Free *)
      eapply MemPropT_fin_inf_bind.
      4: apply INTRINSIC.
      all: eauto.

      { (* MA: handle_free_prop *)
        intros a_fin ms_fin_ma HANDLE_FREE.
        eapply handle_free_fin_inf; eauto.
      }

      intros ms_inf0 ms_fin0 ms_fin'0 a_fin a_inf b_fin H H0 H1 H2.
      cbn in H, H2.
      destruct H2; subst.
      do 2 eexists; cbn; split; auto.
      split; auto.
      rewrite DVC1.dvalue_refine_strict_equation.
      cbn.
      auto.
    }

    (* Unknown intrinsic *)
    cbn in *; auto.
    contradiction.
  Qed.

  Lemma to_ubytes_fin_inf_helper :
    forall {uv_fin uv_inf t sid bytes_fin l},
      DVC1.uvalue_refine_strict uv_inf uv_fin  ->
      map 
        (fun n : N =>
             (Memory64BitIntptr.MP.BYTE_IMPL.uvalue_sbyte uv_fin t n sid))
        l =
        bytes_fin ->
      map
        (fun n : N =>
             (MemoryBigIntptr.MP.BYTE_IMPL.uvalue_sbyte uv_inf t n sid))
        l =
        (map lift_SByte bytes_fin).
  Proof.
    intros uv_fin uv_inf t sid bytes_fin l UV_REF UBYTES.
    generalize dependent bytes_fin.
    induction l; intros; cbn in *.
    - subst; auto.
    - destruct bytes_fin; inversion UBYTES.
      cbn.
      remember (map (fun n : N => Memory64BitIntptr.MP.BYTE_IMPL.uvalue_sbyte uv_fin t n sid) l) as bytes_fin'.
      rewrite (IHl bytes_fin'); auto.

      assert (MemoryBigIntptr.MP.BYTE_IMPL.uvalue_sbyte uv_inf t a sid =
                FiniteSizeof.mkUByte DVC2.DV2.uvalue (fin_to_inf_uvalue uv_fin) t a sid).
      {  unfold MemoryBigIntptr.MP.BYTE_IMPL.uvalue_sbyte.
         erewrite <- fin_to_inf_uvalue_refine_strict'; eauto. }
      rewrite H.
      reflexivity.
  Qed.

  (* TODO: move this *)
  Definition lift_SBytes := map lift_SByte.

  Lemma lift_SBytes_refine :
    forall {bytes_fin},
      sbytes_refine (lift_SBytes bytes_fin) bytes_fin.
  Proof.
    induction bytes_fin; cbn.
    - constructor.
    - constructor.
      apply sbyte_refine_lifted.
      apply IHbytes_fin.
  Qed.

  (* TODO: should we know that uv_inf / uv_fin has type t?

     I think this would have to be an assumption, in theory the front
     end would guarantee this for stores with a syntactic check.
   *)
  Lemma to_ubytes_fin_inf :
    forall {uv_fin uv_inf t sid bytes_fin},
      DVC1.uvalue_refine_strict uv_inf uv_fin ->
       (Memory64BitIntptr.MMEP.MMSP.MemByte.to_ubytes uv_fin t sid) = bytes_fin ->
        exists bytes_inf,
        (MemoryBigIntptr.MMEP.MMSP.MemByte.to_ubytes uv_inf t sid) = bytes_inf /\
           sbytes_refine bytes_inf bytes_fin.
  Proof.
    intros uv_fin uv_inf t sid bytes_fin UV_REF UBYTES.
    exists (lift_SBytes bytes_fin).
    split.
    2: {
      apply lift_SBytes_refine.
    }

    unfold MemoryBigIntptr.MMEP.MMSP.MemByte.to_ubytes,
      Memory64BitIntptr.MMEP.MMSP.MemByte.to_ubytes in *.

    unfold LLVMParams64BitIntptr.SIZEOF.sizeof_dtyp,
      LLVMParamsBigIntptr.SIZEOF.sizeof_dtyp in *.

    eapply to_ubytes_fin_inf_helper; eauto.
  Qed.

  Lemma to_ubytes_fin_inf_sbytes_refine :
    forall {uv_fin uv_inf t sid},
      DVC1.uvalue_refine_strict uv_inf uv_fin ->
      sbytes_refine (MemoryBigIntptr.MMEP.MMSP.MemByte.to_ubytes uv_inf t sid) (Memory64BitIntptr.MMEP.MMSP.MemByte.to_ubytes uv_fin t sid).
  Proof.
    intros uv_fin uv_inf t sid UV_REF.

    unfold MemoryBigIntptr.MMEP.MMSP.MemByte.to_ubytes,
      Memory64BitIntptr.MMEP.MMSP.MemByte.to_ubytes in *.

    red.
    unfold LLVMParams64BitIntptr.SIZEOF.sizeof_dtyp,
      LLVMParamsBigIntptr.SIZEOF.sizeof_dtyp in *.

    remember (Nseq 0 (N.to_nat (FiniteSizeof.FinSizeof.sizeof_dtyp t))) as l.
    clear Heql.
    induction l.
    - cbn. auto.
    - cbn.
      constructor; eauto.
      red.
      cbn.
      rewrite UV_REF.
      reflexivity.
  Qed.

  (* TODO: move this. Should hold for fin / inf *)
  (* TODO: This isn't true... The bytes can get different sids *)
  Lemma serialize_sbytes_deterministic :
    forall {uv t ms ms' bytes bytes'},
      Memory64BitIntptr.MMEP.MemSpec.MemHelpers.serialize_sbytes (M:=MemPropT Memory64BitIntptr.MMEP.MMSP.MemState) uv t ms (success_unERR_UB_OOM (ms', bytes)) ->
      Memory64BitIntptr.MMEP.MemSpec.MemHelpers.serialize_sbytes (M:=MemPropT Memory64BitIntptr.MMEP.MMSP.MemState) uv t ms (success_unERR_UB_OOM (ms', bytes')) ->
      bytes' = bytes.
  Proof.
    (* intros uv t ms ms' bytes bytes' SER1 SER2. *)
    (* rewrite Memory64BitIntptr.MMEP.MemSpec.MemHelpers.serialize_sbytes_equation in SER1, SER2. *)
    (* induction uv using uvalue_ind''. *)

    (* { *)
    (*   apply MemPropT_bind_ret_inv in SER1. *)
    (*   destruct SER1 as (?&?&?&?). *)

    (*   apply MemPropT_bind_ret_inv in SER2. *)
    (*   destruct SER2 as (?&?&?&?). *)

    (*   assert (Memory64BitIntptr.MMEP.MemSpec.MemState_eqv x x1) as EQV. *)
    (*   { etransitivity. *)
    (*     symmetry; eapply fresh_sid_MemState_eqv; eauto. *)
    (*     eapply fresh_sid_MemState_eqv; eauto. *)
    (*   } *)

    (*   assert (Memory64BitIntptr.MMEP.MemSpec.MemState_eqv ms x) as EQV2. *)
    (*   { etransitivity. *)
    (*     eapply fresh_sid_MemState_eqv; eauto. *)
    (*     symmetry; eauto. *)
    (*   } *)

    (*   red in H0. *)
    (*   red in H2. *)


    (*       etransitivity; *)
    (*       [eapply fresh_sid_MemState_eqv; eauto|]; *)
    (*       match goal with *)
    (*       | H: lift_OOM ?x _ _ |- _ => *)
    (*           red in H; destruct x eqn:?HX; inv H *)
    (*       end; reflexivity. *)
    (*     | destruct t_orig; *)
    (*       try solve *)
    (*         [ *)
    (*           apply MemPropT_bind_ret_inv in SERIALIZE; *)
    (*           destruct SERIALIZE as (?&?&?&?); *)
    (*           etransitivity; *)
    (*           [eapply fresh_sid_MemState_eqv; eauto|]; *)
    (*           match goal with *)
    (*           | H: lift_OOM ?x _ _ |- _ => *)
    (*               red in H; destruct x eqn:?HX; inv H *)
    (*           end; reflexivity *)
    (*         ]; *)
    (*       try *)
    (*         solve *)
    (*         [ (* Arrays *) *)
    (*           specialize (IHuv (DTYPE_Array sz0 t_orig) _ _ _ SERIALIZE); auto *)
    (*         | (* Vectors *) *)
    (*           specialize (IHuv (DTYPE_Vector sz0 t_orig) _ _ _ SERIALIZE); auto *)
    (*         | (* Structs *) *)
    (*           specialize (IHuv (DTYPE_Struct fields) _ _ _ SERIALIZE); auto *)
    (*         | (* Packed structs *) *)
    (*           specialize (IHuv (DTYPE_Packed_struct fields) _ _ _ SERIALIZE); auto *)
    (*         ] *)
    (*     ]. *)

    (* } *)
  Abort.

  (* TODO: Move this, and maybe generalize this *)
  Lemma map_monad_InT_length_noom :
    forall {X Y} {xs : list X} {ys : list Y} {f},
      map_monad_InT xs f = NoOom ys ->
      length xs = length ys.
  Proof.
    intros X Y.
    induction xs; intros ys f H.
    - cbn in *.
      inv H; auto.
    - rewrite map_monad_InT_unfold in H.
      cbn in H.
      break_match_hyp; inv H.
      break_match_hyp; inv H1.
      apply IHxs in Heqo0.
      cbn.
      auto.
  Qed.

  (* TODO: Move this hint? *)
  Hint Constructors DVC1.DV2.uvalue_has_dtyp : UVALUE_DTYP.

  (* TODO: Move this *)
  Ltac solve_uvalue_refine_strict :=
    solve [rewrite DVC1.uvalue_refine_strict_equation; cbn; auto].

  (* TODO: Probably a better spot for this too *)
  Lemma uvalue_refine_strict_has_dtyp :
    forall {uv_inf uv_fin t},
      DVC1.uvalue_refine_strict uv_inf uv_fin ->
      DVC1.DV1.uvalue_has_dtyp uv_inf t ->
      DVC1.DV2.uvalue_has_dtyp uv_fin t.
  Proof.
    intros uv_inf uv_fin t UV_REF TYP.
    unfold DVC1.uvalue_refine_strict in UV_REF.
    generalize dependent uv_fin.
    
    induction TYP; intros uv_fin UV_REF; inversion UV_REF; clear UV_REF;
      try solve [
          repeat break_match_hyp_inv;    
          constructor; auto
        | repeat break_match_hyp_inv;
          intuition; econstructor; eauto
        | repeat break_match_hyp_inv;
          constructor;
          rewrite map_monad_oom_Forall2 in Heqo;
          revert l Heqo;
          induction H; intros L HL; inversion HL; subst; constructor; eauto
        ].

    - (* Arrays *)
      repeat break_match_hyp_inv.
      constructor; auto.
      + rewrite map_monad_oom_Forall2 in Heqo.
        revert sz H1.
        induction Heqo; constructor.
        * eapply IH; eauto. left.  reflexivity. 
        * eapply IHHeqo; intros; eauto.
          -- eapply IH; eauto. right.  assumption.
          -- cbn in H2. rewrite Nnat.Nat2N.id. reflexivity.
      + apply map_monad_oom_length in Heqo.
        rewrite <- Heqo. assumption.
    - (* Vectors *)
      repeat break_match_hyp_inv.
      constructor; auto.
      + rewrite map_monad_oom_Forall2 in Heqo.
        revert sz H1.
        induction Heqo; constructor.
        * eapply IH; eauto. left.  reflexivity. 
        * eapply IHHeqo; intros; eauto.
          -- eapply IH; eauto. right.  assumption.
          -- cbn in H2. rewrite Nnat.Nat2N.id. reflexivity.
      + apply map_monad_oom_length in Heqo.
        rewrite <- Heqo. assumption.
    - repeat break_match_hyp_inv.
      econstructor; intuition.
      left. eauto.
    - repeat break_match_hyp_inv.
      econstructor; intuition.
      left. eauto.

    - repeat break_match_hyp_inv.
      destruct H; subst.
      econstructor. left. reflexivity. eauto. eauto.
      econstructor. right. reflexivity. eauto. eauto.

    - break_match_hyp_inv.
      constructor; auto.
      + intros.
        rewrite map_monad_oom_Forall2 in Heqo.      
        apply Forall2_flip in Heqo.
        destruct (Forall2_In _ _ _ _ H2 Heqo) as [x [HIN HX]].
        destruct (H0 _ HIN) as [u [t [idx [sid HY]]]].
        subst.
        cbn in HX.
        repeat break_match_hyp_inv.
        do 4 eexists.
        reflexivity.
      + apply map_monad_oom_length in Heqo.
        rewrite <- Heqo.
        rewrite <- H1.
        reflexivity.
        Unshelve.
        all: eauto.
  Qed.

  Lemma uvalue_refine_strict_has_dtyp_fin_inf :
    forall {uv_inf uv_fin t},
      DVC1.uvalue_refine_strict uv_inf uv_fin ->
      DVC1.DV2.uvalue_has_dtyp uv_fin t ->
      DVC1.DV1.uvalue_has_dtyp uv_inf t.
  Proof.
    intros uv_inf uv_fin t UV_REF TYP.
    unfold DVC1.uvalue_refine_strict in UV_REF.
    generalize dependent uv_inf.

    induction TYP; intros uv_fin UV_REF; inversion UV_REF; clear UV_REF;
      try solve [
          destruct uv_fin; cbn in H0;
          repeat break_match_hyp_inv;
          try discriminate;
          try constructor; auto
        | destruct uv_fin; cbn in H2;
          repeat break_match_hyp_inv;
          try inv H2;
          try discriminate;
          try constructor; auto
        | destruct uv_fin; cbn in H1;
          repeat break_match_hyp_inv;
          try inv H1;
          try discriminate;
          try constructor; auto;      
          rewrite map_monad_oom_Forall2 in Heqo;
          revert fields0 Heqo;
          induction H; intros fields HL; inversion HL; subst; constructor; eauto
        | destruct uv_fin; cbn in H1;
          repeat break_match_hyp_inv;
          try inv H1;
          econstructor; eauto
        ].

    - (* Arrays *)
      destruct uv_fin; cbn in H3;
        repeat break_match_hyp_inv;
        try inv H3.
      constructor; auto.
      + rewrite map_monad_oom_Forall2 in Heqo.
        revert sz H1.
        induction Heqo; constructor.
        * eapply IH; eauto. left.  reflexivity. 
        * eapply IHHeqo; intros; eauto.
          -- eapply IH; eauto. right.  assumption.
          -- cbn in H2. rewrite Nnat.Nat2N.id. reflexivity.
      + apply map_monad_oom_length in Heqo.
        lia.
    - (* Vectors *)
      destruct uv_fin; cbn in H4;
        repeat break_match_hyp_inv;
        try inv H4.
      constructor; auto.
      + rewrite map_monad_oom_Forall2 in Heqo.
        revert sz H1.
        induction Heqo; constructor.
        * eapply IH; eauto. left.  reflexivity. 
        * eapply IHHeqo; intros; eauto.
          -- eapply IH; eauto. right.  assumption.
          -- cbn in H2. rewrite Nnat.Nat2N.id. reflexivity.
      + apply map_monad_oom_length in Heqo.
        lia.
    - destruct uv_fin; cbn in H1;
        repeat break_match_hyp_inv;
        try inv H1.
      destruct H.
      + destruct H as (?&?&?).
        econstructor; eauto.
        left; split; eauto.
      + destruct H.
        * destruct H.
          econstructor; eauto.
          right; left; split; eauto.
        * destruct H.
          econstructor; eauto.
          right; right; split; eauto.
    - destruct uv_fin; cbn in H1;
        repeat break_match_hyp_inv;
        try inv H1.
      destruct H.
      + destruct H as (?&?&?).
        econstructor; eauto.
        left; split; eauto.
      + destruct H.
        * destruct H.
          econstructor; eauto.
          right; left; split; eauto.
        * destruct H.
          econstructor; eauto.
          right; right; split; eauto.
    - destruct uv_fin; cbn in H2;
        repeat break_match_hyp_inv;
        try inv H2.
      destruct H0.
      + econstructor; eauto.
        destruct H0.
        left; eauto.
      + econstructor; eauto.
    - destruct uv_fin; cbn in H2;
        repeat break_match_hyp_inv;
        try inv H2.
      destruct H0.
      + econstructor; eauto.
        destruct H0.
        left; eauto.
      + econstructor; eauto.
    - destruct uv_fin; cbn in H3;
        repeat break_match_hyp_inv;
        try inv H3.
      constructor; auto.
      + intros.
        rewrite map_monad_oom_Forall2 in Heqo.
        destruct (Forall2_In _ _ _ _ H2 Heqo) as [x [HIN HX]].
        destruct (H0 _ HIN) as [u [t [idx [sid HY]]]].
        subst.
        destruct byte; inv HX;
        repeat break_match_hyp_inv.
        do 4 eexists.
        reflexivity.
      + apply map_monad_oom_length in Heqo.
        rewrite Heqo.
        rewrite <- H1.
        reflexivity.
        Unshelve.
        all: eauto.
  Qed.

  (* TODO: move this to where filter_sid_matches is defined *)
  Lemma filter_sid_matches_length_r_le :
    forall {ixbytes sid bytes_left bytes_right},
      Memory64BitIntptr.MMEP.MemSpec.MemHelpers.filter_sid_matches sid ixbytes = (bytes_left, bytes_right) ->
      (length bytes_right <= length ixbytes)%nat.
  Proof.
    induction ixbytes; intros sid bytes_left bytes_right FILTER.
    - cbn in *. inv FILTER.
      cbn. lia.
    - cbn in *.
      break_match_hyp.
      apply filter_split_out_length in Heqp.
      destruct a.
      break_match_hyp; cbn in *; inv FILTER; cbn in *; try lia.
  Qed.

  (* TODO: move this to where re_sid_ubytes is defined *)
  Lemma re_sid_ubytes_helper_MemState_eqv :
    forall ixbytes ms ms' init_map byte_map,
      Memory64BitIntptr.MMEP.MemSpec.MemHelpers.re_sid_ubytes_helper (M:=MemPropT Memory64BitIntptr.MMEP.MMSP.MemState) ixbytes
        init_map ms (ret (ms', byte_map)) ->
      Memory64BitIntptr.MMEP.MemSpec.MemState_eqv ms ms'.
  Proof.
    induction ixbytes using length_strong_ind; intros ms ms' init_map byte_map RESID.
    - rewrite Memory64BitIntptr.MMEP.MemSpec.MemHelpers.re_sid_ubytes_helper_equation in RESID.
      cbn in RESID.
      destruct RESID; subst; reflexivity.
    - rewrite Memory64BitIntptr.MMEP.MemSpec.MemHelpers.re_sid_ubytes_helper_equation in RESID.
      destruct ixbytes; inv H0.
      destruct p.
      break_match_hyp.
      1-28,30: cbn in RESID; contradiction.
      destruct (Memory64BitIntptr.MMEP.MemSpec.MemHelpers.filter_sid_matches s ixbytes) eqn:FILTER.
      repeat red in RESID.
      destruct RESID as (?&?&FRESH&RESID).
      apply Memory64BitIntptr.MMEP.MemSpec.fresh_sid_MemState_eqv in FRESH.
      etransitivity; eauto.
      eapply H.
      2: apply RESID.
      eapply filter_sid_matches_length_r_le; eauto.
  Qed.

  (* TODO: move this to where re_sid_ubytes is defined *)
  Lemma re_sid_ubytes_MemState_eqv :
    forall ms ms' bytes bytes',
      Memory64BitIntptr.MMEP.MemSpec.MemHelpers.re_sid_ubytes (M:=MemPropT Memory64BitIntptr.MMEP.MMSP.MemState) bytes ms (ret (ms', bytes')) ->
      Memory64BitIntptr.MMEP.MemSpec.MemState_eqv ms ms'.
  Proof.
    intros ms ms' bytes bytes' RESID.
    unfold Memory64BitIntptr.MMEP.MemSpec.MemHelpers.re_sid_ubytes in RESID.
    repeat red in RESID.
    destruct RESID as (?&?&?&?).
    cbn in H0.
    red in H0.
    break_match_hyp_inv.
    eapply re_sid_ubytes_helper_MemState_eqv; eauto.
  Qed.

  (* TODO: Move this *)
  Lemma extract_byte_to_sbyte_fin_inf :
    forall {uv_fin uv_inf byte_fin},
      DVC1.uvalue_refine_strict uv_inf uv_fin ->
      Memory64BitIntptr.MMEP.MemSpec.MemHelpers.extract_byte_to_sbyte uv_fin = inr byte_fin ->
      exists byte_inf,
        MemoryBigIntptr.MMEP.MemSpec.MemHelpers.extract_byte_to_sbyte uv_inf = inr byte_inf /\
          sbyte_refine byte_inf byte_fin.
  Proof.
    intros uv_fin uv_inf byte_fin REF BYTE.
    unfold Memory64BitIntptr.MMEP.MemSpec.MemHelpers.extract_byte_to_sbyte in BYTE.
    break_match_hyp_inv.

    (* TODO: Probably make this into an inversion lemma *)
    rewrite DVC1.uvalue_refine_strict_equation in REF.

    destruct uv_inf;
      cbn in *;
      repeat break_match_hyp_inv; try inv REF.

    eexists.
    split; eauto.
    red.
    cbn.
    rewrite Heqo.
    reflexivity.
  Qed.

  Lemma re_sid_ubytes_helper_fin_inf :
    forall {ixbytes_fin ixbytes_inf ms_fin_start ms_fin_final ms_inf_start init_map_fin init_map_inf byte_map_fin},
      MemState_refine_prop ms_inf_start ms_fin_start ->
      Forall2 (fun '(ix1, b1) '(ix2, b2) => ix1 = ix2 /\ sbyte_refine b1 b2) ixbytes_inf ixbytes_fin ->
      Memory64BitIntptr.MMEP.MemSpec.MemHelpers.re_sid_ubytes_helper (M:=MemPropT Memory64BitIntptr.MMEP.MMSP.MemState) ixbytes_fin
        init_map_fin ms_fin_start (ret (ms_fin_final, byte_map_fin)) ->
      exists byte_map_inf ms_inf_final,
        MemoryBigIntptr.MMEP.MemSpec.MemHelpers.re_sid_ubytes_helper (M:=MemPropT MemoryBigIntptr.MMEP.MMSP.MemState) ixbytes_inf
          init_map_inf ms_inf_start (ret (ms_inf_final, byte_map_inf)) /\
          exists bytes_inf, NMaps.NM_find_many (Nseq 0 (Datatypes.length ixbytes_inf)) byte_map_inf = Some bytes_inf.
  Proof.
    (* TODO: Ugh... Need to do a really complicated and nasty induction for this.

           Need to induct over the filtered sid bytes...
     *)
    induction ixbytes_fin using length_strong_ind; intros ixbytes_inf ms_fin_start ms_fin_final ms_inf_start init_map_fin init_map_inf byte_map_fin MSR IXBYTES RESID.
    - cbn in RESID.
      destruct RESID; subst.
      inv IXBYTES.
      cbn.
      exists init_map_inf.
      exists ms_inf_start.
      split; auto.
      exists [].
      auto.
    - rename H into IH.
      rename H0 into LEN.
      destruct ixbytes_fin; inv LEN.

      inv IXBYTES.
      destruct p, x.
      destruct H2; subst.

      rename H0 into BYTE_REF.
      rename H3 into IXBYTES.
      rename l into ixbytes_inf.

      rewrite Memory64BitIntptr.MMEP.MemSpec.MemHelpers.re_sid_ubytes_helper_equation in RESID.
      break_match_hyp.
      1-28,30: contradiction.

      break_match_hyp.
      repeat red in RESID.
      destruct RESID as (ms_fin_fresh & sid' & FRESH & RESID).

      eapply fresh_sid_fin_inf in FRESH; eauto.
      destruct FRESH as (?&?&?&?&?).
      subst.
      rename x0 into ms_inf_fresh.

      remember (MemoryBigIntptr.MMEP.MemSpec.MemHelpers.filter_sid_matches s0 ixbytes_inf).
      destruct p.

      eapply IH.
      4: eauto.

      eapply filter_sid_matches_length_r_le; eauto.
      eapply MemoryBigIntptr.MMEP.MemSpec.fresh_sid_MemState_eqv in H.
      admit.
  Admitted.

  (* TODO: move this to where re_sid_ubytes is defined *)
  Lemma re_sid_ubytes_fin_inf :
    forall {bytes_fin bytes_fin' bytes_inf ms_fin_start ms_fin_final ms_inf_start},
      MemState_refine_prop ms_inf_start ms_fin_start ->
      sbytes_refine bytes_inf bytes_fin ->
      Memory64BitIntptr.MMEP.MemSpec.MemHelpers.re_sid_ubytes (M:=MemPropT Memory64BitIntptr.MMEP.MMSP.MemState) bytes_fin ms_fin_start (ret (ms_fin_final, bytes_fin')) ->
      exists bytes_inf' ms_inf_final,
        MemoryBigIntptr.MMEP.MemSpec.MemHelpers.re_sid_ubytes (M:=MemPropT MemoryBigIntptr.MMEP.MMSP.MemState) bytes_inf ms_inf_start (ret (ms_inf_final, bytes_inf')) /\
          sbytes_refine bytes_inf' bytes_fin' /\
          MemState_refine_prop ms_inf_final ms_fin_final.
  Proof.
    intros bytes_fin bytes_fin' bytes_inf ms_fin_start ms_fin_final ms_inf_start MSR BYTES_REF RESID.
    unfold Memory64BitIntptr.MMEP.MemSpec.MemHelpers.re_sid_ubytes in RESID.
    unfold MemoryBigIntptr.MMEP.MemSpec.MemHelpers.re_sid_ubytes.

    repeat red in RESID.
    destruct RESID as (?&?&?&?).
    cbn in H0.
    red in H0.
    break_match_hyp_inv.
    eapply @re_sid_ubytes_helper_fin_inf
      with (init_map_inf:=NMaps.NM.empty MemoryBigIntptr.MP.BYTE_IMPL.SByte)
           (ixbytes_inf:=zip (Nseq 0 (Datatypes.length bytes_inf)) bytes_inf)
      in H; eauto.
    2: {
      admit.
    }

    destruct H as (?&?&?&?&?).

    (* exists x3. exists x2. *)
    (* repeat red. *)
    (* exists x2. exists x1. *)
    (* split. *)
    (* - apply H. *)
    (* - red. *)
    (*   assert (Datatypes.length (zip (Nseq 0 (Datatypes.length bytes_inf)) bytes_inf) = Datatypes.length bytes_inf) as LEN. *)
    (*   { admit. (* TODO: probably not that hard, but bleh *) *)
    (*   } *)
    (*   rewrite LEN in H0. *)
    (*   rewrite H0. *)
    (*   cbn. *)
    (*   split; auto. *)
  Admitted.

  (* TODO: move this. Should hold for fin / inf *)
  (* SAZ: UNNEEDED? *)
  (* Lemma serialize_sbytes_MemState_eqv : *)
  (*   forall {uv t ms ms' bytes}, *)
  (*     uvalue_has_dtyp uv t -> *)
  (*     Memory64BitIntptr.MMEP.MemSpec.MemHelpers.serialize_sbytes (M:=MemPropT Memory64BitIntptr.MMEP.MMSP.MemState) uv t ms (success_unERR_UB_OOM (ms', bytes)) -> *)
  (*     Memory64BitIntptr.MMEP.MemSpec.MemState_eqv ms ms'. *)
  (* Proof. *)
  (*   intros uv t ms ms' bytes TYPE SERIALIZE. *)
  (*   revert ms ms' bytes SERIALIZE. *)
  (*   induction TYPE; intros ms ms' bytes' SERIALIZE. *)
  (*   (* SAZ: TODO - fix this proof to use the new induction principle. *) *)
  (*   (* *)
  (*   all: *)
  (*     try solve [ *)
  (*         rewrite Memory64BitIntptr.MMEP.MemSpec.MemHelpers.serialize_sbytes_equation in SERIALIZE; *)
  (*         solve *)
  (*           [ *)
  (*             apply MemPropT_bind_ret_inv in SERIALIZE; *)
  (*             destruct SERIALIZE as (?&?&?&?); *)
  (*             etransitivity; *)
  (*             [eapply fresh_sid_MemState_eqv; eauto|]; *)
  (*             match goal with *)
  (*             | H: lift_OOM ?x _ _ |- _ => *)
  (*                 red in H; destruct x eqn:?HX; inv H *)
  (*             end; reflexivity *)
  (*           | destruct t_orig; *)
  (*             try solve *)
  (*               [ *)
  (*                 apply MemPropT_bind_ret_inv in SERIALIZE; *)
  (*                 destruct SERIALIZE as (?&?&?&?); *)
  (*                 etransitivity; *)
  (*                 [eapply fresh_sid_MemState_eqv; eauto|]; *)
  (*                 match goal with *)
  (*                 | H: lift_OOM ?x _ _ |- _ => *)
  (*                     red in H; destruct x eqn:?HX; inv H *)
  (*                 end; reflexivity *)
  (*               ]; *)
  (*             try *)
  (*               solve *)
  (*               [ (* Arrays *) *)
  (*                 specialize (IHuv (DTYPE_Array sz0 t_orig) _ _ _ SERIALIZE); auto *)
  (*               | (* Vectors *) *)
  (*                 specialize (IHuv (DTYPE_Vector sz0 t_orig) _ _ _ SERIALIZE); auto *)
  (*               | (* Structs *) *)
  (*                 specialize (IHuv (DTYPE_Struct fields) _ _ _ SERIALIZE); auto *)
  (*               | (* Packed structs *) *)
  (*                 specialize (IHuv (DTYPE_Packed_struct fields) _ _ _ SERIALIZE); auto *)
  (*               ] *)
  (*           | cbn in SERIALIZE; *)
  (*             destruct SERIALIZE; subst; reflexivity *)
  (*           ] *)
  (*       ]. *)

  (*   { (* Poison arrays *) *)
  (*     generalize dependent ms. *)
  (*     generalize dependent ms'. *)
  (*     generalize dependent bytes'. *)
  (*     induction sz using N.peano_ind; intros bytes' ms' ms SERIALIZE. *)
  (*     - rewrite Memory64BitIntptr.MMEP.MemSpec.MemHelpers.serialize_sbytes_equation in SERIALIZE. *)
  (*       cbn in SERIALIZE. *)
  (*       destruct SERIALIZE as (?&?&?&?&?). *)
  (*       subst. *)
  (*       destruct H; subst. *)
  (*       reflexivity. *)
  (*     - rewrite Memory64BitIntptr.MMEP.MemSpec.MemHelpers.serialize_sbytes_equation in SERIALIZE. *)
  (*       rewrite repeatN_succ in SERIALIZE. *)
  (*       rewrite map_monad_In_unfold in SERIALIZE. *)
  (*       repeat red in SERIALIZE. *)
  (*       destruct SERIALIZE as (?&?&?&?). *)
  (*       repeat red in H. *)
  (*       destruct H as (?&?&?&?). *)
  (*       repeat red in H1. *)
  (*       destruct H1 as (?&?&?&?). *)
  (*       cbn in H2, H0. *)
  (*       destruct H2; subst. *)
  (*       destruct H0; subst. *)

  (*       specialize (IHsz (concat x4) x3 x1). *)
  (*       forward IHsz. *)
  (*       { rewrite Memory64BitIntptr.MMEP.MemSpec.MemHelpers.serialize_sbytes_equation. *)
  (*         repeat red. *)
  (*         exists x3. exists x4. *)
  (*         split; cbn; auto. *)
  (*       } *)

  (*       (* All I need now is to know that MemState_eqv ms x1 *) *)
  (*       specialize (IHTYPE ms x1 x2 H). *)
  (*       etransitivity; eauto. *)
  (*   } *)

  (*   { (* Poison vectors *) *)
  (*     generalize dependent ms. *)
  (*     generalize dependent ms'. *)
  (*     generalize dependent bytes'. *)
  (*     induction sz using N.peano_ind; intros bytes' ms' ms SERIALIZE. *)
  (*     - rewrite Memory64BitIntptr.MMEP.MemSpec.MemHelpers.serialize_sbytes_equation in SERIALIZE. *)
  (*       cbn in SERIALIZE. *)
  (*       destruct SERIALIZE as (?&?&?&?&?). *)
  (*       subst. *)
  (*       destruct H; subst. *)
  (*       reflexivity. *)
  (*     - rewrite Memory64BitIntptr.MMEP.MemSpec.MemHelpers.serialize_sbytes_equation in SERIALIZE. *)
  (*       rewrite repeatN_succ in SERIALIZE. *)
  (*       rewrite map_monad_In_unfold in SERIALIZE. *)
  (*       repeat red in SERIALIZE. *)
  (*       destruct SERIALIZE as (?&?&?&?). *)
  (*       repeat red in H. *)
  (*       destruct H as (?&?&?&?). *)
  (*       repeat red in H1. *)
  (*       destruct H1 as (?&?&?&?). *)
  (*       cbn in H2, H0. *)
  (*       destruct H2; subst. *)
  (*       destruct H0; subst. *)

  (*       specialize (IHsz (concat x4) x3 x1). *)
  (*       forward IHsz. *)
  (*       { rewrite Memory64BitIntptr.MMEP.MemSpec.MemHelpers.serialize_sbytes_equation. *)
  (*         repeat red. *)
  (*         exists x3. exists x4. *)
  (*         split; cbn; auto. *)
  (*       } *)

  (*       (* All I need now is to know that MemState_eqv ms x1 *) *)
  (*       specialize (IHTYPE ms x1 x2 H). *)
  (*       etransitivity; eauto. *)
  (*   } *)

  (*   { (* Poison cons structs *) *)
  (*     rewrite Memory64BitIntptr.MMEP.MemSpec.MemHelpers.serialize_sbytes_equation in SERIALIZE. *)
  (*     repeat red in SERIALIZE. *)
  (*     destruct SERIALIZE as (?&?&?&?). *)

  (*     specialize (IHTYPE ms x x0 H). *)

  (*     repeat red in H0. *)
  (*     destruct H0 as (?&?&?&?). *)
  (*     cbn in H1. *)
  (*     destruct H1; subst. *)
  (*     apply IHTYPE0 in H0. *)
  (*     etransitivity; eauto. *)
  (*   } *)

  (*   { (* Poison cons packed structs *) *)
  (*     rewrite Memory64BitIntptr.MMEP.MemSpec.MemHelpers.serialize_sbytes_equation in SERIALIZE. *)
  (*     repeat red in SERIALIZE. *)
  (*     destruct SERIALIZE as (?&?&?&?). *)

  (*     specialize (IHTYPE ms x x0 H). *)

  (*     repeat red in H0. *)
  (*     destruct H0 as (?&?&?&?). *)
  (*     cbn in H1. *)
  (*     destruct H1; subst. *)
  (*     apply IHTYPE0 in H0. *)
  (*     etransitivity; eauto. *)
  (*   } *)

  (*   { (* Poison non-aggregate type *) *)
  (*     destruct H as (?&?&?&?&?&?). *)
  (*     destruct t; try contradiction; *)
  (*       try solve *)
  (*         [ rewrite Memory64BitIntptr.MMEP.MemSpec.MemHelpers.serialize_sbytes_equation in SERIALIZE; *)
  (*           destruct SERIALIZE as (?&?&FRESH&SERIALIZE); *)
  (*           apply fresh_sid_MemState_eqv in FRESH as EQV1; *)
  (*           match goal with *)
  (*           | H: lift_OOM _ _ _ |- _ => *)
  (*               red in H; break_match_hyp_inv *)
  (*           end; auto *)
  (*         ]. *)

  (*     all: exfalso. *)
  (*     - eapply H3; eauto. *)
  (*     - eapply H1; eauto. *)
  (*     - eapply H2; eauto. *)
  (*     - eapply H4; eauto. *)
  (*   } *)

  (*   { (* Undef arrays *) *)
  (*     generalize dependent ms. *)
  (*     generalize dependent ms'. *)
  (*     generalize dependent bytes'. *)
  (*     induction sz using N.peano_ind; intros bytes' ms' ms SERIALIZE. *)
  (*     - rewrite Memory64BitIntptr.MMEP.MemSpec.MemHelpers.serialize_sbytes_equation in SERIALIZE. *)
  (*       cbn in SERIALIZE. *)
  (*       destruct SERIALIZE as (?&?&?&?&?). *)
  (*       subst. *)
  (*       destruct H; subst. *)
  (*       reflexivity. *)
  (*     - rewrite Memory64BitIntptr.MMEP.MemSpec.MemHelpers.serialize_sbytes_equation in SERIALIZE. *)
  (*       rewrite repeatN_succ in SERIALIZE. *)
  (*       rewrite map_monad_In_unfold in SERIALIZE. *)
  (*       repeat red in SERIALIZE. *)
  (*       destruct SERIALIZE as (?&?&?&?). *)
  (*       repeat red in H. *)
  (*       destruct H as (?&?&?&?). *)
  (*       repeat red in H1. *)
  (*       destruct H1 as (?&?&?&?). *)
  (*       cbn in H2, H0. *)
  (*       destruct H2; subst. *)
  (*       destruct H0; subst. *)

  (*       specialize (IHsz (concat x4) x3 x1). *)
  (*       forward IHsz. *)
  (*       { rewrite Memory64BitIntptr.MMEP.MemSpec.MemHelpers.serialize_sbytes_equation. *)
  (*         repeat red. *)
  (*         exists x3. exists x4. *)
  (*         split; cbn; auto. *)
  (*       } *)

  (*       (* All I need now is to know that MemState_eqv ms x1 *) *)
  (*       specialize (IHTYPE ms x1 x2 H). *)
  (*       etransitivity; eauto. *)
  (*   } *)

  (*   { (* Undef vectors *) *)
  (*     generalize dependent ms. *)
  (*     generalize dependent ms'. *)
  (*     generalize dependent bytes'. *)
  (*     induction sz using N.peano_ind; intros bytes' ms' ms SERIALIZE. *)
  (*     - rewrite Memory64BitIntptr.MMEP.MemSpec.MemHelpers.serialize_sbytes_equation in SERIALIZE. *)
  (*       cbn in SERIALIZE. *)
  (*       destruct SERIALIZE as (?&?&?&?&?). *)
  (*       subst. *)
  (*       destruct H; subst. *)
  (*       reflexivity. *)
  (*     - rewrite Memory64BitIntptr.MMEP.MemSpec.MemHelpers.serialize_sbytes_equation in SERIALIZE. *)
  (*       rewrite repeatN_succ in SERIALIZE. *)
  (*       rewrite map_monad_In_unfold in SERIALIZE. *)
  (*       repeat red in SERIALIZE. *)
  (*       destruct SERIALIZE as (?&?&?&?). *)
  (*       repeat red in H. *)
  (*       destruct H as (?&?&?&?). *)
  (*       repeat red in H1. *)
  (*       destruct H1 as (?&?&?&?). *)
  (*       cbn in H2, H0. *)
  (*       destruct H2; subst. *)
  (*       destruct H0; subst. *)

  (*       specialize (IHsz (concat x4) x3 x1). *)
  (*       forward IHsz. *)
  (*       { rewrite Memory64BitIntptr.MMEP.MemSpec.MemHelpers.serialize_sbytes_equation. *)
  (*         repeat red. *)
  (*         exists x3. exists x4. *)
  (*         split; cbn; auto. *)
  (*       } *)

  (*       (* All I need now is to know that MemState_eqv ms x1 *) *)
  (*       specialize (IHTYPE ms x1 x2 H). *)
  (*       etransitivity; eauto. *)
  (*   } *)

  (*   { (* Undef cons structs *) *)
  (*     rewrite Memory64BitIntptr.MMEP.MemSpec.MemHelpers.serialize_sbytes_equation in SERIALIZE. *)
  (*     repeat red in SERIALIZE. *)
  (*     destruct SERIALIZE as (?&?&?&?). *)

  (*     specialize (IHTYPE ms x x0 H). *)

  (*     repeat red in H0. *)
  (*     destruct H0 as (?&?&?&?). *)
  (*     cbn in H1. *)
  (*     destruct H1; subst. *)
  (*     apply IHTYPE0 in H0. *)
  (*     etransitivity; eauto. *)
  (*   } *)

  (*   { (* Undef cons packed structs *) *)
  (*     rewrite Memory64BitIntptr.MMEP.MemSpec.MemHelpers.serialize_sbytes_equation in SERIALIZE. *)
  (*     repeat red in SERIALIZE. *)
  (*     destruct SERIALIZE as (?&?&?&?). *)

  (*     specialize (IHTYPE ms x x0 H). *)

  (*     repeat red in H0. *)
  (*     destruct H0 as (?&?&?&?). *)
  (*     cbn in H1. *)
  (*     destruct H1; subst. *)
  (*     apply IHTYPE0 in H0. *)
  (*     etransitivity; eauto. *)
  (*   } *)

  (*   { (* Undef non-aggregate type *) *)
  (*     destruct H as (?&?&?&?&?&?). *)
  (*     destruct t; try contradiction; *)
  (*       try solve *)
  (*         [ rewrite Memory64BitIntptr.MMEP.MemSpec.MemHelpers.serialize_sbytes_equation in SERIALIZE; *)
  (*           destruct SERIALIZE as (?&?&FRESH&SERIALIZE); *)
  (*           apply fresh_sid_MemState_eqv in FRESH as EQV1; *)
  (*           match goal with *)
  (*           | H: lift_OOM _ _ _ |- _ => *)
  (*               red in H; break_match_hyp_inv *)
  (*           end; auto *)
  (*         ]. *)

  (*     all: exfalso. *)
  (*     - eapply H3; eauto. *)
  (*     - eapply H1; eauto. *)
  (*     - eapply H2; eauto. *)
  (*     - eapply H4; eauto. *)
  (*   } *)

  (*   { (* Oom arrays *) *)
  (*     generalize dependent ms. *)
  (*     generalize dependent ms'. *)
  (*     generalize dependent bytes'. *)
  (*     induction sz using N.peano_ind; intros bytes' ms' ms SERIALIZE. *)
  (*     - rewrite Memory64BitIntptr.MMEP.MemSpec.MemHelpers.serialize_sbytes_equation in SERIALIZE. *)
  (*       cbn in SERIALIZE. *)
  (*       destruct SERIALIZE as (?&?&?&?&?). *)
  (*       subst. *)
  (*       destruct H; subst. *)
  (*       reflexivity. *)
  (*     - rewrite Memory64BitIntptr.MMEP.MemSpec.MemHelpers.serialize_sbytes_equation in SERIALIZE. *)
  (*       rewrite repeatN_succ in SERIALIZE. *)
  (*       rewrite map_monad_In_unfold in SERIALIZE. *)
  (*       repeat red in SERIALIZE. *)
  (*       destruct SERIALIZE as (?&?&?&?). *)
  (*       repeat red in H. *)
  (*       destruct H as (?&?&?&?). *)
  (*       repeat red in H1. *)
  (*       destruct H1 as (?&?&?&?). *)
  (*       cbn in H2, H0. *)
  (*       destruct H2; subst. *)
  (*       destruct H0; subst. *)

  (*       specialize (IHsz (concat x4) x3 x1). *)
  (*       forward IHsz. *)
  (*       { rewrite Memory64BitIntptr.MMEP.MemSpec.MemHelpers.serialize_sbytes_equation. *)
  (*         repeat red. *)
  (*         exists x3. exists x4. *)
  (*         split; cbn; auto. *)
  (*       } *)

  (*       (* All I need now is to know that MemState_eqv ms x1 *) *)
  (*       specialize (IHTYPE ms x1 x2 H). *)
  (*       etransitivity; eauto. *)
  (*   } *)

  (*   { (* Oom vectors *) *)
  (*     generalize dependent ms. *)
  (*     generalize dependent ms'. *)
  (*     generalize dependent bytes'. *)
  (*     induction sz using N.peano_ind; intros bytes' ms' ms SERIALIZE. *)
  (*     - rewrite Memory64BitIntptr.MMEP.MemSpec.MemHelpers.serialize_sbytes_equation in SERIALIZE. *)
  (*       cbn in SERIALIZE. *)
  (*       destruct SERIALIZE as (?&?&?&?&?). *)
  (*       subst. *)
  (*       destruct H; subst. *)
  (*       reflexivity. *)
  (*     - rewrite Memory64BitIntptr.MMEP.MemSpec.MemHelpers.serialize_sbytes_equation in SERIALIZE. *)
  (*       rewrite repeatN_succ in SERIALIZE. *)
  (*       rewrite map_monad_In_unfold in SERIALIZE. *)
  (*       repeat red in SERIALIZE. *)
  (*       destruct SERIALIZE as (?&?&?&?). *)
  (*       repeat red in H. *)
  (*       destruct H as (?&?&?&?). *)
  (*       repeat red in H1. *)
  (*       destruct H1 as (?&?&?&?). *)
  (*       cbn in H2, H0. *)
  (*       destruct H2; subst. *)
  (*       destruct H0; subst. *)

  (*       specialize (IHsz (concat x4) x3 x1). *)
  (*       forward IHsz. *)
  (*       { rewrite Memory64BitIntptr.MMEP.MemSpec.MemHelpers.serialize_sbytes_equation. *)
  (*         repeat red. *)
  (*         exists x3. exists x4. *)
  (*         split; cbn; auto. *)
  (*       } *)

  (*       (* All I need now is to know that MemState_eqv ms x1 *) *)
  (*       specialize (IHTYPE ms x1 x2 H). *)
  (*       etransitivity; eauto. *)
  (*   } *)

  (*   { (* Oom cons structs *) *)
  (*     rewrite Memory64BitIntptr.MMEP.MemSpec.MemHelpers.serialize_sbytes_equation in SERIALIZE. *)
  (*     repeat red in SERIALIZE. *)
  (*     destruct SERIALIZE as (?&?&?&?). *)

  (*     specialize (IHTYPE ms x x0 H). *)

  (*     repeat red in H0. *)
  (*     destruct H0 as (?&?&?&?). *)
  (*     cbn in H1. *)
  (*     destruct H1; subst. *)
  (*     apply IHTYPE0 in H0. *)
  (*     etransitivity; eauto. *)
  (*   } *)

  (*   { (* Oom cons packed structs *) *)
  (*     rewrite Memory64BitIntptr.MMEP.MemSpec.MemHelpers.serialize_sbytes_equation in SERIALIZE. *)
  (*     repeat red in SERIALIZE. *)
  (*     destruct SERIALIZE as (?&?&?&?). *)

  (*     specialize (IHTYPE ms x x0 H). *)

  (*     repeat red in H0. *)
  (*     destruct H0 as (?&?&?&?). *)
  (*     cbn in H1. *)
  (*     destruct H1; subst. *)
  (*     apply IHTYPE0 in H0. *)
  (*     etransitivity; eauto. *)
  (*   } *)

  (*   { (* Oom non-aggregate type *) *)
  (*     destruct H as (?&?&?&?&?&?). *)
  (*     destruct t; try contradiction; *)
  (*       try solve *)
  (*         [ rewrite Memory64BitIntptr.MMEP.MemSpec.MemHelpers.serialize_sbytes_equation in SERIALIZE; *)
  (*           destruct SERIALIZE as (?&?&FRESH&SERIALIZE); *)
  (*           apply fresh_sid_MemState_eqv in FRESH as EQV1; *)
  (*           match goal with *)
  (*           | H: lift_OOM _ _ _ |- _ => *)
  (*               red in H; break_match_hyp_inv *)
  (*           end; auto *)
  (*         ]. *)

  (*     all: exfalso. *)
  (*     - eapply H3; eauto. *)
  (*     - eapply H1; eauto. *)
  (*     - eapply H2; eauto. *)
  (*     - eapply H4; eauto. *)
  (*   } *)

  (*   { (* Struct cons *) *)
  (*     rewrite Memory64BitIntptr.MMEP.MemSpec.MemHelpers.serialize_sbytes_equation in SERIALIZE. *)
  (*     repeat red in SERIALIZE. *)
  (*     destruct SERIALIZE as (?&?&?&?). *)

  (*     specialize (IHTYPE1 ms x x0 H). *)

  (*     repeat red in H0. *)
  (*     destruct H0 as (?&?&?&?). *)
  (*     cbn in H1. *)
  (*     destruct H1; subst. *)
  (*     apply IHTYPE2 in H0. *)
  (*     etransitivity; eauto. *)
  (*   } *)

  (*   { (* Packed struct cons *) *)
  (*     rewrite Memory64BitIntptr.MMEP.MemSpec.MemHelpers.serialize_sbytes_equation in SERIALIZE. *)
  (*     repeat red in SERIALIZE. *)
  (*     destruct SERIALIZE as (?&?&?&?). *)

  (*     specialize (IHTYPE1 ms x x0 H). *)

  (*     repeat red in H0. *)
  (*     destruct H0 as (?&?&?&?). *)
  (*     cbn in H1. *)
  (*     destruct H1; subst. *)
  (*     apply IHTYPE2 in H0. *)
  (*     etransitivity; eauto. *)
  (*   } *)

  (*   { (* Arrays *) *)
  (*     rewrite Memory64BitIntptr.MMEP.MemSpec.MemHelpers.serialize_sbytes_equation in SERIALIZE. *)
  (*     repeat red in SERIALIZE. *)
  (*     destruct SERIALIZE as (?&?&?&?). *)
  (*     cbn in H1. *)
  (*     destruct H1; subst. *)
  (*     cbn in *. *)

  (*     generalize dependent ms. *)
  (*     generalize dependent x. *)
  (*     generalize dependent x0. *)
  (*     induction xs; intros x0 x ms H0. *)
  (*     - cbn in *. *)
  (*       destruct H0; subst; reflexivity. *)
  (*     - rewrite map_monad_In_cons in H0. *)
  (*       repeat red in H0. *)
  (*       destruct H0 as (?&?&?&?). *)
  (*       destruct H0 as (?&?&?&?). *)
  (*       cbn in H1. *)
  (*       destruct H1; subst. *)

  (*       pose proof (IH a (or_introl eq_refl) ms x1 x2 H) as MSX1. *)
  (*       forward IHxs. *)
  (*       { *)
  (*         intros x H1 ms0 ms' bytes SERIALIZE. *)
  (*         apply IH in SERIALIZE; eauto. *)
  (*         right; auto. *)
  (*       } *)
  (*       forward IHxs. *)
  (*       { intros x H1. *)
  (*         apply IHdtyp. *)
  (*         right; auto. *)
  (*       } *)

  (*       etransitivity. *)
  (*       eauto. *)
  (*       eapply IHxs; eauto. *)
  (*       apply H0. *)
  (*   } *)

  (*   { (* Vectors *) *)
  (*     rewrite Memory64BitIntptr.MMEP.MemSpec.MemHelpers.serialize_sbytes_equation in SERIALIZE. *)
  (*     repeat red in SERIALIZE. *)
  (*     destruct SERIALIZE as (?&?&?&?). *)
  (*     cbn in H2. *)
  (*     destruct H2; subst. *)
  (*     cbn in *. *)

  (*     generalize dependent ms. *)
  (*     generalize dependent x. *)
  (*     generalize dependent x0. *)
  (*     induction xs; intros x0 x ms H1. *)
  (*     - cbn in *. *)
  (*       destruct H1; subst; reflexivity. *)
  (*     - rewrite map_monad_In_cons in H1. *)
  (*       repeat red in H1. *)
  (*       destruct H1 as (?&?&?&?). *)
  (*       destruct H1 as (?&?&?&?). *)
  (*       cbn in H1. *)
  (*       destruct H2; subst. *)

  (*       pose proof (IH a (or_introl eq_refl) ms x1 x2 H) as MSX1. *)
  (*       forward IHxs. *)
  (*       { *)
  (*         intros x H2 ms0 ms' bytes SERIALIZE. *)
  (*         apply IH in SERIALIZE; eauto. *)
  (*         right; auto. *)
  (*       } *)
  (*       forward IHxs. *)
  (*       { intros x H2. *)
  (*         apply IHdtyp. *)
  (*         right; auto. *)
  (*       } *)

  (*       etransitivity. *)
  (*       eauto. *)
  (*       eapply IHxs; eauto. *)
  (*   } *)

  (*   { (* Concat_bytes *) *)
  (*     rewrite Memory64BitIntptr.MMEP.MemSpec.MemHelpers.serialize_sbytes_equation in SERIALIZE. *)
  (*     repeat red in SERIALIZE. *)
  (*     destruct SERIALIZE as (?&?&?&?). *)
  (*     red in H1. *)
  (*     break_match_hyp; try (destruct e; cbn in H1; contradiction). *)
  (*     cbn in H1. *)
  (*     destruct H1; subst. *)
  (*     eapply re_sid_ubytes_MemState_eqv; eauto. *)
  (*   } *)
  (*    *) *)
  (* Admitted.     *)

  (*
    (* SAZ: Can't prove this easily, unfortunately, because we'd need "generic" inversion principles
       for CTR1 and CTR2 *)
  Lemma serialize_by_dtyp_fin_fin :
    forall (CTR1 : dtyp -> DVC1.DV1.uvalue)
      (CTR2 : dtyp -> DVC1.DV2.uvalue)
      Ï„
      (ms_fin_final : Memory64BitIntptr.MMEP.MMSP.MemState) (ms_fin_start : FinMem.MMEP.MMSP.MemState)
      (ms_inf_start : InfMem.MMEP.MMSP.MemState),
      MemState_refine_prop ms_inf_start ms_fin_start ->
      forall bytes_fin : list Memory64BitIntptr.MP.BYTE_IMPL.SByte,
        DVC1.DV2.uvalue_has_dtyp (CTR2 Ï„) Ï„ ->
        Memory64BitIntptr.MMEP.MemSpec.MemHelpers.serialize_by_dtyp
          (M:=MemPropT Memory64BitIntptr.MMEP.MMSP.MemState)
          CTR2 Ï„ ms_fin_start
          (success_unERR_UB_OOM (ms_fin_final, bytes_fin)) ->
        DVC1.uvalue_refine_strict (CTR1 Ï„) (CTR2 Ï„) ->
        exists
          (bytes_inf : list MemoryBigIntptr.MP.BYTE_IMPL.SByte) (ms_inf_final : MemoryBigIntptr.MMEP.MMSP.MemState),
          MemoryBigIntptr.MMEP.MemSpec.MemHelpers.serialize_by_dtyp
            (M:=MemPropT MemoryBigIntptr.MMEP.MMSP.MemState) CTR1
            Ï„ ms_inf_start (success_unERR_UB_OOM (ms_inf_final, bytes_inf)) /\
            sbytes_refine bytes_inf bytes_fin /\ MemState_refine_prop ms_inf_final ms_fin_final.
  Proof.
    intros CTR1 CTR2 dt.
    induction dt; intros ms_fin_final ms_fin_start ms_inf_start MSR bytes_fin TYP_INF SERIALIZE HRS;
      try solve [
          rewrite Memory64BitIntptr.MMEP.MemSpec.MemHelpers.serialize_sbytes_equation in SERIALIZE;
          solve
            [
              apply MemPropT_bind_ret_inv in SERIALIZE;
              destruct SERIALIZE as (?&?&?&?);
              etransitivity;
              [eapply Memory64BitIntptr.MMEP.MemSpec.fresh_sid_MemState_eqv; eauto|];
              match goal with
              | H: lift_OOM ?x _ _ |- _ =>
                  red in H; destruct x eqn:?HX; inv H
              end; reflexivity
            | destruct t_orig;
              try solve
                [
                  apply MemPropT_bind_ret_inv in SERIALIZE;
                  destruct SERIALIZE as (?&?&?&?);
                  etransitivity;
                  [eapply Memory64BitIntptr.MMEP.MemSpec.fresh_sid_MemState_eqv; eauto|];
                  match goal with
                  | H: lift_OOM ?x _ _ |- _ =>
                      red in H; destruct x eqn:?HX; inv H
                  end; reflexivity
                ];
              try
                solve
                [ (* Arrays *)
                  specialize (IHuv (DTYPE_Array sz0 t_orig) _ _ _ SERIALIZE); auto
                | (* Vectors *)
                  specialize (IHuv (DTYPE_Vector sz0 t_orig) _ _ _ SERIALIZE); auto
                | (* Structs *)
                  specialize (IHuv (DTYPE_Struct fields) _ _ _ SERIALIZE); auto
                | (* Packed structs *)
                  specialize (IHuv (DTYPE_Packed_struct fields) _ _ _ SERIALIZE); auto
                ]
            | cbn in SERIALIZE;
              destruct SERIALIZE; subst; reflexivity
            ]
        ].

    - (* Array *) 
      eapply MemPropT_fin_inf_bind.
      + apply MSR.
      + intros.
        eapply MemPropT_bind_ret_inv
      
      cbn in SERIALIZE.
      destruct SERIALIZE as (MS & SID & HM & REF).
      red in REF.
      break_match_hyp_inv.

        specialize (IHsz (concat x4) x3 x1).
        forward IHsz.
        { rewrite Memory64BitIntptr.MMEP.MemSpec.MemHelpers.serialize_sbytes_equation.
          repeat red.
          exists x3. exists x4.
          split; cbn; auto.
        }

        (* All I need now is to know that MemState_eqv ms x1 *)
        specialize (IHTYPE ms x1 x2 H).
        etransitivity; eauto.
    }

    { (* Poison vectors *)
      generalize dependent ms.
      generalize dependent ms'.
      generalize dependent bytes'.
      induction sz using N.peano_ind; intros bytes' ms' ms SERIALIZE.
      - rewrite Memory64BitIntptr.MMEP.MemSpec.MemHelpers.serialize_sbytes_equation in SERIALIZE.
        cbn in SERIALIZE.
        destruct SERIALIZE as (?&?&?&?&?).
        subst.
        destruct H; subst.
        reflexivity.
      - rewrite Memory64BitIntptr.MMEP.MemSpec.MemHelpers.serialize_sbytes_equation in SERIALIZE.
        rewrite repeatN_succ in SERIALIZE.
        rewrite map_monad_In_unfold in SERIALIZE.
        repeat red in SERIALIZE.
        destruct SERIALIZE as (?&?&?&?).
        repeat red in H.
        destruct H as (?&?&?&?).
        repeat red in H1.
        destruct H1 as (?&?&?&?).
        cbn in H2, H0.
        destruct H2; subst.
        destruct H0; subst.

        specialize (IHsz (concat x4) x3 x1).
        forward IHsz.
        { rewrite Memory64BitIntptr.MMEP.MemSpec.MemHelpers.serialize_sbytes_equation.
          repeat red.
          exists x3. exists x4.
          split; cbn; auto.
        }

        (* All I need now is to know that MemState_eqv ms x1 *)
        specialize (IHTYPE ms x1 x2 H).
        etransitivity; eauto.
    }

    { (* Poison cons structs *)
      rewrite Memory64BitIntptr.MMEP.MemSpec.MemHelpers.serialize_sbytes_equation in SERIALIZE.
      repeat red in SERIALIZE.
      destruct SERIALIZE as (?&?&?&?).

      specialize (IHTYPE ms x x0 H).

      repeat red in H0.
      destruct H0 as (?&?&?&?).
      cbn in H1.
      destruct H1; subst.
      apply IHTYPE0 in H0.
      etransitivity; eauto.
    }

    { (* Poison cons packed structs *)
      rewrite Memory64BitIntptr.MMEP.MemSpec.MemHelpers.serialize_sbytes_equation in SERIALIZE.
      repeat red in SERIALIZE.
      destruct SERIALIZE as (?&?&?&?).

      specialize (IHTYPE ms x x0 H).

      repeat red in H0.
      destruct H0 as (?&?&?&?).
      cbn in H1.
      destruct H1; subst.
      apply IHTYPE0 in H0.
      etransitivity; eauto.
    }

    { (* Poison non-aggregate type *)
      destruct H as (?&?&?&?&?&?).
      destruct t; try contradiction;
        try solve
          [ rewrite Memory64BitIntptr.MMEP.MemSpec.MemHelpers.serialize_sbytes_equation in SERIALIZE;
            destruct SERIALIZE as (?&?&FRESH&SERIALIZE);
            apply Memory64BitIntptr.MMEP.MemSpec.fresh_sid_MemState_eqv in FRESH as EQV1;
            match goal with
            | H: lift_OOM _ _ _ |- _ =>
                red in H; break_match_hyp_inv
            end; auto
          ].

      all: exfalso.
      - eapply H3; eauto.
      - eapply H1; eauto.
      - eapply H2; eauto.
      - eapply H4; eauto.
    }

    { (* Undef arrays *)
      generalize dependent ms.
      generalize dependent ms'.
      generalize dependent bytes'.
      induction sz using N.peano_ind; intros bytes' ms' ms SERIALIZE.
      - rewrite Memory64BitIntptr.MMEP.MemSpec.MemHelpers.serialize_sbytes_equation in SERIALIZE.
        cbn in SERIALIZE.
        destruct SERIALIZE as (?&?&?&?&?).
        subst.
        destruct H; subst.
        reflexivity.
      - rewrite Memory64BitIntptr.MMEP.MemSpec.MemHelpers.serialize_sbytes_equation in SERIALIZE.
        rewrite repeatN_succ in SERIALIZE.
        rewrite map_monad_In_unfold in SERIALIZE.
        repeat red in SERIALIZE.
        destruct SERIALIZE as (?&?&?&?).
        repeat red in H.
        destruct H as (?&?&?&?).
        repeat red in H1.
        destruct H1 as (?&?&?&?).
        cbn in H2, H0.
        destruct H2; subst.
        destruct H0; subst.

        specialize (IHsz (concat x4) x3 x1).
        forward IHsz.
        { rewrite Memory64BitIntptr.MMEP.MemSpec.MemHelpers.serialize_sbytes_equation.
          repeat red.
          exists x3. exists x4.
          split; cbn; auto.
        }

        (* All I need now is to know that MemState_eqv ms x1 *)
        specialize (IHTYPE ms x1 x2 H).
        etransitivity; eauto.
    }

    { (* Undef vectors *)
      generalize dependent ms.
      generalize dependent ms'.
      generalize dependent bytes'.
      induction sz using N.peano_ind; intros bytes' ms' ms SERIALIZE.
      - rewrite Memory64BitIntptr.MMEP.MemSpec.MemHelpers.serialize_sbytes_equation in SERIALIZE.
        cbn in SERIALIZE.
        destruct SERIALIZE as (?&?&?&?&?).
        subst.
        destruct H; subst.
        reflexivity.
      - rewrite Memory64BitIntptr.MMEP.MemSpec.MemHelpers.serialize_sbytes_equation in SERIALIZE.
        rewrite repeatN_succ in SERIALIZE.
        rewrite map_monad_In_unfold in SERIALIZE.
        repeat red in SERIALIZE.
        destruct SERIALIZE as (?&?&?&?).
        repeat red in H.
        destruct H as (?&?&?&?).
        repeat red in H1.
        destruct H1 as (?&?&?&?).
        cbn in H2, H0.
        destruct H2; subst.
        destruct H0; subst.

        specialize (IHsz (concat x4) x3 x1).
        forward IHsz.
        { rewrite Memory64BitIntptr.MMEP.MemSpec.MemHelpers.serialize_sbytes_equation.
          repeat red.
          exists x3. exists x4.
          split; cbn; auto.
        }

        (* All I need now is to know that MemState_eqv ms x1 *)
        specialize (IHTYPE ms x1 x2 H).
        etransitivity; eauto.
    }

    { (* Undef cons structs *)
      rewrite Memory64BitIntptr.MMEP.MemSpec.MemHelpers.serialize_sbytes_equation in SERIALIZE.
      repeat red in SERIALIZE.
      destruct SERIALIZE as (?&?&?&?).

      specialize (IHTYPE ms x x0 H).

      repeat red in H0.
      destruct H0 as (?&?&?&?).
      cbn in H1.
      destruct H1; subst.
      apply IHTYPE0 in H0.
      etransitivity; eauto.
    }

    { (* Undef cons packed structs *)
      rewrite Memory64BitIntptr.MMEP.MemSpec.MemHelpers.serialize_sbytes_equation in SERIALIZE.
      repeat red in SERIALIZE.
      destruct SERIALIZE as (?&?&?&?).

      specialize (IHTYPE ms x x0 H).

      repeat red in H0.
      destruct H0 as (?&?&?&?).
      cbn in H1.
      destruct H1; subst.
      apply IHTYPE0 in H0.
      etransitivity; eauto.
    }

    { (* Undef non-aggregate type *)
      destruct H as (?&?&?&?&?&?).
      destruct t; try contradiction;
        try solve
          [ rewrite Memory64BitIntptr.MMEP.MemSpec.MemHelpers.serialize_sbytes_equation in SERIALIZE;
            destruct SERIALIZE as (?&?&FRESH&SERIALIZE);
            apply Memory64BitIntptr.MMEP.MemSpec.fresh_sid_MemState_eqv in FRESH as EQV1;
            match goal with
            | H: lift_OOM _ _ _ |- _ =>
                red in H; break_match_hyp_inv
            end; auto
          ].

      all: exfalso.
      - eapply H3; eauto.
      - eapply H1; eauto.
      - eapply H2; eauto.
      - eapply H4; eauto.
    }

    { (* Oom arrays *)
      generalize dependent ms.
      generalize dependent ms'.
      generalize dependent bytes'.
      induction sz using N.peano_ind; intros bytes' ms' ms SERIALIZE.
      - rewrite Memory64BitIntptr.MMEP.MemSpec.MemHelpers.serialize_sbytes_equation in SERIALIZE.
        cbn in SERIALIZE.
        destruct SERIALIZE as (?&?&?&?&?).
        subst.
        destruct H; subst.
        reflexivity.
      - rewrite Memory64BitIntptr.MMEP.MemSpec.MemHelpers.serialize_sbytes_equation in SERIALIZE.
        rewrite repeatN_succ in SERIALIZE.
        rewrite map_monad_In_unfold in SERIALIZE.
        repeat red in SERIALIZE.
        destruct SERIALIZE as (?&?&?&?).
        repeat red in H.
        destruct H as (?&?&?&?).
        repeat red in H1.
        destruct H1 as (?&?&?&?).
        cbn in H2, H0.
        destruct H2; subst.
        destruct H0; subst.

        specialize (IHsz (concat x4) x3 x1).
        forward IHsz.
        { rewrite Memory64BitIntptr.MMEP.MemSpec.MemHelpers.serialize_sbytes_equation.
          repeat red.
          exists x3. exists x4.
          split; cbn; auto.
        }

        (* All I need now is to know that MemState_eqv ms x1 *)
        specialize (IHTYPE ms x1 x2 H).
        etransitivity; eauto.
    }

    { (* Oom vectors *)
      generalize dependent ms.
      generalize dependent ms'.
      generalize dependent bytes'.
      induction sz using N.peano_ind; intros bytes' ms' ms SERIALIZE.
      - rewrite Memory64BitIntptr.MMEP.MemSpec.MemHelpers.serialize_sbytes_equation in SERIALIZE.
        cbn in SERIALIZE.
        destruct SERIALIZE as (?&?&?&?&?).
        subst.
        destruct H; subst.
        reflexivity.
      - rewrite Memory64BitIntptr.MMEP.MemSpec.MemHelpers.serialize_sbytes_equation in SERIALIZE.
        rewrite repeatN_succ in SERIALIZE.
        rewrite map_monad_In_unfold in SERIALIZE.
        repeat red in SERIALIZE.
        destruct SERIALIZE as (?&?&?&?).
        repeat red in H.
        destruct H as (?&?&?&?).
        repeat red in H1.
        destruct H1 as (?&?&?&?).
        cbn in H2, H0.
        destruct H2; subst.
        destruct H0; subst.

        specialize (IHsz (concat x4) x3 x1).
        forward IHsz.
        { rewrite Memory64BitIntptr.MMEP.MemSpec.MemHelpers.serialize_sbytes_equation.
          repeat red.
          exists x3. exists x4.
          split; cbn; auto.
        }

        (* All I need now is to know that MemState_eqv ms x1 *)
        specialize (IHTYPE ms x1 x2 H).
        etransitivity; eauto.
    }

    { (* Oom cons structs *)
      rewrite Memory64BitIntptr.MMEP.MemSpec.MemHelpers.serialize_sbytes_equation in SERIALIZE.
      repeat red in SERIALIZE.
      destruct SERIALIZE as (?&?&?&?).

      specialize (IHTYPE ms x x0 H).

      repeat red in H0.
      destruct H0 as (?&?&?&?).
      cbn in H1.
      destruct H1; subst.
      apply IHTYPE0 in H0.
      etransitivity; eauto.
    }

    { (* Oom cons packed structs *)
      rewrite Memory64BitIntptr.MMEP.MemSpec.MemHelpers.serialize_sbytes_equation in SERIALIZE.
      repeat red in SERIALIZE.
      destruct SERIALIZE as (?&?&?&?).

      specialize (IHTYPE ms x x0 H).

      repeat red in H0.
      destruct H0 as (?&?&?&?).
      cbn in H1.
      destruct H1; subst.
      apply IHTYPE0 in H0.
      etransitivity; eauto.
    }

    { (* Oom non-aggregate type *)
      destruct H as (?&?&?&?&?&?).
      destruct t; try contradiction;
        try solve
          [ rewrite Memory64BitIntptr.MMEP.MemSpec.MemHelpers.serialize_sbytes_equation in SERIALIZE;
            destruct SERIALIZE as (?&?&FRESH&SERIALIZE);
            apply Memory64BitIntptr.MMEP.MemSpec.fresh_sid_MemState_eqv in FRESH as EQV1;
            match goal with
            | H: lift_OOM _ _ _ |- _ =>
                red in H; break_match_hyp_inv
            end; auto
          ].

      all: exfalso.
      - eapply H3; eauto.
      - eapply H1; eauto.
      - eapply H2; eauto.
      - eapply H4; eauto.
    }

    { (* Struct cons *)
      rewrite Memory64BitIntptr.MMEP.MemSpec.MemHelpers.serialize_sbytes_equation in SERIALIZE.
      repeat red in SERIALIZE.
      destruct SERIALIZE as (?&?&?&?).

      specialize (IHTYPE1 ms x x0 H).

      repeat red in H0.
      destruct H0 as (?&?&?&?).
      cbn in H1.
      destruct H1; subst.
      apply IHTYPE2 in H0.
      etransitivity; eauto.
    }

    { (* Packed struct cons *)
      rewrite Memory64BitIntptr.MMEP.MemSpec.MemHelpers.serialize_sbytes_equation in SERIALIZE.
      repeat red in SERIALIZE.
      destruct SERIALIZE as (?&?&?&?).

      specialize (IHTYPE1 ms x x0 H).

      repeat red in H0.
      destruct H0 as (?&?&?&?).
      cbn in H1.
      destruct H1; subst.
      apply IHTYPE2 in H0.
      etransitivity; eauto.
    }

    { (* Arrays *)
      rewrite Memory64BitIntptr.MMEP.MemSpec.MemHelpers.serialize_sbytes_equation in SERIALIZE.
      repeat red in SERIALIZE.
      destruct SERIALIZE as (?&?&?&?).
      cbn in H1.
      destruct H1; subst.
      cbn in *.

      generalize dependent ms.
      generalize dependent x.
      generalize dependent x0.
      induction xs; intros x0 x ms H0.
      - cbn in *.
        destruct H0; subst; reflexivity.
      - rewrite map_monad_In_cons in H0.
        repeat red in H0.
        destruct H0 as (?&?&?&?).
        destruct H0 as (?&?&?&?).
        cbn in H1.
        destruct H1; subst.

        pose proof (IH a (or_introl eq_refl) ms x1 x2 H) as MSX1.
        forward IHxs.
        {
          intros x H1 ms0 ms' bytes SERIALIZE.
          apply IH in SERIALIZE; eauto.
          right; auto.
        }
        forward IHxs.
        { intros x H1.
          apply IHdtyp.
          right; auto.
        }

        etransitivity.
        eauto.
        eapply IHxs; eauto.
        apply H0.
    }

    { (* Vectors *)
      rewrite Memory64BitIntptr.MMEP.MemSpec.MemHelpers.serialize_sbytes_equation in SERIALIZE.
      repeat red in SERIALIZE.
      destruct SERIALIZE as (?&?&?&?).
      cbn in H2.
      destruct H2; subst.
      cbn in *.

      generalize dependent ms.
      generalize dependent x.
      generalize dependent x0.
      induction xs; intros x0 x ms H1.
      - cbn in *.
        destruct H1; subst; reflexivity.
      - rewrite map_monad_In_cons in H1.
        repeat red in H1.
        destruct H1 as (?&?&?&?).
        destruct H1 as (?&?&?&?).
        cbn in H1.
        destruct H2; subst.

        pose proof (IH a (or_introl eq_refl) ms x1 x2 H) as MSX1.
        forward IHxs.
        {
          intros x H2 ms0 ms' bytes SERIALIZE.
          apply IH in SERIALIZE; eauto.
          right; auto.
        }
        forward IHxs.
        { intros x H2.
          apply IHdtyp.
          right; auto.
        }

        etransitivity.
        eauto.
        eapply IHxs; eauto.
    }

    { (* Concat_bytes *)
      rewrite Memory64BitIntptr.MMEP.MemSpec.MemHelpers.serialize_sbytes_equation in SERIALIZE.
      repeat red in SERIALIZE.
      destruct SERIALIZE as (?&?&?&?).
      red in H1.
      break_match_hyp; try (destruct e; cbn in H1; contradiction).
      cbn in H1.
      destruct H1; subst.
      eapply re_sid_ubytes_MemState_eqv; eauto.
    }
  Qed.

*)

  Lemma sbytes_refine_concat_repeatN : forall sz BS1 BS2,
      sbytes_refine BS1 BS2 ->
      sbytes_refine (concat (repeatN sz BS1)) (concat (repeatN sz BS2)).
  Proof.
    induction sz using N.peano_ind; intros; cbn.
    - constructor.
    - do 2 rewrite repeatN_succ.
      cbn.
      apply Forall2_app; auto.
      apply IHsz.
      assumption.
  Qed.

  Lemma sbytes_refine_concat : forall BS1 BS2,
      Forall2 sbytes_refine BS1 BS2 ->
      sbytes_refine (concat BS1) (concat BS2).
  Proof.
    intros.
    induction H.
    - constructor.
    - cbn.
      apply Forall2_app; auto.
  Qed.


  Lemma Forall2_In_exists2:
    forall {A B : Type} (f : A -> B -> Prop) (l1 : list A) (l2 : list B) (y : B),
      Forall2 f l1 l2 -> In y l2 -> exists x : A, In x l1 /\ f x y.
  Proof.
    intros.
    induction H.
    - inversion H0.
    - inversion H0.
      + subst. exists x. split; auto. left; auto.
      + subst. destruct (IHForall2 H2) as [z [HI Hz]].
        exists z. split; auto. right; auto.
  Qed.

  Lemma MemPropT_fin_inf_lift_ERR_RAISE_ERROR_ret : 
    forall (A_INF A_FIN : Type)
      a_fin ms_fin_start ms_inf_start ms_fin_ma 
      m_fin
      m_inf
      (A_REF : A_INF -> A_FIN -> Prop)
      (MSR : MemState_refine_prop ms_inf_start ms_fin_start)
      (HM : forall a_fin, m_fin = inr a_fin ->
                     exists a_inf,
                       m_inf = inr a_inf /\
                         A_REF a_inf a_fin)
      (HLIFT :
        @lift_ERR_RAISE_ERROR _
             (MemPropT Memory64BitIntptr.MMEP.MMSP.MemState)
             (@MemPropT_Monad Memory64BitIntptr.MMEP.MMSP.MemState)
             (@MemPropT_RAISE_ERROR Memory64BitIntptr.MMEP.MMSP.MemState) m_fin ms_fin_start (ret (ms_fin_ma, a_fin))),
    exists a_inf, exists ms_inf_ma,
      @lift_ERR_RAISE_ERROR _
             (MemPropT MemoryBigIntptr.MMEP.MMSP.MemState)
             (@MemPropT_Monad MemoryBigIntptr.MMEP.MMSP.MemState)
             (@MemPropT_RAISE_ERROR MemoryBigIntptr.MMEP.MMSP.MemState)
             m_inf ms_inf_start (ret (ms_inf_ma, a_inf)) /\
        A_REF a_inf a_fin /\ MemState_refine_prop ms_inf_ma ms_fin_ma.
  Proof.
    intros.
    red in HLIFT.
    break_match_hyp.
    - destruct e; inversion HLIFT.
    - cbn in HLIFT. destruct HLIFT; subst.
      destruct (HM a eq_refl) as [a_inf [EQ1 HINF]].
      exists a_inf. exists ms_inf_start. split.
      red.  rewrite EQ1. cbn.  auto.
      split; auto.
  Qed.

  Ltac solve_to_ubytes SERIALIZE :=
    eapply MemPropT_fin_inf_bind; [ | | | apply SERIALIZE]; eauto;
    [ intros *; eapply fresh_sid_fin_inf; eauto |];

    intros ms_inf ms_fin ms_fin' a_fin a_inf b_fin SID MSR_SID FRESH [MS_EQ UBYTES];
    cbn in SID, UBYTES; subst;
    eexists; eexists;
    cbn;
    split; eauto;
    split; eauto;
    eapply to_ubytes_fin_inf_sbytes_refine; eauto.

  (* TODO: Move this *)
  Lemma serialize_by_dtyp_MemState_eq :
    forall Ï„ CTR ms ms' bytes,
      Memory64BitIntptr.MMEP.MemSpec.MemHelpers.serialize_by_dtyp
      (M:=MemPropT Memory64BitIntptr.MMEP.MMSP.MemState)
      CTR Ï„ ms
      (ret (ms', bytes)) ->
      Memory64BitIntptr.MMEP.MemSpec.MemState_eqv ms ms'.
  Proof.
    induction Ï„; intros CTR ms ms' bytes SERIALIZE;
      try solve
        [ cbn in *;
          destruct SERIALIZE as (?&?&?&?&?); subst;
          red;
          destruct H;
          auto
        ].

    - (* Arrays *)
      red in SERIALIZE.
      eapply MemPropT_bind_ret_inv in SERIALIZE.
      destruct SERIALIZE as (?&?&?&?&?).
      subst.
      eapply IHÏ„; eauto.
    - (* Struct *)
      generalize dependent ms.
      generalize dependent ms'.
      generalize dependent bytes.
      induction fields; intros bytes ms' ms SERIALIZE.
      + cbn in *.
        destruct SERIALIZE as (?&?&?&?&?).
        destruct H0; subst.
        reflexivity.
      + red in SERIALIZE.
        eapply MemPropT_bind_ret_inv in SERIALIZE.
        destruct SERIALIZE as (?&?&?&?&?).
        rewrite map_monad_unfold in H0.
        repeat red in H0.
        destruct H0 as (?&?&?&?&?&?&?).
        cbn in *.
        destruct H4; subst.
        forward IHfields.
        { intros u H1 CTR0 ms0 ms' bytes H2.
          eapply H; eauto.
        }

        specialize (IHfields (concat x4) x3 x1).
        forward IHfields; eauto.

        rewrite <- IHfields.
        eapply H.
        left; eauto.
        eauto.
    - (* Packed Structs *)
      generalize dependent ms.
      generalize dependent ms'.
      generalize dependent bytes.
      induction fields; intros bytes ms' ms SERIALIZE.
      + cbn in *.
        destruct SERIALIZE as (?&?&?&?&?).
        destruct H0; subst.
        reflexivity.
      + red in SERIALIZE.
        eapply MemPropT_bind_ret_inv in SERIALIZE.
        destruct SERIALIZE as (?&?&?&?&?).
        rewrite map_monad_unfold in H0.
        repeat red in H0.
        destruct H0 as (?&?&?&?&?&?&?).
        cbn in *.
        destruct H4; subst.
        forward IHfields.
        { intros u H1 CTR0 ms0 ms' bytes H2.
          eapply H; eauto.
        }

        specialize (IHfields (concat x4) x3 x1).
        forward IHfields; eauto.

        rewrite <- IHfields.
        eapply H.
        left; eauto.
        eauto.
    - (* Vectors *)
      red in SERIALIZE.
      eapply MemPropT_bind_ret_inv in SERIALIZE.
      destruct SERIALIZE as (?&?&?&?&?).
      subst.
      eapply IHÏ„; eauto.
  Qed.

  (* TODO: Move this *)
  Lemma serialize_by_dtyp_eqv_MemState_eq :
    forall Ï„ CTR ms_start ms_start' ms_final bytes,
      Memory64BitIntptr.MMEP.MemSpec.MemState_eqv ms_start ms_start' ->
      Memory64BitIntptr.MMEP.MemSpec.MemHelpers.serialize_by_dtyp
        (M:=MemPropT Memory64BitIntptr.MMEP.MMSP.MemState)
        CTR Ï„ ms_start (ret (ms_final, bytes)) ->
      exists ms_final',
        Memory64BitIntptr.MMEP.MemSpec.MemHelpers.serialize_by_dtyp
        (M:=MemPropT Memory64BitIntptr.MMEP.MMSP.MemState)
        CTR Ï„ ms_start (ret (ms_final', bytes)) /\
        Memory64BitIntptr.MMEP.MemSpec.MemState_eqv ms_final ms_final'.
  Proof.
    induction Ï„; intros CTR ms_start ms_start' ms_final bytes EQV SERIALIZE;
      try solve
        [ repeat red in SERIALIZE;
          destruct SERIALIZE as (?&?&?&?);
          cbn in H0;
          destruct H0; subst;
          exists x;
          split; [|reflexivity];
          repeat red;
          exists x, x0;
          split; cbn; auto
        ].

    - (* Structs *)
      generalize dependent bytes.
      revert ms_start ms_start' ms_final EQV.
      induction fields; intros ms_start ms_start' ms_final EQV bytes SERIALIZE.
      + cbn in SERIALIZE.
        destruct SERIALIZE as (?&?&?&?&?).
        destruct H0; subst.
        cbn.
        exists ms_start.
        split; [|reflexivity].
        eexists. eexists.
        split; eauto.
      + cbn in SERIALIZE.
        destruct SERIALIZE as (?&?&?&?&?).
        subst.
        destruct H0 as (?&?&?&?&?&?&?&?).
        subst.

        forward IHfields.
        { intros u H2 CTR0 ms_start0 ms_start'0 ms_final bytes H3 H4.
          eapply H; eauto.
          right; auto.
        }

        specialize (IHfields x1 x1 x3).
        forward IHfields; [reflexivity|].
        specialize (IHfields (concat x4)).
        forward IHfields.
        { repeat red.
          exists x3, x4.
          split; eauto.
          cbn.
          auto.
        }

        destruct IHfields as (?&?&?).
        exists x3.
        split; eauto.
        red.
        rewrite map_monad_unfold.
        cbn.
        exists x3. exists (x2 :: x4).
        split; eauto.
        2: reflexivity.

        exists x1. exists x2.
        split; eauto.
    - (* Packed Structs *)
      generalize dependent bytes.
      revert ms_start ms_start' ms_final EQV.
      induction fields; intros ms_start ms_start' ms_final EQV bytes SERIALIZE.
      + cbn in SERIALIZE.
        destruct SERIALIZE as (?&?&?&?&?).
        destruct H0; subst.
        cbn.
        exists ms_start.
        split; [|reflexivity].
        eexists. eexists.
        split; eauto.
      + cbn in SERIALIZE.
        destruct SERIALIZE as (?&?&?&?&?).
        subst.
        destruct H0 as (?&?&?&?&?&?&?&?).
        subst.

        forward IHfields.
        { intros u H2 CTR0 ms_start0 ms_start'0 ms_final bytes H3 H4.
          eapply H; eauto.
          right; auto.
        }

        specialize (IHfields x1 x1 x3).
        forward IHfields; [reflexivity|].
        specialize (IHfields (concat x4)).
        forward IHfields.
        { repeat red.
          exists x3, x4.
          split; eauto.
          cbn.
          auto.
        }

        destruct IHfields as (?&?&?).
        exists x3.
        split; eauto.
        red.
        rewrite map_monad_unfold.
        cbn.
        exists x3. exists (x2 :: x4).
        split; eauto.
        2: reflexivity.

        exists x1. exists x2.
        split; eauto.
  Qed.

  Lemma to_ubytes_fin_inf_eq :
    forall {uv_fin uv_inf t sid},
      DVC1.uvalue_refine_strict uv_inf uv_fin ->
       sbytes_refine
        (MemoryBigIntptr.MMEP.MMSP.MemByte.to_ubytes uv_inf t sid) 
        (Memory64BitIntptr.MMEP.MMSP.MemByte.to_ubytes uv_fin t sid).
  Proof.
    intros.
    destruct (@to_ubytes_fin_inf _ _ t sid _ H eq_refl) as [l [EQ R]].
    rewrite EQ. assumption.
  Qed.


  Lemma serialize_sbytes_fin_inf :
    forall {ms_fin_start ms_fin_final ms_inf_start uv_fin uv_inf t bytes_fin},
      MemState_refine_prop ms_inf_start ms_fin_start ->
      DVC1.uvalue_refine_strict uv_inf uv_fin ->
      Memory64BitIntptr.MMEP.MemSpec.MemHelpers.serialize_sbytes (M:=MemPropT Memory64BitIntptr.MMEP.MMSP.MemState) uv_fin t ms_fin_start
        (ret (ms_fin_final, bytes_fin)) ->
      exists
        (bytes_inf : list MemoryBigIntptr.MP.BYTE_IMPL.SByte) (ms_inf_final : MemoryBigIntptr.MMEP.MMSP.MemState),
        MemoryBigIntptr.MMEP.MemSpec.MemHelpers.serialize_sbytes (M:=MemPropT MemoryBigIntptr.MMEP.MMSP.MemState) uv_inf t ms_inf_start
          (ret (ms_inf_final, bytes_inf)) /\
          sbytes_refine bytes_inf bytes_fin /\
          MemState_refine_prop ms_inf_final ms_fin_final.
  Proof.
    intros ms_fin_start ms_fin_final ms_inf_start uv_fin uv_inf t bytes_fin MSR UV_REF SERIALIZE.
    pose proof UV_REF as UV_REF';
      cbn in UV_REF';
      inversion UV_REF; subst; 
      repeat break_match_hyp_inv;
      eapply MemPropT_fin_inf_bind; [ | | | apply SERIALIZE]; eauto;
      [intros *; eapply fresh_sid_fin_inf; eauto|];
      
      intros ms_inf ms_fin ms_fin' a_fin a_inf b_fin SID MSR_FRESH FRESH UBYTES;
      cbn in SID; subst; destruct UBYTES; subst;
      cbn;
      eexists; eexists; split; [split; reflexivity|];
      split; auto;
      apply to_ubytes_fin_inf_eq; auto.
  Qed.

  Lemma serialize_sbytes_fin_inf_ub :
    forall {ms_fin_start ms_inf_start uv_fin uv_inf t msg},
      MemState_refine_prop ms_inf_start ms_fin_start ->
      DVC1.uvalue_refine_strict uv_inf uv_fin ->
      Memory64BitIntptr.MMEP.MemSpec.MemHelpers.serialize_sbytes (M:=MemPropT Memory64BitIntptr.MMEP.MMSP.MemState) uv_fin t ms_fin_start (raise_ub msg) -> False.
  Proof.
    intros ms_fin_start ms_inf_start uv_fin uv_inf t msg MSR UV_REF SERIALIZE.
    cbn in SERIALIZE.
    destruct SERIALIZE; auto.
    destruct H as (?&?&?&?).
    auto.
  Qed.

  Lemma serialize_sbytes_fin_inf_error :
    forall {ms_fin_start ms_inf_start uv_fin uv_inf t msg},
      MemState_refine_prop ms_inf_start ms_fin_start ->
      DVC1.uvalue_refine_strict uv_inf uv_fin ->
      Memory64BitIntptr.MMEP.MemSpec.MemHelpers.serialize_sbytes (M:=MemPropT Memory64BitIntptr.MMEP.MMSP.MemState) uv_fin t ms_fin_start (raise_error msg) ->
      MemoryBigIntptr.MMEP.MemSpec.MemHelpers.serialize_sbytes (M:=MemPropT MemoryBigIntptr.MMEP.MMSP.MemState) uv_inf t ms_inf_start (raise_error msg).
  Proof.
    intros ms_fin_start ms_inf_start uv_fin uv_inf t msg MSR UV_REF SERIALIZE.
    cbn in *.
    destruct SERIALIZE; auto.
    destruct H as (?&?&?&?).
    auto.
  Qed.

  Lemma handle_store_fin_inf :
    forall {t addr_fin addr_inf uv_fin uv_inf ms_fin_start ms_fin_final ms_inf_start res_fin},
      MemState_refine_prop ms_inf_start ms_fin_start ->
      DVC1.dvalue_refine_strict addr_inf addr_fin ->
      DVC1.uvalue_refine_strict uv_inf uv_fin ->
      Memory64BitIntptr.MMEP.MemSpec.handle_memory_prop unit
        (LLVMParams64BitIntptr.Events.Store t addr_fin uv_fin) ms_fin_start (ret (ms_fin_final, res_fin)) ->
      exists res_inf ms_inf_final,
        MemoryBigIntptr.MMEP.MemSpec.handle_memory_prop unit
          (LLVMParamsBigIntptr.Events.Store t addr_inf uv_inf) ms_inf_start (ret (ms_inf_final, res_inf)) /\
          res_inf = res_fin /\
          MemState_refine_prop ms_inf_final ms_fin_final.
  Proof.
    intros t addr_fin addr_inf uv_fin uv_inf ms_fin_start ms_fin_final ms_inf_start res_fin MSR ADDR_REF VALUE_REF HANDLE.

    red in HANDLE.
    induction addr_fin;
      try
        solve
        [ rewrite DVC1.dvalue_refine_strict_equation in ADDR_REF;
          first
            [ apply dvalue_convert_strict_i1_inv in ADDR_REF
            | apply dvalue_convert_strict_i8_inv in ADDR_REF
            | apply dvalue_convert_strict_i32_inv in ADDR_REF
            | apply dvalue_convert_strict_i64_inv in ADDR_REF
            | apply dvalue_convert_strict_iptr_inv in ADDR_REF
            | apply dvalue_convert_strict_addr_inv in ADDR_REF
            | apply dvalue_convert_strict_double_inv in ADDR_REF
            | apply dvalue_convert_strict_float_inv in ADDR_REF
            | apply dvalue_convert_strict_poison_inv in ADDR_REF
            | apply dvalue_convert_strict_oom_inv in ADDR_REF
            | apply dvalue_convert_strict_none_inv in ADDR_REF
            | apply dvalue_convert_strict_struct_inv in ADDR_REF
            | apply dvalue_convert_strict_packed_struct_inv in ADDR_REF
            | apply dvalue_convert_strict_array_inv in ADDR_REF
            | apply dvalue_convert_strict_vector_inv in ADDR_REF
            ];
          first
            [ destruct ADDR_REF as (?&?&?); subst
            | inv ADDR_REF
            ];

          exists tt; destruct res_fin;
          exists (lift_MemState ms_fin_final);
          cbn; repeat (split; auto)
        ].

    (* Main successful portion of the lemma *)
    unfold MemoryBigIntptr.MMEP.MemSpec.handle_memory_prop.
    eapply dvalue_refine_strict_addr_r_inv in ADDR_REF as (ptr_inf&PTR_INF&PTR_REF).
    subst.

    eapply MemPropT_fin_inf_bind.
    4: apply HANDLE.
    all: eauto.

    { (* MA: serialize_sbytes *)
      intros a_fin ms_fin_ma SERIALIZE.
      eapply serialize_sbytes_fin_inf; eauto.
    }

    intros ms_inf ms_fin ms_fin' a_fin a_inf b_fin H H0 H1.
    eapply fin_inf_write_bytes_spec; eauto.
  Qed.

  Lemma handle_store_fin_inf_ub :
    forall {t addr_fin addr_inf uv_fin uv_inf ms_fin_start ms_inf_start msg},
      MemState_refine_prop ms_inf_start ms_fin_start ->
      DVC1.dvalue_refine_strict addr_inf addr_fin ->
      DVC1.uvalue_refine_strict uv_inf uv_fin ->
      Memory64BitIntptr.MMEP.MemSpec.handle_memory_prop unit
        (LLVMParams64BitIntptr.Events.Store t addr_fin uv_fin) ms_fin_start (raise_ub msg) ->
      MemoryBigIntptr.MMEP.MemSpec.handle_memory_prop unit
        (LLVMParamsBigIntptr.Events.Store t addr_inf uv_inf) ms_inf_start (raise_ub msg).
  Proof.
    intros t addr_fin addr_inf uv_fin uv_inf ms_fin_start ms_inf_start msg MSR ADDR_REF VALUE_REF HANDLE.

    red in HANDLE.
    induction addr_fin;
      try
        solve
        [ rewrite DVC1.dvalue_refine_strict_equation in ADDR_REF;
          first
            [ apply dvalue_convert_strict_i1_inv in ADDR_REF
            | apply dvalue_convert_strict_i8_inv in ADDR_REF
            | apply dvalue_convert_strict_i32_inv in ADDR_REF
            | apply dvalue_convert_strict_i64_inv in ADDR_REF
            | apply dvalue_convert_strict_iptr_inv in ADDR_REF
            | apply dvalue_convert_strict_addr_inv in ADDR_REF
            | apply dvalue_convert_strict_double_inv in ADDR_REF
            | apply dvalue_convert_strict_float_inv in ADDR_REF
            | apply dvalue_convert_strict_poison_inv in ADDR_REF
            | apply dvalue_convert_strict_oom_inv in ADDR_REF
            | apply dvalue_convert_strict_none_inv in ADDR_REF
            | apply dvalue_convert_strict_struct_inv in ADDR_REF
            | apply dvalue_convert_strict_packed_struct_inv in ADDR_REF
            | apply dvalue_convert_strict_array_inv in ADDR_REF
            | apply dvalue_convert_strict_vector_inv in ADDR_REF
            ]; subst; cbn; auto;
          first [destruct ADDR_REF as (?&?&?)
                | destruct ADDR_REF as (?&?)]; subst; cbn; auto
        ].

    { (* Main successful portion of the lemma *)
      unfold MemoryBigIntptr.MMEP.MemSpec.handle_memory_prop.
      eapply dvalue_refine_strict_addr_r_inv in ADDR_REF as (ptr_inf&PTR_INF&PTR_REF).
      subst.

      eapply MemPropT_fin_inf_bind_ub.
      5: apply HANDLE.
      all: eauto with FinInf.

      { (* MA: serialize_sbytes *)
        intros a_fin ms_fin_ma SERIALIZE.
        eapply serialize_sbytes_fin_inf; eauto.
      }

      { intros msg0 H.
        eapply serialize_sbytes_fin_inf_ub in H; try contradiction; eauto.
      }

      intros ms_inf ms_fin a_fin a_inf msg0 H H0 H1 H2.
      eapply fin_inf_write_bytes_spec_ub; eauto.
    }

    Unshelve.
    all: eauto.
  Qed.

  (* TODO: Move this *)
  Lemma all_bytes_from_uvalue_helper_has_dtyp :
    forall {bytes idx sid parent t uv},
      E1.DV.uvalue_has_dtyp parent t ->
      MemoryBigIntptr.MMEP.MMSP.MemByte.all_bytes_from_uvalue_helper idx sid parent bytes = Some uv ->
      E1.DV.uvalue_has_dtyp uv t.
  Proof.
    induction bytes; intros idx sid parent t uv TYP ALL.
    - cbn in *.
      inv ALL; auto.
    - cbn in ALL.
      repeat break_match_hyp_inv.
      destruct u0, u1, u2.
      destruct a.
      rewrite MemoryBigIntptr.Byte.sbyte_to_extractbyte_of_uvalue_sbyte in Hequ.
      inv Hequ.
      eauto.
  Qed.

  (* TODO: Move this *)
  Lemma all_bytes_from_uvalue_has_dtyp :
    forall {bytes t uv},
      MemoryBigIntptr.MMEP.MMSP.MemByte.all_bytes_from_uvalue t bytes = Some uv ->
      E1.DV.uvalue_has_dtyp uv t.
  Proof.
    intros bytes t uv ALL.
    unfold MemoryBigIntptr.MMEP.MMSP.MemByte.all_bytes_from_uvalue in ALL.
    destruct bytes; try discriminate.

    destruct s.
    rewrite MemoryBigIntptr.Byte.sbyte_to_extractbyte_of_uvalue_sbyte in ALL.
    Opaque MemoryBigIntptr.MMEP.MMSP.MemByte.all_bytes_from_uvalue_helper.
    cbn in ALL.
    break_match_hyp_inv.
    break_match_hyp_inv.
    eapply all_bytes_from_uvalue_helper_has_dtyp; eauto.
    destruct (dtyp_eqb t dt) eqn:HDTYP;
      cbn in Heqo; inv Heqo.
    destruct (Coqlib.proj_sumbool LLVMParamsBigIntptr.Events.DV.uvalue_has_dtyp_dec) eqn:HUVT;
      cbn in Heqo0; inv Heqo0.
    unfold Coqlib.proj_sumbool in HUVT.
    break_match_hyp_inv.
    apply dtyp_eqb_eq in HDTYP; subst.
    auto.
  Qed.

  (* TODO: Move this *)
  Lemma from_ubytes_dtyp :
    forall {bytes t uv},
      ALL_IX_SUPPORTED t ->
      MemoryBigIntptr.MMEP.MMSP.MemByte.from_ubytes bytes t = uv ->
      N.of_nat (Datatypes.length bytes) = LLVMParamsBigIntptr.SIZEOF.sizeof_dtyp t ->
      E1.DV.uvalue_has_dtyp uv t.
  Proof.
    intros bytes t uv SUPPORTED UBYTES SIZE.
    unfold MemoryBigIntptr.MMEP.MMSP.MemByte.from_ubytes in *.
    rewrite SIZE in UBYTES.
    rewrite N.eqb_refl in UBYTES.
    break_match_hyp; subst.
    - eapply all_bytes_from_uvalue_has_dtyp; eauto.
    - constructor; auto.
      + intros byte IN.
        apply in_map_iff in IN.
        destruct IN as (x&BYTE&IN).
        destruct x.
        rewrite MemoryBigIntptr.Byte.sbyte_to_extractbyte_of_uvalue_sbyte in BYTE.
        subst.
        exists uv, dt, idx, sid.
        reflexivity.
      + rewrite map_length.
        auto.
  Qed.

  Lemma all_bytes_from_uvalue_fin_inf_helper_Some :
    forall {bytes_fin : list Memory64BitIntptr.MP.BYTE_IMPL.SByte}
      {bytes_inf : list MemoryBigIntptr.MP.BYTE_IMPL.SByte}
      {parent_fin parent_inf idx sid uv_fin}
      (BYTES : sbytes_refine bytes_inf bytes_fin),
      DVC1.uvalue_refine_strict parent_inf parent_fin ->
      Memory64BitIntptr.MMEP.MMSP.MemByte.all_bytes_from_uvalue_helper idx sid parent_fin bytes_fin = Some uv_fin ->
      MemoryBigIntptr.MMEP.MMSP.MemByte.all_bytes_from_uvalue_helper idx sid parent_inf bytes_inf = Some parent_inf.
  Proof.
    intros bytes_fin bytes_inf parent_fin parent_inf idx sid uv_fin BYTES REF ALL.
    revert parent_fin parent_inf idx sid uv_fin REF ALL.
    induction BYTES; intros parent_fin parent_inf idx sid uv_fin REF ALL.
    - cbn in *; inv ALL.
      split; eauto.
    - cbn in ALL.
      repeat break_match_hyp_inv.
      destruct u0, u1, u2.
      eapply IHBYTES in H2; eauto.
      Transparent MemoryBigIntptr.MMEP.MMSP.MemByte.all_bytes_from_uvalue_helper.
      cbn.
      destruct x.
      red in H.
      unfold convert_SByte in H.
      cbn in H.
      break_match_hyp_inv.
      rewrite FinLLVM.MEM.Byte.sbyte_to_extractbyte_of_uvalue_sbyte in Hequ.
      inv Hequ.
      rewrite InfLLVM.MEM.Byte.sbyte_to_extractbyte_of_uvalue_sbyte.
      rewrite Heqo.
      unfold OptionUtil.guard_opt in *.
      repeat break_match_hyp_inv.
      pose proof RelDec.rel_dec_correct u parent_fin.
      apply H in Heqb0; subst.
      break_inner_match_goal.
      * eauto.
      * red in REF.
        pose proof DVC1.uvalue_refine_strict_R2_injective.
        red in H0.
        specialize (H0 _ _ _ _ Heqo2 REF).
        destruct H0.
        forward H1; auto.
        subst.
        rewrite Util.eq_dec_eq in Heqb0.
        inv Heqb0.        
  Qed.

  Lemma all_bytes_from_uvalue_fin_helper_Some_same_uv :
    forall {bytes_fin : list Memory64BitIntptr.MP.BYTE_IMPL.SByte}
      {bytes_inf : list MemoryBigIntptr.MP.BYTE_IMPL.SByte}
      {parent_fin parent_inf idx sid uv_fin}
      (BYTES : sbytes_refine bytes_inf bytes_fin),
      DVC1.uvalue_refine_strict parent_inf parent_fin ->
      Memory64BitIntptr.MMEP.MMSP.MemByte.all_bytes_from_uvalue_helper idx sid parent_fin bytes_fin = Some uv_fin ->
      parent_fin = uv_fin.
  Proof.
    intros bytes_fin bytes_inf parent_fin parent_inf idx sid uv_fin BYTES REF ALL.
    revert parent_fin parent_inf idx sid uv_fin REF ALL.
    induction BYTES; intros parent_fin parent_inf idx sid uv_fin REF ALL.
    - cbn in *; inv ALL.
      split; eauto.
    - cbn in ALL.
      repeat break_match_hyp_inv.
      destruct u0, u1, u2.
      eapply IHBYTES in H2; eauto.
  Qed.

  Lemma all_bytes_from_uvalue_fin_inf_Some :
    forall {bytes_fin : list Memory64BitIntptr.MP.BYTE_IMPL.SByte}
      {bytes_inf : list MemoryBigIntptr.MP.BYTE_IMPL.SByte}
      {dt uv_fin}
      (BYTES : sbytes_refine bytes_inf bytes_fin),
      Memory64BitIntptr.MMEP.MMSP.MemByte.all_bytes_from_uvalue dt bytes_fin = Some uv_fin ->
      exists uv_inf,
        MemoryBigIntptr.MMEP.MMSP.MemByte.all_bytes_from_uvalue dt bytes_inf = Some uv_inf /\
          DVC1.uvalue_refine_strict uv_inf uv_fin.
  Proof.
    intros bytes_fin bytes_inf dt uv_fin BYTES ALL.
    unfold Memory64BitIntptr.MMEP.MMSP.MemByte.all_bytes_from_uvalue in ALL.
    destruct BYTES; try discriminate.
    repeat break_match_hyp_inv.
    destruct u0, u1, u3, u4, u5.
    cbn.
    destruct x.
    red in H.
    unfold convert_SByte in H.
    cbn in *.
    break_match_hyp_inv.
    rewrite Memory64BitIntptr.Byte.sbyte_to_extractbyte_of_uvalue_sbyte in Hequ2;
      inv Hequ2;
      inv Hequ.
    rewrite MemoryBigIntptr.Byte.sbyte_to_extractbyte_of_uvalue_sbyte.
    rewrite Heqo.

    pose proof all_bytes_from_uvalue_fin_helper_Some_same_uv BYTES Heqo4 H1; subst.
    eapply all_bytes_from_uvalue_fin_inf_helper_Some in H1; eauto.
    exists uv.
    split; eauto.

    destruct (Coqlib.proj_sumbool LLVMParamsBigIntptr.Events.DV.uvalue_has_dtyp_dec) eqn:HUVT;
      cbn in Heqo0; inv Heqo0;
      unfold Coqlib.proj_sumbool in HUVT;
      break_match_hyp_inv.
    2: {
      exfalso.
      unfold OptionUtil.guard_opt in H0.
      break_match_hyp_inv.
      unfold Coqlib.proj_sumbool in Heqb.
      break_match_hyp_inv.
      eapply n.
      eapply uvalue_refine_strict_has_dtyp_fin_inf; eauto.
    }
    cbn.
    Transparent MemoryBigIntptr.MMEP.MMSP.MemByte.all_bytes_from_uvalue_helper.
    unfold MemoryBigIntptr.MMEP.MMSP.MemByte.all_bytes_from_uvalue_helper.
    rewrite Heqo1, Heqo3.
    rewrite Util.eq_dec_eq.
    cbn.
    eapply H1.
  Qed.

  Opaque MemoryBigIntptr.MMEP.MMSP.MemByte.all_bytes_from_uvalue_helper.
  Opaque Memory64BitIntptr.MMEP.MMSP.MemByte.all_bytes_from_uvalue_helper.

  Lemma sbyte_to_extract_byte_inversion1 :
    forall {x s u_inf1 dt u_inf2 sid},
      sbyte_refine x s ->
      MemoryBigIntptr.MP.BYTE_IMPL.sbyte_to_extractbyte x =
        LLVMParamsBigIntptr.Events.DV.UVALUE_ExtractByte u_inf1 dt u_inf2 sid ->
      exists u_fin1 u_fin2,
        Memory64BitIntptr.MP.BYTE_IMPL.sbyte_to_extractbyte s =
          LLVMParams64BitIntptr.Events.DV.UVALUE_ExtractByte u_fin1 dt u_fin2 sid.
  Proof.
    intros x s u_inf1 dt u_inf2 sid BYTES EQ.
    destruct x.
    rewrite <- InterpreterStackBigIntptr.LLVM.MEM.Byte.sbyte_to_extractbyte_of_uvalue_sbyte in EQ.
    inversion BYTES.
    repeat break_match_hyp_inv.
  Admitted.

  Lemma all_bytes_from_uvalue_fin_inf_helper_None :
    forall {bytes_fin : list Memory64BitIntptr.MP.BYTE_IMPL.SByte}
      {bytes_inf : list MemoryBigIntptr.MP.BYTE_IMPL.SByte}
      {parent_fin parent_inf idx sid}
      (BYTES : sbytes_refine bytes_inf bytes_fin),
      DVC1.uvalue_refine_strict parent_inf parent_fin ->
      Memory64BitIntptr.MMEP.MMSP.MemByte.all_bytes_from_uvalue_helper idx sid parent_fin bytes_fin = None ->
      MemoryBigIntptr.MMEP.MMSP.MemByte.all_bytes_from_uvalue_helper idx sid parent_inf bytes_inf = None.
  Proof.
    intros bytes_fin bytes_inf parent_fin parent_inf idx sid BYTES REF ALL.
    revert parent_fin parent_inf idx sid REF ALL.
    induction BYTES; intros parent_fin parent_inf idx sid REF ALL.
    - cbn in *; inv ALL.
    - Transparent MemoryBigIntptr.MMEP.MMSP.MemByte.all_bytes_from_uvalue_helper.
      Transparent Memory64BitIntptr.MMEP.MMSP.MemByte.all_bytes_from_uvalue_helper.
      cbn in ALL.
      destruct x.
      red in H.
      unfold convert_SByte in H.
      cbn in H.
      move H after ALL.
      break_match_hyp_inv.
      rewrite FinLLVM.MEM.Byte.sbyte_to_extractbyte_of_uvalue_sbyte in ALL.
      cbn.
      rewrite InfLLVM.MEM.Byte.sbyte_to_extractbyte_of_uvalue_sbyte.
      unfold OptionUtil.guard_opt in *.
      repeat break_match_hyp_inv; auto.
      + break_inner_match_goal; auto.
        pose proof RelDec.rel_dec_correct u parent_fin.
        apply H in Heqb0; subst.
        pose proof RelDec.rel_dec_correct uv parent_inf.
        apply H1 in Heqb2; subst.
        eauto.
      + break_inner_match_goal; auto.
      + break_inner_match_goal; auto.
        break_inner_match_goal; auto.
        pose proof RelDec.rel_dec_correct uv parent_inf.
        apply H in Heqb1; subst.
        pose proof DVC1.uvalue_refine_strict_R2_injective.
        red in H0.
        specialize (H0 _ _ _ _ Heqo REF).
        destruct H0.
        forward H0; auto.
        subst.
        rewrite Util.eq_dec_eq in Heqb.
        inv Heqb.
  Qed.

  Lemma all_bytes_from_uvalue_fin_inf_None :
    forall {bytes_fin : list Memory64BitIntptr.MP.BYTE_IMPL.SByte}
      {bytes_inf : list MemoryBigIntptr.MP.BYTE_IMPL.SByte}
      {dt}
      (BYTES : sbytes_refine bytes_inf bytes_fin),
      Memory64BitIntptr.MMEP.MMSP.MemByte.all_bytes_from_uvalue dt bytes_fin = None ->
        MemoryBigIntptr.MMEP.MMSP.MemByte.all_bytes_from_uvalue dt bytes_inf = None.
  Proof.
    intros.
    destruct BYTES; cbn in *; auto.
    destruct x.
    red in H0.
    unfold convert_SByte in H0.
    cbn in H0.
    move H0 after H.
    break_match_hyp_inv.

    rewrite Memory64BitIntptr.Byte.sbyte_to_extractbyte_of_uvalue_sbyte in H.
    rewrite MemoryBigIntptr.Byte.sbyte_to_extractbyte_of_uvalue_sbyte.

    unfold OptionUtil.guard_opt in *.
    rewrite Util.eq_dec_eq.
    rewrite Util.eq_dec_eq in H.
    rewrite N.eqb_refl.
    rewrite N.eqb_refl in H.
    repeat break_match_hyp_inv; cbn in *; eauto; try lia.

    - break_inner_match_goal; eauto.
      eapply all_bytes_from_uvalue_fin_inf_helper_None; eauto.
    - break_inner_match_goal; eauto.
    - break_inner_match_goal; eauto.
      exfalso.
      unfold Coqlib.proj_sumbool in Heqb, Heqb1.
      break_match_hyp_inv.
      break_match_hyp_inv.
      apply n.
      eapply uvalue_refine_strict_has_dtyp; eauto.
  Qed.

  Lemma from_ubytes_inf_fin :
    forall {bytes_fin : list Memory64BitIntptr.MP.BYTE_IMPL.SByte}
      {bytes_inf : list MemoryBigIntptr.MP.BYTE_IMPL.SByte}
      {dt}
      (BYTES : sbytes_refine bytes_inf bytes_fin),
      DVC1.uvalue_refine_strict (MemoryBigIntptr.MMEP.MMSP.MemByte.from_ubytes bytes_inf dt)
        (Memory64BitIntptr.MMEP.MMSP.MemByte.from_ubytes bytes_fin dt).
  Proof.
    intros bytes_fin bytes_inf dt BYTES.

    assert (length bytes_inf = length bytes_fin) as BYTE_LENGTH.
    { eapply sbytes_refine_length; eauto.
    }

    unfold MemoryBigIntptr.MMEP.MMSP.MemByte.from_ubytes.
    unfold Memory64BitIntptr.MMEP.MMSP.MemByte.from_ubytes.
    rewrite <- BYTE_LENGTH.

    break_match_goal.
    2: {
      clear Heqb BYTE_LENGTH.
      induction BYTES.
      - cbn.
        unfold DVC1.uvalue_refine_strict;
          cbn; reflexivity.
      - unfold DVC1.uvalue_refine_strict in *.
        cbn.
        destruct x.
        rewrite MemoryBigIntptr.Byte.sbyte_to_extractbyte_of_uvalue_sbyte.
        cbn.
        red in H.
        unfold convert_SByte in *.
        cbn in H.
        break_match_hyp_inv.
        cbn in *.
        break_match_hyp_inv.
        rewrite Memory64BitIntptr.Byte.sbyte_to_extractbyte_of_uvalue_sbyte.
        reflexivity.
    }

    { destruct (Memory64BitIntptr.MMEP.MMSP.MemByte.all_bytes_from_uvalue dt bytes_fin) eqn:ALL.
      - eapply all_bytes_from_uvalue_fin_inf_Some in ALL; eauto.
        destruct ALL as (?&?&?).
        rewrite H; auto.
      - eapply all_bytes_from_uvalue_fin_inf_None in ALL; eauto.
        rewrite ALL.

        clear Heqb BYTE_LENGTH ALL.
        induction BYTES.
        + cbn.
          unfold DVC1.uvalue_refine_strict;
            cbn; reflexivity.
        + unfold DVC1.uvalue_refine_strict in *.
          cbn.
          destruct x.
          rewrite MemoryBigIntptr.Byte.sbyte_to_extractbyte_of_uvalue_sbyte.
          cbn.
          red in H.
          unfold convert_SByte in *.
          cbn in H.
          break_match_hyp_inv.
          cbn in *.
          break_match_hyp_inv.
          rewrite Memory64BitIntptr.Byte.sbyte_to_extractbyte_of_uvalue_sbyte.
          reflexivity.
    }
  Qed.

  #[global] Opaque Memory64BitIntptr.MMEP.MemSpec.MemHelpers.deserialize_sbytes.
  #[global] Opaque MemoryBigIntptr.MMEP.MemSpec.MemHelpers.deserialize_sbytes.
  #[global] Opaque monad_fold_right.
  (* TODO: Move this *)
  Lemma monad_fold_right_equation :
    forall {A B m} `{HM : Monad m} (f : B -> A -> m B) (l : list A) (b : B),
      monad_fold_right f l b =
        match l with
        | [] => ret b
        | x::xs =>
            r <- monad_fold_right f xs b ;;
            f r x
        end.
  Proof.
    intros A B m HM f l b.
    induction l; auto.
  Qed.

  (* TODO: Move this to listutils or something *)
  Lemma Forall2_take :
    forall {X Y} amount (xs : list X) (ys : list Y) P,
      Forall2 P xs ys ->
      Forall2 P (take amount xs) (take amount ys).
  Proof.
    intros X Y amount xs ys P ALL.
    generalize dependent amount.
    induction ALL; intros amount.
    - cbn; auto.
    - destruct amount; cbn; auto.
  Qed.

  (* TODO: Move this to listutils or something *)
  Lemma Forall2_drop :
    forall {X Y} amount (xs : list X) (ys : list Y) P,
      Forall2 P xs ys ->
      Forall2 P (drop amount xs) (drop amount ys).
  Proof.
    intros X Y amount xs ys P ALL.
    generalize dependent amount.
    induction ALL; intros amount.
    - cbn; auto.
    - destruct amount; cbn; auto.
  Qed.

  (* TODO: Move this to listutils or something *)
  Lemma Forall2_between :
    forall {X Y} (xs : list X) (ys : list Y) P start finish,
      Forall2 P xs ys ->
      Forall2 P (between start finish xs) (between start finish ys).
  Proof.
    unfold between.
    intros X Y xs ys P start finish ALL.
    apply Forall2_take.
    apply Forall2_drop.
    auto.
  Qed.

  (* TODO: Move this to listutils or something *)
  Lemma take_length :
    forall {X} (xs : list X) amount,
      amount <= N.of_nat (length xs) ->
      length (take amount xs) = N.to_nat amount.
  Proof.
    intros X xs.
    induction xs; intros amount LE.
    - destruct amount; cbn in *; auto.
      lia.
    - induction amount using N.peano_ind.
      + cbn in *; auto.
      + cbn.
        break_match_goal;
        break_match_hyp_inv; auto.

        cbn in *.
        rewrite IHxs;
        lia.
  Qed.

  (* TODO: Move this to listutils or something *)
  Lemma drop_length :
    forall {X} (xs : list X) amount,
      amount <= N.of_nat (length xs) ->
      length (drop amount xs) = (length xs - N.to_nat amount)%nat.
  Proof.
    intros X xs.
    induction xs; intros amount LE.
    - destruct amount; cbn in *; auto.
    - induction amount using N.peano_ind.
      + cbn in *; auto.
      + cbn.
        break_match_goal;
        break_match_hyp_inv; auto.
        break_match_goal.
        lia.
        cbn in *.
        rewrite IHxs;
        lia.
  Qed.

  (* TODO: Move this to listutils or something *)
  Lemma between_length :
    forall {X} (xs : list X) start finish,
      start <= finish ->
      finish <= N.of_nat (length xs) ->
      length (between start finish xs) = N.to_nat (finish - start).
  Proof.
    intros X xs start finish START_LE FINISH_LE.
    unfold between.
    apply take_length.
    pose proof drop_length xs start as DROP.
    forward DROP; lia.
  Qed.

  Lemma monad_fold_right_deserialize_sbytes_fin_inf :
    forall {t : dtyp} {bytes_fin bytes_inf}
      (start seq_len : N)
      (BYTES_REF : sbytes_refine bytes_inf bytes_fin)
      (IHt :
        forall (bytes_fin : list Memory64BitIntptr.MP.BYTE_IMPL.SByte)
          (bytes_inf : list MemoryBigIntptr.MP.BYTE_IMPL.SByte)
          (res_fin : LLVMParams64BitIntptr.Events.DV.uvalue),
          sbytes_refine bytes_inf bytes_fin ->
          Memory64BitIntptr.MMEP.MemSpec.MemHelpers.deserialize_sbytes bytes_fin t = inr res_fin ->
          exists res_inf : LLVMParamsBigIntptr.Events.DV.uvalue,
            MemoryBigIntptr.MMEP.MemSpec.MemHelpers.deserialize_sbytes bytes_inf t = inr res_inf /\
              DVC1.uvalue_refine_strict res_inf res_fin)
      (uv_fins : list LLVMParams64BitIntptr.Events.DV.uvalue),
      monad_fold_right
        (fun (acc : list LLVMParams64BitIntptr.Events.DV.uvalue) (idx : N) =>
           uv <-
             Memory64BitIntptr.MMEP.MemSpec.MemHelpers.deserialize_sbytes
               (between (idx * FiniteSizeof.FinSizeof.sizeof_dtyp t)
                  ((idx + 1) * FiniteSizeof.FinSizeof.sizeof_dtyp t) bytes_fin) t;;
           @ret err _ _ (uv :: acc)) (Nseq start (N.to_nat seq_len)) [] = inr uv_fins ->
      exists (uv_infs : list LLVMParamsBigIntptr.Events.DV.uvalue),
        (monad_fold_right
           (fun (acc : list LLVMParamsBigIntptr.Events.DV.uvalue) (idx : N) =>
              uv <-
                MemoryBigIntptr.MMEP.MemSpec.MemHelpers.deserialize_sbytes
                  (between (idx * FiniteSizeof.FinSizeof.sizeof_dtyp t)
                     ((idx + 1) * FiniteSizeof.FinSizeof.sizeof_dtyp t) bytes_inf) t;;
              @ret err _ _ (uv :: acc)) (Nseq start (N.to_nat seq_len)) [] = inr uv_infs) /\
          Forall2 DVC1.uvalue_refine_strict uv_infs uv_fins.
  Proof.
    intros t bytes_fin bytes_inf start seq_len BYTES_REF IHt uv_fins HFOLDR.
    generalize dependent start.
    generalize dependent uv_fins.
    induction seq_len using N.peano_ind; intros uv_fins start HFOLDR.
    - rewrite monad_fold_right_equation.
      rewrite monad_fold_right_equation in HFOLDR.
      cbn in HFOLDR; inv HFOLDR.
      cbn.
      exists [].
      split; auto.
    - rewrite monad_fold_right_equation.
      rewrite monad_fold_right_equation in HFOLDR.
      rewrite Nnat.N2Nat.inj_succ in *.
      rewrite <- cons_Nseq.
      rewrite <- cons_Nseq in HFOLDR.
      destruct
        (monad_fold_right
           (fun (acc : list LLVMParams64BitIntptr.Events.DV.uvalue) (idx : N) =>
              uv <-
                Memory64BitIntptr.MMEP.MemSpec.MemHelpers.deserialize_sbytes
                  (between (idx * FiniteSizeof.FinSizeof.sizeof_dtyp t) ((idx + 1) * FiniteSizeof.FinSizeof.sizeof_dtyp t) bytes_fin) t;;
              ret (uv :: acc)) (Nseq (N.succ start) (N.to_nat seq_len)) []) eqn:HFOLDR'; [cbn in HFOLDR; inv HFOLDR|].

      cbn in HFOLDR.
      break_match_hyp_inv.
      eapply IHt with
        (bytes_inf:=(between (start * FiniteSizeof.FinSizeof.sizeof_dtyp t) ((start + 1) * FiniteSizeof.FinSizeof.sizeof_dtyp t) bytes_inf)) in Heqs.

      2: {
        apply Forall2_between; auto.
      }

      destruct Heqs as (uv_inf&DESER_INFS&REF).

      apply IHseq_len in HFOLDR' as (uv_infs&HFOLDR'&REFS).

      exists (uv_inf :: uv_infs).
      split; auto.

      rewrite HFOLDR'.
      rewrite DESER_INFS.
      cbn.
      reflexivity.
  Qed.

  Lemma deserialize_sbytes_fin_inf :
    forall {t bytes_fin bytes_inf res_fin},
      sbytes_refine bytes_inf bytes_fin ->
      Memory64BitIntptr.MMEP.MemSpec.MemHelpers.deserialize_sbytes bytes_fin t = inr res_fin ->
      exists res_inf,
        MemoryBigIntptr.MMEP.MemSpec.MemHelpers.deserialize_sbytes bytes_inf t = inr res_inf /\
          DVC1.uvalue_refine_strict res_inf res_fin.
  Proof.
    Transparent Memory64BitIntptr.MMEP.MemSpec.MemHelpers.deserialize_sbytes.
    Transparent MemoryBigIntptr.MMEP.MemSpec.MemHelpers.deserialize_sbytes.
    intros t bytes_fin bytes_inf res_fin BYTES DESER.
    destruct t;
      cbn in DESER;
      cbn;
      cbn in *;
      inv DESER;
      eexists; split; eauto;
      apply from_ubytes_inf_fin; auto.
  Qed.

  Lemma monad_fold_right_deserialize_sbytes_fail_fin_inf :
    forall {t : dtyp} {bytes_fin bytes_inf}
      (start seq_len : N) (s : string)
      (BYTES_REF : sbytes_refine bytes_inf bytes_fin)
      (IHt : forall (bytes_fin : list Memory64BitIntptr.MP.BYTE_IMPL.SByte)
               (bytes_inf : list MemoryBigIntptr.MP.BYTE_IMPL.SByte) (s : string),
          sbytes_refine bytes_inf bytes_fin ->
          Memory64BitIntptr.MMEP.MemSpec.MemHelpers.deserialize_sbytes bytes_fin t = inl s ->
          MemoryBigIntptr.MMEP.MemSpec.MemHelpers.deserialize_sbytes bytes_inf t = inl s),
      monad_fold_right
        (fun (acc : list LLVMParams64BitIntptr.Events.DV.uvalue) (idx : N) =>
           uv <-
             Memory64BitIntptr.MMEP.MemSpec.MemHelpers.deserialize_sbytes
               (between (idx * FiniteSizeof.FinSizeof.sizeof_dtyp t)
                  ((idx + 1) * FiniteSizeof.FinSizeof.sizeof_dtyp t) bytes_fin) t;;
           @ret err _ _ (uv :: acc)) (Nseq start (N.to_nat seq_len)) [] = inl s ->
      (monad_fold_right
         (fun (acc : list LLVMParamsBigIntptr.Events.DV.uvalue) (idx : N) =>
            uv <-
              MemoryBigIntptr.MMEP.MemSpec.MemHelpers.deserialize_sbytes
                (between (idx * FiniteSizeof.FinSizeof.sizeof_dtyp t)
                   ((idx + 1) * FiniteSizeof.FinSizeof.sizeof_dtyp t) bytes_inf) t;;
            @ret err _ _ (uv :: acc)) (Nseq start (N.to_nat seq_len)) [] = inl s).
  Proof.
    intros t bytes_fin bytes_inf start seq_len s BYTES_REF IHt HFOLDR.
    generalize dependent start.
    generalize dependent s.
    induction seq_len using N.peano_ind; intros s start HFOLDR.
    - rewrite monad_fold_right_equation in HFOLDR.
      cbn in HFOLDR.
      inv HFOLDR.
    - rewrite Nnat.N2Nat.inj_succ in *.
      rewrite <- cons_Nseq in HFOLDR.
      rewrite monad_fold_right_equation in HFOLDR.
      rewrite <- cons_Nseq.
      rewrite monad_fold_right_equation.
      destruct (monad_fold_right
                  (fun (acc : list LLVMParams64BitIntptr.Events.DV.uvalue) (idx : N) =>
                     uv <-
                       Memory64BitIntptr.MMEP.MemSpec.MemHelpers.deserialize_sbytes
                         (between (idx * FiniteSizeof.FinSizeof.sizeof_dtyp t)
                            ((idx + 1) * FiniteSizeof.FinSizeof.sizeof_dtyp t) bytes_fin) t;;
                     ret (uv :: acc)) (Nseq (N.succ start) (N.to_nat seq_len)) []) eqn:HFOLDR'.
      + eapply IHseq_len in HFOLDR'.
        cbn in HFOLDR; inv HFOLDR.
        rewrite HFOLDR'.
        cbn; auto.
      + cbn in HFOLDR; inv HFOLDR.
        break_match_hyp_inv.
        eapply IHt in Heqs0; [|apply Forall2_between; eauto].

        eapply monad_fold_right_deserialize_sbytes_fin_inf in HFOLDR'; eauto.
        2: {
          intros bytes_fin0 bytes_inf0 res_fin H H0.
          eapply deserialize_sbytes_fin_inf; eauto.
        }
        destruct HFOLDR' as (uv_infs&HFOLDR'&REF).
        rewrite HFOLDR'.
        rewrite Heqs0.
        cbn; auto.
  Qed.

  Lemma deserialize_sbytes_fail_fin_inf :
    forall {t bytes_fin bytes_inf s},
      sbytes_refine bytes_inf bytes_fin ->
      Memory64BitIntptr.MMEP.MemSpec.MemHelpers.deserialize_sbytes bytes_fin t = inl s ->
      MemoryBigIntptr.MMEP.MemSpec.MemHelpers.deserialize_sbytes bytes_inf t = inl s.
  Proof.
    induction t; intros bytes_fin bytes_inf s BYTES DESER.
    all:
      try
        solve
        [ cbn in DESER;
          cbn;
          cbn in *;
          inv DESER;
          eexists; split; eauto;
          apply from_ubytes_inf_fin; auto
        ].
  Qed.

  (* TODO: Move this into memory model. Should be applicable to both fin / inf *)
  Lemma read_bytes_spec_length :
    forall ptr sz ms_start ms_final res,
      MemoryBigIntptr.MMEP.MemSpec.read_bytes_spec ptr sz ms_start (ret (ms_final, res)) ->
      length res = sz.
  Proof.
    intros ptr sz ms_start ms_final res RBS.
    unfold MemoryBigIntptr.MMEP.MemSpec.read_bytes_spec in RBS.
    apply MemPropT_bind_ret_inv in RBS as (ms_gcp&ptrs&GCP&MAPREAD).

    assert (ms_start = ms_gcp) as MSEQ.
    { eapply MemoryBigIntptr.MMEP.get_consecutive_ptrs_MemPropT_MemState_eq.
      eapply GCP.
    }
    subst.

    eapply withinify in GCP.

    assert ((@fmap err_ub_oom (@Functor_err_ub_oom IdentityMonad.ident IdentityMonad.Monad_ident)
               (MemoryBigIntptr.MMEP.MMSP.MemState * list LLVMParamsBigIntptr.ADDR.addr)
               (list LLVMParamsBigIntptr.ADDR.addr)
               (@snd MemoryBigIntptr.MMEP.MMSP.MemState (list LLVMParamsBigIntptr.ADDR.addr))
               (@ret err_ub_oom (@Monad_err_ub_oom IdentityMonad.ident IdentityMonad.Monad_ident)
                  (MemoryBigIntptr.MMEP.MMSP.MemState * list LLVMParamsBigIntptr.ADDR.addr)
                  (ms_gcp, ptrs))) = ret ptrs) as EQ by (cbn; auto).
    rewrite EQ in GCP.
    pose proof InfLLVM.MEM.MMEP.MemSpec.MemHelpers.get_consecutive_ptrs_length _ _ _ GCP; eauto.
    apply map_monad_MemPropT_length in MAPREAD.
    lia.
  Qed.

  Lemma handle_load_fin_inf :
    forall {t addr_fin addr_inf ms_fin_start ms_fin_final ms_inf_start res_fin},
      MemState_refine_prop ms_inf_start ms_fin_start ->
      DVC1.dvalue_refine_strict addr_inf addr_fin ->
      Memory64BitIntptr.MMEP.MemSpec.handle_memory_prop _
        (LLVMParams64BitIntptr.Events.Load t addr_fin) ms_fin_start (ret (ms_fin_final, res_fin)) ->
      exists res_inf ms_inf_final,
        MemoryBigIntptr.MMEP.MemSpec.handle_memory_prop _
          (LLVMParamsBigIntptr.Events.Load t addr_inf) ms_inf_start (ret (ms_inf_final, res_inf)) /\
          DVC1.uvalue_refine_strict res_inf res_fin /\
          MemState_refine_prop ms_inf_final ms_fin_final.
  Proof.
    intros t addr_fin addr_inf ms_fin_start ms_fin_final ms_inf_start res_fin MSR ADDR_REF HANDLE.

    red in HANDLE.
    induction addr_fin;
      try
        solve
        [ rewrite DVC1.dvalue_refine_strict_equation in ADDR_REF;
          first
            [ apply dvalue_convert_strict_i1_inv in ADDR_REF
            | apply dvalue_convert_strict_i8_inv in ADDR_REF
            | apply dvalue_convert_strict_i32_inv in ADDR_REF
            | apply dvalue_convert_strict_i64_inv in ADDR_REF
            | apply dvalue_convert_strict_iptr_inv in ADDR_REF
            | apply dvalue_convert_strict_addr_inv in ADDR_REF
            | apply dvalue_convert_strict_double_inv in ADDR_REF
            | apply dvalue_convert_strict_float_inv in ADDR_REF
            | apply dvalue_convert_strict_poison_inv in ADDR_REF
            | apply dvalue_convert_strict_oom_inv in ADDR_REF
            | apply dvalue_convert_strict_none_inv in ADDR_REF
            | apply dvalue_convert_strict_struct_inv in ADDR_REF
            | apply dvalue_convert_strict_packed_struct_inv in ADDR_REF
            | apply dvalue_convert_strict_array_inv in ADDR_REF
            | apply dvalue_convert_strict_vector_inv in ADDR_REF
            ];
          first
            [ destruct ADDR_REF as (?&?&?); subst
            | inv ADDR_REF
            ];

          exists (fin_to_inf_uvalue res_fin);
          exists (lift_MemState ms_fin_final);
          cbn; repeat (split; auto);
          apply fin_to_inf_uvalue_refine_strict
        ].

    (* Main successful portion of the lemma *)
    unfold MemoryBigIntptr.MMEP.MemSpec.handle_memory_prop.
    eapply dvalue_refine_strict_addr_r_inv in ADDR_REF as (ptr_inf&PTR_INF&PTR_REF).
    subst.

    eapply MemPropT_fin_inf_bind.
    4: apply HANDLE.
    all: eauto.

    { (* MA: read_bytes_spec *)
      intros a_fin ms_fin_ma READ.
      eapply fin_inf_read_bytes_spec; eauto.
      apply READ.
    }

    intros ms_inf ms_fin ms_fin' a_fin a_inf b_fin BYTES_REF MSR_LOAD RBS DESERIALIZE.
    unfold lift_err_RAISE_ERROR in *.

    break_match_hyp.
    - cbn in DESERIALIZE.
      contradiction.
    - eapply deserialize_sbytes_fin_inf in Heqs; eauto.
      destruct Heqs as (?&?&?).
      cbn in DESERIALIZE.
      destruct DESERIALIZE; subst.
      rewrite H.
      exists x. exists ms_inf.
      split; cbn; auto.
  Qed.

  Lemma handle_load_fin_inf_ub :
    forall {t addr_fin addr_inf ms_fin_start ms_inf_start msg},
      MemState_refine_prop ms_inf_start ms_fin_start ->
      DVC1.dvalue_refine_strict addr_inf addr_fin ->
      Memory64BitIntptr.MMEP.MemSpec.handle_memory_prop _
        (LLVMParams64BitIntptr.Events.Load t addr_fin) ms_fin_start (raise_ub msg) ->
      MemoryBigIntptr.MMEP.MemSpec.handle_memory_prop _
        (LLVMParamsBigIntptr.Events.Load t addr_inf) ms_inf_start (raise_ub msg).
  Proof.
    intros t addr_fin addr_inf ms_fin_start ms_inf_start msg MSR ADDR_REF HANDLE.

    red in HANDLE.
    induction addr_fin;
      try
        solve
        [ rewrite DVC1.dvalue_refine_strict_equation in ADDR_REF;
          first
            [ apply dvalue_convert_strict_i1_inv in ADDR_REF
            | apply dvalue_convert_strict_i8_inv in ADDR_REF
            | apply dvalue_convert_strict_i32_inv in ADDR_REF
            | apply dvalue_convert_strict_i64_inv in ADDR_REF
            | apply dvalue_convert_strict_iptr_inv in ADDR_REF
            | apply dvalue_convert_strict_addr_inv in ADDR_REF
            | apply dvalue_convert_strict_double_inv in ADDR_REF
            | apply dvalue_convert_strict_float_inv in ADDR_REF
            | apply dvalue_convert_strict_poison_inv in ADDR_REF
            | apply dvalue_convert_strict_oom_inv in ADDR_REF
            | apply dvalue_convert_strict_none_inv in ADDR_REF
            | apply dvalue_convert_strict_struct_inv in ADDR_REF
            | apply dvalue_convert_strict_packed_struct_inv in ADDR_REF
            | apply dvalue_convert_strict_array_inv in ADDR_REF
            | apply dvalue_convert_strict_vector_inv in ADDR_REF
            ]; subst; cbn; auto;
          first [destruct ADDR_REF as (?&?&?)
                | destruct ADDR_REF as (?&?)]; subst; cbn; auto
        ].

    { (* Main successful portion of the lemma *)
      unfold MemoryBigIntptr.MMEP.MemSpec.handle_memory_prop.
      eapply dvalue_refine_strict_addr_r_inv in ADDR_REF as (ptr_inf&PTR_INF&PTR_REF).
      subst.

      eapply MemPropT_fin_inf_bind_ub.
      5: apply HANDLE.
      all: eauto with FinInf.

      { (* MA: read_bytes_spec *)
        intros a_fin ms_fin_ma READ.
        eapply fin_inf_read_bytes_spec; eauto.
        apply READ.
      }

      { intros msg0 H.
        eapply fin_inf_read_bytes_spec_ub'; eauto.
      }

      intros ms_inf ms_fin a_fin a_inf msg0 H H0 H1 H2.
      red.
      cbn in H2.
      red in H2.
      break_match_hyp; cbn in H2; try contradiction.
    }

    Unshelve.
    all: eauto.
  Qed.

  #[global] Hint Resolve handle_load_fin_inf handle_load_fin_inf_ub : FinInf.

  (* TODO: Move to where the other frame stack lemmas are *)
  Lemma cannot_pop_fin_inf :
    forall {ms_fin ms_inf},
      MemState_refine_prop ms_inf ms_fin ->
      Memory64BitIntptr.MMEP.MemSpec.cannot_pop ms_fin ->
      MemoryBigIntptr.MMEP.MemSpec.cannot_pop ms_inf.
  Proof.
    intros ms_fin ms_inf MSR NPOP.
    red.
    red in NPOP.
    intros fs1 fs2 MSFP POP.
    red in POP.
    break_match_hyp; auto.
    pose proof MemState_refine_prop_frame_stack_preserved _ _ MSR as FSP.
    red in FSP.
    pose proof MSFP as MSFP_FIN.
    apply FSP in MSFP_FIN.
    red in MSFP_FIN.
    destruct ms_inf as [[ms_inf fss_inf hs_inf] msprovs_inf].
    destruct ms_fin as [[ms_fin fss_fin hs_fin] msprovs_fin].
    cbn in *.
    subst.
    cbn in *.
    red in MSFP.
    cbn in *.

    specialize (NPOP fss_fin).
    destruct fss_fin.
    { cbn in *.
      apply MemoryBigIntptrInfiniteSpec.MMSP.frame_stack_eqv_sing_snoc_inv in MSFP_FIN.
      auto.
    }

    specialize (NPOP fss_fin).
    forward NPOP.
    { red; cbn. reflexivity. }
    eapply NPOP.
    red.
    reflexivity.
  Qed.

  (* TODO: Move to where the other frame stack lemmas are *)
  Lemma cannot_pop_inf_fin :
    forall {ms_fin ms_inf},
      MemState_refine_prop ms_inf ms_fin ->
      MemoryBigIntptr.MMEP.MemSpec.cannot_pop ms_inf ->
      Memory64BitIntptr.MMEP.MemSpec.cannot_pop ms_fin.
  Proof.
    intros ms_fin ms_inf MSR NPOP.
    red.
    red in NPOP.
    intros fs1 fs2 MSFP POP.
    red in POP.
    break_match_hyp; auto.

    (* Finite memory had frame to pop *)
    destruct ms_fin as [[ms_fin fss_fin hs_fin] msprovs_fin].
    cbn in *.
    specialize (NPOP (lift_FrameStack fss_fin) (lift_FrameStack fs2)).
    eapply NPOP.
    { eapply MemState_refine_prop_frame_stack_preserved; eauto.
      red.
      cbn in *.
      reflexivity.
    }

    red.
    red in MSFP.
    cbn in MSFP.
    destruct fss_fin; subst.
    - cbn; apply FinMem.MMEP.MMSP.frame_stack_eqv_sing_snoc_inv in MSFP; auto.
    - rewrite lift_FrameStack_snoc.
      apply FinMemMMSP.frame_stack_inv in MSFP.
      destruct MSFP as [MSFP | CONTRA].
      2: {
        destruct CONTRA as (?&?&?&?).
        inv H.
      }

      destruct MSFP as (?&?&?&?&?&?&?&?).
      inv H.
      inv H0.
      apply frame_stack_eqv_lift.
      rewrite H1.
      rewrite POP.
      reflexivity.
  Qed.


  (* TODO: Move into memory model. Likely near MEM_EXEC_INTERP.MemTheory.allocate_bytes_spec_MemPropT_no_err *)
  Lemma allocate_dtyp_spec_no_error :
    forall t num_elements ms msg,
      Memory64BitIntptr.MMEP.MemSpec.allocate_dtyp_spec t num_elements ms (raise_error msg) -> False.
  Proof.
    intros t num_elements ms msg HANDLE.
    repeat red in HANDLE.
    destruct HANDLE as [ASSERT | HANDLE].
    { cbn in ASSERT; auto. }
    destruct HANDLE as (?&[]&ASSERT&HANDLE).
    cbn in ASSERT.
    destruct ASSERT; subst.
    rename H0 into ASSERT.
    destruct HANDLE as [FRESH | HANDLE].
    - cbn in FRESH; auto.
    - destruct HANDLE as (?&?&?&?).
      repeat red in H0.
      destruct H0.
      + (* TODO: Could probably make this a more general lemma about repeatMN / map_monad *)
        red in H0.
        red in H0.

        clear H.
        generalize dependent x.
        generalize dependent x0.
        induction num_elements using N.peano_ind; intros x0 H0 x.
        * cbn in H0; auto.
        * rewrite repeatN_succ in H0.
          rewrite map_monad_unfold in H0.
          repeat red in H0.
          destruct H0.
          -- red in H. cbn in H. red in H.
             break_match_hyp_inv.
          -- destruct H as (?&?&?&?).
             repeat red in H0.
             destruct H0.
             ++ apply IHnum_elements in H0; auto.
             ++ destruct H0 as (?&?&?&?).
                cbn in H1.
                auto.
      + destruct H0 as (?&?&?&?).
        apply MEM_EXEC_INTERP.MemTheory.allocate_bytes_spec_MemPropT_no_err in H1; auto.
  Qed.

  (* TODO: Move into memory model. Likely near MEM_EXEC_INTERP.MemTheory.allocate_bytes_spec_MemPropT_no_err *)
  Lemma handle_alloca_no_error :
    forall t num_elements align ms msg,
      Memory64BitIntptr.MMEP.MemSpec.handle_memory_prop LLVMParams64BitIntptr.Events.DV.dvalue
        (LLVMParams64BitIntptr.Events.Alloca t num_elements align) ms (raise_error msg) ->
      False.
  Proof.
    intros t num_elements align ms msg HANDLE.
    repeat red in HANDLE.
    destruct HANDLE as [HANDLE | HANDLE].
    - apply allocate_dtyp_spec_no_error in HANDLE; auto.
    - destruct HANDLE as (?&?&?&?).
      cbn in H0.
      auto.
  Qed.

  (* TODO: Move this, should apply for fin / inf *)
  Lemma mempush_spec_always_succeeds :
    forall m1,
    exists m2,
      Memory64BitIntptr.MMEP.MemSpec.mempush_spec m1 m2.
  Proof.
    (* Should I just use mempush? *)
    intros m1.
    remember m1.
    destruct m as [m1_stack m1_prov].
    destruct m1_stack as [m1_memory m1_fs m1_heap].
    remember (Memory64BitIntptr.MMEP.push_frame_stack m1_fs Memory64BitIntptr.MMEP.initial_frame) as m2_fs.
    exists (Memory64BitIntptr.MMEP.mem_state_set_frame_stack m1 m2_fs).

    split.
    - intros fs1 fs2 f H H0 H1.
      cbn in *.
      red in H.
      cbn in *.
      red.
      unfold Memory64BitIntptr.MMEP.mem_state_set_frame_stack.
      subst.
      cbn.
      destruct H1.
      red in can_pop.
      red in new_frame.
      break_match_hyp; try contradiction.
      unfold Memory64BitIntptr.MMEP.push_frame_stack.
      subst.
      rewrite H.
      rewrite can_pop.
      unfold Memory64BitIntptr.MMEP.initial_frame in *.
      rewrite FinMem.MMEP.empty_frame_eqv; eauto.
      2: apply Memory64BitIntptr.MMEP.empty_frame_nil.
      rewrite new_frame.
      reflexivity.
    - subst.
      split.
      ++ (* read_byte_preserved *)
        (* TODO: solve_read_byte_preserved. *)
        split.
        ** (* solve_read_byte_allowed_all_preserved. *)
          intros ?ptr; split; intros ?READ.
          --- (* read_byte_allowed *)
            apply Memory64BitIntptr.MMEP.read_byte_allowed_set_frame_stack; eauto.
          --- (* read_byte_allowed *)
            (* TODO: solve_read_byte_allowed *)
            eapply Memory64BitIntptr.MMEP.read_byte_allowed_set_frame_stack; eauto.
        ** (* solve_read_byte_prop_all_preserved. *)
          apply Memory64BitIntptr.MMEP.read_byte_prop_set_frame_stack.
      ++ (* write_byte_allowed_all_preserved *)
        apply Memory64BitIntptr.MMEP.write_byte_allowed_all_preserved_set_frame_stack.
      ++ (* free_byte_allowed_all_preserved *)
        apply Memory64BitIntptr.MMEP.free_byte_allowed_all_preserved_set_frame_stack.
      ++ (* allocations_preserved *)
        (* TODO: move to solve_allocations_preserved *)
        apply Memory64BitIntptr.MMEP.allocations_preserved_set_frame_stack.
      ++ (* preserve_allocation_ids *)
        (* TODO: solve_preserve_allocation_ids *)
        apply Memory64BitIntptr.MMEP.preserve_allocation_ids_set_frame_stack.
      ++ (* TODO: solve_heap_preserved. *)
        unfold Memory64BitIntptr.MMEP.mem_state_set_frame_stack.
        red.
        unfold Memory64BitIntptr.MMEP.MMSP.memory_stack_heap_prop. cbn.
        unfold Memory64BitIntptr.MMEP.MMSP.memory_stack_heap.
        red. reflexivity.
  Qed.

  Lemma fin_inf_malloc_bytes_with_pr_spec_MemPropT_ub :
    forall bytes_fin bytes_inf sid ms_fin ms_fin' ms_inf ms_inf' msg,
      MemState_refine_prop ms_inf ms_fin ->
      MemState_refine_prop ms_inf' ms_fin' ->
      sbytes_refine bytes_inf bytes_fin ->
      Memory64BitIntptr.MMEP.MemSpec.malloc_bytes_with_pr_spec_MemPropT bytes_fin sid ms_fin' (raise_ub msg) ->
      MemoryBigIntptr.MMEP.MemSpec.malloc_bytes_with_pr_spec_MemPropT bytes_inf sid ms_inf' (raise_ub msg).
  Proof.
    intros bytes_fin bytes_inf sid ms_fin ms_fin' ms_inf ms_inf' msg MSR1 MSR2 BYTES_REF MALLOC.
    red; red in MALLOC.

    eapply MemPropT_fin_inf_bind_ub.
    5: apply MALLOC.
    all: eauto with FinInf.

    { intros a_fin ms_fin_ma H.
      eapply find_free_block_fin_inf; eauto.
      erewrite sbytes_refine_length; eauto.
    }

    intros ms_inf0 ms_fin0 a_fin a_inf msg0 REF MSR FIND_FREE MALLOC'.
    cbn in *.
    break_match_hyp.
    destruct MALLOC' as [[] | (?&?&?&[])].

    Unshelve.
    apply ms_fin.
  Qed.

  #[global] Hint Resolve fin_inf_malloc_bytes_with_pr_spec_MemPropT_ub : FinInf.

  Lemma fin_inf_malloc_bytes_with_pr_spec_MemPropT_error :
    forall bytes_fin bytes_inf sid ms_fin ms_fin' ms_inf ms_inf' msg,
      MemState_refine_prop ms_inf ms_fin ->
      MemState_refine_prop ms_inf' ms_fin' ->
      sbytes_refine bytes_inf bytes_fin ->
      Memory64BitIntptr.MMEP.MemSpec.malloc_bytes_with_pr_spec_MemPropT bytes_fin sid ms_fin' (raise_error msg) ->
      MemoryBigIntptr.MMEP.MemSpec.malloc_bytes_with_pr_spec_MemPropT bytes_inf sid ms_inf' (raise_error msg).
  Proof.
    intros bytes_fin bytes_inf sid ms_fin ms_fin' ms_inf ms_inf' msg MSR1 MSR2 BYTES_REF MALLOC.
    red; red in MALLOC.

    eapply MemPropT_fin_inf_bind_error.
    5: apply MALLOC.
    all: eauto with FinInf.

    { intros a_fin ms_fin_ma H.
      eapply find_free_block_fin_inf; eauto.
      erewrite sbytes_refine_length; eauto.
    }

    intros ms_inf0 ms_fin0 a_fin a_inf msg0 REF MSR FIND_FREE MALLOC'.
    cbn in *.
    break_match_hyp.
    destruct MALLOC' as [[] | (?&?&?&[])].

    Unshelve.
    apply ms_fin.
  Qed.

  #[global] Hint Resolve fin_inf_malloc_bytes_with_pr_spec_MemPropT_error : FinInf.

  Lemma fin_inf_malloc_bytes_spec_MemPropT_ub :
    forall bytes_fin bytes_inf ms_fin ms_inf msg,
      MemState_refine_prop ms_inf ms_fin ->
      sbytes_refine bytes_inf bytes_fin ->
      Memory64BitIntptr.MMEP.MemSpec.malloc_bytes_spec_MemPropT bytes_fin ms_fin (raise_ub msg) ->
      MemoryBigIntptr.MMEP.MemSpec.malloc_bytes_spec_MemPropT bytes_inf ms_inf (raise_ub msg).
  Proof.
    intros bytes_fin bytes_inf ms_fin ms_inf msg MSR BYTES MALLOC.
    red; red in MALLOC.

    eapply MemPropT_fin_inf_bind_ub.
    5: apply MALLOC.
    all: eauto with FinInf.

    intros ms_inf0 ms_fin0 sid a_inf msg0 EQ MSR' FRESH_PR MALLOC'.
    cbn in EQ; subst.
    eapply fin_inf_malloc_bytes_with_pr_spec_MemPropT_ub in MALLOC'; eauto.

    Unshelve.
    eauto.
  Qed.

  #[global] Hint Resolve fin_inf_malloc_bytes_spec_MemPropT_ub : FinInf.

  Lemma fin_inf_malloc_bytes_spec_MemPropT_error :
    forall bytes_fin bytes_inf ms_fin ms_inf msg,
      MemState_refine_prop ms_inf ms_fin ->
      sbytes_refine bytes_inf bytes_fin ->
      Memory64BitIntptr.MMEP.MemSpec.malloc_bytes_spec_MemPropT bytes_fin ms_fin (raise_error msg) ->
      MemoryBigIntptr.MMEP.MemSpec.malloc_bytes_spec_MemPropT bytes_inf ms_inf (raise_error msg).
  Proof.
    intros bytes_fin bytes_inf ms_fin ms_inf msg MSR BYTES MALLOC.
    red; red in MALLOC.

    eapply MemPropT_fin_inf_bind_error.
    5: apply MALLOC.
    all: eauto with FinInf.

    intros ms_inf0 ms_fin0 sid a_inf msg0 EQ MSR' FRESH_PR MALLOC'.
    cbn in EQ; subst.
    eapply fin_inf_malloc_bytes_with_pr_spec_MemPropT_error in MALLOC'; eauto.

    Unshelve.
    eauto.
  Qed.

  #[global] Hint Resolve fin_inf_malloc_bytes_spec_MemPropT_error : FinInf.

  (* TODO: Move. Should apply to fin / inf *)
  Lemma ptr_in_heap_prop_dec :
    forall h root ptr,
      {MemoryBigIntptr.MMEP.MMSP.ptr_in_heap_prop h root ptr} + {~ MemoryBigIntptr.MMEP.MMSP.ptr_in_heap_prop h root ptr}.
  Proof.
    intros h root ptr.
    unfold MemoryBigIntptr.MMEP.MMSP.ptr_in_heap_prop.
    destruct (IntMaps.IM.find (elt:=MemoryBigIntptr.MMEP.MMSP.Block) (LLVMParamsBigIntptr.PTOI.ptr_to_int root) h) eqn:FIND; eauto.
    eapply in_dec.
    eapply Z.eq_dec.
  Qed.

  (* TODO: move this *)
  Lemma inf_fin_free_preconditions :
    forall {ms_inf_start : InfMem.MMEP.MMSP.MemState}
      {ms_fin_start : FinMem.MMEP.MMSP.MemState}
      {ptr_fin : FinAddr.addr} {ptr_inf : InfAddr.addr},
      MemState_refine_prop ms_inf_start ms_fin_start ->
      addr_refine ptr_inf ptr_fin ->
      MemoryBigIntptr.MMEP.MemSpec.free_preconditions ms_inf_start ptr_inf ->
      Memory64BitIntptr.MMEP.MemSpec.free_preconditions ms_fin_start ptr_fin.
  Proof.
    intros ms_inf_start ms_fin_start ptr_fin ptr_inf MSR ADDR_REF FREE_SPEC.
    destruct FREE_SPEC.
    split.
    - eapply root_in_memstate_heap_inf_fin; eauto.
    - destruct free_was_allocated.
      eapply inf_fin_byte_allocated in H; eauto.
    - intros ptr H.
      eapply @ptr_in_memstate_heap_fin_inf with (ptr_inf:=fin_to_inf_addr ptr) in H; eauto.
      2: apply addr_refine_fin_to_inf_addr.
      eapply free_block_allocated in H.
      destruct H.
      eapply inf_fin_byte_allocated in H; eauto.
      apply addr_refine_fin_to_inf_addr.
  Qed.

  (* TODO: Prove this / move this *)
  Lemma inf_fin_free_spec :
    forall {ms_inf_start : InfMem.MMEP.MMSP.MemState}
      {ms_inf_final : InfMem.MMEP.MMSP.MemState} {ms_fin_start : FinMem.MMEP.MMSP.MemState}
      {ptr_fin : FinAddr.addr} {ptr_inf : InfAddr.addr},
      MemState_refine_prop ms_inf_start ms_fin_start ->
      addr_refine ptr_inf ptr_fin ->
      MemoryBigIntptr.MMEP.MemSpec.free_preconditions ms_inf_start ptr_inf ->
      MemoryBigIntptr.MMEP.MemSpec.free_spec ms_inf_start ptr_inf ms_inf_final ->
      exists ms_fin_final : Memory64BitIntptr.MMEP.MMSP.MemState,
        Memory64BitIntptr.MMEP.MemSpec.free_spec ms_fin_start ptr_fin ms_fin_final /\
          MemState_refine_prop ms_inf_final ms_fin_final.
  Proof.
    intros ms_inf_start ms_inf_final ms_fin_start ptr_fin ptr_inf MSR ADDR_REF FREE_PRE FREE_SPEC.
    destruct FREE_SPEC.

    (* How do I get an appropriate MemState for this?

       A better question might be... When I have an ms_inf, what can
       make it so I cannot have an ms_fin such that...

       MemState_refine_prop ms_inf ms_fin

       MemState_refine_prop =
       fun (ms_inf : InfMem.MMEP.MMSP.MemState) (ms_fin : FinMem.MMEP.MMSP.MemState) =>
       let ms_fin_lifted := lift_MemState ms_fin in InfMem.MMEP.MemSpec.MemState_eqv ms_inf ms_fin_lifted
       : InfMem.MMEP.MMSP.MemState -> FinMem.MMEP.MMSP.MemState -> Prop

       InfMem.MMEP.MemSpec.MemState_eqv =
       fun ms1 ms2 : InfMem.MMEP.MMSP.MemState =>
       InfMem.MMEP.MemSpec.preserve_allocation_ids ms1 ms2 /\
       InfMem.MMEP.MemSpec.read_byte_preserved ms1 ms2 /\
       InfMem.MMEP.MemSpec.write_byte_allowed_all_preserved ms1 ms2 /\
       InfMem.MMEP.MemSpec.free_byte_allowed_all_preserved ms1 ms2 /\
       InfMem.MMEP.MemSpec.allocations_preserved ms1 ms2 /\
       InfMem.MMEP.MemSpec.frame_stack_preserved ms1 ms2 /\ InfMem.MMEP.MemSpec.heap_preserved ms1 ms2

       HMMMM. Maybe I can use convert_MemState?
     *)

    destruct (convert_MemState ms_inf_final) as [ms_fin_final | ] eqn:MS_FIN_FINAL.
    2: {
      exfalso.

      destruct ms_fin_start as [[ms_fin fss_fin hs_fin] msprovs_fin].
      destruct ms_inf_start as [[ms_inf fss_inf hs_inf] msprovs_inf].
      destruct ms_inf_final as [[ms_inf' fss_inf' hs_inf'] msprovs_inf'].

      unfold convert_MemState in MS_FIN_FINAL.
      cbn in MS_FIN_FINAL.
      repeat break_match_hyp_inv.
      { (* convert_Heap OOM *)
        (* Block failed to convert, which means there's an out of
           bounds address in the block... *)
        apply map_monad_OOM_fail in Heqo2.
        destruct Heqo2 as ((root&block)&?&?).
        break_match_hyp_inv.

        apply map_monad_OOM_fail in Heqo0.
        destruct Heqo0 as (bad_addr&IN_BLOCK&BAD_CONV).

        (* Where did this bad_addr come from?

           There should be a contradiction within free_block's
           free_block_prop...
         *)

        clear - MSR ADDR_REF IN_BLOCK BAD_CONV H free_block.
        apply MemState_refine_prop_heap_preserved in MSR.
        cbn in *.
        red in MSR.
        unfold MemoryBigIntptr.MMEP.MMSP.memory_stack_heap_prop in *.
        cbn in *.

        specialize (free_block hs_inf hs_inf').
        repeat (forward free_block; [reflexivity|]).
        destruct free_block.

      (* Need to know if root is disjoint from ptr_inf or not...

         ptr_inf is the pointer being freed.

         - If root is not disjoint then free_block_root_freed might be
           a contradiction.
         - If root is disjoint then it should exist in hs_inf already,
           which should lead to a contradiction with free_block_disjoint_preserved.
       *)

        pose proof (Z.eq_dec (LLVMParamsBigIntptr.PTOI.ptr_to_int ptr_inf) root) as [NDISJOINT | DISJOINT].
        { (* Not disjoint *)
          red in ADDR_REF.
          eapply free_block_root_freed.
          red.
          rewrite NDISJOINT.
          eapply SetoidList.In_InA in H.
          eapply IntMaps.IP.F.elements_mapsto_iff in H.
          2: typeclasses eauto.
          eapply IntMaps.IP.F.find_mapsto_iff in H.
          eapply IntMaps.lookup_member.
          unfold IntMaps.lookup.
          rewrite H.
          reflexivity.
        }

        { (* Disjoint *)
          pose proof InfITOP_BIG.int_to_ptr_safe root InfPROV.nil_prov.
          break_match_hyp_inv.
          rename a into root_ptr.
          pose proof InfITOP.ptr_to_int_int_to_ptr _ _ _ Heqo as ROOT.

          specialize (free_block_disjoint_preserved bad_addr root_ptr).
          forward free_block_disjoint_preserved.
          { red.
            lia.
          }

          assert (MemoryBigIntptr.MMEP.MMSP.ptr_in_heap_prop hs_inf' root_ptr bad_addr) as IN_HEAP.
          { red.
            eapply SetoidList.In_InA in H.
            eapply IntMaps.IP.F.elements_mapsto_iff in H.
            2: typeclasses eauto.
            eapply IntMaps.IP.F.find_mapsto_iff in H.
            subst.
            rewrite H.
            eapply in_map; eauto.
          }

          apply free_block_disjoint_preserved in IN_HEAP.
          specialize (MSR hs_inf).
          destruct MSR as [MSR _]; forward MSR; [red; reflexivity|].
          rewrite <- MSR in IN_HEAP.
          eapply ptr_in_heap_prop_lift_inv in IN_HEAP.
          destruct IN_HEAP as (?&?&?&CONV&?).
          rewrite BAD_CONV in CONV.
          inv CONV.
        }
      }

      { (* convert_FrameStack OOM *)
        (* Must be an address in one of the frames that does not
           convert... Frames are preserved, though.
         *)

        destruct free_invariants.
        clear - MSR ADDR_REF Heqo free_frame_stack_preserved.
        apply MemState_refine_prop_frame_stack_preserved in MSR.
        cbn in *.
        red in MSR, free_frame_stack_preserved.
        unfold MemoryBigIntptr.MMEP.MMSP.memory_stack_frame_stack_prop in *.
        cbn in *.

        specialize (MSR fss_inf).
        destruct MSR as [MSR _]; forward MSR; [red; reflexivity|].

        specialize (free_frame_stack_preserved fss_inf).
        destruct free_frame_stack_preserved as [FSP _]; forward FSP; [red; reflexivity|].
        red in FSP, MSR. rewrite <- MSR in FSP.

        symmetry in FSP.
        generalize dependent fss_inf.
        generalize dependent fss_inf'.
        induction fss_fin; intros fss_inf' FSP Heqo fss_inf MSR.
        - cbn in FSP.
          apply InfMemMMSP.frame_stack_inv in FSP.
          destruct FSP as [CONTRA | FSP].
          { destruct CONTRA as (?&?&?&?&?&?&?).
            inv H.
          }

          destruct FSP as (f1&f2&F&F2&EQV).
          subst.
          inv F.

          cbn in Heqo.
          break_match_hyp_inv.

          unfold convert_Frame in Heqo0.
          apply map_monad_OOM_fail in Heqo0.
          destruct Heqo0 as (bad_addr&IN_BLOCK&BAD_CONV).
          red in EQV.
          unfold InfMemMMSP.ptr_in_frame_prop in EQV.
          eapply in_map in IN_BLOCK.
          eapply EQV in IN_BLOCK.
          unfold lift_Frame in IN_BLOCK.
          apply in_map_iff in IN_BLOCK.
          destruct IN_BLOCK as (?&?&?).
          apply in_map_iff in H0.
          destruct H0 as (?&?&?).
          subst.
          pose proof fin_to_inf_addr_ptr_to_int x0.
          rewrite H in H0.
          unfold InfToFinAddrConvert.addr_convert in BAD_CONV.
          destruct bad_addr.
          destruct x0.
          pose proof LLVMParams64BitIntptr.ITOP.int_to_ptr_ptr_to_int (i0, p0) p0.
          forward H2; cbn; auto.
          cbn in *.
          rewrite <- H0 in H2.
          eapply int_to_ptr_succeeds_regardless_of_provenance in H2 as (?&?).
          rewrite BAD_CONV in H2.
          inv H2.
        - rewrite lift_FrameStack_snoc in MSR.
          apply InfMemMMSP.frame_stack_inv in FSP.
          destruct FSP as [FSP | CONTRA].
          2: {
            destruct CONTRA as (?&?&?&?).
            inv H.
          }

          destruct FSP as (fs1'&fs2'&f1&f2&SNOC&SNOC'&FSEQV&FEQV).
          subst.

          rewrite lift_FrameStack_snoc in SNOC.
          cbn in SNOC.
          inv SNOC.
          cbn in SNOC'; subst.

          rewrite convert_FrameStack_Snoc_equation in Heqo.
          cbn in Heqo.
          repeat break_match_hyp_inv.

          { (* First frame converts *)
            specialize (IHfss_fin fs2' FSEQV Heqo (lift_FrameStack fss_fin)).
            eapply IHfss_fin; reflexivity.
          }

          { (* First frame OOMs *)
            unfold convert_Frame in Heqo0.
            apply map_monad_OOM_fail in Heqo0.
            destruct Heqo0 as (bad_addr&IN_BLOCK&BAD_CONV).
            red in FEQV.
            unfold InfMemMMSP.ptr_in_frame_prop in FEQV.
            eapply in_map in IN_BLOCK.
            eapply FEQV in IN_BLOCK.
            unfold lift_Frame in IN_BLOCK.
            apply in_map_iff in IN_BLOCK.
            destruct IN_BLOCK as (?&?&?).
            apply in_map_iff in H0.
            destruct H0 as (?&?&?).
            subst.
            pose proof fin_to_inf_addr_ptr_to_int x0.
            rewrite H in H0.
            unfold InfToFinAddrConvert.addr_convert in BAD_CONV.
            destruct bad_addr.
            destruct x0.
            pose proof LLVMParams64BitIntptr.ITOP.int_to_ptr_ptr_to_int (i0, p0) p0.
            forward H2; cbn; auto.
            cbn in *.
            rewrite <- H0 in H2.
            eapply int_to_ptr_succeeds_regardless_of_provenance in H2 as (?&?).
            rewrite BAD_CONV in H2.
            inv H2.
          }
      }

      { (* convert_memory OOM *)
        unfold MemoryBigIntptr.MMEP.MemSpec.ptr_in_memstate_heap in *.
        unfold MemoryBigIntptr.MMEP.MMSP.memory_stack_heap_prop in *.
        cbn in free_bytes_freed.
        eapply MemState_refine_prop_allocations_preserved in MSR.
        red in MSR.

        apply map_monad_OOM_fail in Heqo.
        destruct Heqo as (bad_byte&IN_BLOCK&BAD_CONV).
        destruct bad_byte.
        break_match_hyp_inv.
        2: {
          destruct m.
          assert (MemoryBigIntptr.MMEP.MemSpec.byte_allocated
                    {|
                      InfMemMMSP.ms_memory_stack :=
                        {|
                          InfMemMMSP.memory_stack_memory := ms_inf';
                          InfMemMMSP.memory_stack_frame_stack := fss_inf';
                          InfMemMMSP.memory_stack_heap := hs_inf'
                        |};
                      InfMemMMSP.ms_provenance := msprovs_inf'
                    |} (k, PROV.nil_prov) a).
          { cbn.
            repeat red.
            cbn.
            Transparent MemoryBigIntptr.MMEP.MMSP.read_byte_raw.
            unfold MemoryBigIntptr.MMEP.MMSP.read_byte_raw.
            Opaque MemoryBigIntptr.MMEP.MMSP.read_byte_raw.
            eapply SetoidList.In_InA in IN_BLOCK.
            eapply IntMaps.IP.F.elements_mapsto_iff in IN_BLOCK.
            2: typeclasses eauto.
            eapply IntMaps.IP.F.find_mapsto_iff in IN_BLOCK.
            rewrite IN_BLOCK.
            symmetry; apply InfPROV.aid_eq_dec_refl.
          }

          (* Need to know if k is in the freed block or not *)
          pose proof (ptr_in_heap_prop_dec hs_inf ptr_inf (k, PROV.nil_prov)) as [IN_HEAP | NIN_HEAP].
          { (* k is in freed block *)
            eapply free_bytes_freed.
            intros h H0.
            rewrite <- H0.
            apply IN_HEAP.
            eauto.
          }

          (* k is not in the freed block *)
          pose proof H as ALLOC.
          apply free_non_block_bytes_preserved in ALLOC.
          2: {
            intros CONTRA.
            cbn in CONTRA.
            specialize (CONTRA hs_inf).
            forward CONTRA; [reflexivity|].

            red in CONTRA.
            break_match_hyp; auto.
            apply in_map_iff in CONTRA.
            destruct CONTRA as (?&?&?).
            cbn in H1.

            eapply NIN_HEAP.
            red.
            rewrite Heqo0.
            cbn.
            rewrite <- H1.
            eapply in_map; eauto.
          }

          (* k was allocated in the original finite memory, which
             should mean it must be in bounds. *)
          apply MSR in ALLOC.
          rename Heqo into CONTRA.
          move CONTRA before ALLOC.

          repeat red in ALLOC.
          cbn in ALLOC.
          break_match_hyp; auto.

          destruct m.
          Transparent MemoryBigIntptr.MMEP.MMSP.read_byte_raw.
          unfold MemoryBigIntptr.MMEP.MMSP.read_byte_raw in Heqo.
          Opaque MemoryBigIntptr.MMEP.MMSP.read_byte_raw.
          unfold lift_memory in Heqo.
          rewrite IntMaps.IP.F.map_o in Heqo.
          unfold option_map in Heqo.
          break_match_hyp_inv.

          (* TODO: Need to know ms_fin only has in bounds addresses *)
          (* I should be able to get this from MSR? *)
          pose proof convert_memory_lift ms_fin as CONV_MEM.

          admit.
        }

        break_match_hyp_inv.
        destruct m.
        cbn in Heqo0.
        break_match_hyp_inv.
        unfold convert_SByte in Heqo1.
        repeat break_match_hyp_inv.
        admit.
      }
    }

    exists ms_fin_final.
    split.
    2: {
      apply convert_MemState_MemState_refine_prop; auto.
    }

    split.
    - (* free_bytes_freed *)
      intros ptr PTR.
      pose proof PTR as PTR_INF.
      eapply ptr_in_memstate_heap_fin_inf in PTR_INF; eauto.
      2: {
        apply addr_refine_fin_to_inf_addr.
      }
      apply free_bytes_freed in PTR_INF.
      eapply inf_fin_byte_not_allocated; eauto.
      apply convert_MemState_MemState_refine_prop; auto.
      apply addr_refine_fin_to_inf_addr.
    - (* free_non_block_bytes_preserved *)
      intros ptr aid NPTR.
      pose proof NPTR as NPTR_INF.
      eapply ptr_not_in_memstate_heap_fin_inf in NPTR_INF; eauto.
      2: apply addr_refine_fin_to_inf_addr.
      eapply free_non_block_bytes_preserved in NPTR_INF.
      destruct NPTR_INF as [NPTR_INF1 NPTR_INF2].
      split; intros ALLOC.
      + eapply inf_fin_byte_allocated.
        3: {
          apply NPTR_INF1.
          eapply fin_inf_byte_allocated; eauto.
          apply addr_refine_fin_to_inf_addr.
        }

        apply convert_MemState_MemState_refine_prop; auto.
        apply addr_refine_fin_to_inf_addr.
      + eapply inf_fin_byte_allocated; eauto.
        2: {
          apply NPTR_INF2.
          eapply fin_inf_byte_allocated; eauto.
          apply convert_MemState_MemState_refine_prop; auto.
          apply addr_refine_fin_to_inf_addr.
        }

        apply addr_refine_fin_to_inf_addr.
    - (* free_non_frame_bytes_read *)
      intros ptr byte NPTR.
      pose proof NPTR as NPTR_INF.
      eapply ptr_not_in_memstate_heap_fin_inf in NPTR_INF; eauto.
      2: apply addr_refine_fin_to_inf_addr.
      eapply free_non_frame_bytes_read in NPTR_INF.
      split; intros READ.
      + eapply fin_inf_read_byte_spec_exists in READ; eauto.
        { destruct READ as (?&?&READ&?&?).
          eapply free_non_frame_bytes_read in READ.
          - eapply inf_fin_read_byte_spec in READ.
            + destruct READ as (?&?&?).
              red in H0, H2.
              rewrite H0 in H2.
              inv H2.
              apply H1.
            + eapply convert_MemState_MemState_refine_prop; eauto.
            + apply H.
          - intros PTR.
            eapply ptr_in_memstate_heap_inf_fin in PTR; eauto.
        }
      + eapply fin_inf_read_byte_spec_exists in READ; eauto.
        { destruct READ as (?&?&READ&?&?).
          eapply free_non_frame_bytes_read in READ.
          - eapply inf_fin_read_byte_spec in READ.
            + destruct READ as (?&?&?).
              red in H0, H2.
              rewrite H0 in H2.
              inv H2.
              apply H1.
            + eauto.
            + apply H.
          - intros PTR.
            eapply ptr_in_memstate_heap_inf_fin in PTR; eauto.
        }

        eapply convert_MemState_MemState_refine_prop; eauto.
    - (* free_block *)
      clear - MSR ADDR_REF MS_FIN_FINAL free_block.
      intros h1 h2 HEAP1 HEAP2.
      red in HEAP1, HEAP2.
      eapply free_block_prop_inf_fin; eauto.
      1-2: red; eapply Heap_eqv_lift; eauto.

      apply convert_MemState_MemState_refine_prop in MS_FIN_FINAL.
      destruct ms_fin_start as [[ms_fin fss_fin hs_fin] msprovs_fin].
      destruct ms_inf_start as [[ms_inf fss_inf hs_inf] msprovs_inf].
      destruct ms_fin_final as [[ms_fin' fss_fin' hs_fin'] msprovs_fin'].
      destruct ms_inf_final as [[ms_inf' fss_inf' hs_inf'] msprovs_inf'].

      eapply free_block; red; cbn in *.
      { apply MemState_refine_prop_heap_preserved in MSR.
        apply MSR.
        cbn; red; cbn.
        reflexivity.
      }
      { apply MemState_refine_prop_heap_preserved in MS_FIN_FINAL.
        apply MS_FIN_FINAL.
        cbn; red; cbn.
        reflexivity.
      }
    - (* free_operation_invariants *)
      clear - MSR ADDR_REF MS_FIN_FINAL free_invariants.
      apply convert_MemState_MemState_refine_prop in MS_FIN_FINAL.
      destruct free_invariants.
      split.
      + eapply inf_fin_preserve_allocation_ids; eauto.
      + eapply inf_fin_frame_stack_preserved; eauto.
  Abort.

  Import Tactics.
  #[global] Instance interp_memory_prop_eutt_S1S2_Proper_impl_ :
    forall {S1 S2 : Type} {E F OOM : Type -> Type} {OOMF : OOM -< F}
      (h_spec : forall T : Type, E T -> Monads.stateT S1 (Monads.stateT S2 (PropT F)) T)
      {R1 R2 : Type} (RR : R1 -> S2 * (S1 * R2) -> Prop)
      (RS1 : relation S1)
      (RS2 : relation S2)
      `{SYMRS1 : Symmetric _ RS1}
      `{SYMRS2 : Symmetric _ RS2}
      `{REFRS1 : Reflexive _ RS1}
      `{REFRS2 : Reflexive _ RS2}
      (RR2_RR : forall r1 r2 r3,
          RR r1 r2 -> (prod_rel RS2 (prod_rel RS1 eq)) r2 r3 -> RR r1 r3)
      (k_spec : forall T R3 : Type, E T -> itree F (S2 * (S1 * T)) -> (S2 * (S1 * T) -> itree F (S2 * (S1 * R3))) -> itree F (S2 * (S1 * R3)) -> Prop),
      k_spec_WF h_spec k_spec ->
      k_spec_Proper_S1S2 k_spec RS1 RS2 ->
      forall x : itree E R1, Proper (eutt (prod_rel RS2 (prod_rel RS1 eq)) ==> impl) (@interp_memory_prop S1 S2 E F OOM OOMF h_spec _ _ RR k_spec x).
  Proof.
    repeat intro.
    rename H into KWF.
    rename H0 into PS1S2.
    rename H1 into H0.
    rename H2 into H1.
    red in H1.
    punfold H1; punfold H0; red in H1; red in H0; cbn in *.
    Tactics.revert_until k_spec.
    pcofix CIH; intros k_spec_wellformed PS1S2 x y y' EQ H.
    remember (observe x); remember (observe y).
    pstep. red.
    revert x Heqi y Heqi0 EQ.
    (* induct on interp_memory_prop *)
    rename i into xo, i0 into yo.
    induction H; subst; pclearbot; intros.
    - rewrite <- Heqi.
      remember (RetF (E:= F) r2).
      induction EQ; inv Heqi1; intros.
      + constructor; eauto.
      + constructor; auto.

    - rewrite <- Heqi.
      remember (observe y') as ot3.
      assert (DEC: (exists m3, ot3 = TauF m3) \/ (forall m3, ot3 <> TauF m3)).
      { destruct ot3; eauto; right; red; intros; inv H. }

      rename EQ into INR.
      destruct DEC as [EQ | EQ].
      + destruct EQ as [m3 ?]; rewrite H.
        econstructor. right. pclearbot. eapply CIH; eauto with paco.
        rewrite H in INR.
        assert (eutt (prod_rel RS2 (prod_rel RS1 eq)) (Tau t2) (Tau m3)). pstep; auto.
        eapply eqit_inv_Tau in H0. punfold H0.
        punfold HS.

      + inv INR; try (exfalso; eapply EQ; eauto; fail).
        econstructor; eauto.
        punfold HS. red in HS.
        hinduction REL before CIH; intros; try (exfalso; eapply EQ; eauto; fail).
        * (* Want to know that...

             interp_memory_PropTF ... (observe t1) (RetF r1)

             implies

             interp_memory_PropTF ... (observe t1) (RetF r2)

             If r1 and r2 are related somehow (possibly with RR2).

             The constructors of Interp_Memory_PropTF that are
             relevant for this appear to be:

             | Interp_Memory_PropT_Ret : forall (r1 : R1) (r2 : S2 * (S1 * R2)), RR r1 r2 -> interp_memory_PropTF h_spec RR k_spec b1 b2 sim (RetF r1) (RetF r2)
             | Interp_Memory_PropT_TauL : forall (t1 : itree E R1) (t2 : itree' F (S2 * (S1 * R2))), is_true b1 -> interp_memory_PropTF h_spec RR k_spec b1 b2 sim (observe t1) t2 -> interp_memory_PropTF h_spec RR k_spec b1 b2 sim (TauF t1) t2
             | Interp_Memory_PropT_Vis_OOM : forall (A : Type) (e : OOM A) (k : A -> itree F (S2 * (S1 * R2))) (t1 : itree' E R1) (t2 : itree F (S2 * (S1 * R2))), t2 â‰… vis e k -> interp_memory_PropTF h_spec RR k_spec b1 b2 sim t1 (observe t2)
             | Interp_Memory_PropT_Vis : forall (A : Type) (e : E A) (ta : itree F (S2 * (S1 * A))) (t2 : itree F (S2 * (S1 * R2))) (s1 : S1) (s2 : S2) (k1 : A -> itree E R1) (k2 : S2 * (S1 * A) -> itree F (S2 * (S1 * R2))),
                              (forall (a : A) (b : S2 * (S1 * A)), Returns a (trigger e) -> Returns b ta -> a = snd (snd b) -> sim (k1 a) (k2 b)) -> h_spec A e s1 s2 ta -> k_spec A R2 e ta k2 t2 -> interp_memory_PropTF h_spec RR k_spec b1 b2 sim (VisF e k1) (observe t2).

             Which is... Most of them.

             This proof may proceed from

             HS : interp_memory_PropTF h_spec RR k_spec true true
                (upaco2 (interp_memory_PropT_ h_spec RR k_spec true true) bot2) (observe t1)
                (RetF r1)

             Or it may proceed from t1... But probably it should proceed using HS.

             - In the Interp_Memory_PropT_Ret case we know `t1 = RetF r`, and we'll know that `RR r r1`

               *Note:* RR = (fun (x : res_L2) '(_, (_, y)) => TLR_FIN.R.refine_res2 x y) in this case,
                       and RR2 = (Memory64BitIntptr.MMEP.MemSpec.MemState_eqv Ã— eq)

               In order to show:

                 interp_memory_PropTF h_spec RR k_spec true true
                 (upaco2 (interp_memory_PropT_ h_spec RR k_spec true true) r) (RetF r)
                 (RetF r2)

               I'll need to show `RR r r2` from `RR2 r1 r2` and `RR r r1`...

               r : R1
               r1, r2 : S2 * (S1 * R2)

               RR ignores MemState_eqv... RR2 does not. It should be the case that...

               RR2 r1 r2 -> RR (snd (snd r1)) r2

           *)

          dependent induction HS.
          -- rewrite <- x.
             constructor.
             eapply RR2_RR; eauto.
          -- rewrite <- x.
             constructor; auto.
             eapply IHHS; eauto.
          -- punfold HT1.
             red in HT1.
             rewrite x in HT1.
             inv HT1.
          -- (* Vis *)
            rewrite <- x0.
            (* May depend on if `e` is an OOM event or not? *)
            change (@RetF F (S2 * (S1 * R2)) (itree F (S2 * (S1 * R2))) r2) with (observe ({| _observe := @RetF F (S2 * (S1 * R2)) (itree F (S2 * (S1 * R2))) r2|})).
            eapply Interp_Memory_PropT_Vis.
            ++ intros a b H H0 H1.
               eapply upaco2_mon_bot; eauto.
            ++ apply HSPEC.
            ++ eapply PS1S2; eauto.
               pstep; red. rewrite x.
               cbn.
               constructor.
               symmetry; auto.
        * remember (VisF e k1) as ot.
          hinduction HS before CIH; intros; try discriminate; eauto.
          -- change (VisF e0 k2) with (observe (Vis e0 k2)).
             rewrite itree_eta in HT1.
             rewrite Heqot in HT1.
             pinversion HT1.
             repeat subst_existT.
             eapply Interp_Memory_PropT_Vis_OOM.
             reflexivity.
          -- change (VisF e0 k3) with (observe (Vis e0 k3)).
             eapply Interp_Memory_PropT_Vis.
             ++ intros a b H1 H2 H3.
                left. specialize (HK _ b H1 H2 H3). pclearbot.
                eapply paco2_mon; eauto. intros; inv PR.
             ++ eauto.
             ++ eapply PS1S2; eauto.
                pstep; red. rewrite Heqot.
                cbn.
                constructor.
                intros v.
                specialize (REL v).
                red in REL.
                pclearbot.
                red.
                left.
                change (paco2 (eqit_ (RS2 Ã— (RS1 Ã— eq)) true true id) bot2 (k3 v) (k0 v)) with (eqit (RS2 Ã— (RS1 Ã— eq)) true true (k3 v) (k0 v)).
                change (paco2 (eqit_ (RS2 Ã— (RS1 Ã— eq)) true true id) bot2 (k0 v) (k3 v)) with (eqit (RS2 Ã— (RS1 Ã— eq)) true true (k0 v) (k3 v)) in REL.

                symmetry; auto.
        * eapply IHREL; eauto. pstep_reverse.
          assert (@interp_memory_prop S1 S2 E F OOM OOMF h_spec _ _ RR k_spec t0 (Tau t1)) by (pstep; auto).
          apply interp_memory_prop_inv_tau_r in H. punfold H.

          hinduction HS before CIH; intros; try discriminate; eauto.
    - rewrite <- Heqi. constructor; auto.
      specialize (IHinterp_memory_PropTF _ eq_refl _ Heqi0 EQ). auto.
    - rewrite <- Heqi.
      remember (TauF t2) as ot. clear Heqi0 y.
      hinduction EQ before CIH; intros; try inversion Heqot; pclearbot; subst; eauto.
      punfold REL.
      eapply IHinterp_memory_PropTF; eauto.
      constructor; eauto.
      assert (eutt (RS2 Ã— (RS1 Ã— eq)) (Tau t0) t2). { pstep; red; cbn; auto. }
      apply eqit_inv_Tau_l in H1; punfold H1.
      eapply IHinterp_memory_PropTF; eauto.
      constructor; eauto.
    - rewrite itree_eta in HT1.
      hinduction EQ before CIH; intros.
      + pinversion HT1.
      + pinversion HT1.
        inv CHECK.
      + pinversion HT1; repeat subst_existT.
        change (VisF (subevent A e0) k2) with (observe (Vis (subevent A e0) k2)).
        eapply Interp_Memory_PropT_Vis_OOM.
        reflexivity.
      + pinversion HT1.
        inv CHECK0.
      + constructor; auto.
        eapply IHEQ; eauto.
    - rewrite <- Heqi.
      rewrite Heqi0 in EQ.
      assert (eutt (RS2 Ã— (RS1 Ã— eq)) t2 y) as TSY.
      { rewrite (itree_eta t2).
        rewrite Heqi0.
        rewrite <- itree_eta.
        reflexivity.
      }

      assert (KS':k_spec A R2 e ta k2 y).
      { eapply PS1S2; eauto.
        symmetry; auto.
      }

      eapply Interp_Memory_PropT_Vis; eauto.
      intros; eauto.
      specialize (HK _ _ H H0 H1). pclearbot.
      left. eapply paco2_mon_bot; intros; eauto.

      { eapply PS1S2; eauto.
        symmetry; auto.
        pstep; red; cbn; auto.
      }
  Qed.

  #[global] Instance interp_memory_prop_eutt_S1S2_Proper_impl :
    forall {S1 S2 : Type} {E F OOM : Type -> Type} {OOMF : OOM -< F}
      (h_spec : forall T : Type, E T -> Monads.stateT S1 (Monads.stateT S2 (PropT F)) T)
      {R1 R2 : Type} (RR : R1 -> S2 * (S1 * R2) -> Prop)
      (RS1 : relation S1)
      (RS2 : relation S2)
      `{SYMRS1 : Symmetric _ RS1}
      `{SYMRS2 : Symmetric _ RS2}
      `{REFRS1 : Reflexive _ RS1}
      `{REFRS2 : Reflexive _ RS2}
      (RR2_RR : forall r1 r2 r3,
          RR r1 r2 -> (prod_rel RS2 (prod_rel RS1 eq)) r2 r3 -> RR r1 r3)
      (k_spec : forall T R3 : Type, E T -> itree F (S2 * (S1 * T)) -> (S2 * (S1 * T) -> itree F (S2 * (S1 * R3))) -> itree F (S2 * (S1 * R3)) -> Prop),
      k_spec_WF h_spec k_spec ->
      k_spec_Proper_S1S2 k_spec RS1 RS2 ->
      forall x : itree E R1, Proper (eutt eq ==> eutt (prod_rel RS2 (prod_rel RS1 eq)) ==> impl) (@interp_memory_prop S1 S2 E F OOM OOMF h_spec _ _ RR k_spec).
  Proof.
    intros S1 S2 E F OOM OOMF h_spec R1 R2 RR RS1 RS2 SYMRS1 SYMRS2 REFRS1 REFRS2 RR2_RR k_spec k_spec_wellformed KP t.
    intros y y' EQ x x' EQ' H.
    eapply interp_memory_prop_eutt_S1S2_Proper_impl_; eauto.
    clear x' EQ'.
    punfold H; punfold EQ; red in H; red in EQ; cbn in *.
    Tactics.revert_until k_spec_wellformed.
    pcofix CIH.
    intros KP t x x' EQ y H.
    remember (observe x); remember (observe y).
    pstep. red. genobs_clear x' ox'.
    revert x Heqi y Heqi0 EQ.
    (* induct on interp_memory_prop *)
    rename i into xo, i0 into yo.
    induction H; subst; pclearbot; intros.
    - rewrite <- Heqi0.
      remember (RetF (E:= E) r1).
      induction EQ; inv Heqi1; intros.
      + constructor; auto.
      + constructor; auto.

    - rewrite <- Heqi0.
      rename ox' into ot3.
      assert (DEC: (exists m3, ot3 = TauF m3) \/ (forall m3, ot3 <> TauF m3)).
      { destruct ot3; eauto; right; red; intros; inv H. }

      rename EQ into INR.
      destruct DEC as [EQ | EQ].
      + destruct EQ as [m3 ?]; rewrite H.
        econstructor. right. pclearbot. eapply CIH; eauto with paco.
        rewrite H in INR.
        assert (Tau t1 â‰ˆ Tau m3). pstep; auto.
        eapply eqit_inv_Tau in H0. punfold H0.
        punfold HS.
      + inv INR; try (exfalso; eapply EQ; eauto; fail).
        econstructor; eauto.
        punfold HS. red in HS.
        pclearbot.
        hinduction REL before CIH; intros; try (exfalso; eapply EQ; eauto; fail).
        * subst. remember (RetF r2) as ot.
          eapply interp_memory_PropTF_mono; eauto.
          intros; left; pclearbot; eapply paco2_mon; eauto; intros; inv PR0.
        * remember (VisF e k1) as ot.
          hinduction HS before CIH; intros; try discriminate; eauto.
          -- inv Heqot.
             subst_existT.
             eapply Interp_Memory_PropT_Vis; eauto.
             intros a b H1 H2 H3.
             right.
             eapply CIH; eauto.
             specialize (REL a). pclearbot. punfold REL.
             specialize (HK _ _ H1 H2 H3). pclearbot.
             punfold HK.

        * eapply IHREL; eauto. pstep_reverse.
          assert (@interp_memory_prop S1 S2 E F OOM OOMF h_spec _ _ RR k_spec (Tau t0) t2) by (pstep; auto).
          apply interp_memory_prop_inv_tau_l in H. punfold H.
    - specialize (IHinterp_memory_PropTF _ eq_refl _ Heqi0).
      assert (t1 â‰ˆ go ox').
      { rewrite <- tau_eutt; pstep; auto. }
      punfold H0.
    - rewrite <- Heqi0.
      constructor; auto. eapply IHinterp_memory_PropTF; eauto.
    - apply eqitree_inv_Vis_r in HT1.
      destruct HT1.
      destruct H.
      rewrite <- Heqi0.
      rewrite H.
      change (VisF (subevent A e) x0) with (observe (Vis (subevent A e) x0)).
      eapply Interp_Memory_PropT_Vis_OOM.
      reflexivity.
    - rewrite Heqi in EQ.
      hinduction EQ before CIH; intros; try inversion Heqi1; pclearbot; inv Heqi.
      + dependent destruction H1.
        eapply Interp_Memory_PropT_Vis; eauto.
        intros. specialize (HK _ _ H H0 H1); pclearbot.
        right; eapply CIH; eauto; [ | punfold HK].
        specialize (REL a).
        punfold REL.

        eapply k_spec_Proper; eauto.
        rewrite (itree_eta t2), Heqi0, <- itree_eta.
        reflexivity.
      + econstructor; eauto.
  Qed.

  #[global] Instance interp_memory_prop_eutt_S1S2_Proper :
    forall {S1 S2 : Type} {E F OOM : Type -> Type} {OOMF : OOM -< F}
      (h_spec : forall T : Type, E T -> Monads.stateT S1 (Monads.stateT S2 (PropT F)) T)
      {R1 R2 : Type} (RR : R1 -> S2 * (S1 * R2) -> Prop)
      (RS1 : relation S1)
      (RS2 : relation S2)
      `{SYMRS1 : Symmetric _ RS1}
      `{SYMRS2 : Symmetric _ RS2}
      `{REFRS1 : Reflexive _ RS1}
      `{REFRS2 : Reflexive _ RS2}
      (RR2_RR : forall r1 r2 r3,
          RR r1 r2 -> (prod_rel RS2 (prod_rel RS1 eq)) r2 r3 -> RR r1 r3)
      (k_spec : forall T R3 : Type, E T -> itree F (S2 * (S1 * T)) -> (S2 * (S1 * T) -> itree F (S2 * (S1 * R3))) -> itree F (S2 * (S1 * R3)) -> Prop),
      k_spec_WF h_spec k_spec ->
      k_spec_Proper_S1S2 k_spec RS1 RS2 ->
      forall x : itree E R1, Proper (eutt eq ==> eutt (prod_rel RS2 (prod_rel RS1 eq)) ==> iff) (@interp_memory_prop S1 S2 E F OOM OOMF h_spec _ _ RR k_spec).
  Proof.
    split; intros.
    - eapply interp_memory_prop_eutt_S1S2_Proper_impl_; eauto.
      setoid_rewrite <- H1.
      auto.
    - symmetry in H2.
      eapply interp_memory_prop_eutt_S1S2_Proper_impl_; eauto.
      setoid_rewrite H1.
      auto.
  Qed.

  (* TODO: Move this *)
  Lemma handle_memcpy_fin_inf_error :
    forall {args args0 ms_fin ms_inf msg_fin},
      MemState_refine_prop ms_inf ms_fin ->
      Forall2 DVCInfFin.dvalue_refine_strict args0 args ->
      Memory64BitIntptr.MMEP.MemSpec.handle_memcpy_prop args ms_fin (raise_error msg_fin) ->
      exists msg_inf,
        MemoryBigIntptr.MMEP.MemSpec.handle_memcpy_prop args0 ms_inf (raise_error msg_inf).
  Proof.
    intros args args0 ms_fin ms_inf msg_fin MSR ARGS HANDLER.
    repeat (destruct ARGS;
            try solve [cbn in *; eauto];
            match goal with
            | H: DVCInfFin.dvalue_refine_strict ?x _ |- _ =>
                destruct x;
                rewrite
                  DVCInfFin.dvalue_refine_strict_equation in H;
                  cbn in H;
                inv H;
                try solve [cbn in *; eauto]
            end).
    all: repeat break_match_hyp_inv.
    all: destruct ARGS; [|cbn in *; eauto].

    { (* 32 bit memcpy *)
      unfold MemoryBigIntptr.MMEP.MemSpec.handle_memcpy_prop.
      unfold MemoryBigIntptr.MMEP.MemSpec.memcpy_spec.
      do 2 red in HANDLER.
      break_match_hyp; try contradiction.
      break_match_hyp; try contradiction.
      unfold LLVMParams64BitIntptr.Events.DV.unsigned in Heqb, Heqb0.
      cbn in Heqb, Heqb0.
      unfold LLVMParamsBigIntptr.Events.DV.unsigned.
      unfold LLVMParamsBigIntptr.Events.DV.VInt32.
      rewrite Heqb.
      erewrite <- fin_inf_no_overlap; eauto.
      repeat erewrite <- fin_inf_ptoi; eauto.
      rewrite Heqb0.

      destruct HANDLER.
      { exists msg_fin.
        left.
        eapply fin_inf_read_bytes_spec_err; eauto.
      }

      destruct H as (?&?&?&?).
      exists msg_fin.
      right.

      eapply fin_inf_read_bytes_spec in H; eauto.
      destruct H as (?&?&?&?&?).
      exists x5, x4.
      split; eauto.
      eapply fin_inf_write_bytes_spec_error; eauto.
    }

    { (* 64 bit memcpy *)
      unfold MemoryBigIntptr.MMEP.MemSpec.handle_memcpy_prop.
      unfold MemoryBigIntptr.MMEP.MemSpec.memcpy_spec.
      do 2 red in HANDLER.
      break_match_hyp; try contradiction.
      break_match_hyp; try contradiction.
      unfold LLVMParams64BitIntptr.Events.DV.unsigned in Heqb, Heqb0.
      cbn in Heqb, Heqb0.
      unfold LLVMParamsBigIntptr.Events.DV.unsigned.
      unfold LLVMParamsBigIntptr.Events.DV.VInt64.
      rewrite Heqb.
      erewrite <- fin_inf_no_overlap; eauto.
      repeat erewrite <- fin_inf_ptoi; eauto.
      rewrite Heqb0.

      destruct HANDLER.
      { exists msg_fin.
        left.
        eapply fin_inf_read_bytes_spec_err; eauto.
      }

      destruct H as (?&?&?&?).
      exists msg_fin.
      right.

      eapply fin_inf_read_bytes_spec in H; eauto.
      destruct H as (?&?&?&?&?).
      exists x5, x4.
      split; eauto.
      eapply fin_inf_write_bytes_spec_error; eauto.
    }

    { (* intptr memcpy *)
      unfold MemoryBigIntptr.MMEP.MemSpec.handle_memcpy_prop.
      unfold MemoryBigIntptr.MMEP.MemSpec.memcpy_spec.
      do 2 red in HANDLER.
      break_match_hyp; try contradiction.
      break_match_hyp; try contradiction.
      unfold LLVMParams64BitIntptr.Events.DV.unsigned in Heqb, Heqb0.
      cbn in Heqb, Heqb0.
      assert (LLVMParams64BitIntptr.IP.to_Z i0 = LLVMParamsBigIntptr.IP.to_Z x) as X.
      { unfold LLVMParams64BitIntptr.IP.to_Z, LLVMParamsBigIntptr.IP.to_Z.
        unfold InterpreterStackBigIntptr.LP.IP.to_Z in *.
        erewrite IP.from_Z_to_Z; eauto.
      }
      rewrite <- X; clear X.
      rewrite Heqb.
      erewrite <- fin_inf_no_overlap; eauto.
      repeat erewrite <- fin_inf_ptoi; eauto.
      rewrite Heqb0.

      destruct HANDLER.
      { exists msg_fin.
        left.
        eapply fin_inf_read_bytes_spec_err; eauto.
      }

      destruct H as (?&?&?&?).
      exists msg_fin.
      right.

      eapply fin_inf_read_bytes_spec in H; eauto.
      destruct H as (?&?&?&?&?).
      exists x5, x4.
      split; eauto.
      eapply fin_inf_write_bytes_spec_error; eauto.
    }
  Qed.

  Lemma handle_malloc_fin_inf_error :
    forall {args args0 ms_fin ms_inf msg_fin},
      MemState_refine_prop ms_inf ms_fin ->
      Forall2 DVCInfFin.dvalue_refine_strict args0 args ->
      Memory64BitIntptr.MMEP.MemSpec.handle_malloc_prop args ms_fin (raise_error msg_fin) ->
      exists msg_inf,
        MemoryBigIntptr.MMEP.MemSpec.handle_malloc_prop args0 ms_inf (raise_error msg_inf).
  Proof.
    intros args args0 ms_fin ms_inf msg_fin MSR ARGS HANDLER.

    repeat (destruct ARGS;
            try solve [cbn in *; eauto];
            match goal with
            | H: DVCInfFin.dvalue_refine_strict ?x _ |- _ =>
                destruct x;
                rewrite
                  DVCInfFin.dvalue_refine_strict_equation in H;
                cbn in H;
                inv H;
                try solve [cbn in *; eauto]
            end).
    all: repeat break_match_hyp_inv.
    all: destruct ARGS; [|cbn in *; eauto].

    { (* i1 *)
      unfold MemoryBigIntptr.MMEP.MemSpec.handle_malloc_prop.
      red in HANDLER.
      eapply MemPropT_bind_raise_error_inv in HANDLER.
      destruct HANDLER as [[] | HANDLER].
      destruct HANDLER as (?&?&?&?).
      destruct H0.
      { red in H0.
        break_match_hyp; cbn in H0; contradiction.
      }
      destruct H0 as (?&?&?&?).
      exists msg_fin.
      right.
      eapply fresh_sid_fin_inf in H; eauto.
      destruct H as (?&?&?&?&?); subst.
      do 2 eexists; split; eauto.

      red in H0.
      break_match_hyp_inv.
      eapply generate_num_undef_bytes_fin_inf in Heqo.
      destruct Heqo as (?&?&?).
      right.
      do 2 eexists.
      split.
      red.
      cbn in H0.
      cbn; rewrite H0.
      split; reflexivity.

      eapply fin_inf_malloc_bytes_spec_MemPropT_error; eauto.
    }

    { (* i8 *)
      unfold MemoryBigIntptr.MMEP.MemSpec.handle_malloc_prop.
      red in HANDLER.
      eapply MemPropT_bind_raise_error_inv in HANDLER.
      destruct HANDLER as [[] | HANDLER].
      destruct HANDLER as (?&?&?&?).
      destruct H0.
      { red in H0.
        break_match_hyp; cbn in H0; contradiction.
      }
      destruct H0 as (?&?&?&?).
      exists msg_fin.
      right.
      eapply fresh_sid_fin_inf in H; eauto.
      destruct H as (?&?&?&?&?); subst.
      do 2 eexists; split; eauto.

      red in H0.
      break_match_hyp_inv.
      eapply generate_num_undef_bytes_fin_inf in Heqo.
      destruct Heqo as (?&?&?).
      right.
      do 2 eexists.
      split.
      red.
      cbn in H0.
      cbn; rewrite H0.
      split; reflexivity.

      eapply fin_inf_malloc_bytes_spec_MemPropT_error; eauto.
    }

    { (* i32 *)
      unfold MemoryBigIntptr.MMEP.MemSpec.handle_malloc_prop.
      red in HANDLER.
      eapply MemPropT_bind_raise_error_inv in HANDLER.
      destruct HANDLER as [[] | HANDLER].
      destruct HANDLER as (?&?&?&?).
      destruct H0.
      { red in H0.
        break_match_hyp; cbn in H0; contradiction.
      }
      destruct H0 as (?&?&?&?).
      exists msg_fin.
      right.
      eapply fresh_sid_fin_inf in H; eauto.
      destruct H as (?&?&?&?&?); subst.
      do 2 eexists; split; eauto.

      red in H0.
      break_match_hyp_inv.
      eapply generate_num_undef_bytes_fin_inf in Heqo.
      destruct Heqo as (?&?&?).
      right.
      do 2 eexists.
      split.
      red.
      cbn in H0.
      cbn; rewrite H0.
      split; reflexivity.

      eapply fin_inf_malloc_bytes_spec_MemPropT_error; eauto.
    }

    { (* i64 *)
      unfold MemoryBigIntptr.MMEP.MemSpec.handle_malloc_prop.
      red in HANDLER.
      eapply MemPropT_bind_raise_error_inv in HANDLER.
      destruct HANDLER as [[] | HANDLER].
      destruct HANDLER as (?&?&?&?).
      destruct H0.
      { red in H0.
        break_match_hyp; cbn in H0; contradiction.
      }
      destruct H0 as (?&?&?&?).
      exists msg_fin.
      right.
      eapply fresh_sid_fin_inf in H; eauto.
      destruct H as (?&?&?&?&?); subst.
      do 2 eexists; split; eauto.

      red in H0.
      break_match_hyp_inv.
      eapply generate_num_undef_bytes_fin_inf in Heqo.
      destruct Heqo as (?&?&?).
      right.
      do 2 eexists.
      split.
      red.
      cbn in H0.
      cbn; rewrite H0.
      split; reflexivity.

      eapply fin_inf_malloc_bytes_spec_MemPropT_error; eauto.
    }

    { (* iptr *)
      unfold MemoryBigIntptr.MMEP.MemSpec.handle_malloc_prop.
      red in HANDLER.
      eapply MemPropT_bind_raise_error_inv in HANDLER.
      destruct HANDLER as [[] | HANDLER].
      destruct HANDLER as (?&?&?&?).
      destruct H0.
      { red in H0.
        break_match_hyp; cbn in H0; contradiction.
      }
      destruct H0 as (?&?&?&?).
      exists msg_fin.
      right.
      eapply fresh_sid_fin_inf in H; eauto.
      destruct H as (?&?&?&?&?); subst.
      do 2 eexists; split; eauto.

      red in H0.
      break_match_hyp_inv.
      eapply generate_num_undef_bytes_fin_inf in Heqo0.
      destruct Heqo0 as (?&?&?).
      right.
      do 2 eexists.
      split.

      unfold LLVMParamsBigIntptr.IP.to_unsigned.
      rewrite <- LLVMParamsBigIntptr.IP.to_Z_to_unsigned.
      unfold LLVMParams64BitIntptr.IP.to_unsigned in H0.
      rewrite <- LLVMParams64BitIntptr.IP.to_Z_to_unsigned in H0.


      assert (LLVMParams64BitIntptr.IP.to_Z i = LLVMParamsBigIntptr.IP.to_Z x) as X.
      { unfold LLVMParams64BitIntptr.IP.to_Z, LLVMParamsBigIntptr.IP.to_Z.
        unfold InterpreterStackBigIntptr.LP.IP.to_Z in *.
        erewrite IP.from_Z_to_Z; eauto.
      }
      rewrite <- X; clear X.

      red.
      cbn in H0.
      cbn; rewrite H0.
      split; reflexivity.

      eapply fin_inf_malloc_bytes_spec_MemPropT_error; eauto.
    }
  Qed.

  (* TODO: Move this *)
  Lemma handle_intrinsic_fin_inf_error :
    forall {t f args args0 ms_fin ms_inf msg_fin}
      (ARGS: Forall2 DVCInfFin.dvalue_refine_strict args0 args),
      MemState_refine_prop ms_inf ms_fin ->
      Memory64BitIntptr.MMEP.MemSpec.handle_intrinsic_prop
        LLVMParams64BitIntptr.Events.DV.dvalue
        (LLVMParams64BitIntptr.Events.Intrinsic t f args) ms_fin (raise_error msg_fin) ->
      exists msg_inf,
        MemoryBigIntptr.MMEP.MemSpec.handle_intrinsic_prop DVCInfFin.DV1.dvalue
          (InterpreterStackBigIntptr.LP.Events.Intrinsic t f args0) ms_inf
          (raise_error msg_inf).
  Proof.
    intros t f args args0 ms_fin ms_inf msg_fin ARGS MSR INTRINSIC.

    red in INTRINSIC.
    unfold MemoryBigIntptr.MMEP.MemSpec.handle_intrinsic_prop.
    break_match.
    { (* Memcpy *)
      destruct INTRINSIC.
      2: {
        cbn in H.
        destruct H as (?&?&?&?).
        contradiction.
      }
      eapply handle_memcpy_fin_inf_error in H; eauto.
      destruct H.
      exists x.
      left.
      auto.
    }

    break_match.
    { (* Malloc *)
      destruct INTRINSIC.
      2: {
        cbn in H.
        destruct H as (?&?&?&?).
        contradiction.
      }

      eapply handle_malloc_fin_inf_error in H; eauto.
      destruct H.
      exists x.
      left; auto.
    }

    break_match.
    { (* Free *)
      destruct INTRINSIC.
      2: {
        cbn in H.
        destruct H as (?&?&?&?).
        contradiction.
      }

      eapply handle_free_fin_inf_error in H; eauto.
      destruct H.
      exists x.
      left; auto.
    }

    eauto.
    Unshelve.
    exact ""%string.
  Qed.

  (* TODO: Move this *)
  Lemma contains_UB_Extra_raise_error :
    forall {E F G J} `{O : FailureE -< E +' F +' G +' UBE +' J} {X} msg,
      (forall X e1 e2, O X e1 <> inr1 (inr1 (inr1 (inl1 e2)))) ->
      ~ contains_UB_Extra (@raise_error _ _ X msg).
  Proof.
    intros E F G J O X msg NUBE CONTRA.
    dependent destruction CONTRA.
    - pinversion H; subst; inv CHECK.
    - pinversion H; do 2 subst_existT.
      cbn in *.
      inv x.
    - pinversion H; do 2 subst_existT.
      cbn in *.
      inv x.
    - pinversion H; do 2 subst_existT.
      cbn in *.
      subst.
      rewrite subevent_subevent in H4.
      unfold subevent in *.
      repeat unfold resum, ReSum_id, id_, Id_IFun, ReSum_inr, ReSum_inl, inr_, inl_, cat, Cat_IFun, Inr_sum1, Inl_sum1 in H4.
      apply NUBE in H4.
      auto.
  Qed.

  Lemma bogus :
    forall (P Q : Prop),
      (P -> Q) -> P = Q.
  Proof.
  Admitted.

  Lemma model_E1E2_23_orutt_strict :
    forall t_inf t_fin sid ms1 ms2,
      L2_E1E2_orutt_strict t_inf t_fin ->
      MemState_refine_prop ms1 ms2 ->
      L3_E1E2_orutt_strict (InfMemInterp.interp_memory_prop TLR_INF.R.refine_res2 t_inf sid ms1) (FinMemInterp.interp_memory_prop TLR_FIN.R.refine_res2 t_fin sid ms2).
  Proof.
    intros t_inf t_fin sid ms1 ms2 REL MSR.
    red.
    red in REL.
    (* red in REL. *)

    unfold L3_E1E2_orutt_strict.
    intros t_fin2 FIN_HANDLED.

    exists (get_inf_tree t_fin2).
    split.
    { red.
      revert FIN_HANDLED.
      revert REL.

      rewrite (itree_eta_ t_fin).
      rewrite (itree_eta_ t_fin2).
      rewrite (itree_eta_ t_inf).

      genobs t_fin ot_fin.
      genobs t_fin2 ot_fin2.
      genobs t_inf ot_inf.
      clear t_inf Heqot_inf.
      clear t_fin Heqot_fin.
      clear t_fin2 Heqot_fin2.

      revert ot_inf ot_fin ot_fin2.
      pcofix CIH.
      intros ot_inf ot_fin ot_fin2 REL RUN.

      punfold REL.
      red in REL.
      cbn in REL.

      remember (upaco2
                  (orutt_ L2_refine_strict L2_res_refine_strict
                     (local_refine_strict Ã— stack_refine_strict
                        Ã— (global_refine_strict Ã— DVCInfFin.dvalue_refine_strict))) bot2) as r'.
      revert Heqr'.

      dependent induction REL; intros Heqr'.
      - (* oruttF's EqRet *)
        subst.
        apply interp_memory_prop_ret_inv in RUN.
        destruct RUN as [[r3 [REQ EQ]] | [A [e [k EUTT]]]]; subst.
        2: {
          eapply paco2_mon_bot; eauto.
          rewrite EUTT.
          pstep; red; cbn.
          econstructor.
          destruct e.
          pstep; red; cbn.
          constructor.
          intros [] _.
        }

        (assert (eutt eq (get_inf_tree {| _observe := ot_fin2 |}) (get_inf_tree (ret r3)))).
        { rewrite <- EQ.
          reflexivity.
        }

        eapply paco2_mon_bot; eauto.
        rewrite H0.

        destruct r3. repeat (destruct p; subst).
        destruct p0.

        destruct r1 as [[lenv lstack] [stack res]].
        destruct H as [[LR SR] [GR DR]]. cbn in *.

        pstep; red; cbn.
        constructor.

        red.
        constructor; cbn; red; auto.
        constructor; cbn.
        red. auto.

        destruct REQ as [_ [_ REQ]].
        destruct r2 as [l' [s' r2]].
        cbn in *. subst.
        pose proof (fin_to_inf_dvalue_refine_strict d).

        apply fin_to_inf_dvalue_refine_strict'; auto.
      - (* oruttF's EqTau *)
        punfold RUN.
        red in RUN.
        cbn in RUN.

        assert (DEC: (exists m3, ot_fin2 = TauF m3) \/ (forall m3, ot_fin2 <> TauF m3)).
        { destruct ot_fin2; eauto; right; red; intros; inversion H0. }

        destruct DEC as [EQ | EQ].
        { destruct EQ as [m3 EQ].
          subst.
          pstep; red; cbn.
          constructor.
          right.
          rewrite (itree_eta_ m1).
          rewrite (itree_eta_ m3).
          eapply CIH.

          pclearbot.
          punfold H; red in H.
          pstep. red. cbn.
          eauto.

          red.
          rewrite <- itree_eta_.
          rewrite <- itree_eta_.

          rewrite <- tau_eutt.
          rewrite <- (tau_eutt m3).
          pstep; red; cbn.
          auto.
        }

        inversion RUN; subst.
        + specialize (EQ t2).
          contradiction.
        + pstep; red; cbn.
          constructor; auto.

          rewrite (itree_eta_ m2) in H.
          rewrite (itree_eta_ m2) in RUN.
          genobs m2 om2.
          setoid_rewrite <- Heqom2 in HS.
          clear Heqom2.
          clear m2.
          induction HS; subst.
          -- inversion RUN; subst.
             cbn in *.
             inversion HS; subst.

             pclearbot.
             punfold H.
             red in H.

             { dependent induction H.
               - rewrite <- x.
                 constructor.
                 destruct H as [[LR SR] [GR DR]]. cbn in *; subst; auto.
                 destruct r2 as [l' [s' r2]].
                 destruct r2.
                 destruct p.
                 destruct p0.
                 cbn.
                 cbn in *.
                 destruct r0.
                 destruct p, p0.
                 constructor; auto.
                 constructor; auto.
                 constructor; auto.
                 cbn. red. auto.
                 cbn in *.
                 destruct r1, p, p0. cbn in *.
                 destruct REL as [_ [_ REL]].
                 cbn in REL. subst.
                 apply fin_to_inf_dvalue_refine_strict'. auto.
               - rewrite <- x.
                 constructor; eauto.
             }

             { rewrite itree_eta in HT1.
               rewrite H2 in HT1.
               pinversion HT1.
             }

             { rewrite itree_eta in HT1.
               rewrite H2 in HT1.
               pinversion HT1.
             }
          -- specialize (EQ t2).
             contradiction.
          -- eapply IHHS; eauto.
             left.
             pclearbot.
             assert (orutt (OOM:=OOME) (@L2_refine_strict) (@L2_res_refine_strict) (local_refine_strict Ã— stack_refine_strict
                                                                                      Ã— (global_refine_strict Ã— DVCInfFin.dvalue_refine_strict)) m1 (Tau t1)).
             { apply H.
             }
             setoid_rewrite tau_eutt in H0.
             rewrite <- itree_eta_.
             apply H0.
          -- specialize (EQ t2).
             contradiction.
          -- (* Vis OOM *)
            rewrite itree_eta in HT1.
            genobs t2 ot2. clear t2 Heqot2.
            punfold HT1; red in HT1; cbn in HT1.
            dependent induction HT1.
            ++ destruct e.
               econstructor.
               pstep; red; cbn.
               constructor.
               intros [] _.
            ++ specialize (EQ t0); contradiction.
          -- (* Vis *)
            { rewrite (itree_eta_ t2) in KS.
              genobs t2 ot2.
              clear t2 Heqot2.
              dependent induction RUN; subst.
              - (* Tau Tau *)
                specialize (EQ t2).
                contradiction.
              - (* TauL *)
                clear IHRUN.
                pclearbot.
                apply orutt_inv_Vis_r in H.
                destruct H as [[U1 [e1 [k3 [M1 [EV_REL K_RUTT]]]]] | OOM].
                2: {
                  destruct OOM as [o OOM].
                  inv OOM.
                  cbn in HSPEC.
                  red in HSPEC.
                  setoid_rewrite bind_trigger in HSPEC.
                  red in KS.
                  rewrite HSPEC in KS.
                  destruct KS as [CONTRA | KS].
                  { exfalso.
                    inv CONTRA.
                    - pinversion H0.
                      inv CHECK1.
                    - pinversion H0.
                      subst_existT.
                      subst_existT.
                      inv H0.
                      subst_existT.
                      specialize (REL0 x).
                      red in REL0.
                      pclearbot.
                      rewrite <- REL0 in H1.
                      eapply ret_not_contains_UB_Extra in H1; eauto.
                      cbn.
                      reflexivity.
                    - pinversion H0.
                      do 2 subst_existT.
                      inv H7.
                    - pinversion H0.
                      do 2 subst_existT.
                      inv H6.
                  }
                  setoid_rewrite bind_vis in KS.
                  punfold KS; red in KS; cbn in KS.
                  dependent induction KS.
                  - destruct o.
                    eapply Interp_Memory_PropT_Vis_OOM.
                    rewrite get_inf_tree_equation.
                    cbn.
                    unfold raiseOOM.
                    rewrite bind_trigger.
                    reflexivity.
                  - specialize (EQ t1). contradiction.
                }

                punfold M1; red in M1; cbn in M1.
                genobs m1 om1.
                clear m1 Heqom1.
                dependent induction M1.
                + (* om1 = Vis *)
                  pose proof KS as VIS_HANDLED.
                  red in VIS_HANDLED.

                  (* Need to break apart events e / e1 to figure out
                what event we're dealing with. *)
                  red in EV_REL.
                  destruct e, e1; try destruct e, e0; cbn in EV_REL;
                    move EV_REL after VIS_HANDLED;
                    repeat (first [destruct s | destruct i | destruct e | destruct s0 | destruct m | destruct m0]; try contradiction); cbn in *.

                  { (* ExternalCallE *)
                    destruct EV_REL as (T&F&ARGS); subst.
                    red in HSPEC.
                    rewrite HSPEC in VIS_HANDLED.
                    destruct VIS_HANDLED as [UB | VIS_HANDLED].

                    { (* UB... Should be contradiction *)
                      exfalso.
                      setoid_rewrite bind_trigger in UB.
                      dependent destruction UB.
                      - pinversion H; subst; inv CHECK1.
                      - pinversion H; do 2 subst_existT.
                        specialize (REL0 x).
                        rewrite <- REL0 in UB.
                        eapply ret_not_contains_UB_Extra in UB; cbn; auto.
                        reflexivity.
                      - pinversion H; do 2 subst_existT.
                        specialize (REL0 x).
                        rewrite <- REL0 in UB.
                        eapply ret_not_contains_UB_Extra in UB; cbn; auto.
                        reflexivity.
                      - pinversion H; do 2 subst_existT.
                        subst.
                        dependent destruction H6.
                    }

                    setoid_rewrite bind_trigger in VIS_HANDLED.
                    setoid_rewrite bind_vis in VIS_HANDLED.
                    setoid_rewrite bind_ret_l in VIS_HANDLED.
                    punfold VIS_HANDLED; red in VIS_HANDLED; cbn in VIS_HANDLED.
                    dependent induction VIS_HANDLED.
                    { eapply Interp_Memory_PropT_Vis with
                        (k2:=(fun '(ms_inf, (sid', dv_inf)) =>
                                match DVCInfFin.dvalue_convert_strict dv_inf with
                                | NoOom dv_fin => get_inf_tree (k5 dv_fin)
                                | Oom s => raiseOOM s
                                end)
                        ).
                      2: {
                        cbn. red.
                        reflexivity.
                      }
                      2: {
                        cbn.
                        red.
                        setoid_rewrite bind_trigger.
                        right.
                        pstep; red; cbn.

                        pose proof (fin_to_inf_uvalue_refine_strict' _ _ F).
                        rewrite <- H.

                        rewrite Forall2_map_eq with (l2:=args0).
                        2: {
                          eapply Forall2_flip.
                          eapply Util.Forall2_impl; [| apply ARGS].
                          intros a b H1.
                          red.
                          symmetry.
                          apply fin_to_inf_dvalue_refine_strict'.
                          auto.
                        }

                        constructor.
                        intros v.
                        red.

                        left.
                        setoid_rewrite bind_ret_l.
                        cbn.
                        break_match_goal.

                        apply paco2_eqit_RR_refl; typeclasses eauto.
                        rewrite get_inf_tree_equation; cbn.
                        apply paco2_eqit_RR_refl; typeclasses eauto.
                      }

                      intros a (ms'&sid'&b) RET H1 H2; cbn in *; subst.
                      break_match_goal.
                      2: {
                        (* OOM *)
                        cbn.
                        left.
                        pstep; red; cbn.
                        observe_vis; solve_interp_prop_oom.
                      }

                      (* Need to figure out how k0 and k5 are related *)
                      (*
                      REL : forall v : InterpreterStackBigIntptr.LP.Events.DV.dvalue,
                          id (upaco2 (eqit_ eq true true id) bot2) (k0 v) (k3 v)

                      REL0 : forall v : dvalue,
                          id (upaco2 (eqit_ eq true true id) bot2) (k5 v) (k2 (s2, (s1, v)))

                      HK : forall (a : dvalue) (b : Memory64BitIntptr.MMEP.MMSP.MemState * (MemPropT.store_id * dvalue)),
                        Returns a (trigger (inl1 (ExternalCall t f args))) ->
                        Returns b ta ->
                        a = snd (snd b) ->
                        upaco2
                          (interp_memory_PropT_ FinMemInterp.interp_memory_prop_h
                          (fun (x : res_L2) '(_, (_, y)) => TLR_FIN.R.refine_res2 x y) true true) bot2
                          (k1 a) (k2 b)

                      K_RUTT : forall (v1 : InterpreterStackBigIntptr.LP.Events.DV.dvalue) (v2 : dvalue),
                         t = t /\
                         DVCInfFin.uvalue_refine_strict f0 f /\
                         Forall2 DVCInfFin.dvalue_refine_strict args0 args /\ DVCInfFin.dvalue_refine_strict v1 v2 ->
                         orutt L2_refine_strict L2_res_refine_strict
                         (local_refine_strict Ã— stack_refine_strict
                         Ã— (global_refine_strict Ã— DVCInfFin.dvalue_refine_strict)) (k3 v1)
                         (k1 v2)


                       *)

                      pclearbot.
                      right.
                      rewrite (itree_eta_ (k0 b)).
                      rewrite (itree_eta_ (k5 d)).

                      eapply CIH;
                        repeat rewrite <- itree_eta_.

                      2: {
                        red.
                        red in KS.
                        move REL0 after Heqo.
                        eapply interp_memory_prop_eutt_S1S2_Proper with (RS2:=Memory64BitIntptr.MMEP.MemSpec.MemState_eqv) (RS1:=eq); eauto; try typeclasses eauto.
                        { intros r1 r2 r3 H H0.
                          destruct r2, p.
                          destruct r3, p0.
                          inv H0.
                          inv snd_rel.
                          cbn in *; subst.
                          auto.
                        }
                        2: {
                          rewrite prod_rel_eq.
                          apply REL0.
                        }
                        2: {
                          specialize (HK d (s2, (s1, d))).
                          forward HK.
                          { eapply ReturnsVis.
                            pstep; red; cbn.
                            constructor.
                            intros v. red.
                            left; apply paco2_eqit_refl.
                            constructor.
                            reflexivity.
                          }
                          forward HK.
                          { rewrite HSPEC.
                            rewrite bind_trigger.
                            eapply ReturnsVis.
                            reflexivity.
                            cbn.
                            constructor.
                            reflexivity.
                          }
                          forward HK; cbn; auto.
                          pclearbot.
                          apply HK.
                        }

                        reflexivity.
                      }

                      rewrite REL.
                      eapply K_RUTT; split; auto.
                    }
                    { specialize (EQ t1).
                      contradiction.
                    }
                  }

                  { (* Intrinsic *)
                    destruct EV_REL as (T&F&ARGS); subst.
                    red in HSPEC.
                    red in HSPEC.
                    destruct HSPEC as [UB | [ERR | [OOM | HSPEC]]].

                    { (* Handler raises UB *)
                      destruct UB as [ub_msg INTRINSIC].
                      red in INTRINSIC.
                      break_match_hyp.
                      { (* memcpy *)
                        cbn in *.
                        destruct INTRINSIC as [HANDLER | [sab [[] [HANDLER []]]]].
                        red in HANDLER.
                        repeat (destruct ARGS;
                                [solve [ inversion HANDLER
                                       | red in HANDLER;
                                         repeat break_match_hyp; cbn in HANDLER; inversion HANDLER
                                   ]
                                |
                               ]).
                        repeat break_match_hyp; cbn in HANDLER; try contradiction.

                        { (* 32 bit *)
                          red in HANDLER.
                          break_match_hyp.
                          { (* Negative length UB *)
                            subst.
                            inversion ARGS; subst.
                            inversion H4; subst.
                            inversion H6; subst.
                            inversion H8; subst.
                            inversion H10; subst.

                            apply dvalue_refine_strict_addr_r_inv in H as (?&?&?); subst.
                            apply dvalue_refine_strict_addr_r_inv in H3 as (?&?&?); subst.
                            apply dvalue_refine_strict_i32_r_inv in H5 as (?&?&?); subst.
                            apply dvalue_refine_strict_i32_r_inv in H7 as (?&?&?); subst.
                            apply dvalue_refine_strict_i1_r_inv in H9 as (?&?&?); subst.

                            eapply Interp_Memory_PropT_Vis with
                              (ta:=
                                 vis (ThrowUB tt)
                                   (fun x : void =>
                                      match
                                        x
                                        return
                                        (itree
                                           (InterpreterStackBigIntptr.LP.Events.ExternalCallE +'
                                                                                                 LLVMParamsBigIntptr.Events.PickUvalueE +' OOME +' UBE +' DebugE +' FailureE)
                                           (MemoryBigIntptr.MMEP.MMSP.MemState *
                                              (MemPropT.store_id * LLVMParamsBigIntptr.Events.DV.dvalue)))
                                      with
                                      end)).

                            3: {
                              red in KS.
                              red.
                              left.
                              eapply FindUB.
                              pstep; red; cbn.
                              constructor.
                              intros [].
                            }

                            2: {
                              cbn.
                              repeat red.
                              left.
                              exists "memcpy given negative length.".
                              red.
                              rewrite Heqb.
                              cbn.
                              left.
                              red.
                              cbn in H2.
                              rewrite H2.
                              rewrite Heqb0.
                              cbn; auto.
                            }

                            intros a1 b RETa RETb AB.
                            eapply Returns_vis_inversion in RETb.
                            destruct RETb as [[] _].
                          }

                          subst.
                          inversion ARGS; subst.
                          inversion H4; subst.
                          inversion H6; subst.
                          inversion H8; subst.
                          inversion H10; subst.

                          apply dvalue_refine_strict_addr_r_inv in H as (?&?&?); subst.
                          apply dvalue_refine_strict_addr_r_inv in H3 as (?&?&?); subst.
                          apply dvalue_refine_strict_i32_r_inv in H5 as (?&?&?); subst.
                          apply dvalue_refine_strict_i32_r_inv in H7 as (?&?&?); subst.
                          apply dvalue_refine_strict_i1_r_inv in H9 as (?&?&?); subst.

                          break_match_hyp.

                          2: {
                            (* Overlapping UB *)
                            eapply Interp_Memory_PropT_Vis with
                              (ta:=
                                 vis (ThrowUB tt)
                                   (fun x : void =>
                                      match
                                        x
                                        return
                                        (itree
                                           (InterpreterStackBigIntptr.LP.Events.ExternalCallE +'
                                                                                                 LLVMParamsBigIntptr.Events.PickUvalueE +' OOME +' UBE +' DebugE +' FailureE)
                                           (MemoryBigIntptr.MMEP.MMSP.MemState *
                                              (MemPropT.store_id * LLVMParamsBigIntptr.Events.DV.dvalue)))
                                      with
                                      end)).

                            3: {
                              red in KS.
                              red.
                              left.
                              eapply FindUB.
                              pstep; red; cbn.
                              constructor.
                              intros [].
                            }

                            2: {
                              cbn.
                              repeat red.
                              left.
                              exists "memcpy with overlapping or non-equal src and dst memory locations.".
                              red.
                              rewrite Heqb.
                              cbn.
                              left.
                              red.
                              cbn in H2.
                              rewrite H2.
                              rewrite Heqb0.
                              erewrite <- fin_inf_no_overlap; eauto.
                              erewrite <- fin_inf_ptoi; eauto.
                              erewrite <- fin_inf_ptoi; eauto.
                              rewrite Heqb1.
                              cbn; auto.
                            }

                            intros a1 b RETa RETb AB.
                            eapply Returns_vis_inversion in RETb.
                            destruct RETb as [[] _].
                          }

                          (* May be UB in read / write... *)
                          (* HANDLER has UB in it *)
                          eapply Interp_Memory_PropT_Vis with
                            (ta:=raise_ub "").

                          3: {
                            red in KS.
                            red.
                            left.
                            eapply FindUB.
                            pstep; red; cbn.
                            constructor.
                            intros [].
                          }

                          { intros a1 b RETa RETb AB.
                            cbn in RETb.
                            unfold raiseUB in RETb.
                            rewrite bind_trigger in RETb.
                            eapply Returns_vis_inversion in RETb.
                            destruct RETb as [[] _].
                          }

                          cbn.
                          red.
                          left.
                          exists ub_msg.
                          red.
                          rewrite Heqb.

                          left.
                          cbn.
                          red.

                          cbn in H2, H3, H5.
                          rewrite H2.
                          rewrite Heqb0.
                          erewrite <- fin_inf_no_overlap; eauto.
                          erewrite <- fin_inf_ptoi; eauto.
                          erewrite <- fin_inf_ptoi; eauto.
                          rewrite Heqb1.
                          eapply MemPropT_fin_inf_bind_ub.
                          5: apply HANDLER.
                          all: eauto with FinInf.

                          2: {
                            intros msg H.
                            eapply fin_inf_read_bytes_spec_ub'; eauto.
                            apply lift_MemState_refine_prop.
                          }

                          2: {
                            intros ms_inf ms_fin a_fin a_inf msg H H7 H9 H11.
                            eapply fin_inf_write_bytes_spec_ub; eauto.
                          }

                          intros a_fin ms_fin_ma READ.
                          eapply fin_inf_read_bytes_spec; eauto.
                          apply lift_MemState_refine_prop.
                        }

                        { (* 64 bit *)
                          red in HANDLER.
                          break_match_hyp.
                          { (* Negative length UB *)
                            subst.
                            inversion ARGS; subst.
                            inversion H4; subst.
                            inversion H6; subst.
                            inversion H8; subst.
                            inversion H10; subst.

                            apply dvalue_refine_strict_addr_r_inv in H as (?&?&?); subst.
                            apply dvalue_refine_strict_addr_r_inv in H3 as (?&?&?); subst.
                            apply dvalue_refine_strict_i64_r_inv in H5 as (?&?&?); subst.
                            apply dvalue_refine_strict_i64_r_inv in H7 as (?&?&?); subst.
                            apply dvalue_refine_strict_i1_r_inv in H9 as (?&?&?); subst.

                            eapply Interp_Memory_PropT_Vis with
                              (ta:=
                                 vis (ThrowUB tt)
                                   (fun x : void =>
                                      match
                                        x
                                        return
                                        (itree
                                           (InterpreterStackBigIntptr.LP.Events.ExternalCallE +'
                                                                                                 LLVMParamsBigIntptr.Events.PickUvalueE +' OOME +' UBE +' DebugE +' FailureE)
                                           (MemoryBigIntptr.MMEP.MMSP.MemState *
                                              (MemPropT.store_id * LLVMParamsBigIntptr.Events.DV.dvalue)))
                                      with
                                      end)).

                            3: {
                              red in KS.
                              red.
                              left.
                              eapply FindUB.
                              pstep; red; cbn.
                              constructor.
                              intros [].
                            }

                            2: {
                              cbn.
                              repeat red.
                              left.
                              exists "memcpy given negative length.".
                              red.
                              rewrite Heqb.
                              cbn.
                              left.
                              red.
                              cbn in H2.
                              rewrite H2.
                              rewrite Heqb0.
                              cbn; auto.
                            }

                            intros a1 b RETa RETb AB.
                            eapply Returns_vis_inversion in RETb.
                            destruct RETb as [[] _].
                          }

                          subst.
                          inversion ARGS; subst.
                          inversion H4; subst.
                          inversion H6; subst.
                          inversion H8; subst.
                          inversion H10; subst.

                          apply dvalue_refine_strict_addr_r_inv in H as (?&?&?); subst.
                          apply dvalue_refine_strict_addr_r_inv in H3 as (?&?&?); subst.
                          apply dvalue_refine_strict_i64_r_inv in H5 as (?&?&?); subst.
                          apply dvalue_refine_strict_i64_r_inv in H7 as (?&?&?); subst.
                          apply dvalue_refine_strict_i1_r_inv in H9 as (?&?&?); subst.

                          break_match_hyp.

                          2: {
                            (* Overlapping UB *)
                            eapply Interp_Memory_PropT_Vis with
                              (ta:=
                                 vis (ThrowUB tt)
                                   (fun x : void =>
                                      match
                                        x
                                        return
                                        (itree
                                           (InterpreterStackBigIntptr.LP.Events.ExternalCallE +'
                                                                                                 LLVMParamsBigIntptr.Events.PickUvalueE +' OOME +' UBE +' DebugE +' FailureE)
                                           (MemoryBigIntptr.MMEP.MMSP.MemState *
                                              (MemPropT.store_id * LLVMParamsBigIntptr.Events.DV.dvalue)))
                                      with
                                      end)).

                            3: {
                              red in KS.
                              red.
                              left.
                              eapply FindUB.
                              pstep; red; cbn.
                              constructor.
                              intros [].
                            }

                            2: {
                              cbn.
                              repeat red.
                              left.
                              exists "memcpy with overlapping or non-equal src and dst memory locations.".
                              red.
                              rewrite Heqb.
                              cbn.
                              left.
                              red.
                              cbn in H2.
                              rewrite H2.
                              rewrite Heqb0.
                              erewrite <- fin_inf_no_overlap; eauto.
                              erewrite <- fin_inf_ptoi; eauto.
                              erewrite <- fin_inf_ptoi; eauto.
                              rewrite Heqb1.
                              cbn; auto.
                            }

                            intros a1 b RETa RETb AB.
                            eapply Returns_vis_inversion in RETb.
                            destruct RETb as [[] _].
                          }

                          (* May be UB in read / write... *)
                          (* HANDLER has UB in it *)
                          eapply Interp_Memory_PropT_Vis with
                            (ta:=raise_ub "").

                          3: {
                            red in KS.
                            red.
                            left.
                            eapply FindUB.
                            pstep; red; cbn.
                            constructor.
                            intros [].
                          }

                          { intros a1 b RETa RETb AB.
                            cbn in RETb.
                            unfold raiseUB in RETb.
                            rewrite bind_trigger in RETb.
                            eapply Returns_vis_inversion in RETb.
                            destruct RETb as [[] _].
                          }

                          cbn.
                          red.
                          left.
                          exists ub_msg.
                          red.
                          rewrite Heqb.

                          left.
                          cbn.
                          red.

                          cbn in H2, H3, H5.
                          rewrite H2.
                          rewrite Heqb0.
                          erewrite <- fin_inf_no_overlap; eauto.
                          erewrite <- fin_inf_ptoi; eauto.
                          erewrite <- fin_inf_ptoi; eauto.
                          rewrite Heqb1.
                          eapply MemPropT_fin_inf_bind_ub.
                          5: apply HANDLER.
                          all: eauto with FinInf.

                          2: {
                            intros msg H.
                            eapply fin_inf_read_bytes_spec_ub'; eauto.
                            apply lift_MemState_refine_prop.
                          }

                          2: {
                            intros ms_inf ms_fin a_fin a_inf msg H H7 H9 H11.
                            eapply fin_inf_write_bytes_spec_ub; eauto.
                          }

                          intros a_fin ms_fin_ma READ.
                          eapply fin_inf_read_bytes_spec; eauto.
                          apply lift_MemState_refine_prop.
                        }

                        { (* iptr *)
                          red in HANDLER.
                          break_match_hyp.
                          { (* Negative length UB *)
                            subst.
                            inversion ARGS; subst.
                            inversion H4; subst.
                            inversion H6; subst.
                            inversion H8; subst.
                            inversion H10; subst.

                            apply dvalue_refine_strict_addr_r_inv in H as (?&?&?); subst.
                            apply dvalue_refine_strict_addr_r_inv in H3 as (?&?&?); subst.
                            apply dvalue_refine_strict_iptr_r_inv in H5 as (?&?&?); subst.
                            apply dvalue_refine_strict_iptr_r_inv in H7 as (?&?&?); subst.
                            apply dvalue_refine_strict_i1_r_inv in H9 as (?&?&?); subst.

                            eapply Interp_Memory_PropT_Vis with
                              (ta:=
                                 vis (ThrowUB tt)
                                   (fun x : void =>
                                      match
                                        x
                                        return
                                        (itree
                                           (InterpreterStackBigIntptr.LP.Events.ExternalCallE +'
                                                                                                 LLVMParamsBigIntptr.Events.PickUvalueE +' OOME +' UBE +' DebugE +' FailureE)
                                           (MemoryBigIntptr.MMEP.MMSP.MemState *
                                              (MemPropT.store_id * LLVMParamsBigIntptr.Events.DV.dvalue)))
                                      with
                                      end)).

                            3: {
                              red in KS.
                              red.
                              left.
                              eapply FindUB.
                              pstep; red; cbn.
                              constructor.
                              intros [].
                            }

                            2: {
                              cbn.
                              repeat red.
                              left.
                              exists "memcpy given negative length.".
                              red.
                              rewrite Heqb.
                              cbn.
                              left.
                              red.
                              cbn in H2.
                              unfold InterpreterStackBigIntptr.LP.IP.to_Z in *.
                              erewrite IP.from_Z_to_Z in Heqb0; eauto.
                              rewrite Heqb0.
                              cbn; auto.
                            }

                            intros a1 b RETa RETb AB.
                            eapply Returns_vis_inversion in RETb.
                            destruct RETb as [[] _].
                          }

                          subst.
                          inversion ARGS; subst.
                          inversion H4; subst.
                          inversion H6; subst.
                          inversion H8; subst.
                          inversion H10; subst.

                          apply dvalue_refine_strict_addr_r_inv in H as (?&?&?); subst.
                          apply dvalue_refine_strict_addr_r_inv in H3 as (?&?&?); subst.
                          apply dvalue_refine_strict_iptr_r_inv in H5 as (?&?&?); subst.
                          apply dvalue_refine_strict_iptr_r_inv in H7 as (?&?&?); subst.
                          apply dvalue_refine_strict_i1_r_inv in H9 as (?&?&?); subst.

                          break_match_hyp.

                          2: {
                            (* Overlapping UB *)
                            eapply Interp_Memory_PropT_Vis with
                              (ta:=
                                 vis (ThrowUB tt)
                                   (fun x : void =>
                                      match
                                        x
                                        return
                                        (itree
                                           (InterpreterStackBigIntptr.LP.Events.ExternalCallE +'
                                                                                                 LLVMParamsBigIntptr.Events.PickUvalueE +' OOME +' UBE +' DebugE +' FailureE)
                                           (MemoryBigIntptr.MMEP.MMSP.MemState *
                                              (MemPropT.store_id * LLVMParamsBigIntptr.Events.DV.dvalue)))
                                      with
                                      end)).

                            3: {
                              red in KS.
                              red.
                              left.
                              eapply FindUB.
                              pstep; red; cbn.
                              constructor.
                              intros [].
                            }

                            2: {
                              cbn.
                              repeat red.
                              left.
                              exists "memcpy with overlapping or non-equal src and dst memory locations.".
                              red.
                              rewrite Heqb.
                              cbn.
                              left.
                              red.
                              cbn in H2.
                              unfold InterpreterStackBigIntptr.LP.IP.to_Z in *.
                              erewrite IP.from_Z_to_Z in Heqb0; eauto.
                              rewrite Heqb0.
                              erewrite <- fin_inf_no_overlap; eauto.
                              erewrite <- fin_inf_ptoi; eauto.
                              erewrite <- fin_inf_ptoi; eauto.
                              erewrite IP.from_Z_to_Z in Heqb1; eauto.
                              rewrite Heqb1.
                              cbn; auto.
                            }

                            intros a1 b RETa RETb AB.
                            eapply Returns_vis_inversion in RETb.
                            destruct RETb as [[] _].
                          }

                          (* May be UB in read / write... *)
                          (* HANDLER has UB in it *)
                          eapply Interp_Memory_PropT_Vis with
                            (ta:=raise_ub "").

                          3: {
                            red in KS.
                            red.
                            left.
                            eapply FindUB.
                            pstep; red; cbn.
                            constructor.
                            intros [].
                          }

                          { intros a1 b RETa RETb AB.
                            cbn in RETb.
                            unfold raiseUB in RETb.
                            rewrite bind_trigger in RETb.
                            eapply Returns_vis_inversion in RETb.
                            destruct RETb as [[] _].
                          }

                          cbn.
                          red.
                          left.
                          exists ub_msg.
                          red.
                          rewrite Heqb.

                          left.
                          cbn.
                          red.

                          cbn in H2, H3, H5.
                          unfold InterpreterStackBigIntptr.LP.IP.to_Z in *.
                          erewrite IP.from_Z_to_Z in Heqb0; eauto.
                          rewrite Heqb0.
                          erewrite <- fin_inf_no_overlap; eauto.
                          erewrite <- fin_inf_ptoi; eauto.
                          erewrite <- fin_inf_ptoi; eauto.
                          erewrite IP.from_Z_to_Z in Heqb1; eauto.
                          rewrite Heqb1.
                          eapply MemPropT_fin_inf_bind_ub.
                          5: apply HANDLER.
                          all: eauto with FinInf.

                          2: {
                            intros msg H.
                            erewrite IP.from_Z_to_Z in H; eauto.
                            eapply fin_inf_read_bytes_spec_ub'; eauto.
                            apply lift_MemState_refine_prop.
                          }

                          2: {
                            intros ms_inf ms_fin a_fin a_inf msg H H7 H9 H11.
                            eapply fin_inf_write_bytes_spec_ub; eauto.
                          }

                          intros a_fin ms_fin_ma READ.
                          erewrite IP.from_Z_to_Z in READ; eauto.
                          eapply fin_inf_read_bytes_spec; eauto.
                          apply lift_MemState_refine_prop.
                        }
                      }

                      break_match_hyp.
                      { (* Malloc *)
                        cbn in *.
                        destruct INTRINSIC as [HANDLER | [sab [[] [HANDLER []]]]].
                        red in HANDLER.
                        repeat (destruct ARGS;
                                [solve [ inversion HANDLER
                                       | red in HANDLER;
                                         repeat break_match_hyp; cbn in HANDLER; inversion HANDLER
                                   ]
                                |
                               ]).
                        repeat (break_match_hyp; try solve [cbn in HANDLER; contradiction]);
                        inv ARGS;
                        rename H into ARG_REF.

                        { (* i1 *)
                          apply dvalue_refine_strict_i1_r_inv in ARG_REF as (?&?&ARG_REF); cbn in ARG_REF; subst.
                          eapply Interp_Memory_PropT_Vis with
                            (ta:=raise_ub "").

                          3: {
                            red.
                            left.
                            eapply FindUB.
                            pstep; red; cbn.
                            constructor.
                            intros [].
                          }

                          { intros a b RETa RETb AB.
                            cbn in RETb.
                            unfold raiseUB in RETb.
                            rewrite bind_trigger in RETb.
                            eapply Returns_vis_inversion in RETb.
                            destruct RETb as [[] _].
                          }

                          cbn.
                          red.
                          red.
                          left.
                          exists ub_msg.
                          red.
                          rewrite Heqb, Heqb0.
                          left.

                          eapply MemPropT_fin_inf_bind_ub.
                          5: apply HANDLER.
                          all: eauto with FinInf.

                          { intros a_fin ms_fin_ma H.
                            eapply fresh_sid_fin_inf; eauto with FinInf.
                          }

                          intros ms_inf ms_fin a_fin a_inf msg SID MSR' FRESH MALLOC.

                          eapply MemPropT_fin_inf_bind_ub with
                            (A_REF:=sbytes_refine).
                          5: apply MALLOC.
                          all: eauto with FinInf.

                          2: {
                            intros msg0 GEN.
                            red; red in GEN.
                            break_match_hyp; cbn in GEN; try contradiction.
                          }

                          { intros a_fin0 ms_fin_ma GEN.
                            red in GEN.
                            break_match_hyp; cbn in GEN; try contradiction.
                            destruct GEN; subst.
                            eapply generate_num_undef_bytes_fin_inf in Heqo.

                            destruct Heqo as (bytes_inf&GEN&BYTE_REF).
                            exists bytes_inf. exists ms_inf.
                            split; auto.

                            red.
                            cbn in *; subst.
                            rewrite ARG_REF.
                            rewrite GEN.
                            auto.
                          }
                        }

                        { (* i8 *)
                          apply dvalue_refine_strict_i8_r_inv in ARG_REF as (?&?&ARG_REF); cbn in ARG_REF; subst.
                          eapply Interp_Memory_PropT_Vis with
                            (ta:=raise_ub "").

                          3: {
                            red.
                            left.
                            eapply FindUB.
                            pstep; red; cbn.
                            constructor.
                            intros [].
                          }

                          { intros a b RETa RETb AB.
                            cbn in RETb.
                            unfold raiseUB in RETb.
                            rewrite bind_trigger in RETb.
                            eapply Returns_vis_inversion in RETb.
                            destruct RETb as [[] _].
                          }

                          cbn.
                          red.
                          red.
                          left.
                          exists ub_msg.
                          red.
                          rewrite Heqb, Heqb0.
                          left.

                          eapply MemPropT_fin_inf_bind_ub.
                          5: apply HANDLER.
                          all: eauto with FinInf.

                          { intros a_fin ms_fin_ma H.
                            eapply fresh_sid_fin_inf; eauto with FinInf.
                          }

                          intros ms_inf ms_fin a_fin a_inf msg SID MSR' FRESH MALLOC.

                          eapply MemPropT_fin_inf_bind_ub with
                            (A_REF:=sbytes_refine).
                          5: apply MALLOC.
                          all: eauto with FinInf.

                          2: {
                            intros msg0 GEN.
                            red; red in GEN.
                            break_match_hyp; cbn in GEN; try contradiction.
                          }

                          { intros a_fin0 ms_fin_ma GEN.
                            red in GEN.
                            break_match_hyp; cbn in GEN; try contradiction.
                            destruct GEN; subst.
                            eapply generate_num_undef_bytes_fin_inf in Heqo.

                            destruct Heqo as (bytes_inf&GEN&BYTE_REF).
                            exists bytes_inf. exists ms_inf.
                            split; auto.

                            red.
                            cbn in *; subst.
                            rewrite ARG_REF.
                            rewrite GEN.
                            auto.
                          }
                        }

                        { (* i32 *)
                          apply dvalue_refine_strict_i32_r_inv in ARG_REF as (?&?&ARG_REF); cbn in ARG_REF; subst.
                          eapply Interp_Memory_PropT_Vis with
                            (ta:=raise_ub "").

                          3: {
                            red.
                            left.
                            eapply FindUB.
                            pstep; red; cbn.
                            constructor.
                            intros [].
                          }

                          { intros a b RETa RETb AB.
                            cbn in RETb.
                            unfold raiseUB in RETb.
                            rewrite bind_trigger in RETb.
                            eapply Returns_vis_inversion in RETb.
                            destruct RETb as [[] _].
                          }

                          cbn.
                          red.
                          red.
                          left.
                          exists ub_msg.
                          red.
                          rewrite Heqb, Heqb0.
                          left.

                          eapply MemPropT_fin_inf_bind_ub.
                          5: apply HANDLER.
                          all: eauto with FinInf.

                          { intros a_fin ms_fin_ma H.
                            eapply fresh_sid_fin_inf; eauto with FinInf.
                          }

                          intros ms_inf ms_fin a_fin a_inf msg SID MSR' FRESH MALLOC.

                          eapply MemPropT_fin_inf_bind_ub with
                            (A_REF:=sbytes_refine).
                          5: apply MALLOC.
                          all: eauto with FinInf.

                          2: {
                            intros msg0 GEN.
                            red; red in GEN.
                            break_match_hyp; cbn in GEN; try contradiction.
                          }

                          { intros a_fin0 ms_fin_ma GEN.
                            red in GEN.
                            break_match_hyp; cbn in GEN; try contradiction.
                            destruct GEN; subst.
                            eapply generate_num_undef_bytes_fin_inf in Heqo.

                            destruct Heqo as (bytes_inf&GEN&BYTE_REF).
                            exists bytes_inf. exists ms_inf.
                            split; auto.

                            red.
                            cbn in *; subst.
                            rewrite ARG_REF.
                            rewrite GEN.
                            auto.
                          }
                        }

                        { (* i64 *)
                          apply dvalue_refine_strict_i64_r_inv in ARG_REF as (?&?&ARG_REF); cbn in ARG_REF; subst.
                          eapply Interp_Memory_PropT_Vis with
                            (ta:=raise_ub "").

                          3: {
                            red.
                            left.
                            eapply FindUB.
                            pstep; red; cbn.
                            constructor.
                            intros [].
                          }

                          { intros a b RETa RETb AB.
                            cbn in RETb.
                            unfold raiseUB in RETb.
                            rewrite bind_trigger in RETb.
                            eapply Returns_vis_inversion in RETb.
                            destruct RETb as [[] _].
                          }

                          cbn.
                          red.
                          red.
                          left.
                          exists ub_msg.
                          red.
                          rewrite Heqb, Heqb0.
                          left.

                          eapply MemPropT_fin_inf_bind_ub.
                          5: apply HANDLER.
                          all: eauto with FinInf.

                          { intros a_fin ms_fin_ma H.
                            eapply fresh_sid_fin_inf; eauto with FinInf.
                          }

                          intros ms_inf ms_fin a_fin a_inf msg SID MSR' FRESH MALLOC.

                          eapply MemPropT_fin_inf_bind_ub with
                            (A_REF:=sbytes_refine).
                          5: apply MALLOC.
                          all: eauto with FinInf.

                          2: {
                            intros msg0 GEN.
                            red; red in GEN.
                            break_match_hyp; cbn in GEN; try contradiction.
                          }

                          { intros a_fin0 ms_fin_ma GEN.
                            red in GEN.
                            break_match_hyp; cbn in GEN; try contradiction.
                            destruct GEN; subst.
                            eapply generate_num_undef_bytes_fin_inf in Heqo.

                            destruct Heqo as (bytes_inf&GEN&BYTE_REF).
                            exists bytes_inf. exists ms_inf.
                            split; auto.

                            red.
                            cbn in *; subst.
                            rewrite ARG_REF.
                            rewrite GEN.
                            auto.
                          }
                        }

                        { (* iptr *)
                          apply dvalue_refine_strict_iptr_r_inv in ARG_REF as (?&?&ARG_REF); cbn in ARG_REF; subst.
                          eapply Interp_Memory_PropT_Vis with
                            (ta:=raise_ub "").

                          3: {
                            red.
                            left.
                            eapply FindUB.
                            pstep; red; cbn.
                            constructor.
                            intros [].
                          }

                          { intros a b RETa RETb AB.
                            cbn in RETb.
                            unfold raiseUB in RETb.
                            rewrite bind_trigger in RETb.
                            eapply Returns_vis_inversion in RETb.
                            destruct RETb as [[] _].
                          }

                          cbn.
                          red.
                          red.
                          left.
                          exists ub_msg.
                          red.
                          rewrite Heqb, Heqb0.
                          left.

                          eapply MemPropT_fin_inf_bind_ub.
                          5: apply HANDLER.
                          all: eauto with FinInf.

                          { intros a_fin ms_fin_ma H.
                            eapply fresh_sid_fin_inf; eauto with FinInf.
                          }

                          intros ms_inf ms_fin a_fin a_inf msg SID MSR' FRESH MALLOC.

                          eapply MemPropT_fin_inf_bind_ub with
                            (A_REF:=sbytes_refine).
                          5: apply MALLOC.
                          all: eauto with FinInf.

                          2: {
                            intros msg0 GEN.
                            red; red in GEN.
                            break_match_hyp; cbn in GEN; try contradiction.
                          }

                          { intros a_fin0 ms_fin_ma GEN.
                            red in GEN.
                            break_match_hyp; cbn in GEN; try contradiction.
                            destruct GEN; subst.
                            eapply generate_num_undef_bytes_fin_inf in Heqo.

                            destruct Heqo as (bytes_inf&GEN&BYTE_REF).
                            exists bytes_inf. exists ms_inf.
                            split; auto.


                            red.
                            assert (Z.to_N (LLVMParamsBigIntptr.IP.to_unsigned x1) = (Z.to_N (LLVMParams64BitIntptr.IP.to_unsigned x0))) as EQ'.
                            { unfold Z.to_N.
                              unfold LLVMParams64BitIntptr.IP.to_unsigned.
                              rewrite <- IP.to_Z_to_unsigned.
                              erewrite IP.from_Z_to_Z; eauto.
                              rewrite <- ARG_REF.
                              rewrite <- MemoryBigIntptrInfiniteSpec.LP.IP.to_Z_to_unsigned.
                              reflexivity.
                            }

                            rewrite EQ'.
                            cbn in SID; subst.
                            rewrite GEN.
                            cbn; auto.
                          }
                        }
                      }

                      break_match_hyp.
                      { (* Free *)
                        cbn in *.
                        destruct INTRINSIC as [HANDLER | [sab [[] [HANDLER []]]]].
                        red in HANDLER.
                        repeat (destruct ARGS;
                                [solve [ inversion HANDLER
                                       | red in HANDLER;
                                         repeat break_match_hyp; cbn in HANDLER; inversion HANDLER
                                   ]
                                |
                               ]).
                        repeat (break_match_hyp; try solve [cbn in HANDLER; contradiction]);
                        inv ARGS;
                        rename H into ARG_REF.

                        apply dvalue_refine_strict_addr_r_inv in ARG_REF as (?&?&ARG_REF);
                          cbn in ARG_REF; subst.
                        eapply Interp_Memory_PropT_Vis with
                          (ta:=raise_ub "").

                        3: {
                          red.
                          left.
                          eapply FindUB.
                          pstep; red; cbn.
                          constructor.
                          intros [].
                        }

                        { intros a0 b RETa RETb AB.
                          cbn in RETb.
                          unfold raiseUB in RETb.
                          rewrite bind_trigger in RETb.
                          eapply Returns_vis_inversion in RETb.
                          destruct RETb as [[] _].
                        }

                        cbn.
                        red.
                        red.
                        left.
                        exists ub_msg.
                        red.
                        rewrite Heqb, Heqb0, Heqb1.
                        left.

                        cbn.
                        intros CONTRA.

                        eapply inf_fin_free_preconditions in CONTRA; eauto.
                        apply lift_MemState_refine_prop.
                      }

                      cbn in INTRINSIC.
                      contradiction.
                    }

                    { (* Handler raises Error *)
                      destruct ERR as [err_msg [TA HANDLER]].
                      unfold raise_error in TA.
                      cbn in TA.
                      unfold LLVMEvents.raise in TA.
                      rewrite bind_trigger in TA.

                      destruct VIS_HANDLED as [VIS_HANDLED | VIS_HANDLED].
                      { rewrite TA in VIS_HANDLED.
                        exfalso.
                        eapply contains_UB_Extra_raise_error.
                        2: {
                          unfold raise_error.
                          cbn.
                          unfold LLVMEvents.raise.
                          rewrite bind_trigger.
                          eapply VIS_HANDLED.
                        }

                        intros X e1 e2 CONTRA.
                        inv CONTRA.
                      }

                      clear KS.
                      eapply Interp_Memory_PropT_Vis with (ta:=
                                                             vis (Throw (print_msg err_msg))
                                                               (fun x : void =>
                                                                  match
                                                                    x
                                                                    return
                                                                    (itree
                                                                       (InterpreterStackBigIntptr.LP.Events.ExternalCallE +'
                                                                                                                             LLVMParamsBigIntptr.Events.PickUvalueE +' OOME +' UBE +' DebugE +' FailureE)
                                                                       (MemoryBigIntptr.MMEP.MMSP.MemState *
                                                                          (MemPropT.store_id * LLVMParamsBigIntptr.Events.DV.dvalue)))
                                                                  with
                                                                  end))
                      .

                      3: {
                        right.
                        rewrite VIS_HANDLED.
                        rewrite TA.
                        rewrite bind_vis.
                        rewrite get_inf_tree_equation.
                        cbn. unfold LLVMEvents.raise.

                        rewrite bind_trigger.
                        rewrite bind_vis.
                        pstep; red; cbn.
                        constructor.
                        intros [].
                      }

                      { intros a (ms_b, (sid_b, b)) RET1 RET2 AB.
                        cbn in AB; subst.

                        eapply Returns_vis_inversion in RET2.
                        destruct RET2 as [[] _].
                      }

                      repeat red.
                      right.
                      left.
                      exists err_msg.
                      split.
                      cbn.
                      unfold LLVMEvents.raise.
                      rewrite bind_trigger.
                      reflexivity.

                      destruct HANDLER.
                      eapply handle_intrinsic_fin_inf_error.
                      2: apply lift_MemState_refine_prop.
                      all: eauto.
                    }

                    { (* Handler raises OOM *)
                      destruct OOM as [oom_msg [TA HANDLER]].
                      unfold raise_oom in TA.
                      cbn in TA.
                      unfold raiseOOM in TA.
                      rewrite bind_trigger in TA.

                      rewrite TA in VIS_HANDLED.
                      rewrite bind_vis in VIS_HANDLED.

                      destruct VIS_HANDLED as [VIS_HANDLED | VIS_HANDLED].
                      { exfalso.
                        eapply contains_UB_Extra_raiseOOM.
                        2: {
                          unfold raiseOOM.
                          rewrite bind_trigger.
                          eapply VIS_HANDLED.
                        }

                        intros X e1 e2 CONTRA.
                        inv CONTRA.
                      }

                      punfold VIS_HANDLED; red in VIS_HANDLED; cbn in VIS_HANDLED.
                      dependent induction VIS_HANDLED.
                      2: {
                        specialize (EQ t1); contradiction.
                      }

                      econstructor.
                      rewrite get_inf_tree_equation.
                      cbn.
                      unfold raiseOOM.
                      rewrite bind_trigger.
                      reflexivity.
                    }

                    (* Handler succeeds *)
                    destruct HSPEC as (st1&ms'&d&TA&INTRINSIC).
                    rewrite TA in VIS_HANDLED.

                    destruct VIS_HANDLED as [VIS_HANDLED | VIS_HANDLED].
                    { eapply ret_not_contains_UB_Extra in VIS_HANDLED; try contradiction.
                      reflexivity.
                    }

                    setoid_rewrite bind_ret_l in VIS_HANDLED.

                    { epose proof handle_intrinsic_fin_inf ARGS (lift_MemState_refine_prop s2) INTRINSIC as (dv_inf&ms_inf'&INTRINSIC_INF&DV_REF&MSR_INTRINSIC).

                      eapply Interp_Memory_PropT_Vis with
                        (k2:=(fun '(ms_inf, (sid', dv_inf)) =>
                                get_inf_tree (k2 (ms', (st1, d)))
                             )
                        )
                        (s1:=s1)
                        (s2:=lift_MemState s2).

                      2: {
                        cbn. red. red.
                        repeat right.
                        exists s1.
                        exists ms_inf'.
                        exists dv_inf.
                        split; eauto.
                        reflexivity.
                      }

                      2: {
                        right.
                        cbn.
                        rewrite bind_ret_l.
                        rewrite VIS_HANDLED.
                        reflexivity.
                      }

                      (* Continuation for vis node *)
                      intros a b H H1 H2.
                      destruct b as [ms [sid' res]].
                      cbn in H1.
                      apply Returns_ret_inv in H1.
                      inv H1.

                      cbn.
                      rewrite (itree_eta_ (k0 dv_inf)).
                      rewrite (itree_eta_ (k2 (ms', (st1, d)))).
                      right.
                      eapply CIH.
                      2: {
                        repeat red.
                        specialize (HK d (ms', (st1, d))).
                        forward HK.
                        { eapply ReturnsVis.
                          unfold trigger.
                          reflexivity.
                          cbn.
                          constructor.
                          reflexivity.
                        }
                        forward HK.
                        { constructor.
                          auto.
                        }

                        forward HK; auto.
                        pclearbot.

                        repeat rewrite <- itree_eta.
                        apply HK.
                      }

                      specialize (REL dv_inf).
                      red in REL.
                      pclearbot.

                      repeat rewrite <- itree_eta.
                      rewrite REL.
                      eapply K_RUTT.
                      repeat (split; auto).
                    }
                  }

                  { (* MemPush *)
                    repeat red in H0.
                    rename s2 into m1.
                    destruct HSPEC as [UB | [ERR | [OOM | HSPEC]]].
                    { (* Handler raises UB *)
                      destruct UB as [ub_msg UB].
                      cbn in UB.
                      contradiction.
                    }

                    { (* Handler raises error *)
                      (* Probably not possible to have an error for MemPush... *)
                      destruct ERR as (msg&TA&msg_spec&ERR).
                      cbn in ERR.
                      contradiction.
                    }

                    { (* Handler raises OOM *)
                      destruct OOM as (oom_msg&TA_OOM&(oom_spec_msg&HANDLE_OOM)).
                      rewrite TA_OOM in VIS_HANDLED.
                      pose proof (@Raise.rbm_raise_bind (itree (ExternalCallE +'
                                                                                 LLVMParams64BitIntptr.Events.PickUvalueE +' OOME +' UBE +' DebugE +' FailureE)) _ _ string (@raise_oom _ _) _ _ _ k2 oom_msg) as RAISE.
                      rewrite RAISE in VIS_HANDLED.
                      destruct VIS_HANDLED as [VIS_HANDLED | VIS_HANDLED].
                      { eapply contains_UB_Extra_raiseOOM in VIS_HANDLED; try contradiction.
                        intros X e1 e2 CONTRA.
                        inv CONTRA.
                      }

                      punfold VIS_HANDLED; red in VIS_HANDLED; cbn in VIS_HANDLED.
                      dependent induction VIS_HANDLED.
                      - eapply Interp_Memory_PropT_Vis_OOM.
                        rewrite get_inf_tree_equation.
                        cbn.
                        unfold raiseOOM.
                        rewrite bind_trigger.
                        reflexivity.
                      - specialize (EQ t1); contradiction.
                    }

                    (* Handler succeeds *)
                    destruct HSPEC as [st' [ms_push [[] [TA PUSH_HANDLER]]]].
                    cbn in PUSH_HANDLER.

                    rewrite TA in VIS_HANDLED.
                    cbn in VIS_HANDLED.

                    destruct VIS_HANDLED as [VIS_HANDLED | VIS_HANDLED].
                    { eapply ret_not_contains_UB_Extra in VIS_HANDLED; try contradiction.
                      cbn. reflexivity.
                    }

                    rewrite bind_ret_l in VIS_HANDLED.

                    { epose proof mem_push_spec_fin_inf (lift_MemState_refine_prop m1) (lift_MemState_refine_prop ms_push) PUSH_HANDLER as PUSH_INF.

                      pose proof MemState_fin_to_inf_to_fin_exists ms_push.
                      destruct H as (ms_push'&MS_PUSH_CONV&MS_PUSH_EQV).

                      eapply Interp_Memory_PropT_Vis with
                        (k2:=(fun '(ms_inf, (sid', _)) =>
                                match convert_MemState ms_inf with
                                | NoOom ms_fin =>
                                    get_inf_tree (k2 (ms_push, (st', tt)))
                                | Oom s => raiseOOM s
                                end)
                        )
                        (s1:=s1)
                        (s2:=lift_MemState m1).

                      2: {
                        cbn. red. red.
                        repeat right.
                        exists s1.
                        exists (lift_MemState ms_push).
                        exists tt.
                        split; try reflexivity.
                        cbn; auto.
                      }

                      2: {
                        right.
                        cbn.
                        rewrite bind_ret_l.
                        rewrite MS_PUSH_CONV.
                        rewrite VIS_HANDLED.
                        reflexivity.
                      }

                      (* Continuation for vis node *)
                      intros a b H H1 H2.
                      destruct b as [ms [sid' res]].
                      cbn in H1.
                      apply Returns_ret_inv in H1.
                      inv H1.

                      cbn.
                      rewrite MS_PUSH_CONV.
                      rewrite (itree_eta_ (k0 tt)).
                      rewrite (itree_eta_ (k2 (ms_push, (st', tt)))).
                      right.
                      eapply CIH.
                      2: {
                        repeat red.
                        specialize (HK tt (ms_push, (st', tt))).
                        forward HK.
                        { eapply ReturnsVis.
                          unfold trigger.
                          reflexivity.
                          cbn.
                          constructor.
                          reflexivity.
                        }
                        forward HK.
                        { rewrite TA.
                          constructor.
                          reflexivity.
                        }

                        forward HK; auto.
                        pclearbot.

                        repeat rewrite <- itree_eta.
                        apply HK.
                      }

                      specialize (REL tt).
                      red in REL.
                      pclearbot.

                      repeat rewrite <- itree_eta.
                      rewrite REL.
                      eapply K_RUTT.
                      repeat (split; auto).
                    }
                  }

                  { (* MemPop *)
                    repeat red in HSPEC.
                    destruct HSPEC as [UB | [ERR | [OOM | HSPEC]]].
                    { (* Handler raises UB *)
                      cbn in UB.
                      destruct UB as [msg []].
                    }

                    { (* Handler raises error *)
                      destruct ERR as (msg&TA&msg_spec&ERR).
                      cbn in ERR.

                      (* There's an error if I cannot pop a stack frame...

                         This shouldn't happen, but I should hopefully
                         be able to show that if I cannot pop in the
                         finite world, then I cannot pop in the
                         infinite world either, so we should get an
                         error in both places.
                       *)

                      rewrite TA in VIS_HANDLED.
                      pose proof (@Raise.rbm_raise_bind (itree (ExternalCallE +'
                                                                                 LLVMParams64BitIntptr.Events.PickUvalueE +' OOME +' UBE +' DebugE +' FailureE)) _ _ string (@raise_error _ _) _ _ _ k2 msg) as RAISE.
                      rewrite RAISE in VIS_HANDLED.

                      destruct VIS_HANDLED as [VIS_HANDLED | VIS_HANDLED].
                      { eapply contains_UB_Extra_raise_error in VIS_HANDLED; try contradiction.
                        intros X e1 e2 CONTRA.
                        inv CONTRA.
                      }

                      punfold VIS_HANDLED; red in VIS_HANDLED; cbn in VIS_HANDLED.
                      dependent induction VIS_HANDLED.
                      2: {
                        specialize (EQ t1); contradiction.
                      }

                      eapply Interp_Memory_PropT_Vis with
                        (k2:=(fun '(ms_inf, (sid', _)) =>
                                get_inf_tree (k2 (s2, (s1, tt)))
                        ))
                        (s1:=s1)
                        (s2:=lift_MemState s2).

                      2: {
                        pose proof cannot_pop_fin_inf (lift_MemState_refine_prop s2) ERR as ERR_INF.
                        cbn.
                        repeat red.
                        right.
                        left.
                        cbn.
                        exists msg.
                        split; [reflexivity|].
                        exists msg_spec.
                        auto.
                      }

                      2: {
                        right.
                        rewrite get_inf_tree_equation.
                        cbn.
                        setoid_rewrite Raise.raise_bind_itree.
                        reflexivity.
                      }

                      intros a b H H0 H1.
                      (* H0 might be a contradiction... *)
                      unfold LLVMEvents.raise in H0.
                      rewrite bind_trigger in H0.
                      apply Returns_vis_inversion in H0.
                      destruct H0 as [[] _].
                    }

                    { (* Handler raises OOM *)
                      destruct OOM as (oom_msg&TA_OOM&(oom_spec_msg&HANDLE_OOM)).
                      rewrite TA_OOM in VIS_HANDLED.
                      pose proof (@Raise.rbm_raise_bind (itree (ExternalCallE +'
                                                                                 LLVMParams64BitIntptr.Events.PickUvalueE +' OOME +' UBE +' DebugE +' FailureE)) _ _ string (@raise_oom _ _) _ _ _ k2 oom_msg) as RAISE.
                      rewrite RAISE in VIS_HANDLED.
                      destruct VIS_HANDLED as [VIS_HANDLED | VIS_HANDLED].
                      { eapply contains_UB_Extra_raiseOOM in VIS_HANDLED; try contradiction.
                        intros X e1 e2 CONTRA.
                        inv CONTRA.
                      }

                      punfold VIS_HANDLED; red in VIS_HANDLED; cbn in VIS_HANDLED.
                      dependent induction VIS_HANDLED.
                      - eapply Interp_Memory_PropT_Vis_OOM.
                        rewrite get_inf_tree_equation.
                        cbn.
                        unfold raiseOOM.
                        rewrite bind_trigger.
                        reflexivity.
                      - specialize (EQ t1); contradiction.
                    }

                    (* Handler succeeds *)
                    destruct HSPEC as [st' [ms_pop [[] [TA POP_HANDLER]]]].
                    cbn in POP_HANDLER.

                    rewrite TA in VIS_HANDLED.
                    cbn in VIS_HANDLED.
                    destruct VIS_HANDLED as [VIS_HANDLED | VIS_HANDLED].
                    { eapply ret_not_contains_UB_Extra in VIS_HANDLED; try contradiction.
                      cbn. reflexivity.
                    }

                    rewrite bind_ret_l in VIS_HANDLED.
                    pose proof MemState_fin_to_inf_to_fin_exists ms_pop.
                    destruct H as (ms_pop'&MS_POP_CONV&MS_POP_EQV).

                    { eapply Interp_Memory_PropT_Vis with
                        (k2:=(fun '(ms_inf, (sid', _)) =>
                                match convert_MemState ms_inf with
                                | NoOom ms_fin =>
                                    get_inf_tree (k2 (ms_pop, (st', tt)))
                                | Oom s => raiseOOM s
                                end)
                        )
                        (s1:=s1)
                        (s2:=lift_MemState s2).

                      2: {
                        cbn. red. red.
                        repeat right.
                        exists s1.
                        exists (lift_MemState ms_pop).
                        exists tt.
                        split; try reflexivity.
                        cbn.

                        eapply mem_pop_spec_fin_inf; eauto; apply lift_MemState_refine_prop.
                      }

                      2: {
                        right.
                        cbn.
                        rewrite bind_ret_l.
                        rewrite MS_POP_CONV.
                        rewrite VIS_HANDLED.
                        reflexivity.
                      }

                      (* Continuation for vis node *)
                      intros [] b H H1 H2.
                      destruct b as [ms [sid' res]].
                      cbn in H1.
                      cbn in H2. inv H2.
                      apply Returns_ret_inv in H1.
                      inv H1.

                      cbn.
                      rewrite MS_POP_CONV.
                      rewrite (itree_eta_ (k0 tt)).
                      rewrite (itree_eta_ (k2 (ms_pop, (st', tt)))).
                      right.
                      eapply CIH.
                      2: {
                        repeat red.
                        specialize (HK tt (ms_pop, (st', tt))).
                        forward HK.
                        { eapply ReturnsVis.
                          unfold trigger.
                          reflexivity.
                          cbn.
                          constructor.
                          reflexivity.
                        }
                        forward HK.
                        { rewrite TA.
                          constructor.
                          reflexivity.
                        }

                        forward HK; auto.
                        pclearbot.

                        repeat rewrite <- itree_eta.
                        apply HK.
                      }

                      specialize (REL tt).
                      red in REL.
                      pclearbot.

                      repeat rewrite <- itree_eta.
                      rewrite REL.
                      eapply K_RUTT.
                      repeat (split; auto).
                    }
                  }

                  { (* Alloca *)
                    repeat red in HSPEC.
                    destruct HSPEC as [UB | [ERR | [OOM | HSPEC]]].
                    { (* Handler raises UB *)

                      destruct UB as (msg_spec&UB).
                      destruct EV_REL as (?&?&?); subst.

                      eapply Interp_Memory_PropT_Vis
                          with (ta:= raise_ub "").
                        2: {
                          cbn; red.
                          left.
                          exists msg_spec.
                          red.
                          eapply MemPropT_fin_inf_bind_ub.
                          5: apply UB.
                          all: eauto with FinInf.

                          intros a_fin ms_fin_ma ALLOC.
                          eapply allocate_dtyp_spec_fin_inf; eauto with FinInf.
                        }

                        { intros a b RETa RETb AB.
                          cbn in AB; subst.
                          unfold raise_ub in RETb.
                          cbn in RETb.
                          unfold raiseUB in RETb.
                          rewrite bind_trigger in RETb.

                          eapply Returns_vis_inversion in RETb.
                          destruct RETb as [[] _].
                        }

                        left.
                        eapply FindUB.
                        unfold raise_ub. cbn; unfold raiseUB; cbn.
                        rewrite bind_trigger.
                        pstep; red; cbn.
                        rewrite subevent_subevent.
                        constructor.
                        intros [].
                    }

                    { (* Handler raises error *)
                      destruct ERR as (msg&TA&msg_spec&ERR).
                      destruct EV_REL as (?&?&?); subst.

                      apply handle_alloca_no_error in ERR.
                      contradiction.
                    }

                    { (* Handler raises OOM *)
                      destruct OOM as (oom_msg&TA_OOM&(oom_spec_msg&HANDLE_OOM)).
                      rewrite TA_OOM in VIS_HANDLED.
                      pose proof (@Raise.rbm_raise_bind (itree (ExternalCallE +'
                                                                                 LLVMParams64BitIntptr.Events.PickUvalueE +' OOME +' UBE +' DebugE +' FailureE)) _ _ string (@raise_oom _ _) _ _ _ k2 oom_msg) as RAISE.
                      rewrite RAISE in VIS_HANDLED.
                      destruct VIS_HANDLED as [VIS_HANDLED | VIS_HANDLED].
                      { eapply contains_UB_Extra_raiseOOM in VIS_HANDLED; try contradiction.
                        intros X e1 e2 CONTRA.
                        inv CONTRA.
                      }

                      punfold VIS_HANDLED; red in VIS_HANDLED; cbn in VIS_HANDLED.
                      dependent induction VIS_HANDLED.
                      - eapply Interp_Memory_PropT_Vis_OOM.
                        rewrite get_inf_tree_equation.
                        cbn.
                        unfold raiseOOM.
                        rewrite bind_trigger.
                        reflexivity.
                      - specialize (EQ t1); contradiction.
                    }

                    (* Handler succeeds *)
                    destruct HSPEC as [st' [ms_alloca [d [TA ALLOCA_HANDLER]]]].

                    rewrite TA in VIS_HANDLED.
                    cbn in VIS_HANDLED.
                    destruct VIS_HANDLED as [VIS_HANDLED | VIS_HANDLED].
                    { eapply ret_not_contains_UB_Extra in VIS_HANDLED; try contradiction.
                      cbn. reflexivity.
                    }

                    rewrite bind_ret_l in VIS_HANDLED.
                    destruct EV_REL as (?&?&?); subst.

                    { epose proof handle_alloca_fin_inf (lift_MemState_refine_prop s2) ALLOCA_HANDLER as (dv_inf&ms_inf'&ALLOCA_INF&DV_REF&MSR_ALLOCA).

                      eapply Interp_Memory_PropT_Vis with
                        (k2:=(fun '(ms_inf, (sid', dv_inf)) =>
                                get_inf_tree (k2 (ms_alloca, (st', d)))))
                        (s1:=s1)
                        (s2:=lift_MemState s2).

                      2: {
                        cbn. red. red.
                        repeat right.
                        exists s1.
                        exists ms_inf'.
                        exists dv_inf.
                        split; auto; reflexivity.
                      }

                      2: {
                        right.
                        cbn.
                        rewrite bind_ret_l.
                        rewrite VIS_HANDLED.
                        reflexivity.
                      }

                      (* Continuation for vis node *)
                      intros a b H H0 H1.
                      destruct b as [ms [sid' res]].
                      cbn in H1; subst.
                      cbn in H0.
                      apply Returns_ret_inv in H0.
                      inv H0.

                      rewrite (itree_eta_ (k0 dv_inf)).
                      rewrite (itree_eta_ (k2 (ms_alloca, (st', d)))).
                      right.
                      eapply CIH.
                      2: {
                        repeat red.
                        specialize (HK d (ms_alloca, (st', d))).
                        forward HK.
                        { eapply ReturnsVis.
                          unfold trigger.
                          reflexivity.
                          cbn.
                          constructor.
                          reflexivity.
                        }
                        forward HK.
                        { rewrite TA.
                          constructor.
                          reflexivity.
                        }

                        forward HK; auto.
                        pclearbot.

                        repeat rewrite <- itree_eta.
                        apply HK.
                      }

                      specialize (REL dv_inf).
                      red in REL.
                      pclearbot.

                      repeat rewrite <- itree_eta.
                      rewrite REL.
                      eapply K_RUTT.
                      repeat (split; auto).
                    }
                  }

                  { (* Load *)
                    repeat red in HSPEC.
                    destruct HSPEC as [UB | [ERR | [OOM | HSPEC]]].
                    { (* Handler raises UB *)
                      destruct UB as (msg_spec&UB).
                      destruct EV_REL as (?&?); subst.
                      rename H0 into DV_REF.

                      eapply Interp_Memory_PropT_Vis
                        with (ta:= raise_ub "").

                      2: {
                        cbn; red.
                        left.
                        exists msg_spec.
                        eapply handle_load_fin_inf_ub.
                        3: apply UB.
                        all: eauto with FinInf.
                      }

                      { intros a1 b RETa RETb AB.
                        cbn in AB; subst.
                        unfold raise_ub in RETb.
                        cbn in RETb.
                        unfold raiseUB in RETb.
                        rewrite bind_trigger in RETb.

                        eapply Returns_vis_inversion in RETb.
                        destruct RETb as [[] _].
                      }

                      left.
                      eapply FindUB.
                      unfold raise_ub. cbn; unfold raiseUB; cbn.
                      rewrite bind_trigger.
                      pstep; red; cbn.
                      rewrite subevent_subevent.
                      constructor.
                      intros [].
                    }

                    { (* Handler raises error *)
                      destruct ERR as (msg&TA&msg_spec&ERR).
                      destruct EV_REL as (?&?); subst.

                      rewrite TA in VIS_HANDLED.
                      pose proof (@Raise.rbm_raise_bind (itree (ExternalCallE +'
                                                                                 LLVMParams64BitIntptr.Events.PickUvalueE +' OOME +' UBE +' DebugE +' FailureE)) _ _ string (@raise_error _ _) _ _ _ k2 msg) as RAISE.
                      rewrite RAISE in VIS_HANDLED.
                      destruct VIS_HANDLED as [VIS_HANDLED | VIS_HANDLED].
                      { eapply contains_UB_Extra_raise_error in VIS_HANDLED; try contradiction.
                        intros X e1 e2 CONTRA.
                        inv CONTRA.
                      }

                      punfold VIS_HANDLED; red in VIS_HANDLED; cbn in VIS_HANDLED.
                      dependent induction VIS_HANDLED.
                      2: {
                        specialize (EQ t1); contradiction.
                      }

                      eapply Interp_Memory_PropT_Vis with
                        (k2:=(fun '(ms_inf, (sid', uv_inf)) =>
                                match DVCInfFin.uvalue_convert_strict uv_inf with
                                | NoOom uv_fin => get_inf_tree (k2 (s2, (s1, uv_fin)))
                                | Oom s => raiseOOM s
                                end)
                        )
                        (s1:=s1)
                        (s2:=lift_MemState s2)
                        (ta:= raise_error msg).
                      3: {
                        right.
                        rewrite get_inf_tree_equation.
                        cbn.
                        setoid_rewrite Raise.raise_bind_itree.
                        reflexivity.
                      }

                      2: {
                        (* raise_ub includes raise_error... *)
                        red in ERR.
                        break_match_hyp;
                          try solve
                            [ repeat red;
                              left;
                              exists "Loading from something that isn't an address.";
                              unfold_dvalue_refine_strict_in H0;
                              destruct a0; cbn in H0; try break_match_hyp_inv; cbn; auto
                            ].

                        apply dvalue_refine_strict_addr_r_inv in H0 as (ptr_inf&ADDR&ADDR_REF).
                        subst.

                        repeat red.
                        right.
                        left.

                        (* TODO: read_uvalue_spec_fin_inf_error lemma *)
                        (* Figure out where error came from in read_uvalue_spec *)
                        red in ERR.
                        repeat red in ERR.

                        destruct ERR as [ERR | ERR].
                        { (* TODO: read_bytes_spec_fin_inf_error lemma *)
                          repeat red in ERR.
                          destruct ERR as [ERR | ERR].
                          { exfalso.
                            apply get_consecutive_ptrs_never_fails in ERR.
                            auto.
                          }

                          destruct ERR as (?&?&GCP&ERR).
                          exists msg.
                          split; [reflexivity|].
                          exists msg_spec.

                          cbn.
                          left.
                          right.

                          pose proof GCP as GCP_INF.
                          eapply fin_inf_get_consecutive_ptrs_success_exists in GCP_INF; eauto.
                          2: apply lift_MemState_refine_prop.

                          destruct GCP_INF as(?&?&GCP_INF&FORALL_INF&MSR').
                          exists x2. exists x1.
                          split; auto.

                          clear - FORALL_INF ERR MSR'.
                          generalize dependent x.
                          generalize dependent x2.
                          induction FORALL_INF; intros x2 x' ERR MSR'.
                          - cbn in ERR; contradiction.
                          - rewrite map_monad_unfold.
                            rewrite map_monad_unfold in ERR.
                            destruct ERR as [ERR | ERR].
                            cbn in ERR; contradiction.

                            destruct ERR as (?&?&?&ERR).
                            cbn in ERR.
                            destruct ERR as [ERR | ERR].
                            + right.

                              pose proof H0 as READ_INF.
                              eapply fin_inf_read_byte_spec_MemPropT in READ_INF; eauto.
                              destruct READ_INF as (byte_inf & ms_inf' & READ_INF & BYTES_REF & MSR'').
                              exists ms_inf'. exists byte_inf.
                              split; auto.

                              cbn.
                              left.
                              eapply IHFORALL_INF; eauto.
                            + destruct ERR as (?&?&?&?).
                              contradiction.
                        }

                        destruct ERR as (?&?&?&ERR).
                        red in ERR.
                        break_match_hyp_inv.

                        eapply fin_inf_read_bytes_spec in H; eauto.
                        2: apply lift_MemState_refine_prop.
                        destruct H as (?&?&?&?&?).

                        pose proof Heqs as DESER_INF.
                        eapply deserialize_sbytes_fail_fin_inf in DESER_INF.
                        2: apply H0.

                        exists msg.
                        split; [reflexivity|].

                        exists s.
                        cbn.
                        right.

                        cbn in H.
                        destruct H as (?&?&?&?).
                        exists x2. exists x1.
                        split.
                        2: {
                          red.
                          rewrite DESER_INF.
                          cbn; auto.
                        }

                        exists x3. exists x4.
                        split; auto.
                      }

                      intros a1 b H H1 H2.
                      (* H0 might be a contradiction... *)
                      unfold raise_error in H1.
                      cbn in H1.
                      unfold LLVMEvents.raise in H1.
                      rewrite bind_trigger in H1.
                      apply Returns_vis_inversion in H1.
                      destruct H1 as [[] _].
                    }

                    { (* Handler raises OOM *)
                      destruct OOM as (oom_msg&TA_OOM&(oom_spec_msg&HANDLE_OOM)).
                      rewrite TA_OOM in VIS_HANDLED.
                      pose proof (@Raise.rbm_raise_bind (itree (ExternalCallE +'
                                                                                 LLVMParams64BitIntptr.Events.PickUvalueE +' OOME +' UBE +' DebugE +' FailureE)) _ _ string (@raise_oom _ _) _ _ _ k2 oom_msg) as RAISE.
                      rewrite RAISE in VIS_HANDLED.
                      destruct VIS_HANDLED as [VIS_HANDLED | VIS_HANDLED].
                      { eapply contains_UB_Extra_raiseOOM in VIS_HANDLED; try contradiction.
                        intros X e1 e2 CONTRA.
                        inv CONTRA.
                      }

                      punfold VIS_HANDLED; red in VIS_HANDLED; cbn in VIS_HANDLED.
                      dependent induction VIS_HANDLED.
                      - eapply Interp_Memory_PropT_Vis_OOM.
                        rewrite get_inf_tree_equation.
                        cbn.
                        unfold raiseOOM.
                        rewrite bind_trigger.
                        reflexivity.
                      - specialize (EQ t1); contradiction.
                    }

                    (* Handler succeeds *)
                    destruct HSPEC as [st' [ms_load [uv_fin [TA LOAD_HANDLER]]]].

                    rewrite TA in VIS_HANDLED.
                    cbn in VIS_HANDLED.
                    destruct VIS_HANDLED as [VIS_HANDLED | VIS_HANDLED].
                    { eapply ret_not_contains_UB_Extra in VIS_HANDLED; try contradiction.
                      cbn; reflexivity.
                    }

                    rewrite bind_ret_l in VIS_HANDLED.
                    destruct EV_REL as (?&?); subst.

                    { epose proof handle_load_fin_inf (lift_MemState_refine_prop s2) H0 LOAD_HANDLER as (uv_inf&ms_inf'&LOAD_INF&UV_REF&MSR_LOAD).

                      eapply Interp_Memory_PropT_Vis with
                        (k2:=(fun '(ms_inf, (sid', uv_inf)) =>
                                get_inf_tree (k2 (ms_load, (st', uv_fin)))))
                        (s1:=s1)
                        (s2:=lift_MemState s2).

                      2: {
                        cbn. red. red.
                        repeat right.
                        exists s1.
                        exists ms_inf'.
                        exists uv_inf.
                        split; auto; reflexivity.
                      }

                      2: {
                        right.
                        cbn.
                        rewrite bind_ret_l.
                        rewrite VIS_HANDLED.
                        reflexivity.
                      }

                      (* Continuation for vis node *)
                      intros a1 b H H2 H3.
                      destruct b as [ms [sid' res]].
                      cbn in H2; subst.
                      apply Returns_ret_inv in H2.
                      inv H2.
                      cbn.

                      rewrite (itree_eta_ (k0 uv_inf)).
                      rewrite (itree_eta_ (k2 (ms_load, (st', uv_fin)))).
                      right.
                      eapply CIH.
                      2: {
                        repeat red.
                        specialize (HK uv_fin (ms_load, (st', uv_fin))).
                        forward HK.
                        { eapply ReturnsVis.
                          unfold trigger.
                          reflexivity.
                          cbn.
                          constructor.
                          reflexivity.
                        }
                        forward HK.
                        { rewrite TA.
                          constructor.
                          reflexivity.
                        }

                        forward HK; auto.
                        pclearbot.

                        repeat rewrite <- itree_eta.
                        apply HK.
                      }

                      specialize (REL uv_inf).
                      red in REL.
                      pclearbot.

                      repeat rewrite <- itree_eta.
                      rewrite REL.
                      eapply K_RUTT.
                      repeat (split; auto).
                    }
                  }

                  { (* Store *)
                    repeat red in HSPEC.
                    destruct HSPEC as [UB | [ERR | [OOM | HSPEC]]].
                    { (* Handler raises UB *)
                      destruct UB as (msg_spec&UB).
                      destruct EV_REL as (?&?); subst.
                      rename H0 into DV_REF.
                      destruct DV_REF as [DV_REF UV_REF].

                      eapply Interp_Memory_PropT_Vis
                        with (ta:= raise_ub "").

                      2: {
                        cbn; red.
                        left.
                        exists msg_spec.
                        eapply handle_store_fin_inf_ub.
                        4: apply UB.
                        all: eauto with FinInf.
                      }

                      { intros a1 b RETa RETb AB.
                        cbn in AB; subst.
                        unfold raise_ub in RETb.
                        cbn in RETb.
                        unfold raiseUB in RETb.
                        rewrite bind_trigger in RETb.

                        eapply Returns_vis_inversion in RETb.
                        destruct RETb as [[] _].
                      }

                      left.
                      eapply FindUB.
                      unfold raise_ub. cbn; unfold raiseUB; cbn.
                      rewrite bind_trigger.
                      pstep; red; cbn.
                      rewrite subevent_subevent.
                      constructor.
                      intros [].
                    }

                    { (* Handler raises error *)
                      destruct ERR as (msg&TA&msg_spec&ERR).
                      destruct EV_REL as (?&?&?); subst.

                      rewrite TA in VIS_HANDLED.
                      pose proof (@Raise.rbm_raise_bind (itree (ExternalCallE +'
                                                                                 LLVMParams64BitIntptr.Events.PickUvalueE +' OOME +' UBE +' DebugE +' FailureE)) _ _ string (@raise_error _ _) _ _ _ k2 msg) as RAISE.
                      rewrite RAISE in VIS_HANDLED.
                      destruct VIS_HANDLED as [VIS_HANDLED | VIS_HANDLED].
                      { eapply contains_UB_Extra_raise_error in VIS_HANDLED; try contradiction.
                        intros X e1 e2 CONTRA.
                        inv CONTRA.
                      }

                      punfold VIS_HANDLED; red in VIS_HANDLED; cbn in VIS_HANDLED.
                      dependent induction VIS_HANDLED.
                      2: {
                        specialize (EQ t1); contradiction.
                      }

                      eapply Interp_Memory_PropT_Vis with
                        (k2:=(fun '(ms_inf, (sid', _)) =>
                                get_inf_tree (k2 (s2, (s1, tt))))
                        )
                        (s1:=s1)
                        (s2:=lift_MemState s2)
                        (ta:= raise_error msg).

                      3: {
                        right.
                        rewrite get_inf_tree_equation.
                        cbn.
                        setoid_rewrite Raise.raise_bind_itree.
                        reflexivity.
                      }

                      2: {
                        (* raise_ub includes raise_error... *)
                        red in ERR.
                        break_match_hyp;
                          try solve
                            [ repeat red;
                              left;
                              exists "Writing something to somewhere that isn't an address.";
                              unfold_dvalue_refine_strict_in H0;
                              destruct a0; cbn in H0; try break_match_hyp_inv; cbn; auto
                            ].

                        apply dvalue_refine_strict_addr_r_inv in H0 as (ptr_inf&ADDR&ADDR_REF).
                        subst.

                        red in ERR.
                        repeat red in ERR.
                        destruct ERR as [ERR | ERR].
                        { cbn.
                          repeat red.
                          right.
                          left.
                          exists msg.
                          split; eauto.
                          reflexivity.
                          exists msg.
                          repeat red.
                          left.
                          eapply serialize_sbytes_fin_inf_error; eauto.
                          2: apply ERR.
                          apply lift_MemState_refine_prop.
                        }

                        destruct ERR as (?&?&?&ERR).
                        destruct ERR as [ERR | ERR].
                        { exfalso.
                          apply get_consecutive_ptrs_never_fails in ERR.
                          auto.
                        }

                        destruct ERR as (?&?&GCP&ERR).
                        { (* ERR should be a contradiction as
                             write_byte_spec_MemPropT doesn't contain
                             error... Except in UB cases *)
                          remember (zip x2 x0) as z.
                          cbn in ERR.
                          destruct ERR as [ERR | ERR].
                          2: destruct ERR as (?&?&?&?); contradiction.

                          clear Heqz GCP.
                          generalize dependent x.
                          generalize dependent x1.
                          generalize dependent x2.
                          induction z; intros x2 x1 ERR x H.
                          - cbn in ERR; contradiction.
                          - rewrite map_monad_unfold in ERR.
                            destruct ERR as [ERR | ERR].
                            + destruct a.
                              cbn in ERR.
                              contradiction.
                            + destruct ERR as (?&?&?&ERR).
                              repeat red in ERR.
                              destruct ERR as [ERR | ERR].
                              2: {
                                destruct ERR as (?&?&?&ERR).
                                cbn in ERR; contradiction.
                              }

                              eapply IHz in ERR; eauto.
                        }
                      }

                      intros a1 b H H2 H3.
                      unfold raise_error in H2.
                      cbn in H2.
                      unfold LLVMEvents.raise in H2.
                      rewrite bind_trigger in H2.
                      apply Returns_vis_inversion in H2.
                      destruct H2 as [[] _].
                    }

                    { (* Handler raises OOM *)
                      destruct OOM as (oom_msg&TA_OOM&(oom_spec_msg&HANDLE_OOM)).
                      rewrite TA_OOM in VIS_HANDLED.
                      pose proof (@Raise.rbm_raise_bind (itree (ExternalCallE +'
                                                                                 LLVMParams64BitIntptr.Events.PickUvalueE +' OOME +' UBE +' DebugE +' FailureE)) _ _ string (@raise_oom _ _) _ _ _ k2 oom_msg) as RAISE.
                      rewrite RAISE in VIS_HANDLED.
                      destruct VIS_HANDLED as [VIS_HANDLED | VIS_HANDLED].
                      { eapply contains_UB_Extra_raiseOOM in VIS_HANDLED; try contradiction.
                        intros X e1 e2 CONTRA.
                        inv CONTRA.
                      }

                      punfold VIS_HANDLED; red in VIS_HANDLED; cbn in VIS_HANDLED.
                      dependent induction VIS_HANDLED.
                      - eapply Interp_Memory_PropT_Vis_OOM.
                        rewrite get_inf_tree_equation.
                        cbn.
                        unfold raiseOOM.
                        rewrite bind_trigger.
                        reflexivity.
                      - specialize (EQ t1); contradiction.
                    }

                    (* Handler succeeds *)
                    destruct HSPEC as [st' [ms_store [[] [TA STORE_HANDLER]]]].

                    rewrite TA in VIS_HANDLED.
                    cbn in VIS_HANDLED.
                    destruct VIS_HANDLED as [VIS_HANDLED | VIS_HANDLED].
                    { eapply ret_not_contains_UB_Extra in VIS_HANDLED; try contradiction.
                      cbn; reflexivity.
                    }

                    rewrite bind_ret_l in VIS_HANDLED.
                    destruct EV_REL as (?&?&?); subst.

                    { epose proof handle_store_fin_inf (lift_MemState_refine_prop s2) H0 H1 STORE_HANDLER as ([]&ms_inf'&STORE_INF&_&MSR_STORE).

                      eapply Interp_Memory_PropT_Vis with
                        (k2:=(fun '(ms_inf, (sid', dv_inf)) =>
                                get_inf_tree (k2 (ms_store, (st', tt)))))
                        (s1:=s1)
                        (s2:=lift_MemState s2).

                      2: {
                        cbn. red. red.
                        repeat right.
                        exists s1.
                        exists ms_inf'.
                        exists tt.
                        split; auto; reflexivity.
                      }

                      2: {
                        right.
                        cbn.
                        rewrite bind_ret_l.
                        rewrite VIS_HANDLED.
                        reflexivity.
                      }

                      (* Continuation for vis node *)
                      intros a1 b H H2 H3.
                      destruct b as [ms [sid' res]].
                      cbn in H1; subst.
                      cbn in H2.
                      apply Returns_ret_inv in H2.
                      inv H0.
                      cbn.
                      destruct res.

                      rewrite (itree_eta_ (k0 tt)).
                      rewrite (itree_eta_ (k2 (ms_store, (st', tt)))).
                      right.
                      eapply CIH.
                      2: {
                        repeat red.
                        specialize (HK tt (ms_store, (st', tt))).
                        forward HK.
                        { eapply ReturnsVis.
                          unfold trigger.
                          reflexivity.
                          cbn.
                          constructor.
                          reflexivity.
                        }
                        forward HK.
                        { rewrite TA.
                          constructor.
                          reflexivity.
                        }

                        forward HK; auto.
                        pclearbot.

                        repeat rewrite <- itree_eta.
                        apply HK.
                      }

                      specialize (REL tt).
                      red in REL.
                      pclearbot.

                      repeat rewrite <- itree_eta.
                      rewrite REL.
                      eapply K_RUTT.
                      repeat (split; auto).
                    }
                  }

                  { (* Pick *)
                    destruct p0.
                    cbn in EV_REL.
                    destruct p.
                    cbn in *.
                    destruct EV_REL as [EV_PRE UV_REF].
                    unfold FinMemInterp.F_trigger in HSPEC.
                    setoid_rewrite bind_trigger in HSPEC.
                    cbn in HSPEC.
                    rewrite HSPEC in VIS_HANDLED.
                    rewrite bind_vis in VIS_HANDLED.
                    destruct VIS_HANDLED as [VIS_HANDLED | VIS_HANDLED].
                    { exfalso.
                      clear - VIS_HANDLED.
                      dependent induction VIS_HANDLED.
                      - pinversion H; subst; inv CHECK.
                      - pinversion H; do 2 subst_existT; subst.
                        specialize (REL x).
                        exfalso.
                        rewrite <- REL in VIS_HANDLED.
                        eapply ret_not_contains_UB_Extra in VIS_HANDLED; eauto.
                        cbn; reflexivity.
                      - pinversion H; do 2 subst_existT; subst.
                        specialize (REL x).
                        exfalso.
                        rewrite <- REL in VIS_HANDLED.
                        eapply ret_not_contains_UB_Extra in VIS_HANDLED; eauto.
                        cbn; reflexivity.
                      - pinversion H; do 2 subst_existT; subst.
                        inversion H5.
                    }

                    setoid_rewrite bind_ret_l in VIS_HANDLED.
                    punfold VIS_HANDLED; red in VIS_HANDLED; cbn in VIS_HANDLED.
                    dependent induction VIS_HANDLED.
                    2: { (* Tau *)
                      specialize (EQ t1). contradiction.
                    }

                    rename Pre into Pre_inf.
                    rename Pre0 into Pre_fin.

                    cbn.
                    match goal with
                    | |- 
                        interp_memory_PropTF _ _ _ _ _ _ _
                          (VisF ?e ?k) =>
                        change (VisF e k) with (observe (Vis e k))
                    end.

                    eapply Interp_Memory_PropT_Vis with
                        (k2:=(fun '(ms_inf, (sid', dv_inf)) =>
                                match DVCInfFin.dvalue_convert_strict (proj1_sig dv_inf) with
                                | NoOom dv_fin => get_inf_tree (k2 (s2, (s1, exist _ dv_fin I)))
                                | Oom s => raiseOOM s
                                end)
                        )
                      (s1:=s1)
                      (s2:=lift_MemState s2).

                    2: {
                      cbn.
                      red.
                      cbn.
                      rewrite bind_trigger.
                      reflexivity.
                    }

                    2: {
                      rewrite resum_to_subevent.
                      repeat setoid_rewrite subevent_subevent.
                      right.
                      cbn.
                      rewrite bind_vis.
                      setoid_rewrite bind_ret_l.
                      cbn.
                      replace Pre_inf with Pre_fin.
                      2: {
                        symmetry.
                        apply bogus; eauto.
                      }
                      erewrite <- fin_to_inf_uvalue_refine_strict'; eauto.
                      pstep. red.
                      cbn.
                      constructor.
                      intros v.
                      red.
                      left.
                      destruct v.
                      cbn.
                      break_match_goal.
                      2: {
                        (* OOM *)
                        rewrite get_inf_tree_equation.
                        cbn.
                        unfold raiseOOM, print_msg.
                        eapply paco2_eqit_RR_refl.
                        typeclasses eauto.
                      }

                      move REL0 after Heqo.
                      specialize (REL0 (exist (fun _ : dvalue => True) d t)).
                      red in REL0.
                      pclearbot.
                      rewrite REL0.
                      destruct t.

                      eapply paco2_eqit_RR_refl; typeclasses eauto.
                    }

                    intros a b H H0 H1.
                    destruct a.
                    destruct b as (?&?&?&?).
                    destruct t, t0.

                    cbn.
                    break_match_goal.
                    2: {
                      left.
                      pstep; red; cbn.
                      observe_vis.
                      eapply Interp_Memory_PropT_Vis_OOM.
                      reflexivity.
                    }

                    right.
                    rewrite (itree_eta_ (k0 _)).
                    rewrite (itree_eta_ (k2 _)).

                    eapply CIH.
                    2: {
                      repeat red.
                      repeat rewrite <- itree_eta.
                      specialize (HK (exist _ d I)
                                    (s2, (s1, exist _ d I))).
                      forward HK; cbn; auto.
                      { eapply ReturnsVis.
                        unfold ITree.trigger.
                        cbn.
                        reflexivity.
                        cbn.
                        constructor; reflexivity.
                      }
                      forward HK.
                      { rewrite HSPEC.
                        eapply ReturnsVis.
                        reflexivity.
                        constructor; reflexivity.
                      }

                      forward HK; cbn; auto.
                      pclearbot.
                      apply HK.
                    }

                    repeat rewrite <- itree_eta.
                    specialize (REL (exist (fun _ : InterpreterStackBigIntptr.LP.Events.DV.dvalue => True) x1 I)).
                    red in REL.
                    pclearbot.
                    rewrite REL.

                    eapply K_RUTT.
                    split; eauto.
                    split; eauto.
                    cbn in H1.
                    inv H1.
                    auto.
                  }

                  { (* OOM *)
                    red in HSPEC.
                    rewrite HSPEC in VIS_HANDLED.
                    destruct VIS_HANDLED as [VIS_HANDLED | VIS_HANDLED].
                    { destruct o.
                      cbn in VIS_HANDLED.
                      exfalso.
                      rewrite bind_trigger in VIS_HANDLED.
                      clear - VIS_HANDLED.
                      dependent induction VIS_HANDLED.
                      - pinversion H; subst; inv CHECK.
                      - pinversion H; do 2 subst_existT; subst.
                        specialize (REL x).
                        exfalso.
                        rewrite <- REL in VIS_HANDLED.
                        eapply ret_not_contains_UB_Extra in VIS_HANDLED; eauto.
                        cbn; reflexivity.
                      - pinversion H; do 2 subst_existT; subst.
                        specialize (REL x).
                        exfalso.
                        rewrite <- REL in VIS_HANDLED.
                        eapply ret_not_contains_UB_Extra in VIS_HANDLED; eauto.
                        cbn; reflexivity.
                      - pinversion H; do 2 subst_existT; subst.
                        inversion H4.
                    }

                    setoid_rewrite bind_bind in VIS_HANDLED.
                    rewrite bind_trigger in VIS_HANDLED.
                    setoid_rewrite bind_ret_l in VIS_HANDLED.

                    destruct t2; pinversion VIS_HANDLED; subst_existT.
                    { exfalso; eapply EQ; eauto. }
                    subst_existT.

                    destruct o.
                    eapply Interp_Memory_PropT_Vis_OOM.
                    cbn.
                    rewrite get_inf_tree_equation.
                    cbn.
                    unfold raiseOOM.
                    rewrite bind_trigger.
                    reflexivity.
                  }

                  { (* UBE *)
                    rename HSPEC into HANDLER.
                    subst.
                    destruct u, u0.

                    eapply Interp_Memory_PropT_Vis.

                    2: {
                      cbn. red.
                      cbn.
                      rewrite bind_trigger.
                      reflexivity.
                    }

                    2: {
                      left.
                      rewrite resum_to_subevent.
                      eapply FindUB.
                      pstep.
                      red.
                      cbn.
                      rewrite subevent_subevent.
                      constructor.
                      intros [].
                    }

                    intros [].
                  }

                  { (* DebugE *)
                    rename HSPEC into HANDLER.
                    red in HANDLER.
                    destruct d, d0.
                    subst.
                    destruct u.
                    cbn in HANDLER.
                    rewrite bind_trigger in HANDLER.
                    rewrite HANDLER in VIS_HANDLED.
                    destruct VIS_HANDLED as [VIS_HANDLED | VIS_HANDLED].
                    { cbn in VIS_HANDLED.
                      exfalso.
                      clear - VIS_HANDLED.
                      dependent induction VIS_HANDLED.
                      - pinversion H; subst; inv CHECK.
                      - pinversion H; do 2 subst_existT; subst.
                        specialize (REL x).
                        exfalso.
                        rewrite <- REL in VIS_HANDLED.
                        eapply ret_not_contains_UB_Extra in VIS_HANDLED; eauto.
                        cbn; reflexivity.
                      - pinversion H; do 2 subst_existT; subst.
                        specialize (REL x).
                        exfalso.
                        rewrite <- REL in VIS_HANDLED.
                        eapply ret_not_contains_UB_Extra in VIS_HANDLED; eauto.
                        cbn; reflexivity.
                      - pinversion H; do 2 subst_existT; subst.
                        inversion H5.
                    }
                    rewrite bind_vis in VIS_HANDLED.

                    destruct t2; pinversion VIS_HANDLED; subst_existT.
                    { exfalso; eapply EQ; eauto. }
                    subst_existT.

                    eapply Interp_Memory_PropT_Vis with
                      (k2:=(fun '(ms_inf, (sid', dv_inf)) =>
                              get_inf_tree (k2 (s2, (s1, tt)))))
                      (s1:=s1)
                      (s2:=lift_MemState s2).

                    2: {
                      cbn.
                      red.
                      cbn.
                      rewrite bind_trigger.
                      reflexivity.
                    }

                    2: {
                      right.
                      cbn.
                      rewrite bind_vis.
                      setoid_rewrite bind_ret_l.
                      pstep; red; cbn.
                      constructor.
                      intros [].
                      red.
                      left.
                      red in VIS_HANDLED.
                      cbn in VIS_HANDLED.
                      inversion VIS_HANDLED.
                      subst_existT.
                      specialize (REL1 tt).
                      red in REL1.
                      pclearbot.
                      rewrite REL1.
                      setoid_rewrite bind_ret_l.
                      eapply paco2_eqit_RR_refl; typeclasses eauto.
                    }

                    intros a b RETa RETb AB.
                    apply Returns_vis_inversion in RETb as [[] RETb].
                    destruct b as [ms' [sid' []]].
                    cbn in AB; subst.

                    apply Returns_ret_inv in RETb.
                    inv RETb.
                    cbn.

                    specialize (REL0 tt).
                    specialize (REL tt).
                    pclearbot.

                    specialize (HK tt (s2, (s1, tt))).
                    forward HK.
                    { eapply ReturnsVis.
                      unfold trigger.
                      reflexivity.
                      cbn.
                      constructor.
                      reflexivity.
                    }
                    forward HK.
                    { rewrite HANDLER.
                      eapply ReturnsVis.
                      reflexivity.
                      constructor.
                      reflexivity.
                    }
                    specialize (HK eq_refl).
                    pclearbot.

                    right.

                    rewrite (itree_eta_ (k0 tt)).
                    rewrite (itree_eta_ (k2 (s2, (s1, tt)))).

                    eapply CIH.
                    2: {
                      repeat red.
                      repeat rewrite <- itree_eta.
                      apply HK.
                    }

                    repeat rewrite <- itree_eta.
                    rewrite REL.
                    specialize (K_RUTT tt tt eq_refl).
                    exact K_RUTT.
                  }

                  { (* FailureE *)
                    red in HSPEC.
                    destruct f, f0.
                    cbn in HSPEC.
                    rewrite bind_trigger in HSPEC.
                    rewrite HSPEC in VIS_HANDLED.
                    destruct VIS_HANDLED as [VIS_HANDLED | VIS_HANDLED].
                    { cbn in VIS_HANDLED.
                      exfalso.
                      clear - VIS_HANDLED.
                      dependent induction VIS_HANDLED.
                      - pinversion H; subst; inv CHECK.
                      - pinversion H; do 2 subst_existT; subst.
                        specialize (REL x).
                        exfalso.
                        rewrite <- REL in VIS_HANDLED.
                        eapply ret_not_contains_UB_Extra in VIS_HANDLED; eauto.
                        cbn; reflexivity.
                      - pinversion H; do 2 subst_existT; subst.
                        specialize (REL x).
                        exfalso.
                        rewrite <- REL in VIS_HANDLED.
                        eapply ret_not_contains_UB_Extra in VIS_HANDLED; eauto.
                        cbn; reflexivity.
                      - pinversion H; do 2 subst_existT; subst.
                        inversion H4.
                    }

                    rewrite bind_vis in VIS_HANDLED.
                    punfold VIS_HANDLED; red in VIS_HANDLED; cbn in VIS_HANDLED.
                    dependent induction VIS_HANDLED.
                    2: {
                      specialize (EQ t1); contradiction.
                    }

                    eapply Interp_Memory_PropT_Vis with
                      (s1:=s1)
                      (s2:=lift_MemState s2).

                    2: {
                      cbn.
                      red.
                      cbn.
                      rewrite bind_trigger.
                      reflexivity.
                    }

                    2: {
                      right.
                      rewrite get_inf_tree_equation.
                      cbn.
                      unfold LLVMEvents.raise.
                      rewrite bind_trigger.
                      rewrite bind_vis.
                      cbn.
                      pfold. red.
                      cbn.
                      subst.
                      unfold print_msg.
                      destruct u.
                      constructor.
                      intros [].
                    }

                    intros [].
                  }

                + (* om1 = Tau *)
                  (* Tau on the left... *)
                  constructor; auto.
                  eapply IHM1; eauto.
              - (* TauL *)
                exfalso; eapply EQ; eauto.
              - (* OOM *)
                eapply Interp_Memory_PropT_Vis_OOM.
                rewrite get_inf_tree_equation.
                cbn.
                pinversion HT1; subst_existT; subst.
                2: {
                  exfalso; eapply EQ; eauto.
                }

                cbn.
                destruct e0.
                cbn.
                unfold raiseOOM.
                rewrite bind_trigger.
                reflexivity.
            }

        + specialize (EQ t2); contradiction.
        + (* OOM *)
          destruct e.
          punfold HT1; red in HT1; cbn in HT1.
          dependent induction HT1.
          rewrite <- x.
          pstep.
          red.
          eapply Interp_Memory_PropT_Vis_OOM.
          rewrite get_inf_tree_equation.
          cbn.
          unfold raiseOOM.
          rewrite bind_trigger.
          reflexivity.
      - (* oruttF's EqVis case *)
        red in RUN.
        cbn in RUN.
        repeat red in RUN.
        punfold RUN; red in RUN; cbn in RUN.

        dependent induction RUN.
        + (* TauR *)
          pstep; red; cbn.
          constructor; auto.

          specialize (IHRUN k1 e1 _ e2 k2 H H0 H1 (observe t2) CIH MSR).
          repeat (forward IHRUN; auto).
          punfold IHRUN.
        + (* VisOOM *)
          eapply paco2_mon_bot; eauto.
          rewrite HT1.
          cbn.
          rewrite get_inf_tree_equation.
          destruct e.
          cbn.
          pstep; red; cbn.
          unfold print_msg.
          change (VisF (subevent void (ThrowOOM tt))
                    (fun x : void =>
                       ITree.subst
                         (fun v : void => match v return (itree InfLP.Events.L3 TopLevelBigIntptr.res_L6) with
                                       end) (Ret x)))
            with
            (observe (Vis (subevent void (ThrowOOM tt))
                        (fun x : void =>
                           ITree.subst
                             (fun v : void => match v return (itree InfLP.Events.L3 TopLevelBigIntptr.res_L6) with
                                           end) (Ret x)))).
          eapply Interp_Memory_PropT_Vis_OOM.
          reflexivity.
        + (* Vis *)
          rename H0 into REL.
          rename H into EV_REL.
          rename KS into VIS_HANDLED.
          rename HSPEC into HANDLER.
          red in VIS_HANDLED.

          repeat red in HANDLER.
          (* Need to break apart events e / e1 to figure out
                what event we're dealing with. *)
          red in EV_REL.
          destruct e1, e2; try destruct e, e0; cbn in EV_REL;
            move EV_REL after VIS_HANDLED;
            repeat (first [destruct s | destruct i | destruct e | destruct s0 | destruct m | destruct m0]; try contradiction); cbn in *.

          { (* ExternalCallE *)
            red in HANDLER. cbn in HANDLER.
            rewrite bind_trigger in HANDLER.
            rewrite HANDLER in VIS_HANDLED.
            destruct VIS_HANDLED as [VIS_HANDLED | VIS_HANDLED].
            { cbn in VIS_HANDLED.
              exfalso.
              clear - VIS_HANDLED.
              dependent induction VIS_HANDLED.
              - pinversion H; subst; inv CHECK.
              - pinversion H; do 2 subst_existT; subst.
                specialize (REL x).
                exfalso.
                rewrite <- REL in VIS_HANDLED.
                eapply ret_not_contains_UB_Extra in VIS_HANDLED; eauto.
                cbn; reflexivity.
              - pinversion H; do 2 subst_existT; subst.
                specialize (REL x).
                exfalso.
                rewrite <- REL in VIS_HANDLED.
                eapply ret_not_contains_UB_Extra in VIS_HANDLED; eauto.
                cbn; reflexivity.
              - pinversion H; do 2 subst_existT; subst.
                inversion H5.
            }
            pstep; red; cbn.

            destruct EV_REL as (?&F_REF&ARGS_REF).
            subst.

            (* External calls *)

            eapply Interp_Memory_PropT_Vis with
              (s1:=s1)
              (s2:=lift_MemState s2)
              (ta:=(vis (InterpreterStackBigIntptr.LP.Events.ExternalCall t0 f args)
                      (fun x : InterpreterStackBigIntptr.LP.Events.DV.dvalue =>
                         ITree.subst
                           (fun r0 : InterpreterStackBigIntptr.LP.Events.DV.dvalue =>
                              SemNotations.Ret2 s1 (lift_MemState s2) r0) (Ret x))))
              (k2:=(fun '(ms_inf, (sid', dv_inf)) =>
                      match DVCInfFin.dvalue_convert_strict dv_inf with
                      | NoOom dv_fin => get_inf_tree (ITree.subst k3 (SemNotations.Ret2 s1 s2 dv_fin)) (* ITree.subst k3 (SemNotations.Ret2 s1 s2 dv_fin) *)
                      | Oom s => raiseOOM s
                      end)
              ); eauto.
            2: {
              repeat red.
              cbn.
              pstep; red; cbn.
              observe_vis.
              constructor.
              intros v.
              red.
              left.
              pstep; red; cbn.
              constructor.
              reflexivity.
            }

            2: {
              right.
              cbn.
              rewrite bind_vis.
              cbn.
              rewrite itree_eta in VIS_HANDLED.
              rewrite VIS_HANDLED.
              cbn.
              rewrite get_inf_tree_equation.
              cbn.

              erewrite <- fin_to_inf_uvalue_refine_strict'; eauto.
              rewrite Forall2_map_eq with (l2:=args).
              2: {
                eapply Forall2_flip.
                eapply Util.Forall2_impl; [| apply ARGS_REF].
                intros a b ?.
                red.
                symmetry.
                apply fin_to_inf_dvalue_refine_strict'.
                auto.
              }

              pstep; red; cbn.
              constructor.

              intros v.
              red.

              left.
              setoid_rewrite bind_ret_l.
              setoid_rewrite bind_ret_l.

              break_match_goal.
              - apply paco2_eqit_RR_refl; typeclasses eauto.
              - rewrite get_inf_tree_equation.
                cbn.
                pstep; red; cbn.
                unfold print_msg.
                constructor.
                intros [].
            }

            intros a b H H4 H5.
            destruct b, p.
            cbn in *; subst.
            break_match.
            + (* NoOom for external call result *)
              specialize (REL d d0).
              forward REL; auto.

              rewrite (itree_eta_ (ITree.subst k3 (SemNotations.Ret2 s1 s2 d0))).
              rewrite (itree_eta_ (k1 d)).
              right.
              eapply CIH.
              do 2 rewrite <- itree_eta.

              pclearbot. apply REL.

              repeat red.
              repeat rewrite <- itree_eta.
              setoid_rewrite bind_ret_l.

              specialize (HK d0 (s2, (s1, d0))).
              forward HK.
              { eapply ReturnsVis.
                unfold ITree.trigger.
                cbn.
                reflexivity.
                cbn.
                constructor; reflexivity.
              }
              forward HK.
              { rewrite HANDLER.
                eapply ReturnsVis.
                reflexivity.
                constructor; reflexivity.
              }

              forward HK; cbn; auto.
              pclearbot.
              apply HK.
            + (* External call result OOMs *)
              left.
              pstep; red; cbn.
              observe_vis.
              eapply Interp_Memory_PropT_Vis_OOM.
              reflexivity.
          }

          { (* Intrinsic *)
            destruct EV_REL as (T&F&ARGS); subst.
            red in HANDLER.
            red in HANDLER.
            destruct HANDLER as [UB | [ERR | [OOM | HANDLER]]].
            { (* Handler raises UB *)
              destruct UB as [ub_msg INTRINSIC].
              red in INTRINSIC.
              break_match_hyp.

              { (* memcpy *)
                cbn in *.
                destruct INTRINSIC as [HANDLER | [sab [[] [HANDLER []]]]].
                red in HANDLER.
                repeat (destruct ARGS;
                        [solve [ inversion HANDLER
                               | red in HANDLER;
                                 repeat break_match_hyp; cbn in HANDLER; inversion HANDLER
                           ]
                        |
                       ]).
                repeat break_match_hyp; cbn in HANDLER; try contradiction.

                { (* 32 bit *)
                  red in HANDLER.
                  subst.
                  inversion ARGS; subst.
                  inversion H5; subst.
                  inversion H7; subst.
                  inversion H9; subst.
                  inversion H11; subst.

                  apply dvalue_refine_strict_addr_r_inv in H as (?&?&?); subst.
                  apply dvalue_refine_strict_addr_r_inv in H4 as (?&?&?); subst.
                  apply dvalue_refine_strict_i32_r_inv in H6 as (?&?&?); subst.
                  apply dvalue_refine_strict_i32_r_inv in H8 as (?&?&?); subst.
                  apply dvalue_refine_strict_i1_r_inv in H10 as (?&?&?); subst.

                  break_match_hyp.
                  { (* Negative length UB *)
                    pstep; red; cbn.

                    eapply Interp_Memory_PropT_Vis with
                      (ta:=
                         vis (ThrowUB tt)
                           (fun x : void =>
                              match
                                x
                                return
                                (itree
                                   (InterpreterStackBigIntptr.LP.Events.ExternalCallE +'
                                                                                         LLVMParamsBigIntptr.Events.PickUvalueE +' OOME +' UBE +' DebugE +' FailureE)
                                   (MemoryBigIntptr.MMEP.MMSP.MemState *
                                      (MemPropT.store_id * LLVMParamsBigIntptr.Events.DV.dvalue)))
                              with
                              end)).

                    2: {
                      cbn.
                      repeat red.
                      left.
                      exists "memcpy given negative length.".
                      red.
                      rewrite Heqb.
                      cbn.
                      left.
                      red.
                      cbn in H3.
                      rewrite H3.
                      rewrite Heqb0.
                      cbn; auto.
                    }

                    intros a1 b RETa RETb AB.
                    eapply Returns_vis_inversion in RETb.
                    destruct RETb as [[] _].

                    left.
                    eapply FindUB.
                    pstep.
                    red.
                    cbn.
                    rewrite subevent_subevent.
                    constructor.
                    intros [].
                  }

                  break_match_hyp.
                  2: {
                    pstep; red; cbn.
                    eapply Interp_Memory_PropT_Vis with
                      (ta:=
                         vis (ThrowUB tt)
                           (fun x : void =>
                              match
                                x
                                return
                                (itree
                                   (InterpreterStackBigIntptr.LP.Events.ExternalCallE +'
                                                                                         LLVMParamsBigIntptr.Events.PickUvalueE +' OOME +' UBE +' DebugE +' FailureE)
                                   (MemoryBigIntptr.MMEP.MMSP.MemState *
                                      (MemPropT.store_id * LLVMParamsBigIntptr.Events.DV.dvalue)))
                              with
                              end)).

                    2: {
                      cbn.
                      repeat red.
                      left.
                      exists "memcpy with overlapping or non-equal src and dst memory locations.".
                      red.
                      rewrite Heqb.
                      left.
                      red.
                      cbn.
                      red.
                      cbn in H3; rewrite H3.
                      rewrite Heqb0.
                      erewrite <- fin_inf_no_overlap; eauto.
                      erewrite <- fin_inf_ptoi; eauto.
                      erewrite <- fin_inf_ptoi; eauto.
                      rewrite Heqb1.
                      cbn; auto.
                    }

                    2: {
                      red.
                      left.
                      eapply FindUB.
                      pstep; red; cbn.
                      constructor.
                      intros [].
                    }

                    intros a1 b RETa RETb AB.
                    eapply Returns_vis_inversion in RETb.
                    destruct RETb as [[] _].
                  }

                  (* HANDLER has UB in it *)
                  pstep; red; cbn.
                  eapply Interp_Memory_PropT_Vis with
                    (ta:=raise_ub "").

                  3: {
                    red.
                    left.
                    eapply FindUB.
                    pstep; red; cbn.
                    constructor.
                    intros [].
                  }

                  { intros a1 b RETa RETb AB.
                    cbn in RETb.
                    unfold raiseUB in RETb.
                    rewrite bind_trigger in RETb.
                    eapply Returns_vis_inversion in RETb.
                    destruct RETb as [[] _].
                  }

                  cbn.
                  red.
                  left.
                  exists ub_msg.
                  red.
                  rewrite Heqb.

                  left.
                  cbn.
                  red.

                  cbn in H2, H3, H5.
                  unfold InterpreterStackBigIntptr.LP.IP.to_Z in *.
                  rewrite H3.
                  rewrite Heqb0.
                  erewrite <- fin_inf_no_overlap; eauto.
                  erewrite <- fin_inf_ptoi; eauto.
                  erewrite <- fin_inf_ptoi; eauto.
                  rewrite Heqb1.
                  eapply MemPropT_fin_inf_bind_ub.
                  5: apply HANDLER.
                  all: eauto with FinInf.

                  2: {
                    intros msg H.
                    eapply fin_inf_read_bytes_spec_ub'; eauto.
                    apply lift_MemState_refine_prop.
                  }

                  2: {
                    intros ms_inf ms_fin a_fin a_inf msg ? ? ? ?.
                    eapply fin_inf_write_bytes_spec_ub; eauto.
                  }

                  intros a_fin ms_fin_ma READ.
                  eapply fin_inf_read_bytes_spec; eauto.
                  apply lift_MemState_refine_prop.
                }

                { (* 64 bit *)
                  red in HANDLER.
                  subst.
                  inversion ARGS; subst.
                  inversion H5; subst.
                  inversion H7; subst.
                  inversion H9; subst.
                  inversion H11; subst.

                  apply dvalue_refine_strict_addr_r_inv in H as (?&?&?); subst.
                  apply dvalue_refine_strict_addr_r_inv in H4 as (?&?&?); subst.
                  apply dvalue_refine_strict_i64_r_inv in H6 as (?&?&?); subst.
                  apply dvalue_refine_strict_i64_r_inv in H8 as (?&?&?); subst.
                  apply dvalue_refine_strict_i1_r_inv in H10 as (?&?&?); subst.

                  break_match_hyp.
                  { (* Negative length UB *)
                    pstep; red; cbn.

                    eapply Interp_Memory_PropT_Vis with
                      (ta:=
                         vis (ThrowUB tt)
                           (fun x : void =>
                              match
                                x
                                return
                                (itree
                                   (InterpreterStackBigIntptr.LP.Events.ExternalCallE +'
                                                                                         LLVMParamsBigIntptr.Events.PickUvalueE +' OOME +' UBE +' DebugE +' FailureE)
                                   (MemoryBigIntptr.MMEP.MMSP.MemState *
                                      (MemPropT.store_id * LLVMParamsBigIntptr.Events.DV.dvalue)))
                              with
                              end)).

                    2: {
                      cbn.
                      repeat red.
                      left.
                      exists "memcpy given negative length.".
                      red.
                      rewrite Heqb.
                      cbn.
                      left.
                      red.
                      cbn in H3.
                      rewrite H3.
                      rewrite Heqb0.
                      cbn; auto.
                    }

                    intros a1 b RETa RETb AB.
                    eapply Returns_vis_inversion in RETb.
                    destruct RETb as [[] _].

                    left.
                    eapply FindUB.
                    pstep.
                    red.
                    cbn.
                    rewrite subevent_subevent.
                    constructor.
                    intros [].
                  }

                  break_match_hyp.
                  2: {
                    pstep; red; cbn.
                    eapply Interp_Memory_PropT_Vis with
                      (ta:=
                         vis (ThrowUB tt)
                           (fun x : void =>
                              match
                                x
                                return
                                (itree
                                   (InterpreterStackBigIntptr.LP.Events.ExternalCallE +'
                                                                                         LLVMParamsBigIntptr.Events.PickUvalueE +' OOME +' UBE +' DebugE +' FailureE)
                                   (MemoryBigIntptr.MMEP.MMSP.MemState *
                                      (MemPropT.store_id * LLVMParamsBigIntptr.Events.DV.dvalue)))
                              with
                              end)).

                    2: {
                      cbn.
                      repeat red.
                      left.
                      exists "memcpy with overlapping or non-equal src and dst memory locations.".
                      red.
                      rewrite Heqb.
                      left.
                      red.
                      cbn.
                      red.
                      cbn in H3; rewrite H3.
                      rewrite Heqb0.
                      erewrite <- fin_inf_no_overlap; eauto.
                      erewrite <- fin_inf_ptoi; eauto.
                      erewrite <- fin_inf_ptoi; eauto.
                      rewrite Heqb1.
                      cbn; auto.
                    }

                    2: {
                      red.
                      left.
                      eapply FindUB.
                      pstep; red; cbn.
                      constructor.
                      intros [].
                    }

                    intros a1 b RETa RETb AB.
                    eapply Returns_vis_inversion in RETb.
                    destruct RETb as [[] _].
                  }

                  (* HANDLER has UB in it *)
                  pstep; red; cbn.
                  eapply Interp_Memory_PropT_Vis with
                    (ta:=raise_ub "").

                  3: {
                    red.
                    left.
                    eapply FindUB.
                    pstep; red; cbn.
                    constructor.
                    intros [].
                  }

                  { intros a1 b RETa RETb AB.
                    cbn in RETb.
                    unfold raiseUB in RETb.
                    rewrite bind_trigger in RETb.
                    eapply Returns_vis_inversion in RETb.
                    destruct RETb as [[] _].
                  }

                  cbn.
                  red.
                  left.
                  exists ub_msg.
                  red.
                  rewrite Heqb.

                  left.
                  cbn.
                  red.

                  cbn in H2, H3, H5.
                  unfold InterpreterStackBigIntptr.LP.IP.to_Z in *.
                  rewrite H3.
                  rewrite Heqb0.
                  erewrite <- fin_inf_no_overlap; eauto.
                  erewrite <- fin_inf_ptoi; eauto.
                  erewrite <- fin_inf_ptoi; eauto.
                  rewrite Heqb1.
                  eapply MemPropT_fin_inf_bind_ub.
                  5: apply HANDLER.
                  all: eauto with FinInf.

                  2: {
                    intros msg H.
                    eapply fin_inf_read_bytes_spec_ub'; eauto.
                    apply lift_MemState_refine_prop.
                  }

                  2: {
                    intros ms_inf ms_fin a_fin a_inf msg ? ? ? ?.
                    eapply fin_inf_write_bytes_spec_ub; eauto.
                  }

                  intros a_fin ms_fin_ma READ.
                  eapply fin_inf_read_bytes_spec; eauto.
                  apply lift_MemState_refine_prop.
                }

                { (* iptr *)
                  red in HANDLER.
                  subst.
                  inversion ARGS; subst.
                  inversion H5; subst.
                  inversion H7; subst.
                  inversion H9; subst.
                  inversion H11; subst.

                  apply dvalue_refine_strict_addr_r_inv in H as (?&?&?); subst.
                  apply dvalue_refine_strict_addr_r_inv in H4 as (?&?&?); subst.
                  apply dvalue_refine_strict_iptr_r_inv in H6 as (?&?&?); subst.
                  apply dvalue_refine_strict_iptr_r_inv in H8 as (?&?&?); subst.
                  apply dvalue_refine_strict_i1_r_inv in H10 as (?&?&?); subst.

                  break_match_hyp.
                  { (* Negative length UB *)
                    pstep; red; cbn.

                    eapply Interp_Memory_PropT_Vis with
                      (ta:=
                         vis (ThrowUB tt)
                           (fun x : void =>
                              match
                                x
                                return
                                (itree
                                   (InterpreterStackBigIntptr.LP.Events.ExternalCallE +'
                                                                                         LLVMParamsBigIntptr.Events.PickUvalueE +' OOME +' UBE +' DebugE +' FailureE)
                                   (MemoryBigIntptr.MMEP.MMSP.MemState *
                                      (MemPropT.store_id * LLVMParamsBigIntptr.Events.DV.dvalue)))
                              with
                              end)).

                    2: {
                      cbn.
                      repeat red.
                      left.
                      exists "memcpy given negative length.".
                      red.
                      rewrite Heqb.
                      cbn.
                      left.
                      red.
                      cbn in H3.
                      unfold InterpreterStackBigIntptr.LP.IP.to_Z in *.
                      erewrite IP.from_Z_to_Z in Heqb0; eauto.
                      rewrite Heqb0.
                      cbn; auto.
                    }

                    intros a1 b RETa RETb AB.
                    eapply Returns_vis_inversion in RETb.
                    destruct RETb as [[] _].

                    left.
                    eapply FindUB.
                    pstep.
                    red.
                    cbn.
                    rewrite subevent_subevent.
                    constructor.
                    intros [].
                  }

                  break_match_hyp.
                  2: {
                    pstep; red; cbn.
                    eapply Interp_Memory_PropT_Vis with
                      (ta:=
                         vis (ThrowUB tt)
                           (fun x : void =>
                              match
                                x
                                return
                                (itree
                                   (InterpreterStackBigIntptr.LP.Events.ExternalCallE +'
                                                                                         LLVMParamsBigIntptr.Events.PickUvalueE +' OOME +' UBE +' DebugE +' FailureE)
                                   (MemoryBigIntptr.MMEP.MMSP.MemState *
                                      (MemPropT.store_id * LLVMParamsBigIntptr.Events.DV.dvalue)))
                              with
                              end)).

                    2: {
                      cbn.
                      repeat red.
                      left.
                      exists "memcpy with overlapping or non-equal src and dst memory locations.".
                      red.
                      rewrite Heqb.
                      left.
                      red.
                      cbn.
                      red.
                      cbn in H2, H3, H5.
                      unfold InterpreterStackBigIntptr.LP.IP.to_Z in *.
                      erewrite IP.from_Z_to_Z in Heqb0; eauto.
                      rewrite Heqb0.
                      erewrite <- fin_inf_no_overlap; eauto.
                      erewrite <- fin_inf_ptoi; eauto.
                      erewrite <- fin_inf_ptoi; eauto.
                      erewrite IP.from_Z_to_Z in Heqb1; eauto.
                      rewrite Heqb1.
                      cbn; auto.
                    }

                    2: {
                      red.
                      left.
                      eapply FindUB.
                      pstep; red; cbn.
                      constructor.
                      intros [].
                    }

                    intros a1 b RETa RETb AB.
                    eapply Returns_vis_inversion in RETb.
                    destruct RETb as [[] _].
                  }

                  (* HANDLER has UB in it *)
                  pstep; red; cbn.
                  eapply Interp_Memory_PropT_Vis with
                    (ta:=raise_ub "").

                  3: {
                    red.
                    left.
                    eapply FindUB.
                    pstep; red; cbn.
                    constructor.
                    intros [].
                  }

                  { intros a1 b RETa RETb AB.
                    cbn in RETb.
                    unfold raiseUB in RETb.
                    rewrite bind_trigger in RETb.
                    eapply Returns_vis_inversion in RETb.
                    destruct RETb as [[] _].
                  }

                  cbn.
                  red.
                  left.
                  exists ub_msg.
                  red.
                  rewrite Heqb.

                  left.
                  cbn.
                  red.

                  cbn in H2, H3, H5.
                  unfold InterpreterStackBigIntptr.LP.IP.to_Z in *.
                  erewrite IP.from_Z_to_Z in Heqb0; eauto.
                  rewrite Heqb0.
                  erewrite <- fin_inf_no_overlap; eauto.
                  erewrite <- fin_inf_ptoi; eauto.
                  erewrite <- fin_inf_ptoi; eauto.
                  erewrite IP.from_Z_to_Z in Heqb1; eauto.
                  rewrite Heqb1.
                  eapply MemPropT_fin_inf_bind_ub.
                  5: apply HANDLER.
                  all: eauto with FinInf.

                  2: {
                    intros msg H.
                    erewrite IP.from_Z_to_Z in H; eauto.
                    eapply fin_inf_read_bytes_spec_ub'; eauto.
                    apply lift_MemState_refine_prop.
                  }

                  2: {
                    intros ms_inf ms_fin a_fin a_inf msg ? ? ? ?.
                    eapply fin_inf_write_bytes_spec_ub; eauto.
                  }

                  intros a_fin ms_fin_ma READ.
                  erewrite IP.from_Z_to_Z in READ; eauto.
                  eapply fin_inf_read_bytes_spec; eauto.
                  apply lift_MemState_refine_prop.
                }
              }

              break_match_hyp.
              { (* Malloc *)
                cbn in *.
                destruct INTRINSIC as [HANDLER | [sab [[] [HANDLER []]]]].
                red in HANDLER.
                repeat (destruct ARGS;
                        [solve [ inversion HANDLER
                               | red in HANDLER;
                                 repeat break_match_hyp; cbn in HANDLER; inversion HANDLER
                           ]
                        |
                       ]).
                pstep; red; cbn.
                repeat (break_match_hyp; try solve [cbn in HANDLER; contradiction]);
                  inv ARGS;
                  rename H into ARG_REF.

                { (* i1 *)
                  apply dvalue_refine_strict_i1_r_inv in ARG_REF as (?&?&ARG_REF); cbn in ARG_REF; subst.
                  eapply Interp_Memory_PropT_Vis with
                    (ta:=raise_ub "").

                  3: {
                    red.
                    left.
                    eapply FindUB.
                    pstep; red; cbn.
                    constructor.
                    intros [].
                  }

                  { intros a b RETa RETb AB.
                    cbn in RETb.
                    unfold raiseUB in RETb.
                    rewrite bind_trigger in RETb.
                    eapply Returns_vis_inversion in RETb.
                    destruct RETb as [[] _].
                  }

                  cbn.
                  red.
                  red.
                  left.
                  exists ub_msg.
                  red.
                  rewrite Heqb, Heqb0.
                  left.

                  eapply MemPropT_fin_inf_bind_ub.
                  5: apply HANDLER.
                  all: eauto with FinInf.

                  { intros a_fin ms_fin_ma H.
                    eapply fresh_sid_fin_inf; eauto with FinInf.
                  }

                  intros ms_inf ms_fin a_fin a_inf msg SID MSR' FRESH MALLOC.

                  eapply MemPropT_fin_inf_bind_ub with
                    (A_REF:=sbytes_refine).
                  5: apply MALLOC.
                  all: eauto with FinInf.

                  2: {
                    intros msg0 GEN.
                    red; red in GEN.
                    break_match_hyp; cbn in GEN; try contradiction.
                  }

                  { intros a_fin0 ms_fin_ma GEN.
                    red in GEN.
                    break_match_hyp; cbn in GEN; try contradiction.
                    destruct GEN; subst.
                    eapply generate_num_undef_bytes_fin_inf in Heqo.

                    destruct Heqo as (bytes_inf&GEN&BYTE_REF).
                    exists bytes_inf. exists ms_inf.
                    split; auto.

                    red.
                    cbn in *; subst.
                    rewrite ARG_REF.
                    rewrite GEN.
                    auto.
                  }
                }

                { (* i8 *)
                  apply dvalue_refine_strict_i8_r_inv in ARG_REF as (?&?&ARG_REF); cbn in ARG_REF; subst.
                  eapply Interp_Memory_PropT_Vis with
                    (ta:=raise_ub "").

                  3: {
                    red.
                    left.
                    eapply FindUB.
                    pstep; red; cbn.
                    constructor.
                    intros [].
                  }

                  { intros a b RETa RETb AB.
                    cbn in RETb.
                    unfold raiseUB in RETb.
                    rewrite bind_trigger in RETb.
                    eapply Returns_vis_inversion in RETb.
                    destruct RETb as [[] _].
                  }

                  cbn.
                  red.
                  red.
                  left.
                  exists ub_msg.
                  red.
                  rewrite Heqb, Heqb0.
                  left.

                  eapply MemPropT_fin_inf_bind_ub.
                  5: apply HANDLER.
                  all: eauto with FinInf.

                  { intros a_fin ms_fin_ma H.
                    eapply fresh_sid_fin_inf; eauto with FinInf.
                  }

                  intros ms_inf ms_fin a_fin a_inf msg SID MSR' FRESH MALLOC.

                  eapply MemPropT_fin_inf_bind_ub with
                    (A_REF:=sbytes_refine).
                  5: apply MALLOC.
                  all: eauto with FinInf.

                  2: {
                    intros msg0 GEN.
                    red; red in GEN.
                    break_match_hyp; cbn in GEN; try contradiction.
                  }

                  { intros a_fin0 ms_fin_ma GEN.
                    red in GEN.
                    break_match_hyp; cbn in GEN; try contradiction.
                    destruct GEN; subst.
                    eapply generate_num_undef_bytes_fin_inf in Heqo.

                    destruct Heqo as (bytes_inf&GEN&BYTE_REF).
                    exists bytes_inf. exists ms_inf.
                    split; auto.

                    red.
                    cbn in *; subst.
                    rewrite ARG_REF.
                    rewrite GEN.
                    auto.
                  }
                }

                { (* i32 *)
                  apply dvalue_refine_strict_i32_r_inv in ARG_REF as (?&?&ARG_REF); cbn in ARG_REF; subst.
                  eapply Interp_Memory_PropT_Vis with
                    (ta:=raise_ub "").

                  3: {
                    red.
                    left.
                    eapply FindUB.
                    pstep; red; cbn.
                    constructor.
                    intros [].
                  }

                  { intros a b RETa RETb AB.
                    cbn in RETb.
                    unfold raiseUB in RETb.
                    rewrite bind_trigger in RETb.
                    eapply Returns_vis_inversion in RETb.
                    destruct RETb as [[] _].
                  }

                  cbn.
                  red.
                  red.
                  left.
                  exists ub_msg.
                  red.
                  rewrite Heqb, Heqb0.
                  left.

                  eapply MemPropT_fin_inf_bind_ub.
                  5: apply HANDLER.
                  all: eauto with FinInf.

                  { intros a_fin ms_fin_ma H.
                    eapply fresh_sid_fin_inf; eauto with FinInf.
                  }

                  intros ms_inf ms_fin a_fin a_inf msg SID MSR' FRESH MALLOC.

                  eapply MemPropT_fin_inf_bind_ub with
                    (A_REF:=sbytes_refine).
                  5: apply MALLOC.
                  all: eauto with FinInf.

                  2: {
                    intros msg0 GEN.
                    red; red in GEN.
                    break_match_hyp; cbn in GEN; try contradiction.
                  }

                  { intros a_fin0 ms_fin_ma GEN.
                    red in GEN.
                    break_match_hyp; cbn in GEN; try contradiction.
                    destruct GEN; subst.
                    eapply generate_num_undef_bytes_fin_inf in Heqo.

                    destruct Heqo as (bytes_inf&GEN&BYTE_REF).
                    exists bytes_inf. exists ms_inf.
                    split; auto.

                    red.
                    cbn in *; subst.
                    rewrite ARG_REF.
                    rewrite GEN.
                    auto.
                  }
                }

                { (* i64 *)
                  apply dvalue_refine_strict_i64_r_inv in ARG_REF as (?&?&ARG_REF); cbn in ARG_REF; subst.
                  eapply Interp_Memory_PropT_Vis with
                    (ta:=raise_ub "").

                  3: {
                    red.
                    left.
                    eapply FindUB.
                    pstep; red; cbn.
                    constructor.
                    intros [].
                  }

                  { intros a b RETa RETb AB.
                    cbn in RETb.
                    unfold raiseUB in RETb.
                    rewrite bind_trigger in RETb.
                    eapply Returns_vis_inversion in RETb.
                    destruct RETb as [[] _].
                  }

                  cbn.
                  red.
                  red.
                  left.
                  exists ub_msg.
                  red.
                  rewrite Heqb, Heqb0.
                  left.

                  eapply MemPropT_fin_inf_bind_ub.
                  5: apply HANDLER.
                  all: eauto with FinInf.

                  { intros a_fin ms_fin_ma H.
                    eapply fresh_sid_fin_inf; eauto with FinInf.
                  }

                  intros ms_inf ms_fin a_fin a_inf msg SID MSR' FRESH MALLOC.

                  eapply MemPropT_fin_inf_bind_ub with
                    (A_REF:=sbytes_refine).
                  5: apply MALLOC.
                  all: eauto with FinInf.

                  2: {
                    intros msg0 GEN.
                    red; red in GEN.
                    break_match_hyp; cbn in GEN; try contradiction.
                  }

                  { intros a_fin0 ms_fin_ma GEN.
                    red in GEN.
                    break_match_hyp; cbn in GEN; try contradiction.
                    destruct GEN; subst.
                    eapply generate_num_undef_bytes_fin_inf in Heqo.

                    destruct Heqo as (bytes_inf&GEN&BYTE_REF).
                    exists bytes_inf. exists ms_inf.
                    split; auto.

                    red.
                    cbn in *; subst.
                    rewrite ARG_REF.
                    rewrite GEN.
                    auto.
                  }
                }

                { (* iptr *)
                  apply dvalue_refine_strict_iptr_r_inv in ARG_REF as (?&?&ARG_REF); cbn in ARG_REF; subst.
                  eapply Interp_Memory_PropT_Vis with
                    (ta:=raise_ub "").

                  3: {
                    red.
                    left.
                    eapply FindUB.
                    pstep; red; cbn.
                    constructor.
                    intros [].
                  }

                  { intros a b RETa RETb AB.
                    cbn in RETb.
                    unfold raiseUB in RETb.
                    rewrite bind_trigger in RETb.
                    eapply Returns_vis_inversion in RETb.
                    destruct RETb as [[] _].
                  }

                  cbn.
                  red.
                  red.
                  left.
                  exists ub_msg.
                  red.
                  rewrite Heqb, Heqb0.
                  left.

                  eapply MemPropT_fin_inf_bind_ub.
                  5: apply HANDLER.
                  all: eauto with FinInf.

                  { intros a_fin ms_fin_ma H.
                    eapply fresh_sid_fin_inf; eauto with FinInf.
                  }

                  intros ms_inf ms_fin a_fin a_inf msg SID MSR' FRESH MALLOC.

                  eapply MemPropT_fin_inf_bind_ub with
                    (A_REF:=sbytes_refine).
                  5: apply MALLOC.
                  all: eauto with FinInf.

                  2: {
                    intros msg0 GEN.
                    red; red in GEN.
                    break_match_hyp; cbn in GEN; try contradiction.
                  }

                  { intros a_fin0 ms_fin_ma GEN.
                    red in GEN.
                    break_match_hyp; cbn in GEN; try contradiction.
                    destruct GEN; subst.
                    eapply generate_num_undef_bytes_fin_inf in Heqo.

                    destruct Heqo as (bytes_inf&GEN&BYTE_REF).
                    exists bytes_inf. exists ms_inf.
                    split; auto.


                    red.
                    assert (Z.to_N (LLVMParamsBigIntptr.IP.to_unsigned x1) = (Z.to_N (LLVMParams64BitIntptr.IP.to_unsigned x0))) as EQ'.
                    { unfold Z.to_N.
                      unfold LLVMParams64BitIntptr.IP.to_unsigned.
                      rewrite <- IP.to_Z_to_unsigned.
                      erewrite IP.from_Z_to_Z; eauto.
                      rewrite <- ARG_REF.
                      rewrite <- MemoryBigIntptrInfiniteSpec.LP.IP.to_Z_to_unsigned.
                      reflexivity.
                    }

                    rewrite EQ'.
                    cbn in SID; subst.
                    rewrite GEN.
                    cbn; auto.
                  }
                }
              }

              break_match_hyp.
              { (* Free *)
                cbn in *.
                destruct INTRINSIC as [HANDLER | [sab [[] [HANDLER []]]]].
                red in HANDLER.
                repeat (destruct ARGS;
                        [solve [ inversion HANDLER
                               | red in HANDLER;
                                 repeat break_match_hyp; cbn in HANDLER; inversion HANDLER
                           ]
                        |
                       ]).
                pstep; red; cbn.
                repeat (break_match_hyp; try solve [cbn in HANDLER; contradiction]);
                  inv ARGS;
                  rename H into ARG_REF.

                apply dvalue_refine_strict_addr_r_inv in ARG_REF as (?&?&ARG_REF);
                  cbn in ARG_REF; subst.
                eapply Interp_Memory_PropT_Vis with
                  (ta:=raise_ub "").

                3: {
                  red.
                  left.
                  eapply FindUB.
                  pstep; red; cbn.
                  constructor.
                  intros [].
                }

                { intros a0 b RETa RETb AB.
                  cbn in RETb.
                  unfold raiseUB in RETb.
                  rewrite bind_trigger in RETb.
                  eapply Returns_vis_inversion in RETb.
                  destruct RETb as [[] _].
                }

                cbn.
                red.
                red.
                left.
                exists ub_msg.
                red.
                rewrite Heqb, Heqb0, Heqb1.
                left.

                cbn.
                intros CONTRA.

                eapply inf_fin_free_preconditions in CONTRA; eauto.
                apply lift_MemState_refine_prop.
              }

              cbn in INTRINSIC.
              contradiction.
            }

            { (* Handler raises Error *)
              destruct ERR as [err_msg [TA HANDLER]].
              unfold raise_error in TA.
              cbn in TA.
              unfold LLVMEvents.raise in TA.
              rewrite bind_trigger in TA.

              rewrite TA in VIS_HANDLED.
              rewrite bind_vis in VIS_HANDLED.

              destruct VIS_HANDLED as [VIS_HANDLED | VIS_HANDLED].
              { cbn in VIS_HANDLED.
                exfalso.
                clear - VIS_HANDLED.
                dependent induction VIS_HANDLED.
                - pinversion H; subst; inv CHECK.
                - pinversion H; do 2 subst_existT; subst.
                  destruct x.
                - pinversion H; do 2 subst_existT; subst.
                  destruct x.
                - pinversion H; do 2 subst_existT; subst.
                  inversion H4.
              }

              pstep; red; cbn.
              eapply Interp_Memory_PropT_Vis with (ta:=
                                                     vis (Throw (print_msg err_msg))
                                                       (fun x : void =>
                                                          match
                                                            x
                                                            return
                                                            (itree
                                                               (InterpreterStackBigIntptr.LP.Events.ExternalCallE +'
                                                                                                                     LLVMParamsBigIntptr.Events.PickUvalueE +' OOME +' UBE +' DebugE +' FailureE)
                                                               (MemoryBigIntptr.MMEP.MMSP.MemState *
                                                                  (MemPropT.store_id * LLVMParamsBigIntptr.Events.DV.dvalue)))
                                                          with
                                                          end)).

              3: {
                right.
                rewrite itree_eta in VIS_HANDLED.
                rewrite VIS_HANDLED.
                rewrite get_inf_tree_equation.
                cbn. unfold LLVMEvents.raise.

                rewrite bind_trigger.
                rewrite bind_vis.
                pstep; red; cbn.
                constructor.
                intros [].
              }

              { intros a (ms_b, (sid_b, b)) RET1 RET2 AB.
                cbn in AB; subst.

                eapply Returns_vis_inversion in RET2.
                destruct RET2 as [[] _].
              }

              repeat red.
              right.
              left.
              exists err_msg.
              split.
              cbn.
              unfold LLVMEvents.raise.
              rewrite bind_trigger.
              reflexivity.

              destruct HANDLER.
              eapply handle_intrinsic_fin_inf_error.
              2: apply lift_MemState_refine_prop.
              all: eauto.
            }

            { (* Handler raises OOM *)
              destruct OOM as [oom_msg [TA HANDLER]].

              rewrite TA in VIS_HANDLED.
              destruct VIS_HANDLED as [VIS_HANDLED | VIS_HANDLED].
              { eapply contains_UB_Extra_raiseOOM in VIS_HANDLED; try contradiction.
                intros X e1 e2 CONTRA.
                inv CONTRA.
              }
              unfold raise_oom in TA, VIS_HANDLED.
              cbn in TA, VIS_HANDLED.
              unfold raiseOOM in TA, VIS_HANDLED.
              rewrite bind_trigger in TA, VIS_HANDLED.
              rewrite bind_vis in VIS_HANDLED.

              eapply paco2_mon_bot; eauto.
              eapply interp_memory_prop_eutt_S1S2_Proper with (RS2:=MemoryBigIntptr.MMEP.MemSpec.MemState_eqv) (RS1:=eq); eauto; try typeclasses eauto.
              { intros r1 r2 r3 H H0.
                destruct r2, p.
                destruct r3, p0.
                inv H0.
                inv snd_rel.
                cbn in *; subst.
                auto.
              }
              3: {
                rewrite prod_rel_eq.
                rewrite <- itree_eta.
                setoid_rewrite VIS_HANDLED.
                rewrite get_inf_tree_equation.
                cbn.
                reflexivity.
              }
              2: {
                reflexivity.
              }
              2: {
                pstep; red; cbn.
                change ((VisF (subevent void (ThrowOOM (print_msg "")))
                           (fun x : void =>
                              ITree.subst
                                (fun v : void => match v return (itree InfLP.Events.L3 TopLevelBigIntptr.res_L6) with
                                              end) (Ret x)))) with (observe (Vis (subevent void (ThrowOOM (print_msg "")))
                                                                               (fun x : void =>
                                                                                  ITree.subst
                                                                                    (fun v : void => match v return (itree InfLP.Events.L3 TopLevelBigIntptr.res_L6) with
                                                                                                  end) (Ret x)))).
                eapply Interp_Memory_PropT_Vis_OOM.
                reflexivity.
              }

              apply k1.
              apply InterpreterStackBigIntptr.LP.Events.DV.DVALUE_None.
            }

            (* Handler succeeds *)
            destruct HANDLER as (st1&ms'&d&TA&INTRINSIC).
            rewrite TA in VIS_HANDLED.
            setoid_rewrite bind_ret_l in VIS_HANDLED.
            destruct VIS_HANDLED as [VIS_HANDLED | VIS_HANDLED].
            { eapply ret_not_contains_UB_Extra in VIS_HANDLED; try contradiction.
              cbn; reflexivity.
            }

            { epose proof handle_intrinsic_fin_inf ARGS (lift_MemState_refine_prop s2) INTRINSIC as (dv_inf&ms_inf'&INTRINSIC_INF&DV_REF&MSR_INTRINSIC).

              pstep; red; cbn.
              eapply Interp_Memory_PropT_Vis with
                (k2:=(fun '(ms_inf, (sid', dv_inf)) =>
                        get_inf_tree (k3 (ms', (st1, d)))
                     )
                )
                (s1:=s1)
                (s2:=lift_MemState s2).

              2: {
                cbn. red. red.
                repeat right.
                exists s1.
                exists ms_inf'.
                exists dv_inf.
                split; eauto.
                reflexivity.
              }

              2: {
                right.
                cbn.
                rewrite bind_ret_l.
                rewrite <- itree_eta.
                rewrite VIS_HANDLED.
                reflexivity.
              }

              (* Continuation for vis node *)
              intros a b H H2 H3.
              destruct b as [ms [sid' res]].
              cbn in H2.
              apply Returns_ret_inv in H2.
              inv H2.

              cbn.
              rewrite (itree_eta_ (k1 dv_inf)).
              rewrite (itree_eta_ (k3 (ms', (st1, d)))).
              right.
              eapply CIH.
              2: {
                repeat red.
                specialize (HK d (ms', (st1, d))).
                forward HK.
                { eapply ReturnsVis.
                  unfold trigger.
                  reflexivity.
                  cbn.
                  constructor.
                  reflexivity.
                }
                forward HK.
                { constructor.
                  auto.
                }

                forward HK; auto.
                pclearbot.

                repeat rewrite <- itree_eta.
                apply HK.
              }

              specialize (REL dv_inf d).
              forward REL; auto.
              pclearbot.

              repeat rewrite <- itree_eta.
              exact REL.
            }
          }

          { (* MemPush *)
            repeat red in HANDLER.
            rename s2 into m1.
            destruct HANDLER as [UB | [ERR | [OOM | HANDLER]]].
            { (* Handler raises UB *)
              destruct UB as [ub_msg UB].
              cbn in UB.
              contradiction.
            }

            { (* Handler raises error *)
              (* Probably not possible to have an error for MemPush... *)
              destruct ERR as (msg&TA&msg_spec&ERR).
              cbn in ERR.
              contradiction.
            }

            { (* Handler raises OOM *)
              destruct OOM as (oom_msg&TA_OOM&(oom_spec_msg&HANDLE_OOM)).
              rewrite TA_OOM in VIS_HANDLED.
              pose proof (@Raise.rbm_raise_bind (itree (ExternalCallE +'
                                                                         LLVMParams64BitIntptr.Events.PickUvalueE +' OOME +' UBE +' DebugE +' FailureE)) _ _ string (@raise_oom _ _) _ _ _ k3 oom_msg) as RAISE.
              rewrite RAISE in VIS_HANDLED.
              destruct VIS_HANDLED as [VIS_HANDLED | VIS_HANDLED].
              { eapply contains_UB_Extra_raiseOOM in VIS_HANDLED; try contradiction.
                intros X e1 e2 CONTRA.
                inv CONTRA.
              }
              eapply paco2_mon_bot; eauto.
              rewrite <- itree_eta.
              eapply interp_memory_prop_eutt_S1S2_Proper with (RS2:=MemoryBigIntptr.MMEP.MemSpec.MemState_eqv) (RS1:=eq); eauto; try typeclasses eauto.
              { intros r1 r2 r3 H H0.
                destruct r2, p.
                destruct r3, p0.
                inv H0.
                inv snd_rel.
                cbn in *; subst.
                auto.
              }
              3: {
                rewrite prod_rel_eq.
                setoid_rewrite VIS_HANDLED.
                rewrite get_inf_tree_equation.
                cbn.
                reflexivity.
              }
              2: {
                reflexivity.
              }
              2: {
                pstep; red; cbn.
                change ((VisF (subevent void (ThrowOOM (print_msg "")))
                           (fun x : void =>
                              ITree.subst
                                (fun v : void => match v return (itree InfLP.Events.L3 TopLevelBigIntptr.res_L6) with
                                              end) (Ret x)))) with (observe (Vis (subevent void (ThrowOOM (print_msg "")))
                                                                               (fun x : void =>
                                                                                  ITree.subst
                                                                                    (fun v : void => match v return (itree InfLP.Events.L3 TopLevelBigIntptr.res_L6) with
                                                                                                  end) (Ret x)))).
                eapply Interp_Memory_PropT_Vis_OOM.
                reflexivity.
              }

              apply k1; constructor.
            }

            (* Handler succeeds *)
            destruct HANDLER as [st' [ms_push [[] [TA PUSH_HANDLER]]]].
            cbn in PUSH_HANDLER.

            rewrite TA in VIS_HANDLED.
            cbn in VIS_HANDLED.
            rewrite bind_ret_l in VIS_HANDLED.
            destruct VIS_HANDLED as [VIS_HANDLED | VIS_HANDLED].
            { eapply ret_not_contains_UB_Extra in VIS_HANDLED; try contradiction.
              cbn; reflexivity.
            }

            { epose proof mem_push_spec_fin_inf (lift_MemState_refine_prop m1) (lift_MemState_refine_prop ms_push) PUSH_HANDLER as PUSH_INF.

              pose proof MemState_fin_to_inf_to_fin_exists ms_push as (ms_push'&MS_PUSH_CONV&MS_PUSH_EQV).
              pstep; red; cbn.

              eapply Interp_Memory_PropT_Vis with
                (k2:=(fun '(ms_inf, (sid', _)) =>
                            get_inf_tree (k3 (ms_push, (st', tt)))
                     )
                )
                (s1:=s1)
                (s2:=lift_MemState m1).

              2: {
                cbn. red. red.
                repeat right.
                exists s1.
                exists (lift_MemState ms_push).
                exists tt.
                split; try reflexivity.
                cbn; auto.
              }

              2: {
                right.
                cbn.
                rewrite bind_ret_l.
                rewrite <- itree_eta.
                rewrite VIS_HANDLED.
                reflexivity.
              }

              (* Continuation for vis node *)
              intros a b RETa RETb AB.
              destruct b as [ms [sid' res]].
              cbn in AB; subst; cbn in RETb.
              apply Returns_ret_inv in RETb.
              inv RETb.

              cbn.
              rewrite (itree_eta_ (k1 tt)).
              rewrite (itree_eta_ (k3 (ms_push, (st', tt)))).
              right.
              eapply CIH.
              2: {
                repeat red.
                specialize (HK tt (ms_push, (st', tt))).
                forward HK.
                { eapply ReturnsVis.
                  unfold trigger.
                  reflexivity.
                  cbn.
                  constructor.
                  reflexivity.
                }
                forward HK.
                { rewrite TA.
                  constructor.
                  reflexivity.
                }

                forward HK; auto.
                pclearbot.

                repeat rewrite <- itree_eta.
                apply HK.
              }

              specialize (REL tt tt I).
              pclearbot.

              repeat rewrite <- itree_eta.
              exact REL.
            }
          }

          { (* MemPop *)
            repeat red in HANDLER.
            destruct HANDLER as [UB | [ERR | [OOM | HANDLER]]].
            { (* Handler raises UB *)
              cbn in UB.
              destruct UB as [msg []].
            }

            { (* Handler raises error *)
              destruct ERR as (msg&TA&msg_spec&ERR).
              cbn in ERR.

              (* There's an error if I cannot pop a stack frame...

                         This shouldn't happen, but I should hopefully
                         be able to show that if I cannot pop in the
                         finite world, then I cannot pop in the
                         infinite world either, so we should get an
                         error in both places.
               *)

              rewrite TA in VIS_HANDLED.
              pose proof (@Raise.rbm_raise_bind (itree (ExternalCallE +'
                                                                         LLVMParams64BitIntptr.Events.PickUvalueE +' OOME +' UBE +' DebugE +' FailureE)) _ _ string (@raise_error _ _) _ _ _ k3 msg) as RAISE.
              rewrite RAISE in VIS_HANDLED.
              destruct VIS_HANDLED as [VIS_HANDLED | VIS_HANDLED].
              { eapply contains_UB_Extra_raise_error in VIS_HANDLED; try contradiction.
                intros X e1 e2 CONTRA.
                inv CONTRA.
              }

              pstep; red; cbn.

              eapply Interp_Memory_PropT_Vis with
                (k2:=(fun '(ms_inf, (sid', _)) =>
                        get_inf_tree (k3 (s2, (s1, tt)))
                ))
                (s1:=s1)
                (s2:=lift_MemState s2).
              2: {
                pose proof cannot_pop_fin_inf (lift_MemState_refine_prop s2) ERR as ERR_INF.
                cbn.
                repeat red.
                right.
                left.
                cbn.
                exists msg.
                split; [reflexivity|].
                exists msg_spec.
                auto.
              }

              2: {
                right.
                rewrite <- itree_eta.
                rewrite VIS_HANDLED.
                rewrite get_inf_tree_equation.
                cbn.
                setoid_rewrite Raise.raise_bind_itree.
                reflexivity.
              }

              intros a b RETa RETb AB.

              unfold LLVMEvents.raise in RETb.
              rewrite bind_trigger in RETb.
              apply Returns_vis_inversion in RETb.
              destruct RETb as [[] _].
            }

            { (* Handler raises OOM *)
              destruct OOM as (oom_msg&TA_OOM&(oom_spec_msg&HANDLE_OOM)).
              rewrite TA_OOM in VIS_HANDLED.
              pose proof (@Raise.rbm_raise_bind (itree (ExternalCallE +'
                                                                         LLVMParams64BitIntptr.Events.PickUvalueE +' OOME +' UBE +' DebugE +' FailureE)) _ _ string (@raise_oom _ _) _ _ _ k3 oom_msg) as RAISE.
              rewrite RAISE in VIS_HANDLED.
              destruct VIS_HANDLED as [VIS_HANDLED | VIS_HANDLED].
              { eapply contains_UB_Extra_raiseOOM in VIS_HANDLED; try contradiction.
                intros X e1 e2 CONTRA.
                inv CONTRA.
              }

              eapply paco2_mon_bot; eauto.
              rewrite <- itree_eta.
              eapply interp_memory_prop_eutt_S1S2_Proper with (RS2:=MemoryBigIntptr.MMEP.MemSpec.MemState_eqv) (RS1:=eq); eauto; try typeclasses eauto.
              { intros r1 r2 r3 H H0.
                destruct r2, p.
                destruct r3, p0.
                inv H0.
                inv snd_rel.
                cbn in *; subst.
                auto.
              }
              3: {
                rewrite prod_rel_eq.
                setoid_rewrite VIS_HANDLED.
                rewrite get_inf_tree_equation.
                cbn.
                reflexivity.
              }
              2: {
                reflexivity.
              }
              2: {
                pstep; red; cbn.
                change ((VisF (subevent void (ThrowOOM (print_msg "")))
                           (fun x : void =>
                              ITree.subst
                                (fun v : void => match v return (itree InfLP.Events.L3 TopLevelBigIntptr.res_L6) with
                                              end) (Ret x)))) with (observe (Vis (subevent void (ThrowOOM (print_msg "")))
                                                                               (fun x : void =>
                                                                                  ITree.subst
                                                                                    (fun v : void => match v return (itree InfLP.Events.L3 TopLevelBigIntptr.res_L6) with
                                                                                                  end) (Ret x)))).
                eapply Interp_Memory_PropT_Vis_OOM.
                reflexivity.
              }

              apply k1; constructor.
            }

            (* Handler succeeds *)
            destruct HANDLER as [st' [ms_pop [[] [TA POP_HANDLER]]]].
            cbn in POP_HANDLER.

            rewrite TA in VIS_HANDLED.
            cbn in VIS_HANDLED.
            rewrite bind_ret_l in VIS_HANDLED.
            destruct VIS_HANDLED as [VIS_HANDLED | VIS_HANDLED].
            { eapply ret_not_contains_UB_Extra in VIS_HANDLED; try contradiction.
              cbn; reflexivity.
            }

            { pstep; red; cbn.
              eapply Interp_Memory_PropT_Vis with
                (k2:=(fun '(ms_inf, (sid', _)) =>
                            get_inf_tree (k3 (ms_pop, (st', tt)))
                     )
                )
                (s1:=s1)
                (s2:=lift_MemState s2).

              2: {
                cbn. red. red.
                repeat right.
                exists s1.
                exists (lift_MemState ms_pop).
                exists tt.
                split; try reflexivity.
                cbn.

                eapply mem_pop_spec_fin_inf; eauto; apply lift_MemState_refine_prop.
              }

              2: {
                right.
                cbn.
                rewrite bind_ret_l.
                rewrite <- itree_eta.
                rewrite VIS_HANDLED.
                reflexivity.
              }

              (* Continuation for vis node *)
              intros [] b RETa RETb AB.
              destruct b as [ms [sid' res]].
              cbn in RETb.
              cbn in AB. inv AB.
              apply Returns_ret_inv in RETb.
              inv RETb.

              cbn.
              rewrite (itree_eta_ (k1 tt)).
              rewrite (itree_eta_ (k3 (ms_pop, (st', tt)))).
              right.
              eapply CIH.
              2: {
                repeat red.
                specialize (HK tt (ms_pop, (st', tt))).
                forward HK.
                { eapply ReturnsVis.
                  unfold trigger.
                  reflexivity.
                  cbn.
                  constructor.
                  reflexivity.
                }
                forward HK.
                { rewrite TA.
                  constructor.
                  reflexivity.
                }

                forward HK; auto.
                pclearbot.

                repeat rewrite <- itree_eta.
                apply HK.
              }

              specialize (REL tt tt I).
              red in REL.
              pclearbot.

              repeat rewrite <- itree_eta.
              exact REL.
            }
          }

          { (* Alloca *)
            repeat red in HANDLER.
            destruct HANDLER as [UB | [ERR | [OOM | HANDLER]]].
            { (* Handler raises UB *)

              destruct UB as (msg_spec&UB).
              destruct EV_REL as (?&?&?); subst.

              pstep; red; cbn.
              eapply Interp_Memory_PropT_Vis
                with (ta:= raise_ub "").
              2: {
                cbn; red.
                left.
                exists msg_spec.
                red.
                eapply MemPropT_fin_inf_bind_ub.
                5: apply UB.
                all: eauto with FinInf.

                intros a_fin ms_fin_ma ALLOC.
                eapply allocate_dtyp_spec_fin_inf; eauto with FinInf.
              }

              { intros a b RETa RETb AB.
                cbn in AB; subst.
                unfold raise_ub in RETb.
                cbn in RETb.
                unfold raiseUB in RETb.
                rewrite bind_trigger in RETb.

                eapply Returns_vis_inversion in RETb.
                destruct RETb as [[] _].
              }

              left.
              eapply FindUB.
              unfold raise_ub. cbn; unfold raiseUB; cbn.
              rewrite bind_trigger.
              pstep; red; cbn.
              rewrite subevent_subevent.
              constructor.
              intros [].
            }

            { (* Handler raises error *)
              destruct ERR as (msg&TA&msg_spec&ERR).
              destruct EV_REL as (?&?&?); subst.

              apply handle_alloca_no_error in ERR.
              contradiction.
            }

            { (* Handler raises OOM *)
              destruct OOM as (oom_msg&TA_OOM&(oom_spec_msg&HANDLE_OOM)).
              rewrite TA_OOM in VIS_HANDLED.
              pose proof (@Raise.rbm_raise_bind (itree (ExternalCallE +'
                                                                         LLVMParams64BitIntptr.Events.PickUvalueE +' OOME +' UBE +' DebugE +' FailureE)) _ _ string (@raise_oom _ _) _ _ _ k3 oom_msg) as RAISE.
              rewrite RAISE in VIS_HANDLED.
              destruct VIS_HANDLED as [VIS_HANDLED | VIS_HANDLED].
              { eapply contains_UB_Extra_raiseOOM in VIS_HANDLED; try contradiction.
                intros X e1 e2 CONTRA.
                inv CONTRA.
              }

              eapply paco2_mon_bot; eauto.
              eapply interp_memory_prop_eutt_S1S2_Proper with (RS2:=MemoryBigIntptr.MMEP.MemSpec.MemState_eqv) (RS1:=eq); eauto; try typeclasses eauto.
              { intros r1 r2 r3 H H0.
                destruct r2, p.
                destruct r3, p0.
                inv H0.
                inv snd_rel.
                cbn in *; subst.
                auto.
              }
              3: {
                rewrite prod_rel_eq.
                rewrite <- itree_eta.
                setoid_rewrite VIS_HANDLED.
                rewrite get_inf_tree_equation.
                cbn.
                reflexivity.
              }
              2: {
                reflexivity.
              }
              2: {
                pstep; red; cbn.
                change ((VisF (subevent void (ThrowOOM (print_msg "")))
                           (fun x : void =>
                              ITree.subst
                                (fun v : void => match v return (itree InfLP.Events.L3 TopLevelBigIntptr.res_L6) with
                                              end) (Ret x)))) with (observe (Vis (subevent void (ThrowOOM (print_msg "")))
                                                                               (fun x : void =>
                                                                                  ITree.subst
                                                                                    (fun v : void => match v return (itree InfLP.Events.L3 TopLevelBigIntptr.res_L6) with
                                                                                                  end) (Ret x)))).
                eapply Interp_Memory_PropT_Vis_OOM.
                reflexivity.
              }

              apply k1.
              apply InterpreterStackBigIntptr.LP.Events.DV.DVALUE_None.
            }

            (* Handler succeeds *)
            destruct HANDLER as [st' [ms_alloca [d [TA ALLOCA_HANDLER]]]].

            rewrite TA in VIS_HANDLED.
            cbn in VIS_HANDLED.
            rewrite bind_ret_l in VIS_HANDLED.
            destruct VIS_HANDLED as [VIS_HANDLED | VIS_HANDLED].
            { eapply ret_not_contains_UB_Extra in VIS_HANDLED; try contradiction.
              cbn; reflexivity.
            }

            destruct EV_REL as (?&?&?); subst.

            { epose proof handle_alloca_fin_inf (lift_MemState_refine_prop s2) ALLOCA_HANDLER as (dv_inf&ms_inf'&ALLOCA_INF&DV_REF&MSR_ALLOCA).

              pstep; red; cbn.

              eapply Interp_Memory_PropT_Vis with
                (k2:=(fun '(ms_inf, (sid', dv_inf)) =>
                        get_inf_tree (k3 (ms_alloca, (st', d)))))
                (s1:=s1)
                (s2:=lift_MemState s2).

              2: {
                cbn. red. red.
                repeat right.
                exists s1.
                exists ms_inf'.
                exists dv_inf.
                split; auto; reflexivity.
              }

              2: {
                right.
                cbn.
                rewrite bind_ret_l.
                rewrite <- itree_eta.
                rewrite VIS_HANDLED.
                reflexivity.
              }

              (* Continuation for vis node *)
              intros a b RETa RETb AB.
              destruct b as [ms [sid' res]].
              cbn in RETb; subst.
              apply Returns_ret_inv in RETb.
              inv RETb.

              cbn.
              rewrite (itree_eta_ (k1 dv_inf)).
              rewrite (itree_eta_ (k3 (ms_alloca, (st', d)))).
              right.
              eapply CIH.
              2: {
                repeat red.
                specialize (HK d (ms_alloca, (st', d))).
                forward HK.
                { eapply ReturnsVis.
                  unfold trigger.
                  reflexivity.
                  cbn.
                  constructor.
                  reflexivity.
                }
                forward HK.
                { rewrite TA.
                  constructor.
                  reflexivity.
                }

                forward HK; auto.
                pclearbot.

                repeat rewrite <- itree_eta.
                apply HK.
              }

              specialize (REL dv_inf d).
              forward REL; auto.
              pclearbot.

              repeat rewrite <- itree_eta.
              exact REL.
            }
          }

          { (* Load *)
            repeat red in HANDLER.
            destruct HANDLER as [UB | [ERR | [OOM | HANDLER]]].
            { (* Handler raises UB *)
              destruct UB as (msg_spec&UB).
              destruct EV_REL as (?&?); subst.
              rename H0 into DV_REF.

              pstep; red; cbn.
              eapply Interp_Memory_PropT_Vis
                with (ta:= raise_ub "").

              2: {
                cbn; red.
                left.
                exists msg_spec.
                eapply handle_load_fin_inf_ub.
                3: apply UB.
                all: eauto with FinInf.
              }

              { intros a1 b RETa RETb AB.
                cbn in AB; subst.
                unfold raise_ub in RETb.
                cbn in RETb.
                unfold raiseUB in RETb.
                rewrite bind_trigger in RETb.

                eapply Returns_vis_inversion in RETb.
                destruct RETb as [[] _].
              }

              left.
              eapply FindUB.
              unfold raise_ub. cbn; unfold raiseUB; cbn.
              rewrite bind_trigger.
              pstep; red; cbn.
              rewrite subevent_subevent.
              constructor.
              intros [].
            }

            { (* Handler raises error *)
              destruct ERR as (msg&TA&msg_spec&ERR).
              destruct EV_REL as (?&?); subst.

              rewrite TA in VIS_HANDLED.
              pose proof (@Raise.rbm_raise_bind (itree (ExternalCallE +'
                                                                         LLVMParams64BitIntptr.Events.PickUvalueE +' OOME +' UBE +' DebugE +' FailureE)) _ _ string (@raise_error _ _) _ _ _ k3 msg) as RAISE.
              rewrite RAISE in VIS_HANDLED.
              destruct VIS_HANDLED as [VIS_HANDLED | VIS_HANDLED].
              { eapply contains_UB_Extra_raise_error in VIS_HANDLED; try contradiction.
                intros X e1 e2 CONTRA.
                inv CONTRA.
              }

              pstep; red; cbn.

              eapply Interp_Memory_PropT_Vis with
                (k2:=(fun '(ms_inf, (sid', uv_inf)) =>
                        match DVCInfFin.uvalue_convert_strict uv_inf with
                        | NoOom uv_fin => get_inf_tree (k3 (s2, (s1, uv_fin)))
                        | Oom s => raiseOOM s
                        end)
                )
                (s1:=s1)
                (s2:=lift_MemState s2)
                (ta:= raise_error msg).
              3: {
                right.
                rewrite <- itree_eta.
                rewrite VIS_HANDLED.
                rewrite get_inf_tree_equation.
                cbn.
                setoid_rewrite Raise.raise_bind_itree.
                reflexivity.
              }

              2: {
                (* raise_ub includes raise_error... *)
                red in ERR.
                cbn.
                break_match_hyp;
                  try solve
                    [ repeat red;
                      left;
                      exists "Loading from something that isn't an address.";
                      unfold_dvalue_refine_strict_in H0;
                      destruct a; cbn in H0; try break_match_hyp_inv; cbn; auto
                    ].

                apply dvalue_refine_strict_addr_r_inv in H0 as (ptr_inf&ADDR&ADDR_REF).
                subst.

                repeat red.
                right.
                left.

                (* TODO: read_uvalue_spec_fin_inf_error lemma *)
                (* Figure out where error came from in read_uvalue_spec *)
                red in ERR.
                repeat red in ERR.

                destruct ERR as [ERR | ERR].
                { (* TODO: read_bytes_spec_fin_inf_error lemma *)
                  repeat red in ERR.
                  destruct ERR as [ERR | ERR].
                  { exfalso.
                    apply get_consecutive_ptrs_never_fails in ERR.
                    auto.
                  }

                  destruct ERR as (?&?&GCP&ERR).
                  exists msg.
                  split; [reflexivity|].
                  exists msg_spec.

                  cbn.
                  left.
                  right.

                  pose proof GCP as GCP_INF.
                  eapply fin_inf_get_consecutive_ptrs_success_exists in GCP_INF; eauto.
                  2: apply lift_MemState_refine_prop.

                  destruct GCP_INF as(?&?&GCP_INF&FORALL_INF&MSR').
                  exists x2. exists x1.
                  split; auto.

                  clear - FORALL_INF ERR MSR'.
                  generalize dependent x.
                  generalize dependent x2.
                  induction FORALL_INF; intros x2 x' ERR MSR'.
                  - cbn in ERR; contradiction.
                  - rewrite map_monad_unfold.
                    rewrite map_monad_unfold in ERR.
                    destruct ERR as [ERR | ERR].
                    cbn in ERR; contradiction.

                    destruct ERR as (?&?&?&ERR).
                    cbn in ERR.
                    destruct ERR as [ERR | ERR].
                    + right.

                      pose proof H0 as READ_INF.
                      eapply fin_inf_read_byte_spec_MemPropT in READ_INF; eauto.
                      destruct READ_INF as (byte_inf & ms_inf' & READ_INF & BYTES_REF & MSR'').
                      exists ms_inf'. exists byte_inf.
                      split; auto.

                      cbn.
                      left.
                      eapply IHFORALL_INF; eauto.
                    + destruct ERR as (?&?&?&?).
                      contradiction.
                }

                destruct ERR as (?&?&?&ERR).
                red in ERR.
                break_match_hyp_inv.

                eapply fin_inf_read_bytes_spec in H; eauto.
                2: apply lift_MemState_refine_prop.
                destruct H as (?&?&?&?&?).

                pose proof Heqs as DESER_INF.
                eapply deserialize_sbytes_fail_fin_inf in DESER_INF.
                2: apply H0.

                exists msg.
                split; [reflexivity|].

                exists s.
                cbn.
                right.

                cbn in H.
                destruct H as (?&?&?&?).
                exists x2. exists x1.
                split.
                2: {
                  red.
                  rewrite DESER_INF.
                  cbn; auto.
                }

                exists x3. exists x4.
                split; auto.
              }

              intros a1 b RETa RETb AB.

              (* H0 might be a contradiction... *)
              unfold raise_error in RETb.
              cbn in RETb.
              unfold LLVMEvents.raise in RETb.
              rewrite bind_trigger in RETb.
              apply Returns_vis_inversion in RETb.
              destruct RETb as [[] _].
            }

            { (* Handler raises OOM *)
              destruct OOM as (oom_msg&TA_OOM&(oom_spec_msg&HANDLE_OOM)).
              rewrite TA_OOM in VIS_HANDLED.
              pose proof (@Raise.rbm_raise_bind (itree (ExternalCallE +'
                                                                         LLVMParams64BitIntptr.Events.PickUvalueE +' OOME +' UBE +' DebugE +' FailureE)) _ _ string (@raise_oom _ _) _ _ _ k3 oom_msg) as RAISE.
              rewrite RAISE in VIS_HANDLED.
              destruct VIS_HANDLED as [VIS_HANDLED | VIS_HANDLED].
              { eapply contains_UB_Extra_raiseOOM in VIS_HANDLED; try contradiction.
                intros X e1 e2 CONTRA.
                inv CONTRA.
              }

              eapply paco2_mon_bot; eauto.
              rewrite <- itree_eta.
              eapply interp_memory_prop_eutt_S1S2_Proper with (RS2:=MemoryBigIntptr.MMEP.MemSpec.MemState_eqv) (RS1:=eq); eauto; try typeclasses eauto.
              { intros r1 r2 r3 H H0.
                destruct r2, p.
                destruct r3, p0.
                inv H0.
                inv snd_rel.
                cbn in *; subst.
                auto.
              }
              3: {
                rewrite prod_rel_eq.
                setoid_rewrite VIS_HANDLED.
                rewrite get_inf_tree_equation.
                cbn.
                reflexivity.
              }
              2: {
                reflexivity.
              }
              2: {
                pstep; red; cbn.
                change ((VisF (subevent void (ThrowOOM (print_msg "")))
                           (fun x : void =>
                              ITree.subst
                                (fun v : void => match v return (itree InfLP.Events.L3 TopLevelBigIntptr.res_L6) with
                                              end) (Ret x)))) with (observe (Vis (subevent void (ThrowOOM (print_msg "")))
                                                                               (fun x : void =>
                                                                                  ITree.subst
                                                                                    (fun v : void => match v return (itree InfLP.Events.L3 TopLevelBigIntptr.res_L6) with
                                                                                                  end) (Ret x)))).
                eapply Interp_Memory_PropT_Vis_OOM.
                reflexivity.
              }

              apply k1.
              apply InterpreterStackBigIntptr.LP.Events.DV.UVALUE_None.
            }

            (* Handler succeeds *)
            destruct HANDLER as [st' [ms_load [uv_fin [TA LOAD_HANDLER]]]].

            rewrite TA in VIS_HANDLED.
            cbn in VIS_HANDLED.
            rewrite bind_ret_l in VIS_HANDLED.
            destruct VIS_HANDLED as [VIS_HANDLED | VIS_HANDLED].
            { eapply ret_not_contains_UB_Extra in VIS_HANDLED; try contradiction.
              cbn; reflexivity.
            }

            destruct EV_REL as (?&?); subst.

            { epose proof handle_load_fin_inf (lift_MemState_refine_prop s2) H0 LOAD_HANDLER as (uv_inf&ms_inf'&LOAD_INF&UV_REF&MSR_LOAD).

              pstep; red; cbn.

              eapply Interp_Memory_PropT_Vis with
                (k2:=(fun '(ms_inf, (sid', uv_inf)) =>
                        get_inf_tree (k3 (ms_load, (st', uv_fin)))))
                (s1:=s1)
                (s2:=lift_MemState s2).

              2: {
                cbn. red. red.
                repeat right.
                exists s1.
                exists ms_inf'.
                exists uv_inf.
                split; auto; reflexivity.
              }

              2: {
                right.
                cbn.
                rewrite bind_ret_l.
                rewrite <- itree_eta.
                rewrite VIS_HANDLED.
                reflexivity.
              }

              (* Continuation for vis node *)
              intros a1 b RETa RETb AB.
              destruct b as [ms [sid' res]].
              cbn in AB; subst.
              apply Returns_ret_inv in RETb.
              inv RETb.
              cbn.

              rewrite (itree_eta_ (k1 uv_inf)).
              rewrite (itree_eta_ (k3 (ms_load, (st', uv_fin)))).
              right.
              eapply CIH.
              2: {
                repeat red.
                specialize (HK uv_fin (ms_load, (st', uv_fin))).
                forward HK.
                { eapply ReturnsVis.
                  unfold trigger.
                  reflexivity.
                  cbn.
                  constructor.
                  reflexivity.
                }
                forward HK.
                { rewrite TA.
                  constructor.
                  reflexivity.
                }

                forward HK; auto.
                pclearbot.

                repeat rewrite <- itree_eta.
                apply HK.
              }

              specialize (REL uv_inf uv_fin).
              forward REL; auto.
              pclearbot.

              repeat rewrite <- itree_eta.
              exact REL.
            }
          }

          { (* Store *)
            repeat red in HANDLER.
            destruct HANDLER as [UB | [ERR | [OOM | HANDLER]]].
            { (* Handler raises UB *)
              destruct UB as (msg_spec&UB).
              destruct EV_REL as (?&?); subst.
              rename H0 into DV_REF.
              destruct DV_REF as [DV_REF UV_REF].

              pstep; red; cbn.
              eapply Interp_Memory_PropT_Vis
                with (ta:= raise_ub "").

              2: {
                cbn; red.
                left.
                exists msg_spec.
                eapply handle_store_fin_inf_ub.
                4: apply UB.
                all: eauto with FinInf.
              }

              { intros a1 b RETa RETb AB.
                cbn in AB; subst.
                unfold raise_ub in RETb.
                cbn in RETb.
                unfold raiseUB in RETb.
                rewrite bind_trigger in RETb.

                eapply Returns_vis_inversion in RETb.
                destruct RETb as [[] _].
              }

              left.
              eapply FindUB.
              unfold raise_ub. cbn; unfold raiseUB; cbn.
              rewrite bind_trigger.
              pstep; red; cbn.
              rewrite subevent_subevent.
              constructor.
              intros [].
            }

            { (* Handler raises error *)
              destruct ERR as (msg&TA&msg_spec&ERR).
              destruct EV_REL as (?&?&?); subst.

              rewrite TA in VIS_HANDLED.
              pose proof (@Raise.rbm_raise_bind (itree (ExternalCallE +'
                                                                         LLVMParams64BitIntptr.Events.PickUvalueE +' OOME +' UBE +' DebugE +' FailureE)) _ _ string (@raise_error _ _) _ _ _ k3 msg) as RAISE.
              rewrite RAISE in VIS_HANDLED.
              destruct VIS_HANDLED as [VIS_HANDLED | VIS_HANDLED].
              { eapply contains_UB_Extra_raise_error in VIS_HANDLED; try contradiction.
                intros X e1 e2 CONTRA.
                inv CONTRA.
              }

              eapply paco2_mon_bot; eauto.
              rewrite <- itree_eta.
              eapply interp_memory_prop_eutt_S1S2_Proper with (RS2:=MemoryBigIntptr.MMEP.MemSpec.MemState_eqv) (RS1:=eq); eauto; try typeclasses eauto.
              { intros r1 r2 r3 H H3.
                destruct r2, p.
                destruct r3, p0.
                inv H3.
                inv snd_rel.
                cbn in *; subst.
                auto.
              }
              3: {
                rewrite prod_rel_eq.
                setoid_rewrite VIS_HANDLED.
                rewrite get_inf_tree_equation.
                cbn.
                reflexivity.
              }
              2: {
                reflexivity.
              }
              2: {
                pstep; red; cbn.
                change ((VisF (subevent void (raise ""))
                           (fun x : void =>
                              ITree.subst
                                (fun v : void => match v return (itree InfLP.Events.L3 TopLevelBigIntptr.res_L6) with
                                              end) (Ret x)))) with (observe (Vis (subevent void (ThrowOOM (print_msg "")))
                                                                               (fun x : void =>
                                                                                  ITree.subst
                                                                                    (fun v : void => match v return (itree InfLP.Events.L3 TopLevelBigIntptr.res_L6) with
                                                                                                  end) (Ret x)))).
              change (VisF (subevent void (Throw (print_msg "")))
       (fun x : void =>
        ITree.subst
          (fun v1 : void => match v1 return (itree InfLP.Events.L3 TopLevelBigIntptr.res_L6) with
                         end) (Ret x)))
                with
                (observe (Vis (subevent void (Throw (print_msg "")))
       (fun x : void =>
        ITree.subst
          (fun v1 : void => match v1 return (itree InfLP.Events.L3 TopLevelBigIntptr.res_L6) with
                            end) (Ret x)))).

              eapply Interp_Memory_PropT_Vis with
                (k2:=(fun '(ms_inf, (sid', _)) =>
                        get_inf_tree (k3 (s2, (s1, tt))))
                )
                (s1:=s1)
                (s2:=lift_MemState s2)
                (ta:= raise_error msg).
              3: {
                right.
                cbn.
                setoid_rewrite Raise.raise_bind_itree.
                unfold LLVMEvents.raise.
                rewrite bind_trigger.
                unfold print_msg.
                cbn.
                setoid_rewrite bind_ret_l.
                reflexivity.
              }

              2: {
                (* raise_ub includes raise_error... *)
                red in ERR.
                break_match_hyp;
                  try solve
                    [ repeat red;
                      left;
                      exists "Writing something to somewhere that isn't an address.";
                      unfold_dvalue_refine_strict_in H0;
                      destruct a; cbn in H0; try break_match_hyp_inv; cbn; auto
                    ].

                apply dvalue_refine_strict_addr_r_inv in H0 as (ptr_inf&ADDR&ADDR_REF).
                subst.

                red in ERR.
                repeat red in ERR.
                destruct ERR as [ERR | ERR].
                { cbn.
                  repeat red.
                  right.
                  left.
                  exists msg.
                  split; eauto.
                  reflexivity.
                  exists msg.
                  repeat red.
                  left.
                  eapply serialize_sbytes_fin_inf_error; eauto.
                  2: apply ERR.
                  apply lift_MemState_refine_prop.
                }

                destruct ERR as (?&?&?&ERR).
                destruct ERR as [ERR | ERR].
                { exfalso.
                  apply get_consecutive_ptrs_never_fails in ERR.
                  auto.
                }

                destruct ERR as (?&?&GCP&ERR).
                { (* ERR should be a contradiction as
                             write_byte_spec_MemPropT doesn't contain
                             error... Except in UB cases *)
                  remember (zip x2 x0) as z.
                  cbn in ERR.
                  destruct ERR as [ERR | ERR].
                  2: destruct ERR as (?&?&?&?); contradiction.

                  clear Heqz GCP.
                  generalize dependent x.
                  generalize dependent x1.
                  generalize dependent x2.
                  induction z; intros x2 x1 ERR x H.
                  - cbn in ERR; contradiction.
                  - rewrite map_monad_unfold in ERR.
                    destruct ERR as [ERR | ERR].
                    + destruct a.
                      cbn in ERR.
                      contradiction.
                    + destruct ERR as (?&?&?&ERR).
                      repeat red in ERR.
                      destruct ERR as [ERR | ERR].
                      2: {
                        destruct ERR as (?&?&?&ERR).
                        cbn in ERR; contradiction.
                      }

                      eapply IHz in ERR; eauto.
                }
              }

              intros a1 b RETa RETb AB.
              unfold raise_error in RETb.
              cbn in RETb.
              unfold LLVMEvents.raise in RETb.
              rewrite bind_trigger in RETb.
              apply Returns_vis_inversion in RETb.
              destruct RETb as [[] _].
              }

              apply k1; constructor.
            }

            { (* Handler raises OOM *)
              destruct OOM as (oom_msg&TA_OOM&(oom_spec_msg&HANDLE_OOM)).
              rewrite TA_OOM in VIS_HANDLED.
              pose proof (@Raise.rbm_raise_bind (itree (ExternalCallE +'
                                                                         LLVMParams64BitIntptr.Events.PickUvalueE +' OOME +' UBE +' DebugE +' FailureE)) _ _ string (@raise_oom _ _) _ _ _ k3 oom_msg) as RAISE.
              rewrite RAISE in VIS_HANDLED.
              destruct VIS_HANDLED as [VIS_HANDLED | VIS_HANDLED].
              { eapply contains_UB_Extra_raiseOOM in VIS_HANDLED; try contradiction.
                intros X e1 e2 CONTRA.
                inv CONTRA.
              }

              eapply paco2_mon_bot; eauto.
              rewrite <- itree_eta.
              eapply interp_memory_prop_eutt_S1S2_Proper with (RS2:=MemoryBigIntptr.MMEP.MemSpec.MemState_eqv) (RS1:=eq); eauto; try typeclasses eauto.
              { intros r1 r2 r3 H H0.
                destruct r2, p.
                destruct r3, p0.
                inv H0.
                inv snd_rel.
                cbn in *; subst.
                auto.
              }
              3: {
                rewrite prod_rel_eq.
                setoid_rewrite VIS_HANDLED.
                rewrite get_inf_tree_equation.
                cbn.
                reflexivity.
              }
              2: {
                reflexivity.
              }
              2: {
                pstep; red; cbn.
                change ((VisF (subevent void (ThrowOOM (print_msg "")))
                           (fun x : void =>
                              ITree.subst
                                (fun v : void => match v return (itree InfLP.Events.L3 TopLevelBigIntptr.res_L6) with
                                              end) (Ret x)))) with (observe (Vis (subevent void (ThrowOOM (print_msg "")))
                                                                               (fun x : void =>
                                                                                  ITree.subst
                                                                                    (fun v : void => match v return (itree InfLP.Events.L3 TopLevelBigIntptr.res_L6) with
                                                                                                  end) (Ret x)))).
                eapply Interp_Memory_PropT_Vis_OOM.
                reflexivity.
              }

              apply k1; constructor.
            }

            { (* Handler succeeds *)
            destruct HANDLER as [st' [ms_store [[] [TA STORE_HANDLER]]]].

            rewrite TA in VIS_HANDLED.
            cbn in VIS_HANDLED.
            rewrite bind_ret_l in VIS_HANDLED.
            destruct VIS_HANDLED as [VIS_HANDLED | VIS_HANDLED].
            { eapply ret_not_contains_UB_Extra in VIS_HANDLED; try contradiction.
              cbn; reflexivity.
            }

            destruct EV_REL as (?&?&?); subst.

            { epose proof handle_store_fin_inf (lift_MemState_refine_prop s2) H0 H2 STORE_HANDLER as ([]&ms_inf'&STORE_INF&_&MSR_STORE).

              pstep; red; cbn.
              eapply Interp_Memory_PropT_Vis with
                (k2:=(fun '(ms_inf, (sid', dv_inf)) =>
                        get_inf_tree (k3 (ms_store, (st', tt)))))
                (s1:=s1)
                (s2:=lift_MemState s2).

              2: {
                cbn. red. red.
                repeat right.
                exists s1.
                exists ms_inf'.
                exists tt.
                split; auto; reflexivity.
              }

              2: {
                right.
                cbn.
                rewrite bind_ret_l.
                rewrite <- itree_eta.
                rewrite VIS_HANDLED.
                reflexivity.
              }

              (* Continuation for vis node *)
              intros a1 b RETa RETb AB.
              destruct b as [ms [sid' res]].
              cbn in AB; subst.
              cbn in RETb.
              apply Returns_ret_inv in RETb.
              inv RETb.
              cbn.

              rewrite (itree_eta_ (k1 tt)).
              rewrite (itree_eta_ (k3 (ms_store, (st', tt)))).
              right.
              eapply CIH.
              2: {
                repeat red.
                specialize (HK tt (ms_store, (st', tt))).
                forward HK.
                { eapply ReturnsVis.
                  unfold trigger.
                  reflexivity.
                  cbn.
                  constructor.
                  reflexivity.
                }
                forward HK.
                { rewrite TA.
                  constructor.
                  reflexivity.
                }

                forward HK; auto.
                pclearbot.

                repeat rewrite <- itree_eta.
                apply HK.
              }

              specialize (REL tt tt).
              forward REL; auto.
              pclearbot.

              repeat rewrite <- itree_eta.
              exact REL.
            }
            }
          }

          { (* Pick *)
            destruct p0.
            cbn in EV_REL.
            destruct p.
            cbn in *.
            destruct EV_REL as [EV_PRE UV_REF].
            unfold FinMemInterp.F_trigger in HANDLER.
            setoid_rewrite bind_trigger in HANDLER.
            cbn in HANDLER.
            rewrite HANDLER in VIS_HANDLED.
            rewrite bind_vis in VIS_HANDLED.
            destruct VIS_HANDLED as [VIS_HANDLED | VIS_HANDLED].
            { exfalso.
              clear - VIS_HANDLED.
              dependent induction VIS_HANDLED.
              - pinversion H; subst; inv CHECK.
              - pinversion H; do 2 subst_existT; subst.
                specialize (REL x0).
                exfalso.
                rewrite <- REL in VIS_HANDLED.
                eapply ret_not_contains_UB_Extra in VIS_HANDLED; eauto.
                cbn; reflexivity.
              - pinversion H; do 2 subst_existT; subst.
                specialize (REL x0).
                exfalso.
                rewrite <- REL in VIS_HANDLED.
                eapply ret_not_contains_UB_Extra in VIS_HANDLED; eauto.
                cbn; reflexivity.
              - pinversion H; do 2 subst_existT; subst.
                inversion H5.
            }

            pstep; red; cbn.
            punfold VIS_HANDLED; red in VIS_HANDLED; cbn in VIS_HANDLED.
            genobs t2 ot2.
            clear t2 Heqot2.
            dependent induction VIS_HANDLED.
            2: {
              cbn.
              constructor; eauto.
            }

            cbn.
            rename Pre0 into Pre_inf.
            rename Pre into Pre_fin.
            subst.

            cbn.
            match goal with
            | |- 
                interp_memory_PropTF _ _ _ _ _ _ _
                  (VisF ?e ?k) =>
                change (VisF e k) with (observe (Vis e k))
            end.

            eapply Interp_Memory_PropT_Vis with
              (k2:=(fun '(ms_inf, (sid', dv_inf)) =>
                      match DVCInfFin.dvalue_convert_strict (proj1_sig dv_inf) with
                      | NoOom dv_fin => get_inf_tree (k3 (s2, (s1, exist _ dv_fin I)))
                      | Oom s => raiseOOM s
                      end)
              )
              (s1:=s1)
              (s2:=lift_MemState s2).

            2: {
              cbn.
              red.
              cbn.
              rewrite bind_trigger.
              reflexivity.
            }

            2: {
              rewrite resum_to_subevent.
              repeat setoid_rewrite subevent_subevent.
              right.
              cbn.
              rewrite bind_vis.
              setoid_rewrite bind_ret_l.
              cbn.
              replace Pre_fin with Pre_inf.
              2: {
                apply bogus; eauto.
              }
              erewrite <- fin_to_inf_uvalue_refine_strict'; eauto.
              pstep. red.
              cbn.
              constructor.
              intros v.
              red.
              left.
              destruct v.
              cbn.
              break_match_goal.
              2: {
                (* OOM *)
                rewrite get_inf_tree_equation.
                cbn.
                unfold raiseOOM, print_msg.
                eapply paco2_eqit_RR_refl.
                typeclasses eauto.
              }

              destruct t.
              specialize (REL (exist (fun _ : dvalue => True) d I)).
              red in REL. pclearbot.
              rewrite REL.
              rewrite bind_ret_l.
              eapply paco2_eqit_RR_refl; typeclasses eauto.
            }

            intros a b H H0 H2.
            destruct a.
            destruct b as (?&?&?&?).
            destruct t, t0.

            cbn.
            break_match_goal.
            2: {
              left.
              pstep; red; cbn.
              observe_vis.
              eapply Interp_Memory_PropT_Vis_OOM.
              reflexivity.
            }

            right.
            rewrite (itree_eta_ (k0 _)).
            rewrite (itree_eta_ (k3 _)).
            eapply CIH.
            2: {
              repeat red.
              repeat rewrite <- itree_eta.
              specialize (HK (exist _ d I)
                            (s2, (s1, exist _ d I))).
              forward HK; cbn; auto.
              { eapply ReturnsVis.
                unfold ITree.trigger.
                cbn.
                reflexivity.
                cbn.
                constructor; reflexivity.
              }
              forward HK.
              { rewrite HANDLER.
                eapply ReturnsVis.
                reflexivity.
                constructor; reflexivity.
              }

              forward HK; cbn; auto.
              pclearbot.
              apply HK.
            }

            repeat rewrite <- itree_eta.
            specialize (REL0 (exist (fun _ : InterpreterStackBigIntptr.LP.Events.DV.dvalue => True) x1 I)
                          (exist (fun _ : DVCInfFin.DV2.dvalue => True) d I)).
            cbn in REL0.
            forward REL0.
            split; eauto.
            split; eauto.
            cbn in H2; inv H2; auto.
            pclearbot.
            auto.
          }

          { (* OOM *)
            exfalso.
            eapply H1.
            reflexivity.
          }

          { (* UBE *)
            subst.
            destruct u, u0.
            red in HANDLER.
            cbn in HANDLER.
            rewrite bind_trigger in HANDLER.
            rewrite HANDLER in VIS_HANDLED.
            rewrite bind_vis in VIS_HANDLED.

            pstep; red; cbn.
            eapply Interp_Memory_PropT_Vis with
              (k2:=(fun '(ms_inf, (sid', dv_inf)) =>
                      get_inf_tree (k3 (s2, (s1, _)))))
              (s1:=s1)
              (s2:=lift_MemState s2).

            2: {
              cbn. red.
              cbn.
              rewrite bind_trigger.
              reflexivity.
            }

            2: {
              left.
              eapply FindUB.
              pstep.
              red.
              cbn.
              rewrite subevent_subevent.
              constructor.
              intros [].
            }

            intros [].
          }

          { (* DebugE *)
            red in HANDLER.
            destruct d, d0.
            subst.
            destruct u0.
            cbn in HANDLER.
            rewrite bind_trigger in HANDLER.
            rewrite HANDLER in VIS_HANDLED.
            destruct VIS_HANDLED as [VIS_HANDLED | VIS_HANDLED].
            { cbn in VIS_HANDLED.
              exfalso.
              clear - VIS_HANDLED.
              dependent induction VIS_HANDLED.
              - pinversion H; subst; inv CHECK.
              - pinversion H; do 2 subst_existT; subst.
                specialize (REL x).
                exfalso.
                rewrite <- REL in VIS_HANDLED.
                eapply ret_not_contains_UB_Extra in VIS_HANDLED; eauto.
                cbn; reflexivity.
              - pinversion H; do 2 subst_existT; subst.
                specialize (REL x).
                exfalso.
                rewrite <- REL in VIS_HANDLED.
                eapply ret_not_contains_UB_Extra in VIS_HANDLED; eauto.
                cbn; reflexivity.
              - pinversion H; do 2 subst_existT; subst.
                inversion H5.
            }
            rewrite bind_vis in VIS_HANDLED.

            pstep; red; cbn.

            change
              (VisF (subevent unit (Debug tt))
                 (fun H13 : unit => get_inf_tree (ITree.bind (SemNotations.Ret2 s1 s2 H13) k3)))
              with
              (observe
                 (Vis (subevent unit (Debug tt))
                    (fun H13 : unit => get_inf_tree (ITree.bind (SemNotations.Ret2 s1 s2 H13) k3)))).

            eapply Interp_Memory_PropT_Vis with
              (k2:=(fun '(ms_inf, (sid', dv_inf)) =>
                      get_inf_tree (k3 (s2, (s1, tt)))))
              (s1:=s1)
              (s2:=lift_MemState s2).

            2: {
              cbn.
              red.
              cbn.
              rewrite bind_trigger.
              reflexivity.
            }

            2: {
              right.
              cbn.
              rewrite <- itree_eta.
              rewrite VIS_HANDLED.
              rewrite bind_vis.
              setoid_rewrite bind_ret_l.
              pstep; red; cbn.
              constructor.
              intros [].
              red.
              left.
              eapply paco2_eqit_RR_refl; typeclasses eauto.
            }

            intros a b RETa RETb AB.
            apply Returns_vis_inversion in RETb as [[] RETb].
            destruct b as [ms' [sid' []]].
            cbn in AB; subst.

            apply Returns_ret_inv in RETb.
            inv RETb.
            cbn.

            specialize (REL tt tt eq_refl).
            pclearbot.

            specialize (HK tt (s2, (s1, tt))).
            forward HK.
            { eapply ReturnsVis.
              unfold trigger.
              reflexivity.
              cbn.
              constructor.
              reflexivity.
            }
            forward HK.
            { rewrite HANDLER.
              eapply ReturnsVis.
              reflexivity.
              constructor.
              reflexivity.
            }
            specialize (HK eq_refl).
            pclearbot.

            right.

            rewrite (itree_eta_ (k1 tt)).
            rewrite (itree_eta_ (k3 (s2, (s1, tt)))).

            eapply CIH.
            2: {
              repeat red.
              repeat rewrite <- itree_eta.
              apply HK.
            }

            repeat rewrite <- itree_eta.
            exact REL.
          }

          { (* FailureE *)
            red in HANDLER.
            destruct f, f0.
            cbn in HANDLER.
            rewrite bind_trigger in HANDLER.
            rewrite HANDLER in VIS_HANDLED.
            destruct VIS_HANDLED as [VIS_HANDLED | VIS_HANDLED].
            { cbn in VIS_HANDLED.
              exfalso.
              clear - VIS_HANDLED.
              dependent induction VIS_HANDLED.
              - pinversion H; subst; inv CHECK.
              - pinversion H; do 2 subst_existT; subst.
                specialize (REL x).
                exfalso.
                rewrite <- REL in VIS_HANDLED.
                eapply ret_not_contains_UB_Extra in VIS_HANDLED; eauto.
                cbn; reflexivity.
              - pinversion H; do 2 subst_existT; subst.
                specialize (REL x).
                exfalso.
                rewrite <- REL in VIS_HANDLED.
                eapply ret_not_contains_UB_Extra in VIS_HANDLED; eauto.
                cbn; reflexivity.
              - pinversion H; do 2 subst_existT; subst.
                inversion H4.
            }
            rewrite bind_vis in VIS_HANDLED.

            eapply paco2_mon_bot; eauto.
            eapply interp_memory_prop_eutt_S1S2_Proper with (RS2:=MemoryBigIntptr.MMEP.MemSpec.MemState_eqv) (RS1:=eq); eauto; try typeclasses eauto.
            { intros r1 r2 r3 H H0.
              destruct r2, p.
              destruct r3, p0.
              inv H0.
              inv snd_rel.
              cbn in *; subst.
              auto.
            }
            3: {
              rewrite prod_rel_eq.
              rewrite <- itree_eta.
              setoid_rewrite VIS_HANDLED.
              rewrite get_inf_tree_equation.
              cbn.
              reflexivity.
            }
            2: {
              reflexivity.
            }
            2: {
              pstep; red; cbn.
              match goal with
              | |- interp_memory_PropTF _ _ _ _ _ _ _ (VisF ?e ?k) =>
                  change (VisF e k) with (observe (Vis e k))
              end.
              eapply Interp_Memory_PropT_Vis.

              intros [].
              cbn; red; cbn.
              reflexivity.

              red; cbn; right.
              rewrite bind_trigger.
              rewrite bind_vis.
              destruct u.
              unfold print_msg.
              pstep; red; cbn.
              constructor.
              intros [].
            }

            apply ret.
            repeat constructor.
          }
      - (* oruttF's EqVisOOM *)
        destruct e.
        repeat red in RUN.
        punfold RUN; red in RUN; cbn in RUN.

        clear CIH MSR.
        dependent induction RUN.
        + (* TauR *)
          pstep; red; cbn.
          constructor; auto.

          specialize (IHRUN (observe t2) u k2).
          repeat (forward IHRUN; auto).

          punfold IHRUN.
        + (* VisOOM *)
          eapply paco2_mon_bot; eauto.
          rewrite HT1.
          cbn.
          rewrite get_inf_tree_equation.
          destruct e.
          cbn.
          pstep; red; cbn.
          observe_vis.
          eapply Interp_Memory_PropT_Vis_OOM.
          reflexivity.
        + (* Vis *)
          cbn in HSPEC.
          red in HSPEC.
          cbn in HSPEC.
          rewrite bind_trigger in HSPEC.
          red in KS.
          rewrite HSPEC in KS.
          destruct KS as [KS | KS].
          { cbn in KS.
            exfalso.
            clear - KS.
            dependent induction KS.
            - pinversion H; subst; inv CHECK.
            - pinversion H; do 2 subst_existT; subst.
              specialize (REL x).
              exfalso.
              rewrite <- REL in KS.
              eapply ret_not_contains_UB_Extra in KS; eauto.
              cbn; reflexivity.
            - pinversion H; do 2 subst_existT; subst.
              specialize (REL x).
              exfalso.
              rewrite <- REL in KS.
              eapply ret_not_contains_UB_Extra in KS; eauto.
              cbn; reflexivity.
            - pinversion H; do 2 subst_existT; subst.
              inversion H4.
          }

          eapply paco2_mon_bot; eauto.
          eapply interp_memory_prop_eutt_S1S2_Proper with (RS2:=MemoryBigIntptr.MMEP.MemSpec.MemState_eqv) (RS1:=eq); eauto; try typeclasses eauto.
          { intros r1 r2 r3 H H0.
            destruct r2, p.
            destruct r3, p0.
            inv H0.
            inv snd_rel.
            cbn in *; subst.
            auto.
          }
          3: {
            rewrite prod_rel_eq.
            rewrite <- itree_eta.
            setoid_rewrite KS.
            rewrite get_inf_tree_equation.
            cbn.
            reflexivity.
          }
          2: {
            reflexivity.
          }
          2: {
            pstep; red; cbn.
            change ((VisF (subevent void (ThrowOOM (print_msg "")))
                       (fun x : void =>
                          ITree.subst
                            (fun v : void => match v return (itree InfLP.Events.L3 TopLevelBigIntptr.res_L6) with
                                          end) (Ret x)))) with (observe (Vis (subevent void (ThrowOOM (print_msg "")))
                                                                           (fun x : void =>
                                                                              ITree.subst
                                                                                (fun v : void => match v return (itree InfLP.Events.L3 TopLevelBigIntptr.res_L6) with
                                                                                              end) (Ret x)))).
            eapply Interp_Memory_PropT_Vis_OOM.
            reflexivity.
          }

          apply ret; repeat constructor.
      - (* oruttF's EqTauL *)
        forward IHREL; [exact RUN|].
        forward IHREL; auto.
        pfold. red. constructor; auto.
        punfold IHREL.
      - (* oruttF's Equator *)
        forward IHREL.
        { repeat red.
          repeat red in RUN.
          cbn in *.
          rewrite tau_eutt in RUN.
          rewrite <- itree_eta.
          exact RUN.
        }

        forward IHREL; auto.
    }

    apply get_inf_tree_orutt.

    Unshelve.
    all: try solve
           [ intros []
           | exact 0%N
           | exact Memory64BitIntptr.MMEP.MMSP.initial_memory_state
           | exact MemoryBigIntptr.MMEP.MMSP.initial_memory_state
           | eauto
           | intros;
             apply get_inf_tree;
             first [eapply k2 | eapply k3];
             destruct X as (msX&sidX&dvX);
             constructor; [|constructor];
             [ exact Memory64BitIntptr.MMEP.MMSP.initial_memory_state
             | exact sidX
             | first [ exact LLVMParams64BitIntptr.Events.DV.DVALUE_None
                     | exact LLVMParams64BitIntptr.Events.DV.UVALUE_None
                     | auto]]
           ].
  Qed.

  Print Assumptions model_E1E2_23_orutt_strict.
  (* Extra stuff from the proof of the above lemma that needs to get cleaned up... But there's some other stuff in here that I need to not accidentally delete *)

  (* TODO: Move this *)
  Lemma MemState_refine_prop_initial :
    MemState_refine_prop InfMemMMSP.initial_memory_state FinMemMMSP.initial_memory_state.
  Proof.
    red. red.
    split; [| split; [| split; [| split; [| split; [| split]]]]].
    - red.
      intros p.
      split; intros USED;
        red; red in USED; cbn in *;
        auto.
    - red.
      split.
      + (* Read byte allowed *)
        red.
        intros ptr.
        split; intros ALLOWED.
  Admitted.

  Lemma model_E1E2_L3_orutt_strict_sound
    (p : list
           (LLVMAst.toplevel_entity
              LLVMAst.typ
              (LLVMAst.block LLVMAst.typ * list (LLVMAst.block LLVMAst.typ)))) :
    model_E1E2_L3_orutt_strict p p.
  Proof.
    eapply model_E1E2_23_orutt_strict;
      [ apply model_E1E2_L2_orutt_strict_sound
      | apply MemState_refine_prop_initial
      ].
  Qed.

  Definition L4_E1E2_orutt_strict
    (t1 : PropT InfLP.Events.L4 (InfMemMMSP.MemState *
                                   (MemPropT.store_id * (InfLLVM.Local.local_env * InfLLVM.Stack.lstack * (InfLLVM.Global.global_env * InfLP.Events.DV.dvalue)))))
    (t2 : PropT FinLP.Events.L4 (FinMemMMSP.MemState *
                                   (MemPropT.store_id * (FinLLVM.Local.local_env * FinLLVM.Stack.lstack * (FinLLVM.Global.global_env * FinLP.Events.DV.dvalue)))))
    : Prop :=
    forall t', t2 t' ->
               exists t, t1 t /\
                           orutt
                             L4_refine_strict
                             L4_res_refine_strict
                             (MemState_refine_prop Ã— (eq Ã— (local_refine_strict Ã— stack_refine_strict Ã— (global_refine_strict Ã— DVC1.dvalue_refine_strict))))
                             t t' (OOM:=OOME).

  Definition model_E1E2_L4_orutt_strict p1 p2 :=
    L4_E1E2_orutt_strict
      (TopLevelBigIntptr.model_oom_L4 TLR_INF.R.refine_res2 TLR_INF.R.refine_res3 p1)
      (TopLevel64BitIntptr.model_oom_L4 TLR_FIN.R.refine_res2 TLR_FIN.R.refine_res3 p2).

  Definition get_inf_tree_L4' :
    forall (t_fin2 : itree L4 (FinMem.MMEP.MMSP.MemState * (MemPropT.store_id * (local_env * @stack local_env * res_L1)))), itree InfLP.Events.L4 TopLevelBigIntptr.res_L4.
  Proof.
    cofix CIH.
    intros t_fin2.
    destruct t_fin2.
    destruct _observe.
    - (* Ret *)
      refine (ret _).
      destruct r as [ms [sid [[lenv s] [genv res]]]].
      constructor.
      exact (lift_MemState ms).

      constructor.
      exact sid.

      constructor.
      constructor.
      exact (lift_local_env lenv).
      exact (lift_stack s).

      constructor.
      exact (lift_global_env genv).
      exact (fin_to_inf_dvalue res).
    - (*Tau *)
      apply go.
      apply TauF.
      apply CIH.
      apply t.
    - (* Vis *)
      inversion e; clear e; subst.
      { (* ExternalCallE *)
        inversion H; subst.
        apply go.
        apply (VisF (subevent _ (E1.ExternalCall t (fin_to_inf_uvalue f) (map fin_to_inf_dvalue args)))).

        (* Continuation *)
        intros x.
        apply CIH.

        pose proof (DVCInfFin.dvalue_convert_strict x).
        destruct H0.
        - exact (k d).
        - (* OOM -- somewhat worried about this case *)
          exact (raiseOOM s).
      }

      inversion H; clear H; subst.
      { (* OOM *)
        inversion H0; subst.
        exact (raiseOOM "").
      }

      inversion H0; clear H0; subst.
      { (* UBE *)
        inversion H; subst.
        exact (raiseUB "").
      }

      inversion H; clear H; subst.
      { (* DebugE *)
        inversion H0; subst.
        apply go.
        apply (VisF (subevent _ (Debug H))).
        intros H1.
        apply CIH.
        apply k; auto.
      }

      { (* FailureE *)
        inversion H0; subst.
        exact (LLVMEvents.raise "").
      }

      Show Proof.
  Defined.

  Set Printing All.
  Set Printing Implicit.
  Set Printing Depth 1000.
  Print get_inf_tree_L4'.


  Unset Printing All.
  Unset Printing Implicit.
  Definition get_inf_tree_L4 :
    forall (t_fin2 : itree L4 (FinMem.MMEP.MMSP.MemState * (MemPropT.store_id * (local_env * @stack local_env * res_L1)))), itree InfLP.Events.L4 TopLevelBigIntptr.res_L4 :=
cofix CIH
  (t_fin2 : itree L4
              (prod FinMem.MMEP.MMSP.MemState
                 (prod MemPropT.store_id
                    (prod (prod local_env (@stack local_env)) (prod global_env dvalue))))) :
    itree InfLP.Events.L4
      (prod InterpreterStackBigIntptr.LLVM.MEM.MMEP.MMSP.MemState
         (prod MemPropT.store_id
            (prod
               (prod InterpreterStackBigIntptr.LLVM.Local.local_env
                  InterpreterStackBigIntptr.LLVM.Stack.lstack)
               (prod InterpreterStackBigIntptr.LLVM.Global.global_env
                  InterpreterStackBigIntptr.LP.Events.DV.dvalue)))) :=
  (fun
     _observe : itreeF L4
                  (prod FinMem.MMEP.MMSP.MemState
                     (prod MemPropT.store_id
                        (prod (prod local_env (@stack local_env)) (prod global_env dvalue))))
                  (itree L4
                     (prod FinMem.MMEP.MMSP.MemState
                        (prod MemPropT.store_id
                           (prod (prod local_env (@stack local_env)) (prod global_env dvalue))))) =>
   match
     _observe
     return
       (itree InfLP.Events.L4
          (prod InterpreterStackBigIntptr.LLVM.MEM.MMEP.MMSP.MemState
             (prod MemPropT.store_id
                (prod
                   (prod InterpreterStackBigIntptr.LLVM.Local.local_env
                      InterpreterStackBigIntptr.LLVM.Stack.lstack)
                   (prod InterpreterStackBigIntptr.LLVM.Global.global_env
                      InterpreterStackBigIntptr.LP.Events.DV.dvalue)))))
   with
   | RetF r =>
       (fun
          r0 : prod FinMem.MMEP.MMSP.MemState
                 (prod MemPropT.store_id
                    (prod (prod local_env (@stack local_env)) (prod global_env dvalue))) =>
        @ret (itree InfLP.Events.L4) (@Monad_itree InfLP.Events.L4)
          (prod InterpreterStackBigIntptr.LLVM.MEM.MMEP.MMSP.MemState
             (prod MemPropT.store_id
                (prod
                   (prod InterpreterStackBigIntptr.LLVM.Local.local_env
                      InterpreterStackBigIntptr.LLVM.Stack.lstack)
                   (prod InterpreterStackBigIntptr.LLVM.Global.global_env
                      InterpreterStackBigIntptr.LP.Events.DV.dvalue))))
          match
            r0
            return
              (prod InterpreterStackBigIntptr.LLVM.MEM.MMEP.MMSP.MemState
                 (prod MemPropT.store_id
                    (prod
                       (prod InterpreterStackBigIntptr.LLVM.Local.local_env
                          InterpreterStackBigIntptr.LLVM.Stack.lstack)
                       (prod InterpreterStackBigIntptr.LLVM.Global.global_env
                          InterpreterStackBigIntptr.LP.Events.DV.dvalue))))
          with
          | pair a b =>
              (fun (ms : FinMem.MMEP.MMSP.MemState)
                 (p : prod MemPropT.store_id
                        (prod (prod local_env (@stack local_env)) (prod global_env dvalue))) =>
               match
                 p
                 return
                   (prod InterpreterStackBigIntptr.LLVM.MEM.MMEP.MMSP.MemState
                      (prod MemPropT.store_id
                         (prod
                            (prod InterpreterStackBigIntptr.LLVM.Local.local_env
                               InterpreterStackBigIntptr.LLVM.Stack.lstack)
                            (prod InterpreterStackBigIntptr.LLVM.Global.global_env
                               InterpreterStackBigIntptr.LP.Events.DV.dvalue))))
               with
               | pair a0 b0 =>
                   (fun (sid : MemPropT.store_id)
                      (p0 : prod (prod local_env (@stack local_env)) (prod global_env dvalue)) =>
                    match
                      p0
                      return
                        (prod InterpreterStackBigIntptr.LLVM.MEM.MMEP.MMSP.MemState
                           (prod MemPropT.store_id
                              (prod
                                 (prod InterpreterStackBigIntptr.LLVM.Local.local_env
                                    InterpreterStackBigIntptr.LLVM.Stack.lstack)
                                 (prod InterpreterStackBigIntptr.LLVM.Global.global_env
                                    InterpreterStackBigIntptr.LP.Events.DV.dvalue))))
                    with
                    | pair a1 b1 =>
                        (fun p1 : prod local_env (@stack local_env) =>
                         match
                           p1
                           return
                             (forall _ : prod global_env dvalue,
                              prod InterpreterStackBigIntptr.LLVM.MEM.MMEP.MMSP.MemState
                                (prod MemPropT.store_id
                                   (prod
                                      (prod InterpreterStackBigIntptr.LLVM.Local.local_env
                                         InterpreterStackBigIntptr.LLVM.Stack.lstack)
                                      (prod InterpreterStackBigIntptr.LLVM.Global.global_env
                                         InterpreterStackBigIntptr.LP.Events.DV.dvalue))))
                         with
                         | pair a2 b2 =>
                             (fun (lenv : local_env) (s : @stack local_env)
                                (p2 : prod global_env dvalue) =>
                              match
                                p2
                                return
                                  (prod InterpreterStackBigIntptr.LLVM.MEM.MMEP.MMSP.MemState
                                     (prod MemPropT.store_id
                                        (prod
                                           (prod InterpreterStackBigIntptr.LLVM.Local.local_env
                                              InterpreterStackBigIntptr.LLVM.Stack.lstack)
                                           (prod InterpreterStackBigIntptr.LLVM.Global.global_env
                                              InterpreterStackBigIntptr.LP.Events.DV.dvalue))))
                              with
                              | pair a3 b3 =>
                                  (fun (genv : global_env) (res : dvalue) =>
                                   @pair InterpreterStackBigIntptr.LLVM.MEM.MMEP.MMSP.MemState
                                     (prod MemPropT.store_id
                                        (prod
                                           (prod InterpreterStackBigIntptr.LLVM.Local.local_env
                                              InterpreterStackBigIntptr.LLVM.Stack.lstack)
                                           (prod InterpreterStackBigIntptr.LLVM.Global.global_env
                                              InterpreterStackBigIntptr.LP.Events.DV.dvalue)))
                                     (lift_MemState ms)
                                     (@pair MemPropT.store_id
                                        (prod
                                           (prod InterpreterStackBigIntptr.LLVM.Local.local_env
                                              InterpreterStackBigIntptr.LLVM.Stack.lstack)
                                           (prod InterpreterStackBigIntptr.LLVM.Global.global_env
                                              InterpreterStackBigIntptr.LP.Events.DV.dvalue)) sid
                                        (@pair
                                           (prod InterpreterStackBigIntptr.LLVM.Local.local_env
                                              InterpreterStackBigIntptr.LLVM.Stack.lstack)
                                           (prod InterpreterStackBigIntptr.LLVM.Global.global_env
                                              InterpreterStackBigIntptr.LP.Events.DV.dvalue)
                                           (@pair InterpreterStackBigIntptr.LLVM.Local.local_env
                                              InterpreterStackBigIntptr.LLVM.Stack.lstack
                                              (lift_local_env lenv) (lift_stack s))
                                           (@pair InterpreterStackBigIntptr.LLVM.Global.global_env
                                              InterpreterStackBigIntptr.LP.Events.DV.dvalue
                                              (lift_global_env genv) (fin_to_inf_dvalue res))))) a3 b3
                              end) a2 b2
                         end) a1 b1
                    end) a0 b0
               end) a b
          end) r
   | TauF t =>
       (fun
          t0 : itree L4
                 (prod FinMem.MMEP.MMSP.MemState
                    (prod MemPropT.store_id
                       (prod (prod local_env (@stack local_env)) (prod global_env dvalue)))) =>
        @go InfLP.Events.L4
          (prod InterpreterStackBigIntptr.LLVM.MEM.MMEP.MMSP.MemState
             (prod MemPropT.store_id
                (prod
                   (prod InterpreterStackBigIntptr.LLVM.Local.local_env
                      InterpreterStackBigIntptr.LLVM.Stack.lstack)
                   (prod InterpreterStackBigIntptr.LLVM.Global.global_env
                      InterpreterStackBigIntptr.LP.Events.DV.dvalue))))
          (@TauF InfLP.Events.L4
             (prod InterpreterStackBigIntptr.LLVM.MEM.MMEP.MMSP.MemState
                (prod MemPropT.store_id
                   (prod
                      (prod InterpreterStackBigIntptr.LLVM.Local.local_env
                         InterpreterStackBigIntptr.LLVM.Stack.lstack)
                      (prod InterpreterStackBigIntptr.LLVM.Global.global_env
                         InterpreterStackBigIntptr.LP.Events.DV.dvalue))))
             (itree InfLP.Events.L4
                (prod InterpreterStackBigIntptr.LLVM.MEM.MMEP.MMSP.MemState
                   (prod MemPropT.store_id
                      (prod
                         (prod InterpreterStackBigIntptr.LLVM.Local.local_env
                            InterpreterStackBigIntptr.LLVM.Stack.lstack)
                         (prod InterpreterStackBigIntptr.LLVM.Global.global_env
                            InterpreterStackBigIntptr.LP.Events.DV.dvalue)))))
             (CIH t0))) t
   | @VisF _ _ _ X e k =>
       (fun (X0 : Type) (e0 : L4 X0)
          (k0 : forall _ : X0,
                itree L4
                  (prod FinMem.MMEP.MMSP.MemState
                     (prod MemPropT.store_id
                        (prod (prod local_env (@stack local_env)) (prod global_env dvalue))))) =>
        let X1 :
          itree InfLP.Events.L4
            (prod InterpreterStackBigIntptr.LLVM.MEM.MMEP.MMSP.MemState
               (prod MemPropT.store_id
                  (prod
                     (prod InterpreterStackBigIntptr.LLVM.Local.local_env
                        InterpreterStackBigIntptr.LLVM.Stack.lstack)
                     (prod InterpreterStackBigIntptr.LLVM.Global.global_env
                        InterpreterStackBigIntptr.LP.Events.DV.dvalue)))) :=
          match
            e0
            return
              (itree InfLP.Events.L4
                 (prod InterpreterStackBigIntptr.LLVM.MEM.MMEP.MMSP.MemState
                    (prod MemPropT.store_id
                       (prod
                          (prod InterpreterStackBigIntptr.LLVM.Local.local_env
                             InterpreterStackBigIntptr.LLVM.Stack.lstack)
                          (prod InterpreterStackBigIntptr.LLVM.Global.global_env
                             InterpreterStackBigIntptr.LP.Events.DV.dvalue)))))
          with
          | inl1 x =>
              (fun H : ExternalCallE X0 =>
               (fun H0 : ExternalCallE X0 =>
                let X1 :
                  forall _ : @eq Type X0 X0,
                  itree InfLP.Events.L4
                    (prod InterpreterStackBigIntptr.LLVM.MEM.MMEP.MMSP.MemState
                       (prod MemPropT.store_id
                          (prod
                             (prod InterpreterStackBigIntptr.LLVM.Local.local_env
                                InterpreterStackBigIntptr.LLVM.Stack.lstack)
                             (prod InterpreterStackBigIntptr.LLVM.Global.global_env
                                InterpreterStackBigIntptr.LP.Events.DV.dvalue)))) :=
                  match
                    H0 in (ExternalCallE T)
                    return
                      (forall _ : @eq Type T X0,
                       itree InfLP.Events.L4
                         (prod InterpreterStackBigIntptr.LLVM.MEM.MMEP.MMSP.MemState
                            (prod MemPropT.store_id
                               (prod
                                  (prod InterpreterStackBigIntptr.LLVM.Local.local_env
                                     InterpreterStackBigIntptr.LLVM.Stack.lstack)
                                  (prod InterpreterStackBigIntptr.LLVM.Global.global_env
                                     InterpreterStackBigIntptr.LP.Events.DV.dvalue)))))
                  with
                  | ExternalCall t f args =>
                      (fun (t0 : dtyp) (f0 : uvalue) (args0 : list dvalue) (H1 : @eq Type dvalue X0)
                       =>
                       (fun H2 : @eq Type dvalue X0 =>
                        let H3 : @eq Type dvalue X0 := H2 in
                        @eq_rect Type dvalue
                          (fun _ : Type =>
                           forall (_ : dtyp) (_ : uvalue) (_ : list dvalue),
                           itree InfLP.Events.L4
                             (prod InterpreterStackBigIntptr.LLVM.MEM.MMEP.MMSP.MemState
                                (prod MemPropT.store_id
                                   (prod
                                      (prod InterpreterStackBigIntptr.LLVM.Local.local_env
                                         InterpreterStackBigIntptr.LLVM.Stack.lstack)
                                      (prod InterpreterStackBigIntptr.LLVM.Global.global_env
                                         InterpreterStackBigIntptr.LP.Events.DV.dvalue)))))
                          (fun (t1 : dtyp) (f1 : uvalue) (args1 : list dvalue) =>
                           @eq_rect Type dvalue
                             (fun X1 : Type =>
                              forall
                                (_ : forall _ : X1,
                                     itree L4
                                       (prod FinMem.MMEP.MMSP.MemState
                                          (prod MemPropT.store_id
                                             (prod (prod local_env (@stack local_env))
                                                (prod global_env dvalue)))))
                                (_ : ExternalCallE X1),
                              itree InfLP.Events.L4
                                (prod InterpreterStackBigIntptr.LLVM.MEM.MMEP.MMSP.MemState
                                   (prod MemPropT.store_id
                                      (prod
                                         (prod InterpreterStackBigIntptr.LLVM.Local.local_env
                                            InterpreterStackBigIntptr.LLVM.Stack.lstack)
                                         (prod InterpreterStackBigIntptr.LLVM.Global.global_env
                                            InterpreterStackBigIntptr.LP.Events.DV.dvalue)))))
                             (fun
                                (k1 : forall _ : dvalue,
                                      itree L4
                                        (prod FinMem.MMEP.MMSP.MemState
                                           (prod MemPropT.store_id
                                              (prod (prod local_env (@stack local_env))
                                                 (prod global_env dvalue)))))
                                (_ : ExternalCallE dvalue) =>
                              @go InfLP.Events.L4
                                (prod InterpreterStackBigIntptr.LLVM.MEM.MMEP.MMSP.MemState
                                   (prod MemPropT.store_id
                                      (prod
                                         (prod InterpreterStackBigIntptr.LLVM.Local.local_env
                                            InterpreterStackBigIntptr.LLVM.Stack.lstack)
                                         (prod InterpreterStackBigIntptr.LLVM.Global.global_env
                                            InterpreterStackBigIntptr.LP.Events.DV.dvalue))))
                                (@VisF InfLP.Events.L4
                                   (prod InterpreterStackBigIntptr.LLVM.MEM.MMEP.MMSP.MemState
                                      (prod MemPropT.store_id
                                         (prod
                                            (prod InterpreterStackBigIntptr.LLVM.Local.local_env
                                               InterpreterStackBigIntptr.LLVM.Stack.lstack)
                                            (prod InterpreterStackBigIntptr.LLVM.Global.global_env
                                               InterpreterStackBigIntptr.LP.Events.DV.dvalue))))
                                   (itree InfLP.Events.L4
                                      (prod InterpreterStackBigIntptr.LLVM.MEM.MMEP.MMSP.MemState
                                         (prod MemPropT.store_id
                                            (prod
                                               (prod InterpreterStackBigIntptr.LLVM.Local.local_env
                                                  InterpreterStackBigIntptr.LLVM.Stack.lstack)
                                               (prod InterpreterStackBigIntptr.LLVM.Global.global_env
                                                  InterpreterStackBigIntptr.LP.Events.DV.dvalue)))))
                                   E1.DV.dvalue
                                   (@subevent E1.ExternalCallE InfLP.Events.L4
                                      (@ReSum_inl (forall _ : Type, Type) IFun sum1 Cat_IFun Inl_sum1
                                         E1.ExternalCallE InfLP.Events.ExternalCallE
                                         (sum1 OOME (sum1 UBE (sum1 DebugE FailureE)))
                                         (@ReSum_id (forall _ : Type, Type) IFun Id_IFun
                                            InfLP.Events.ExternalCallE)) E1.DV.dvalue
                                      (E1.ExternalCall t1 (fin_to_inf_uvalue f1)
                                         (@map LLVMParams64BitIntptr.Events.DV.dvalue
                                            LLVMParamsBigIntptr.Events.DV.dvalue fin_to_inf_dvalue
                                            args1)))
                                   (fun x0 : E1.DV.dvalue =>
                                    CIH
                                      (let H5 : OOM DVCInfFin.DV2.dvalue :=
                                         DVCInfFin.dvalue_convert_strict x0 in
                                       match
                                         H5
                                         return
                                           (itree L4
                                              (prod FinMem.MMEP.MMSP.MemState
                                                 (prod MemPropT.store_id
                                                    (prod (prod local_env (@stack local_env))
                                                       (prod global_env dvalue)))))
                                       with
                                       | NoOom a => (fun d : DVCInfFin.DV2.dvalue => k1 d) a
                                       | Oom s =>
                                           (fun s0 : string =>
                                            @raiseOOM L4
                                              (@ReSum_inr (forall _ : Type, Type) IFun sum1 Cat_IFun
                                                 Inr_sum1 OOME
                                                 (sum1 OOME (sum1 UBE (sum1 DebugE FailureE)))
                                                 ExternalCallE
                                                 (@ReSum_inl (forall _ : Type, Type) IFun sum1
                                                    Cat_IFun Inl_sum1 OOME OOME
                                                    (sum1 UBE (sum1 DebugE FailureE))
                                                    (@ReSum_id (forall _ : Type, Type) IFun Id_IFun
                                                       OOME)))
                                              (prod FinMem.MMEP.MMSP.MemState
                                                 (prod MemPropT.store_id
                                                    (prod (prod local_env (@stack local_env))
                                                       (prod global_env dvalue)))) s0) s
                                       end)))) X0 H2 k0 H0) X0 H3) H1 t0 f0 args0) t f args
                  end in
                X1 (@eq_refl Type X0)) H) x
          | inr1 x =>
              (fun H : sum1 OOME (sum1 UBE (sum1 DebugE FailureE)) X0 =>
               (fun H0 : sum1 OOME (sum1 UBE (sum1 DebugE FailureE)) X0 =>
                let X1 :
                  itree InfLP.Events.L4
                    (prod InterpreterStackBigIntptr.LLVM.MEM.MMEP.MMSP.MemState
                       (prod MemPropT.store_id
                          (prod
                             (prod InterpreterStackBigIntptr.LLVM.Local.local_env
                                InterpreterStackBigIntptr.LLVM.Stack.lstack)
                             (prod InterpreterStackBigIntptr.LLVM.Global.global_env
                                InterpreterStackBigIntptr.LP.Events.DV.dvalue)))) :=
                  match
                    H0
                    return
                      (itree InfLP.Events.L4
                         (prod InterpreterStackBigIntptr.LLVM.MEM.MMEP.MMSP.MemState
                            (prod MemPropT.store_id
                               (prod
                                  (prod InterpreterStackBigIntptr.LLVM.Local.local_env
                                     InterpreterStackBigIntptr.LLVM.Stack.lstack)
                                  (prod InterpreterStackBigIntptr.LLVM.Global.global_env
                                     InterpreterStackBigIntptr.LP.Events.DV.dvalue)))))
                  with
                  | inl1 x0 =>
                      (fun H1 : OOME X0 =>
                       (fun H2 : OOME X0 =>
                        let X1 :
                          forall _ : @eq Type X0 X0,
                          itree InfLP.Events.L4
                            (prod InterpreterStackBigIntptr.LLVM.MEM.MMEP.MMSP.MemState
                               (prod MemPropT.store_id
                                  (prod
                                     (prod InterpreterStackBigIntptr.LLVM.Local.local_env
                                        InterpreterStackBigIntptr.LLVM.Stack.lstack)
                                     (prod InterpreterStackBigIntptr.LLVM.Global.global_env
                                        InterpreterStackBigIntptr.LP.Events.DV.dvalue)))) :=
                          match
                            H2 in (OOME T)
                            return
                              (forall _ : @eq Type T X0,
                               itree InfLP.Events.L4
                                 (prod InterpreterStackBigIntptr.LLVM.MEM.MMEP.MMSP.MemState
                                    (prod MemPropT.store_id
                                       (prod
                                          (prod InterpreterStackBigIntptr.LLVM.Local.local_env
                                             InterpreterStackBigIntptr.LLVM.Stack.lstack)
                                          (prod InterpreterStackBigIntptr.LLVM.Global.global_env
                                             InterpreterStackBigIntptr.LP.Events.DV.dvalue)))))
                          with
                          | ThrowOOM x1 =>
                              (fun (H3 : unit) (H4 : @eq Type Empty_set X0) =>
                               (fun H5 : @eq Type Empty_set X0 =>
                                let H6 : @eq Type Empty_set X0 := H5 in
                                @eq_rect Type Empty_set
                                  (fun _ : Type =>
                                   forall _ : unit,
                                   itree InfLP.Events.L4
                                     (prod InterpreterStackBigIntptr.LLVM.MEM.MMEP.MMSP.MemState
                                        (prod MemPropT.store_id
                                           (prod
                                              (prod InterpreterStackBigIntptr.LLVM.Local.local_env
                                                 InterpreterStackBigIntptr.LLVM.Stack.lstack)
                                              (prod InterpreterStackBigIntptr.LLVM.Global.global_env
                                                 InterpreterStackBigIntptr.LP.Events.DV.dvalue)))))
                                  (fun _ : unit =>
                                   @eq_rect Type Empty_set
                                     (fun X1 : Type =>
                                      forall
                                        (_ : forall _ : X1,
                                             itree L4
                                               (prod FinMem.MMEP.MMSP.MemState
                                                  (prod MemPropT.store_id
                                                     (prod (prod local_env (@stack local_env))
                                                        (prod global_env dvalue)))))
                                        (_ : OOME X1),
                                      itree InfLP.Events.L4
                                        (prod InterpreterStackBigIntptr.LLVM.MEM.MMEP.MMSP.MemState
                                           (prod MemPropT.store_id
                                              (prod
                                                 (prod InterpreterStackBigIntptr.LLVM.Local.local_env
                                                    InterpreterStackBigIntptr.LLVM.Stack.lstack)
                                                 (prod
                                                    InterpreterStackBigIntptr.LLVM.Global.global_env
                                                    InterpreterStackBigIntptr.LP.Events.DV.dvalue)))))
                                     (fun
                                        (_ : forall _ : Empty_set,
                                             itree L4
                                               (prod FinMem.MMEP.MMSP.MemState
                                                  (prod MemPropT.store_id
                                                     (prod (prod local_env (@stack local_env))
                                                        (prod global_env dvalue)))))
                                        (_ : OOME Empty_set) =>
                                      @raiseOOM InfLP.Events.L4
                                        (@ReSum_inr (forall _ : Type, Type) IFun sum1 Cat_IFun
                                           Inr_sum1 OOME (sum1 OOME (sum1 UBE (sum1 DebugE FailureE)))
                                           InfLP.Events.ExternalCallE
                                           (@ReSum_inl (forall _ : Type, Type) IFun sum1 Cat_IFun
                                              Inl_sum1 OOME OOME (sum1 UBE (sum1 DebugE FailureE))
                                              (@ReSum_id (forall _ : Type, Type) IFun Id_IFun OOME)))
                                        (prod InterpreterStackBigIntptr.LLVM.MEM.MMEP.MMSP.MemState
                                           (prod MemPropT.store_id
                                              (prod
                                                 (prod InterpreterStackBigIntptr.LLVM.Local.local_env
                                                    InterpreterStackBigIntptr.LLVM.Stack.lstack)
                                                 (prod
                                                    InterpreterStackBigIntptr.LLVM.Global.global_env
                                                    InterpreterStackBigIntptr.LP.Events.DV.dvalue))))
                                        EmptyString) X0 H5 k0 H2) X0 H6) H4 H3) x1
                          end in
                        X1 (@eq_refl Type X0)) H1) x0
                  | inr1 x0 =>
                      (fun H1 : sum1 UBE (sum1 DebugE FailureE) X0 =>
                       (fun H2 : sum1 UBE (sum1 DebugE FailureE) X0 =>
                        let X1 :
                          itree InfLP.Events.L4
                            (prod InterpreterStackBigIntptr.LLVM.MEM.MMEP.MMSP.MemState
                               (prod MemPropT.store_id
                                  (prod
                                     (prod InterpreterStackBigIntptr.LLVM.Local.local_env
                                        InterpreterStackBigIntptr.LLVM.Stack.lstack)
                                     (prod InterpreterStackBigIntptr.LLVM.Global.global_env
                                        InterpreterStackBigIntptr.LP.Events.DV.dvalue)))) :=
                          match
                            H2
                            return
                              (itree InfLP.Events.L4
                                 (prod InterpreterStackBigIntptr.LLVM.MEM.MMEP.MMSP.MemState
                                    (prod MemPropT.store_id
                                       (prod
                                          (prod InterpreterStackBigIntptr.LLVM.Local.local_env
                                             InterpreterStackBigIntptr.LLVM.Stack.lstack)
                                          (prod InterpreterStackBigIntptr.LLVM.Global.global_env
                                             InterpreterStackBigIntptr.LP.Events.DV.dvalue)))))
                          with
                          | inl1 x1 =>
                              (fun H3 : UBE X0 =>
                               (fun H4 : UBE X0 =>
                                let X1 :
                                  forall _ : @eq Type X0 X0,
                                  itree InfLP.Events.L4
                                    (prod InterpreterStackBigIntptr.LLVM.MEM.MMEP.MMSP.MemState
                                       (prod MemPropT.store_id
                                          (prod
                                             (prod InterpreterStackBigIntptr.LLVM.Local.local_env
                                                InterpreterStackBigIntptr.LLVM.Stack.lstack)
                                             (prod InterpreterStackBigIntptr.LLVM.Global.global_env
                                                InterpreterStackBigIntptr.LP.Events.DV.dvalue)))) :=
                                  match
                                    H4 in (UBE T)
                                    return
                                      (forall _ : @eq Type T X0,
                                       itree InfLP.Events.L4
                                         (prod InterpreterStackBigIntptr.LLVM.MEM.MMEP.MMSP.MemState
                                            (prod MemPropT.store_id
                                               (prod
                                                  (prod InterpreterStackBigIntptr.LLVM.Local.local_env
                                                     InterpreterStackBigIntptr.LLVM.Stack.lstack)
                                                  (prod
                                                     InterpreterStackBigIntptr.LLVM.Global.global_env
                                                     InterpreterStackBigIntptr.LP.Events.DV.dvalue)))))
                                  with
                                  | ThrowUB x2 =>
                                      (fun (H5 : unit) (H6 : @eq Type Empty_set X0) =>
                                       (fun H7 : @eq Type Empty_set X0 =>
                                        let H8 : @eq Type Empty_set X0 := H7 in
                                        @eq_rect Type Empty_set
                                          (fun _ : Type =>
                                           forall _ : unit,
                                           itree InfLP.Events.L4
                                             (prod
                                                InterpreterStackBigIntptr.LLVM.MEM.MMEP.MMSP.MemState
                                                (prod MemPropT.store_id
                                                   (prod
                                                      (prod
                                                         InterpreterStackBigIntptr.LLVM.Local.local_env
                                                         InterpreterStackBigIntptr.LLVM.Stack.lstack)
                                                      (prod
                                                         InterpreterStackBigIntptr.LLVM.Global.global_env
                                                         InterpreterStackBigIntptr.LP.Events.DV.dvalue)))))
                                          (fun _ : unit =>
                                           @eq_rect Type Empty_set
                                             (fun X1 : Type =>
                                              forall
                                                (_ : forall _ : X1,
                                                     itree L4
                                                       (prod FinMem.MMEP.MMSP.MemState
                                                          (prod MemPropT.store_id
                                                             (prod (prod local_env (@stack local_env))
                                                                (prod global_env dvalue)))))
                                                (_ : UBE X1),
                                              itree InfLP.Events.L4
                                                (prod
                                                   InterpreterStackBigIntptr.LLVM.MEM.MMEP.MMSP.MemState
                                                   (prod MemPropT.store_id
                                                      (prod
                                                         (prod
                                                            InterpreterStackBigIntptr.LLVM.Local.local_env
                                                            InterpreterStackBigIntptr.LLVM.Stack.lstack)
                                                         (prod
                                                            InterpreterStackBigIntptr.LLVM.Global.global_env
                                                            InterpreterStackBigIntptr.LP.Events.DV.dvalue)))))
                                             (fun
                                                (_ : forall _ : Empty_set,
                                                     itree L4
                                                       (prod FinMem.MMEP.MMSP.MemState
                                                          (prod MemPropT.store_id
                                                             (prod (prod local_env (@stack local_env))
                                                                (prod global_env dvalue)))))
                                                (_ : UBE Empty_set) =>
                                              @raiseUB InfLP.Events.L4
                                                (@ReSum_inr (forall _ : Type, Type) IFun sum1 Cat_IFun
                                                   Inr_sum1 UBE
                                                   (sum1 OOME (sum1 UBE (sum1 DebugE FailureE)))
                                                   InfLP.Events.ExternalCallE
                                                   (@ReSum_inr (forall _ : Type, Type) IFun sum1
                                                      Cat_IFun Inr_sum1 UBE
                                                      (sum1 UBE (sum1 DebugE FailureE)) OOME
                                                      (@ReSum_inl (forall _ : Type, Type) IFun sum1
                                                         Cat_IFun Inl_sum1 UBE UBE
                                                         (sum1 DebugE FailureE)
                                                         (@ReSum_id (forall _ : Type, Type) IFun
                                                            Id_IFun UBE))))
                                                (prod
                                                   InterpreterStackBigIntptr.LLVM.MEM.MMEP.MMSP.MemState
                                                   (prod MemPropT.store_id
                                                      (prod
                                                         (prod
                                                            InterpreterStackBigIntptr.LLVM.Local.local_env
                                                            InterpreterStackBigIntptr.LLVM.Stack.lstack)
                                                         (prod
                                                            InterpreterStackBigIntptr.LLVM.Global.global_env
                                                            InterpreterStackBigIntptr.LP.Events.DV.dvalue))))
                                                EmptyString) X0 H7 k0 H4) X0 H8) H6 H5) x2
                                  end in
                                X1 (@eq_refl Type X0)) H3) x1
                          | inr1 x1 =>
                              (fun H3 : sum1 DebugE FailureE X0 =>
                               (fun H4 : sum1 DebugE FailureE X0 =>
                                let X1 :
                                  itree InfLP.Events.L4
                                    (prod InterpreterStackBigIntptr.LLVM.MEM.MMEP.MMSP.MemState
                                       (prod MemPropT.store_id
                                          (prod
                                             (prod InterpreterStackBigIntptr.LLVM.Local.local_env
                                                InterpreterStackBigIntptr.LLVM.Stack.lstack)
                                             (prod InterpreterStackBigIntptr.LLVM.Global.global_env
                                                InterpreterStackBigIntptr.LP.Events.DV.dvalue)))) :=
                                  match
                                    H4
                                    return
                                      (itree InfLP.Events.L4
                                         (prod InterpreterStackBigIntptr.LLVM.MEM.MMEP.MMSP.MemState
                                            (prod MemPropT.store_id
                                               (prod
                                                  (prod InterpreterStackBigIntptr.LLVM.Local.local_env
                                                     InterpreterStackBigIntptr.LLVM.Stack.lstack)
                                                  (prod
                                                     InterpreterStackBigIntptr.LLVM.Global.global_env
                                                     InterpreterStackBigIntptr.LP.Events.DV.dvalue)))))
                                  with
                                  | inl1 x2 =>
                                      (fun H5 : DebugE X0 =>
                                       (fun H6 : DebugE X0 =>
                                        let X1 :
                                          forall _ : @eq Type X0 X0,
                                          itree InfLP.Events.L4
                                            (prod
                                               InterpreterStackBigIntptr.LLVM.MEM.MMEP.MMSP.MemState
                                               (prod MemPropT.store_id
                                                  (prod
                                                     (prod
                                                        InterpreterStackBigIntptr.LLVM.Local.local_env
                                                        InterpreterStackBigIntptr.LLVM.Stack.lstack)
                                                     (prod
                                                        InterpreterStackBigIntptr.LLVM.Global.global_env
                                                        InterpreterStackBigIntptr.LP.Events.DV.dvalue)))) :=
                                          match
                                            H6 in (DebugE T)
                                            return
                                              (forall _ : @eq Type T X0,
                                               itree InfLP.Events.L4
                                                 (prod
                                                    InterpreterStackBigIntptr.LLVM.MEM.MMEP.MMSP.MemState
                                                    (prod MemPropT.store_id
                                                       (prod
                                                          (prod
                                                             InterpreterStackBigIntptr.LLVM.Local.local_env
                                                             InterpreterStackBigIntptr.LLVM.Stack.lstack)
                                                          (prod
                                                             InterpreterStackBigIntptr.LLVM.Global.global_env
                                                             InterpreterStackBigIntptr.LP.Events.DV.dvalue)))))
                                          with
                                          | Debug x3 =>
                                              (fun (H7 : unit) (H8 : @eq Type unit X0) =>
                                               (fun H9 : @eq Type unit X0 =>
                                                let H10 : @eq Type unit X0 := H9 in
                                                @eq_rect Type unit
                                                  (fun _ : Type =>
                                                   forall _ : unit,
                                                   itree InfLP.Events.L4
                                                     (prod
                                                        InterpreterStackBigIntptr.LLVM.MEM.MMEP.MMSP.MemState
                                                        (prod MemPropT.store_id
                                                           (prod
                                                              (prod
                                                                 InterpreterStackBigIntptr.LLVM.Local.local_env
                                                                 InterpreterStackBigIntptr.LLVM.Stack.lstack)
                                                              (prod
                                                                 InterpreterStackBigIntptr.LLVM.Global.global_env
                                                                 InterpreterStackBigIntptr.LP.Events.DV.dvalue)))))
                                                  (fun H11 : unit =>
                                                   @eq_rect Type unit
                                                     (fun X1 : Type =>
                                                      forall
                                                        (_ : forall _ : X1,
                                                             itree L4
                                                               (prod FinMem.MMEP.MMSP.MemState
                                                                  (prod MemPropT.store_id
                                                                     (prod
                                                                        (prod local_env
                                                                         (@stack local_env))
                                                                        (prod global_env dvalue)))))
                                                        (_ : DebugE X1),
                                                      itree InfLP.Events.L4
                                                        (prod
                                                           InterpreterStackBigIntptr.LLVM.MEM.MMEP.MMSP.MemState
                                                           (prod MemPropT.store_id
                                                              (prod
                                                                 (prod
                                                                    InterpreterStackBigIntptr.LLVM.Local.local_env
                                                                    InterpreterStackBigIntptr.LLVM.Stack.lstack)
                                                                 (prod
                                                                    InterpreterStackBigIntptr.LLVM.Global.global_env
                                                                    InterpreterStackBigIntptr.LP.Events.DV.dvalue)))))
                                                     (fun
                                                        (k1 : forall _ : unit,
                                                              itree L4
                                                                (prod FinMem.MMEP.MMSP.MemState
                                                                   (prod MemPropT.store_id
                                                                      (prod
                                                                         (prod local_env
                                                                         (@stack local_env))
                                                                         (prod global_env dvalue)))))
                                                        (_ : DebugE unit) =>
                                                      @go InfLP.Events.L4
                                                        (prod
                                                           InterpreterStackBigIntptr.LLVM.MEM.MMEP.MMSP.MemState
                                                           (prod MemPropT.store_id
                                                              (prod
                                                                 (prod
                                                                    InterpreterStackBigIntptr.LLVM.Local.local_env
                                                                    InterpreterStackBigIntptr.LLVM.Stack.lstack)
                                                                 (prod
                                                                    InterpreterStackBigIntptr.LLVM.Global.global_env
                                                                    InterpreterStackBigIntptr.LP.Events.DV.dvalue))))
                                                        (@VisF InfLP.Events.L4
                                                           (prod
                                                              InterpreterStackBigIntptr.LLVM.MEM.MMEP.MMSP.MemState
                                                              (prod MemPropT.store_id
                                                                 (prod
                                                                    (prod
                                                                       InterpreterStackBigIntptr.LLVM.Local.local_env
                                                                       InterpreterStackBigIntptr.LLVM.Stack.lstack)
                                                                    (prod
                                                                       InterpreterStackBigIntptr.LLVM.Global.global_env
                                                                       InterpreterStackBigIntptr.LP.Events.DV.dvalue))))
                                                           (itree InfLP.Events.L4
                                                              (prod
                                                                 InterpreterStackBigIntptr.LLVM.MEM.MMEP.MMSP.MemState
                                                                 (prod MemPropT.store_id
                                                                    (prod
                                                                       (prod
                                                                         InterpreterStackBigIntptr.LLVM.Local.local_env
                                                                         InterpreterStackBigIntptr.LLVM.Stack.lstack)
                                                                       (prod
                                                                         InterpreterStackBigIntptr.LLVM.Global.global_env
                                                                         InterpreterStackBigIntptr.LP.Events.DV.dvalue)))))
                                                           unit
                                                           (@subevent DebugE InfLP.Events.L4
                                                              (@ReSum_inr
                                                                 (forall _ : Type, Type) IFun sum1
                                                                 Cat_IFun Inr_sum1 DebugE
                                                                 (sum1 OOME
                                                                    (sum1 UBE (sum1 DebugE FailureE)))
                                                                 InfLP.Events.ExternalCallE
                                                                 (@ReSum_inr
                                                                    (forall _ : Type, Type) IFun sum1
                                                                    Cat_IFun Inr_sum1 DebugE
                                                                    (sum1 UBE (sum1 DebugE FailureE))
                                                                    OOME
                                                                    (@ReSum_inr
                                                                       (forall _ : Type, Type) IFun
                                                                       sum1 Cat_IFun Inr_sum1 DebugE
                                                                       (sum1 DebugE FailureE) UBE
                                                                       (@ReSum_inl
                                                                         (forall _ : Type, Type) IFun
                                                                         sum1 Cat_IFun Inl_sum1 DebugE
                                                                         DebugE FailureE
                                                                         (@ReSum_id
                                                                         (forall _ : Type, Type) IFun
                                                                         Id_IFun DebugE))))) unit
                                                              (Debug H11))
                                                           (fun H13 : unit => CIH (k1 H13)))) X0 H9 k0
                                                     H6) X0 H10) H8 H7) x3
                                          end in
                                        X1 (@eq_refl Type X0)) H5) x2
                                  | inr1 x2 =>
                                      (fun H5 : FailureE X0 =>
                                       (fun H6 : FailureE X0 =>
                                        let X1 :
                                          forall _ : @eq Type X0 X0,
                                          itree InfLP.Events.L4
                                            (prod
                                               InterpreterStackBigIntptr.LLVM.MEM.MMEP.MMSP.MemState
                                               (prod MemPropT.store_id
                                                  (prod
                                                     (prod
                                                        InterpreterStackBigIntptr.LLVM.Local.local_env
                                                        InterpreterStackBigIntptr.LLVM.Stack.lstack)
                                                     (prod
                                                        InterpreterStackBigIntptr.LLVM.Global.global_env
                                                        InterpreterStackBigIntptr.LP.Events.DV.dvalue)))) :=
                                          match
                                            H6 in (FailureE T)
                                            return
                                              (forall _ : @eq Type T X0,
                                               itree InfLP.Events.L4
                                                 (prod
                                                    InterpreterStackBigIntptr.LLVM.MEM.MMEP.MMSP.MemState
                                                    (prod MemPropT.store_id
                                                       (prod
                                                          (prod
                                                             InterpreterStackBigIntptr.LLVM.Local.local_env
                                                             InterpreterStackBigIntptr.LLVM.Stack.lstack)
                                                          (prod
                                                             InterpreterStackBigIntptr.LLVM.Global.global_env
                                                             InterpreterStackBigIntptr.LP.Events.DV.dvalue)))))
                                          with
                                          | Throw x3 =>
                                              (fun (H7 : unit) (H8 : @eq Type Empty_set X0) =>
                                               (fun H9 : @eq Type Empty_set X0 =>
                                                let H10 : @eq Type Empty_set X0 := H9 in
                                                @eq_rect Type Empty_set
                                                  (fun _ : Type =>
                                                   forall _ : unit,
                                                   itree InfLP.Events.L4
                                                     (prod
                                                        InterpreterStackBigIntptr.LLVM.MEM.MMEP.MMSP.MemState
                                                        (prod MemPropT.store_id
                                                           (prod
                                                              (prod
                                                                 InterpreterStackBigIntptr.LLVM.Local.local_env
                                                                 InterpreterStackBigIntptr.LLVM.Stack.lstack)
                                                              (prod
                                                                 InterpreterStackBigIntptr.LLVM.Global.global_env
                                                                 InterpreterStackBigIntptr.LP.Events.DV.dvalue)))))
                                                  (fun _ : unit =>
                                                   @eq_rect Type Empty_set
                                                     (fun X1 : Type =>
                                                      forall
                                                        (_ : forall _ : X1,
                                                             itree L4
                                                               (prod FinMem.MMEP.MMSP.MemState
                                                                  (prod MemPropT.store_id
                                                                     (prod
                                                                        (prod local_env
                                                                         (@stack local_env))
                                                                        (prod global_env dvalue)))))
                                                        (_ : FailureE X1),
                                                      itree InfLP.Events.L4
                                                        (prod
                                                           InterpreterStackBigIntptr.LLVM.MEM.MMEP.MMSP.MemState
                                                           (prod MemPropT.store_id
                                                              (prod
                                                                 (prod
                                                                    InterpreterStackBigIntptr.LLVM.Local.local_env
                                                                    InterpreterStackBigIntptr.LLVM.Stack.lstack)
                                                                 (prod
                                                                    InterpreterStackBigIntptr.LLVM.Global.global_env
                                                                    InterpreterStackBigIntptr.LP.Events.DV.dvalue)))))
                                                     (fun
                                                        (_ : forall _ : Empty_set,
                                                             itree L4
                                                               (prod FinMem.MMEP.MMSP.MemState
                                                                  (prod MemPropT.store_id
                                                                     (prod
                                                                        (prod local_env
                                                                         (@stack local_env))
                                                                        (prod global_env dvalue)))))
                                                        (_ : FailureE Empty_set) =>
                                                      @LLVMEvents.raise InfLP.Events.L4
                                                        (prod
                                                           InterpreterStackBigIntptr.LLVM.MEM.MMEP.MMSP.MemState
                                                           (prod MemPropT.store_id
                                                              (prod
                                                                 (prod
                                                                    InterpreterStackBigIntptr.LLVM.Local.local_env
                                                                    InterpreterStackBigIntptr.LLVM.Stack.lstack)
                                                                 (prod
                                                                    InterpreterStackBigIntptr.LLVM.Global.global_env
                                                                    InterpreterStackBigIntptr.LP.Events.DV.dvalue))))
                                                        (@ReSum_inr (forall _ : Type, Type) IFun sum1
                                                           Cat_IFun Inr_sum1 FailureE
                                                           (sum1 OOME
                                                              (sum1 UBE (sum1 DebugE FailureE)))
                                                           InfLP.Events.ExternalCallE
                                                           (@ReSum_inr (forall _ : Type, Type) IFun
                                                              sum1 Cat_IFun Inr_sum1 FailureE
                                                              (sum1 UBE (sum1 DebugE FailureE)) OOME
                                                              (@ReSum_inr
                                                                 (forall _ : Type, Type) IFun sum1
                                                                 Cat_IFun Inr_sum1 FailureE
                                                                 (sum1 DebugE FailureE) UBE
                                                                 (@ReSum_inr
                                                                    (forall _ : Type, Type) IFun sum1
                                                                    Cat_IFun Inr_sum1 FailureE
                                                                    FailureE DebugE
                                                                    (@ReSum_id
                                                                       (forall _ : Type, Type) IFun
                                                                       Id_IFun FailureE)))))
                                                        EmptyString) X0 H9 k0 H6) X0 H10) H8 H7) x3
                                          end in
                                        X1 (@eq_refl Type X0)) H5) x2
                                  end in
                                X1) H3) x1
                          end in
                        X1) H1) x0
                  end in
                X1) H) x
          end in
        X1) X e k
   end) (@_observe _ _ t_fin2).

  Definition _get_inf_tree_L4 (t_fin2 : itree' L4 (FinMem.MMEP.MMSP.MemState * (MemPropT.store_id * (local_env * @stack local_env * res_L1)))) : itree InfLP.Events.L4 TopLevelBigIntptr.res_L4 :=
   match
     t_fin2
     return
       (itree InfLP.Events.L4
          (prod InterpreterStackBigIntptr.LLVM.MEM.MMEP.MMSP.MemState
             (prod MemPropT.store_id
                (prod
                   (prod InterpreterStackBigIntptr.LLVM.Local.local_env
                      InterpreterStackBigIntptr.LLVM.Stack.lstack)
                   (prod InterpreterStackBigIntptr.LLVM.Global.global_env
                      InterpreterStackBigIntptr.LP.Events.DV.dvalue)))))
   with
   | RetF r =>
       (fun
          r0 : prod FinMem.MMEP.MMSP.MemState
                 (prod MemPropT.store_id
                    (prod (prod local_env (@stack local_env)) (prod global_env dvalue))) =>
        @ret (itree InfLP.Events.L4) (@Monad_itree InfLP.Events.L4)
          (prod InterpreterStackBigIntptr.LLVM.MEM.MMEP.MMSP.MemState
             (prod MemPropT.store_id
                (prod
                   (prod InterpreterStackBigIntptr.LLVM.Local.local_env
                      InterpreterStackBigIntptr.LLVM.Stack.lstack)
                   (prod InterpreterStackBigIntptr.LLVM.Global.global_env
                      InterpreterStackBigIntptr.LP.Events.DV.dvalue))))
          match
            r0
            return
              (prod InterpreterStackBigIntptr.LLVM.MEM.MMEP.MMSP.MemState
                 (prod MemPropT.store_id
                    (prod
                       (prod InterpreterStackBigIntptr.LLVM.Local.local_env
                          InterpreterStackBigIntptr.LLVM.Stack.lstack)
                       (prod InterpreterStackBigIntptr.LLVM.Global.global_env
                          InterpreterStackBigIntptr.LP.Events.DV.dvalue))))
          with
          | pair a b =>
              (fun (ms : FinMem.MMEP.MMSP.MemState)
                 (p : prod MemPropT.store_id
                        (prod (prod local_env (@stack local_env)) (prod global_env dvalue))) =>
               match
                 p
                 return
                   (prod InterpreterStackBigIntptr.LLVM.MEM.MMEP.MMSP.MemState
                      (prod MemPropT.store_id
                         (prod
                            (prod InterpreterStackBigIntptr.LLVM.Local.local_env
                               InterpreterStackBigIntptr.LLVM.Stack.lstack)
                            (prod InterpreterStackBigIntptr.LLVM.Global.global_env
                               InterpreterStackBigIntptr.LP.Events.DV.dvalue))))
               with
               | pair a0 b0 =>
                   (fun (sid : MemPropT.store_id)
                      (p0 : prod (prod local_env (@stack local_env)) (prod global_env dvalue)) =>
                    match
                      p0
                      return
                        (prod InterpreterStackBigIntptr.LLVM.MEM.MMEP.MMSP.MemState
                           (prod MemPropT.store_id
                              (prod
                                 (prod InterpreterStackBigIntptr.LLVM.Local.local_env
                                    InterpreterStackBigIntptr.LLVM.Stack.lstack)
                                 (prod InterpreterStackBigIntptr.LLVM.Global.global_env
                                    InterpreterStackBigIntptr.LP.Events.DV.dvalue))))
                    with
                    | pair a1 b1 =>
                        (fun p1 : prod local_env (@stack local_env) =>
                         match
                           p1
                           return
                             (forall _ : prod global_env dvalue,
                              prod InterpreterStackBigIntptr.LLVM.MEM.MMEP.MMSP.MemState
                                (prod MemPropT.store_id
                                   (prod
                                      (prod InterpreterStackBigIntptr.LLVM.Local.local_env
                                         InterpreterStackBigIntptr.LLVM.Stack.lstack)
                                      (prod InterpreterStackBigIntptr.LLVM.Global.global_env
                                         InterpreterStackBigIntptr.LP.Events.DV.dvalue))))
                         with
                         | pair a2 b2 =>
                             (fun (lenv : local_env) (s : @stack local_env)
                                (p2 : prod global_env dvalue) =>
                              match
                                p2
                                return
                                  (prod InterpreterStackBigIntptr.LLVM.MEM.MMEP.MMSP.MemState
                                     (prod MemPropT.store_id
                                        (prod
                                           (prod InterpreterStackBigIntptr.LLVM.Local.local_env
                                              InterpreterStackBigIntptr.LLVM.Stack.lstack)
                                           (prod InterpreterStackBigIntptr.LLVM.Global.global_env
                                              InterpreterStackBigIntptr.LP.Events.DV.dvalue))))
                              with
                              | pair a3 b3 =>
                                  (fun (genv : global_env) (res : dvalue) =>
                                   @pair InterpreterStackBigIntptr.LLVM.MEM.MMEP.MMSP.MemState
                                     (prod MemPropT.store_id
                                        (prod
                                           (prod InterpreterStackBigIntptr.LLVM.Local.local_env
                                              InterpreterStackBigIntptr.LLVM.Stack.lstack)
                                           (prod InterpreterStackBigIntptr.LLVM.Global.global_env
                                              InterpreterStackBigIntptr.LP.Events.DV.dvalue)))
                                     (lift_MemState ms)
                                     (@pair MemPropT.store_id
                                        (prod
                                           (prod InterpreterStackBigIntptr.LLVM.Local.local_env
                                              InterpreterStackBigIntptr.LLVM.Stack.lstack)
                                           (prod InterpreterStackBigIntptr.LLVM.Global.global_env
                                              InterpreterStackBigIntptr.LP.Events.DV.dvalue)) sid
                                        (@pair
                                           (prod InterpreterStackBigIntptr.LLVM.Local.local_env
                                              InterpreterStackBigIntptr.LLVM.Stack.lstack)
                                           (prod InterpreterStackBigIntptr.LLVM.Global.global_env
                                              InterpreterStackBigIntptr.LP.Events.DV.dvalue)
                                           (@pair InterpreterStackBigIntptr.LLVM.Local.local_env
                                              InterpreterStackBigIntptr.LLVM.Stack.lstack
                                              (lift_local_env lenv) (lift_stack s))
                                           (@pair InterpreterStackBigIntptr.LLVM.Global.global_env
                                              InterpreterStackBigIntptr.LP.Events.DV.dvalue
                                              (lift_global_env genv) (fin_to_inf_dvalue res))))) a3 b3
                              end) a2 b2
                         end) a1 b1
                    end) a0 b0
               end) a b
          end) r
   | TauF t =>
       (fun
          t0 : itree L4
                 (prod FinMem.MMEP.MMSP.MemState
                    (prod MemPropT.store_id
                       (prod (prod local_env (@stack local_env)) (prod global_env dvalue)))) =>
        @go InfLP.Events.L4
          (prod InterpreterStackBigIntptr.LLVM.MEM.MMEP.MMSP.MemState
             (prod MemPropT.store_id
                (prod
                   (prod InterpreterStackBigIntptr.LLVM.Local.local_env
                      InterpreterStackBigIntptr.LLVM.Stack.lstack)
                   (prod InterpreterStackBigIntptr.LLVM.Global.global_env
                      InterpreterStackBigIntptr.LP.Events.DV.dvalue))))
          (@TauF InfLP.Events.L4
             (prod InterpreterStackBigIntptr.LLVM.MEM.MMEP.MMSP.MemState
                (prod MemPropT.store_id
                   (prod
                      (prod InterpreterStackBigIntptr.LLVM.Local.local_env
                         InterpreterStackBigIntptr.LLVM.Stack.lstack)
                      (prod InterpreterStackBigIntptr.LLVM.Global.global_env
                         InterpreterStackBigIntptr.LP.Events.DV.dvalue))))
             (itree InfLP.Events.L4
                (prod InterpreterStackBigIntptr.LLVM.MEM.MMEP.MMSP.MemState
                   (prod MemPropT.store_id
                      (prod
                         (prod InterpreterStackBigIntptr.LLVM.Local.local_env
                            InterpreterStackBigIntptr.LLVM.Stack.lstack)
                         (prod InterpreterStackBigIntptr.LLVM.Global.global_env
                            InterpreterStackBigIntptr.LP.Events.DV.dvalue)))))
             (get_inf_tree_L4 t0))) t
   | @VisF _ _ _ X e k =>
       (fun (X0 : Type) (e0 : L4 X0)
          (k0 : forall _ : X0,
                itree L4
                  (prod FinMem.MMEP.MMSP.MemState
                     (prod MemPropT.store_id
                        (prod (prod local_env (@stack local_env)) (prod global_env dvalue))))) =>
        let X1 :
          itree InfLP.Events.L4
            (prod InterpreterStackBigIntptr.LLVM.MEM.MMEP.MMSP.MemState
               (prod MemPropT.store_id
                  (prod
                     (prod InterpreterStackBigIntptr.LLVM.Local.local_env
                        InterpreterStackBigIntptr.LLVM.Stack.lstack)
                     (prod InterpreterStackBigIntptr.LLVM.Global.global_env
                        InterpreterStackBigIntptr.LP.Events.DV.dvalue)))) :=
          match
            e0
            return
              (itree InfLP.Events.L4
                 (prod InterpreterStackBigIntptr.LLVM.MEM.MMEP.MMSP.MemState
                    (prod MemPropT.store_id
                       (prod
                          (prod InterpreterStackBigIntptr.LLVM.Local.local_env
                             InterpreterStackBigIntptr.LLVM.Stack.lstack)
                          (prod InterpreterStackBigIntptr.LLVM.Global.global_env
                             InterpreterStackBigIntptr.LP.Events.DV.dvalue)))))
          with
          | inl1 x =>
              (fun H : ExternalCallE X0 =>
               (fun H0 : ExternalCallE X0 =>
                let X1 :
                  forall _ : @eq Type X0 X0,
                  itree InfLP.Events.L4
                    (prod InterpreterStackBigIntptr.LLVM.MEM.MMEP.MMSP.MemState
                       (prod MemPropT.store_id
                          (prod
                             (prod InterpreterStackBigIntptr.LLVM.Local.local_env
                                InterpreterStackBigIntptr.LLVM.Stack.lstack)
                             (prod InterpreterStackBigIntptr.LLVM.Global.global_env
                                InterpreterStackBigIntptr.LP.Events.DV.dvalue)))) :=
                  match
                    H0 in (ExternalCallE T)
                    return
                      (forall _ : @eq Type T X0,
                       itree InfLP.Events.L4
                         (prod InterpreterStackBigIntptr.LLVM.MEM.MMEP.MMSP.MemState
                            (prod MemPropT.store_id
                               (prod
                                  (prod InterpreterStackBigIntptr.LLVM.Local.local_env
                                     InterpreterStackBigIntptr.LLVM.Stack.lstack)
                                  (prod InterpreterStackBigIntptr.LLVM.Global.global_env
                                     InterpreterStackBigIntptr.LP.Events.DV.dvalue)))))
                  with
                  | ExternalCall t f args =>
                      (fun (t0 : dtyp) (f0 : uvalue) (args0 : list dvalue) (H1 : @eq Type dvalue X0)
                       =>
                       (fun H2 : @eq Type dvalue X0 =>
                        let H3 : @eq Type dvalue X0 := H2 in
                        @eq_rect Type dvalue
                          (fun _ : Type =>
                           forall (_ : dtyp) (_ : uvalue) (_ : list dvalue),
                           itree InfLP.Events.L4
                             (prod InterpreterStackBigIntptr.LLVM.MEM.MMEP.MMSP.MemState
                                (prod MemPropT.store_id
                                   (prod
                                      (prod InterpreterStackBigIntptr.LLVM.Local.local_env
                                         InterpreterStackBigIntptr.LLVM.Stack.lstack)
                                      (prod InterpreterStackBigIntptr.LLVM.Global.global_env
                                         InterpreterStackBigIntptr.LP.Events.DV.dvalue)))))
                          (fun (t1 : dtyp) (f1 : uvalue) (args1 : list dvalue) =>
                           @eq_rect Type dvalue
                             (fun X1 : Type =>
                              forall
                                (_ : forall _ : X1,
                                     itree L4
                                       (prod FinMem.MMEP.MMSP.MemState
                                          (prod MemPropT.store_id
                                             (prod (prod local_env (@stack local_env))
                                                (prod global_env dvalue)))))
                                (_ : ExternalCallE X1),
                              itree InfLP.Events.L4
                                (prod InterpreterStackBigIntptr.LLVM.MEM.MMEP.MMSP.MemState
                                   (prod MemPropT.store_id
                                      (prod
                                         (prod InterpreterStackBigIntptr.LLVM.Local.local_env
                                            InterpreterStackBigIntptr.LLVM.Stack.lstack)
                                         (prod InterpreterStackBigIntptr.LLVM.Global.global_env
                                            InterpreterStackBigIntptr.LP.Events.DV.dvalue)))))
                             (fun
                                (k1 : forall _ : dvalue,
                                      itree L4
                                        (prod FinMem.MMEP.MMSP.MemState
                                           (prod MemPropT.store_id
                                              (prod (prod local_env (@stack local_env))
                                                 (prod global_env dvalue)))))
                                (_ : ExternalCallE dvalue) =>
                              @go InfLP.Events.L4
                                (prod InterpreterStackBigIntptr.LLVM.MEM.MMEP.MMSP.MemState
                                   (prod MemPropT.store_id
                                      (prod
                                         (prod InterpreterStackBigIntptr.LLVM.Local.local_env
                                            InterpreterStackBigIntptr.LLVM.Stack.lstack)
                                         (prod InterpreterStackBigIntptr.LLVM.Global.global_env
                                            InterpreterStackBigIntptr.LP.Events.DV.dvalue))))
                                (@VisF InfLP.Events.L4
                                   (prod InterpreterStackBigIntptr.LLVM.MEM.MMEP.MMSP.MemState
                                      (prod MemPropT.store_id
                                         (prod
                                            (prod InterpreterStackBigIntptr.LLVM.Local.local_env
                                               InterpreterStackBigIntptr.LLVM.Stack.lstack)
                                            (prod InterpreterStackBigIntptr.LLVM.Global.global_env
                                               InterpreterStackBigIntptr.LP.Events.DV.dvalue))))
                                   (itree InfLP.Events.L4
                                      (prod InterpreterStackBigIntptr.LLVM.MEM.MMEP.MMSP.MemState
                                         (prod MemPropT.store_id
                                            (prod
                                               (prod InterpreterStackBigIntptr.LLVM.Local.local_env
                                                  InterpreterStackBigIntptr.LLVM.Stack.lstack)
                                               (prod InterpreterStackBigIntptr.LLVM.Global.global_env
                                                  InterpreterStackBigIntptr.LP.Events.DV.dvalue)))))
                                   E1.DV.dvalue
                                   (@subevent E1.ExternalCallE InfLP.Events.L4
                                      (@ReSum_inl (forall _ : Type, Type) IFun sum1 Cat_IFun Inl_sum1
                                         E1.ExternalCallE InfLP.Events.ExternalCallE
                                         (sum1 OOME (sum1 UBE (sum1 DebugE FailureE)))
                                         (@ReSum_id (forall _ : Type, Type) IFun Id_IFun
                                            InfLP.Events.ExternalCallE)) E1.DV.dvalue
                                      (E1.ExternalCall t1 (fin_to_inf_uvalue f1)
                                         (@map LLVMParams64BitIntptr.Events.DV.dvalue
                                            LLVMParamsBigIntptr.Events.DV.dvalue fin_to_inf_dvalue
                                            args1)))
                                   (fun x0 : E1.DV.dvalue =>
                                    get_inf_tree_L4
                                      (let H5 : OOM DVCInfFin.DV2.dvalue :=
                                         DVCInfFin.dvalue_convert_strict x0 in
                                       match
                                         H5
                                         return
                                           (itree L4
                                              (prod FinMem.MMEP.MMSP.MemState
                                                 (prod MemPropT.store_id
                                                    (prod (prod local_env (@stack local_env))
                                                       (prod global_env dvalue)))))
                                       with
                                       | NoOom a => (fun d : DVCInfFin.DV2.dvalue => k1 d) a
                                       | Oom s =>
                                           (fun s0 : string =>
                                            @raiseOOM L4
                                              (@ReSum_inr (forall _ : Type, Type) IFun sum1 Cat_IFun
                                                 Inr_sum1 OOME
                                                 (sum1 OOME (sum1 UBE (sum1 DebugE FailureE)))
                                                 ExternalCallE
                                                 (@ReSum_inl (forall _ : Type, Type) IFun sum1
                                                    Cat_IFun Inl_sum1 OOME OOME
                                                    (sum1 UBE (sum1 DebugE FailureE))
                                                    (@ReSum_id (forall _ : Type, Type) IFun Id_IFun
                                                       OOME)))
                                              (prod FinMem.MMEP.MMSP.MemState
                                                 (prod MemPropT.store_id
                                                    (prod (prod local_env (@stack local_env))
                                                       (prod global_env dvalue)))) s0) s
                                       end)))) X0 H2 k0 H0) X0 H3) H1 t0 f0 args0) t f args
                  end in
                X1 (@eq_refl Type X0)) H) x
          | inr1 x =>
              (fun H : sum1 OOME (sum1 UBE (sum1 DebugE FailureE)) X0 =>
               (fun H0 : sum1 OOME (sum1 UBE (sum1 DebugE FailureE)) X0 =>
                let X1 :
                  itree InfLP.Events.L4
                    (prod InterpreterStackBigIntptr.LLVM.MEM.MMEP.MMSP.MemState
                       (prod MemPropT.store_id
                          (prod
                             (prod InterpreterStackBigIntptr.LLVM.Local.local_env
                                InterpreterStackBigIntptr.LLVM.Stack.lstack)
                             (prod InterpreterStackBigIntptr.LLVM.Global.global_env
                                InterpreterStackBigIntptr.LP.Events.DV.dvalue)))) :=
                  match
                    H0
                    return
                      (itree InfLP.Events.L4
                         (prod InterpreterStackBigIntptr.LLVM.MEM.MMEP.MMSP.MemState
                            (prod MemPropT.store_id
                               (prod
                                  (prod InterpreterStackBigIntptr.LLVM.Local.local_env
                                     InterpreterStackBigIntptr.LLVM.Stack.lstack)
                                  (prod InterpreterStackBigIntptr.LLVM.Global.global_env
                                     InterpreterStackBigIntptr.LP.Events.DV.dvalue)))))
                  with
                  | inl1 x0 =>
                      (fun H1 : OOME X0 =>
                       (fun H2 : OOME X0 =>
                        let X1 :
                          forall _ : @eq Type X0 X0,
                          itree InfLP.Events.L4
                            (prod InterpreterStackBigIntptr.LLVM.MEM.MMEP.MMSP.MemState
                               (prod MemPropT.store_id
                                  (prod
                                     (prod InterpreterStackBigIntptr.LLVM.Local.local_env
                                        InterpreterStackBigIntptr.LLVM.Stack.lstack)
                                     (prod InterpreterStackBigIntptr.LLVM.Global.global_env
                                        InterpreterStackBigIntptr.LP.Events.DV.dvalue)))) :=
                          match
                            H2 in (OOME T)
                            return
                              (forall _ : @eq Type T X0,
                               itree InfLP.Events.L4
                                 (prod InterpreterStackBigIntptr.LLVM.MEM.MMEP.MMSP.MemState
                                    (prod MemPropT.store_id
                                       (prod
                                          (prod InterpreterStackBigIntptr.LLVM.Local.local_env
                                             InterpreterStackBigIntptr.LLVM.Stack.lstack)
                                          (prod InterpreterStackBigIntptr.LLVM.Global.global_env
                                             InterpreterStackBigIntptr.LP.Events.DV.dvalue)))))
                          with
                          | ThrowOOM x1 =>
                              (fun (H3 : unit) (H4 : @eq Type Empty_set X0) =>
                               (fun H5 : @eq Type Empty_set X0 =>
                                let H6 : @eq Type Empty_set X0 := H5 in
                                @eq_rect Type Empty_set
                                  (fun _ : Type =>
                                   forall _ : unit,
                                   itree InfLP.Events.L4
                                     (prod InterpreterStackBigIntptr.LLVM.MEM.MMEP.MMSP.MemState
                                        (prod MemPropT.store_id
                                           (prod
                                              (prod InterpreterStackBigIntptr.LLVM.Local.local_env
                                                 InterpreterStackBigIntptr.LLVM.Stack.lstack)
                                              (prod InterpreterStackBigIntptr.LLVM.Global.global_env
                                                 InterpreterStackBigIntptr.LP.Events.DV.dvalue)))))
                                  (fun _ : unit =>
                                   @eq_rect Type Empty_set
                                     (fun X1 : Type =>
                                      forall
                                        (_ : forall _ : X1,
                                             itree L4
                                               (prod FinMem.MMEP.MMSP.MemState
                                                  (prod MemPropT.store_id
                                                     (prod (prod local_env (@stack local_env))
                                                        (prod global_env dvalue)))))
                                        (_ : OOME X1),
                                      itree InfLP.Events.L4
                                        (prod InterpreterStackBigIntptr.LLVM.MEM.MMEP.MMSP.MemState
                                           (prod MemPropT.store_id
                                              (prod
                                                 (prod InterpreterStackBigIntptr.LLVM.Local.local_env
                                                    InterpreterStackBigIntptr.LLVM.Stack.lstack)
                                                 (prod
                                                    InterpreterStackBigIntptr.LLVM.Global.global_env
                                                    InterpreterStackBigIntptr.LP.Events.DV.dvalue)))))
                                     (fun
                                        (_ : forall _ : Empty_set,
                                             itree L4
                                               (prod FinMem.MMEP.MMSP.MemState
                                                  (prod MemPropT.store_id
                                                     (prod (prod local_env (@stack local_env))
                                                        (prod global_env dvalue)))))
                                        (_ : OOME Empty_set) =>
                                      @raiseOOM InfLP.Events.L4
                                        (@ReSum_inr (forall _ : Type, Type) IFun sum1 Cat_IFun
                                           Inr_sum1 OOME (sum1 OOME (sum1 UBE (sum1 DebugE FailureE)))
                                           InfLP.Events.ExternalCallE
                                           (@ReSum_inl (forall _ : Type, Type) IFun sum1 Cat_IFun
                                              Inl_sum1 OOME OOME (sum1 UBE (sum1 DebugE FailureE))
                                              (@ReSum_id (forall _ : Type, Type) IFun Id_IFun OOME)))
                                        (prod InterpreterStackBigIntptr.LLVM.MEM.MMEP.MMSP.MemState
                                           (prod MemPropT.store_id
                                              (prod
                                                 (prod InterpreterStackBigIntptr.LLVM.Local.local_env
                                                    InterpreterStackBigIntptr.LLVM.Stack.lstack)
                                                 (prod
                                                    InterpreterStackBigIntptr.LLVM.Global.global_env
                                                    InterpreterStackBigIntptr.LP.Events.DV.dvalue))))
                                        EmptyString) X0 H5 k0 H2) X0 H6) H4 H3) x1
                          end in
                        X1 (@eq_refl Type X0)) H1) x0
                  | inr1 x0 =>
                      (fun H1 : sum1 UBE (sum1 DebugE FailureE) X0 =>
                       (fun H2 : sum1 UBE (sum1 DebugE FailureE) X0 =>
                        let X1 :
                          itree InfLP.Events.L4
                            (prod InterpreterStackBigIntptr.LLVM.MEM.MMEP.MMSP.MemState
                               (prod MemPropT.store_id
                                  (prod
                                     (prod InterpreterStackBigIntptr.LLVM.Local.local_env
                                        InterpreterStackBigIntptr.LLVM.Stack.lstack)
                                     (prod InterpreterStackBigIntptr.LLVM.Global.global_env
                                        InterpreterStackBigIntptr.LP.Events.DV.dvalue)))) :=
                          match
                            H2
                            return
                              (itree InfLP.Events.L4
                                 (prod InterpreterStackBigIntptr.LLVM.MEM.MMEP.MMSP.MemState
                                    (prod MemPropT.store_id
                                       (prod
                                          (prod InterpreterStackBigIntptr.LLVM.Local.local_env
                                             InterpreterStackBigIntptr.LLVM.Stack.lstack)
                                          (prod InterpreterStackBigIntptr.LLVM.Global.global_env
                                             InterpreterStackBigIntptr.LP.Events.DV.dvalue)))))
                          with
                          | inl1 x1 =>
                              (fun H3 : UBE X0 =>
                               (fun H4 : UBE X0 =>
                                let X1 :
                                  forall _ : @eq Type X0 X0,
                                  itree InfLP.Events.L4
                                    (prod InterpreterStackBigIntptr.LLVM.MEM.MMEP.MMSP.MemState
                                       (prod MemPropT.store_id
                                          (prod
                                             (prod InterpreterStackBigIntptr.LLVM.Local.local_env
                                                InterpreterStackBigIntptr.LLVM.Stack.lstack)
                                             (prod InterpreterStackBigIntptr.LLVM.Global.global_env
                                                InterpreterStackBigIntptr.LP.Events.DV.dvalue)))) :=
                                  match
                                    H4 in (UBE T)
                                    return
                                      (forall _ : @eq Type T X0,
                                       itree InfLP.Events.L4
                                         (prod InterpreterStackBigIntptr.LLVM.MEM.MMEP.MMSP.MemState
                                            (prod MemPropT.store_id
                                               (prod
                                                  (prod InterpreterStackBigIntptr.LLVM.Local.local_env
                                                     InterpreterStackBigIntptr.LLVM.Stack.lstack)
                                                  (prod
                                                     InterpreterStackBigIntptr.LLVM.Global.global_env
                                                     InterpreterStackBigIntptr.LP.Events.DV.dvalue)))))
                                  with
                                  | ThrowUB x2 =>
                                      (fun (H5 : unit) (H6 : @eq Type Empty_set X0) =>
                                       (fun H7 : @eq Type Empty_set X0 =>
                                        let H8 : @eq Type Empty_set X0 := H7 in
                                        @eq_rect Type Empty_set
                                          (fun _ : Type =>
                                           forall _ : unit,
                                           itree InfLP.Events.L4
                                             (prod
                                                InterpreterStackBigIntptr.LLVM.MEM.MMEP.MMSP.MemState
                                                (prod MemPropT.store_id
                                                   (prod
                                                      (prod
                                                         InterpreterStackBigIntptr.LLVM.Local.local_env
                                                         InterpreterStackBigIntptr.LLVM.Stack.lstack)
                                                      (prod
                                                         InterpreterStackBigIntptr.LLVM.Global.global_env
                                                         InterpreterStackBigIntptr.LP.Events.DV.dvalue)))))
                                          (fun _ : unit =>
                                           @eq_rect Type Empty_set
                                             (fun X1 : Type =>
                                              forall
                                                (_ : forall _ : X1,
                                                     itree L4
                                                       (prod FinMem.MMEP.MMSP.MemState
                                                          (prod MemPropT.store_id
                                                             (prod (prod local_env (@stack local_env))
                                                                (prod global_env dvalue)))))
                                                (_ : UBE X1),
                                              itree InfLP.Events.L4
                                                (prod
                                                   InterpreterStackBigIntptr.LLVM.MEM.MMEP.MMSP.MemState
                                                   (prod MemPropT.store_id
                                                      (prod
                                                         (prod
                                                            InterpreterStackBigIntptr.LLVM.Local.local_env
                                                            InterpreterStackBigIntptr.LLVM.Stack.lstack)
                                                         (prod
                                                            InterpreterStackBigIntptr.LLVM.Global.global_env
                                                            InterpreterStackBigIntptr.LP.Events.DV.dvalue)))))
                                             (fun
                                                (_ : forall _ : Empty_set,
                                                     itree L4
                                                       (prod FinMem.MMEP.MMSP.MemState
                                                          (prod MemPropT.store_id
                                                             (prod (prod local_env (@stack local_env))
                                                                (prod global_env dvalue)))))
                                                (_ : UBE Empty_set) =>
                                              @raiseUB InfLP.Events.L4
                                                (@ReSum_inr (forall _ : Type, Type) IFun sum1 Cat_IFun
                                                   Inr_sum1 UBE
                                                   (sum1 OOME (sum1 UBE (sum1 DebugE FailureE)))
                                                   InfLP.Events.ExternalCallE
                                                   (@ReSum_inr (forall _ : Type, Type) IFun sum1
                                                      Cat_IFun Inr_sum1 UBE
                                                      (sum1 UBE (sum1 DebugE FailureE)) OOME
                                                      (@ReSum_inl (forall _ : Type, Type) IFun sum1
                                                         Cat_IFun Inl_sum1 UBE UBE
                                                         (sum1 DebugE FailureE)
                                                         (@ReSum_id (forall _ : Type, Type) IFun
                                                            Id_IFun UBE))))
                                                (prod
                                                   InterpreterStackBigIntptr.LLVM.MEM.MMEP.MMSP.MemState
                                                   (prod MemPropT.store_id
                                                      (prod
                                                         (prod
                                                            InterpreterStackBigIntptr.LLVM.Local.local_env
                                                            InterpreterStackBigIntptr.LLVM.Stack.lstack)
                                                         (prod
                                                            InterpreterStackBigIntptr.LLVM.Global.global_env
                                                            InterpreterStackBigIntptr.LP.Events.DV.dvalue))))
                                                EmptyString) X0 H7 k0 H4) X0 H8) H6 H5) x2
                                  end in
                                X1 (@eq_refl Type X0)) H3) x1
                          | inr1 x1 =>
                              (fun H3 : sum1 DebugE FailureE X0 =>
                               (fun H4 : sum1 DebugE FailureE X0 =>
                                let X1 :
                                  itree InfLP.Events.L4
                                    (prod InterpreterStackBigIntptr.LLVM.MEM.MMEP.MMSP.MemState
                                       (prod MemPropT.store_id
                                          (prod
                                             (prod InterpreterStackBigIntptr.LLVM.Local.local_env
                                                InterpreterStackBigIntptr.LLVM.Stack.lstack)
                                             (prod InterpreterStackBigIntptr.LLVM.Global.global_env
                                                InterpreterStackBigIntptr.LP.Events.DV.dvalue)))) :=
                                  match
                                    H4
                                    return
                                      (itree InfLP.Events.L4
                                         (prod InterpreterStackBigIntptr.LLVM.MEM.MMEP.MMSP.MemState
                                            (prod MemPropT.store_id
                                               (prod
                                                  (prod InterpreterStackBigIntptr.LLVM.Local.local_env
                                                     InterpreterStackBigIntptr.LLVM.Stack.lstack)
                                                  (prod
                                                     InterpreterStackBigIntptr.LLVM.Global.global_env
                                                     InterpreterStackBigIntptr.LP.Events.DV.dvalue)))))
                                  with
                                  | inl1 x2 =>
                                      (fun H5 : DebugE X0 =>
                                       (fun H6 : DebugE X0 =>
                                        let X1 :
                                          forall _ : @eq Type X0 X0,
                                          itree InfLP.Events.L4
                                            (prod
                                               InterpreterStackBigIntptr.LLVM.MEM.MMEP.MMSP.MemState
                                               (prod MemPropT.store_id
                                                  (prod
                                                     (prod
                                                        InterpreterStackBigIntptr.LLVM.Local.local_env
                                                        InterpreterStackBigIntptr.LLVM.Stack.lstack)
                                                     (prod
                                                        InterpreterStackBigIntptr.LLVM.Global.global_env
                                                        InterpreterStackBigIntptr.LP.Events.DV.dvalue)))) :=
                                          match
                                            H6 in (DebugE T)
                                            return
                                              (forall _ : @eq Type T X0,
                                               itree InfLP.Events.L4
                                                 (prod
                                                    InterpreterStackBigIntptr.LLVM.MEM.MMEP.MMSP.MemState
                                                    (prod MemPropT.store_id
                                                       (prod
                                                          (prod
                                                             InterpreterStackBigIntptr.LLVM.Local.local_env
                                                             InterpreterStackBigIntptr.LLVM.Stack.lstack)
                                                          (prod
                                                             InterpreterStackBigIntptr.LLVM.Global.global_env
                                                             InterpreterStackBigIntptr.LP.Events.DV.dvalue)))))
                                          with
                                          | Debug x3 =>
                                              (fun (H7 : unit) (H8 : @eq Type unit X0) =>
                                               (fun H9 : @eq Type unit X0 =>
                                                let H10 : @eq Type unit X0 := H9 in
                                                @eq_rect Type unit
                                                  (fun _ : Type =>
                                                   forall _ : unit,
                                                   itree InfLP.Events.L4
                                                     (prod
                                                        InterpreterStackBigIntptr.LLVM.MEM.MMEP.MMSP.MemState
                                                        (prod MemPropT.store_id
                                                           (prod
                                                              (prod
                                                                 InterpreterStackBigIntptr.LLVM.Local.local_env
                                                                 InterpreterStackBigIntptr.LLVM.Stack.lstack)
                                                              (prod
                                                                 InterpreterStackBigIntptr.LLVM.Global.global_env
                                                                 InterpreterStackBigIntptr.LP.Events.DV.dvalue)))))
                                                  (fun H11 : unit =>
                                                   @eq_rect Type unit
                                                     (fun X1 : Type =>
                                                      forall
                                                        (_ : forall _ : X1,
                                                             itree L4
                                                               (prod FinMem.MMEP.MMSP.MemState
                                                                  (prod MemPropT.store_id
                                                                     (prod
                                                                        (prod local_env
                                                                         (@stack local_env))
                                                                        (prod global_env dvalue)))))
                                                        (_ : DebugE X1),
                                                      itree InfLP.Events.L4
                                                        (prod
                                                           InterpreterStackBigIntptr.LLVM.MEM.MMEP.MMSP.MemState
                                                           (prod MemPropT.store_id
                                                              (prod
                                                                 (prod
                                                                    InterpreterStackBigIntptr.LLVM.Local.local_env
                                                                    InterpreterStackBigIntptr.LLVM.Stack.lstack)
                                                                 (prod
                                                                    InterpreterStackBigIntptr.LLVM.Global.global_env
                                                                    InterpreterStackBigIntptr.LP.Events.DV.dvalue)))))
                                                     (fun
                                                        (k1 : forall _ : unit,
                                                              itree L4
                                                                (prod FinMem.MMEP.MMSP.MemState
                                                                   (prod MemPropT.store_id
                                                                      (prod
                                                                         (prod local_env
                                                                         (@stack local_env))
                                                                         (prod global_env dvalue)))))
                                                        (_ : DebugE unit) =>
                                                      @go InfLP.Events.L4
                                                        (prod
                                                           InterpreterStackBigIntptr.LLVM.MEM.MMEP.MMSP.MemState
                                                           (prod MemPropT.store_id
                                                              (prod
                                                                 (prod
                                                                    InterpreterStackBigIntptr.LLVM.Local.local_env
                                                                    InterpreterStackBigIntptr.LLVM.Stack.lstack)
                                                                 (prod
                                                                    InterpreterStackBigIntptr.LLVM.Global.global_env
                                                                    InterpreterStackBigIntptr.LP.Events.DV.dvalue))))
                                                        (@VisF InfLP.Events.L4
                                                           (prod
                                                              InterpreterStackBigIntptr.LLVM.MEM.MMEP.MMSP.MemState
                                                              (prod MemPropT.store_id
                                                                 (prod
                                                                    (prod
                                                                       InterpreterStackBigIntptr.LLVM.Local.local_env
                                                                       InterpreterStackBigIntptr.LLVM.Stack.lstack)
                                                                    (prod
                                                                       InterpreterStackBigIntptr.LLVM.Global.global_env
                                                                       InterpreterStackBigIntptr.LP.Events.DV.dvalue))))
                                                           (itree InfLP.Events.L4
                                                              (prod
                                                                 InterpreterStackBigIntptr.LLVM.MEM.MMEP.MMSP.MemState
                                                                 (prod MemPropT.store_id
                                                                    (prod
                                                                       (prod
                                                                         InterpreterStackBigIntptr.LLVM.Local.local_env
                                                                         InterpreterStackBigIntptr.LLVM.Stack.lstack)
                                                                       (prod
                                                                         InterpreterStackBigIntptr.LLVM.Global.global_env
                                                                         InterpreterStackBigIntptr.LP.Events.DV.dvalue)))))
                                                           unit
                                                           (@subevent DebugE InfLP.Events.L4
                                                              (@ReSum_inr
                                                                 (forall _ : Type, Type) IFun sum1
                                                                 Cat_IFun Inr_sum1 DebugE
                                                                 (sum1 OOME
                                                                    (sum1 UBE (sum1 DebugE FailureE)))
                                                                 InfLP.Events.ExternalCallE
                                                                 (@ReSum_inr
                                                                    (forall _ : Type, Type) IFun sum1
                                                                    Cat_IFun Inr_sum1 DebugE
                                                                    (sum1 UBE (sum1 DebugE FailureE))
                                                                    OOME
                                                                    (@ReSum_inr
                                                                       (forall _ : Type, Type) IFun
                                                                       sum1 Cat_IFun Inr_sum1 DebugE
                                                                       (sum1 DebugE FailureE) UBE
                                                                       (@ReSum_inl
                                                                         (forall _ : Type, Type) IFun
                                                                         sum1 Cat_IFun Inl_sum1 DebugE
                                                                         DebugE FailureE
                                                                         (@ReSum_id
                                                                         (forall _ : Type, Type) IFun
                                                                         Id_IFun DebugE))))) unit
                                                              (Debug H11))
                                                           (fun H13 : unit => get_inf_tree_L4 (k1 H13)))) X0 H9 k0
                                                     H6) X0 H10) H8 H7) x3
                                          end in
                                        X1 (@eq_refl Type X0)) H5) x2
                                  | inr1 x2 =>
                                      (fun H5 : FailureE X0 =>
                                       (fun H6 : FailureE X0 =>
                                        let X1 :
                                          forall _ : @eq Type X0 X0,
                                          itree InfLP.Events.L4
                                            (prod
                                               InterpreterStackBigIntptr.LLVM.MEM.MMEP.MMSP.MemState
                                               (prod MemPropT.store_id
                                                  (prod
                                                     (prod
                                                        InterpreterStackBigIntptr.LLVM.Local.local_env
                                                        InterpreterStackBigIntptr.LLVM.Stack.lstack)
                                                     (prod
                                                        InterpreterStackBigIntptr.LLVM.Global.global_env
                                                        InterpreterStackBigIntptr.LP.Events.DV.dvalue)))) :=
                                          match
                                            H6 in (FailureE T)
                                            return
                                              (forall _ : @eq Type T X0,
                                               itree InfLP.Events.L4
                                                 (prod
                                                    InterpreterStackBigIntptr.LLVM.MEM.MMEP.MMSP.MemState
                                                    (prod MemPropT.store_id
                                                       (prod
                                                          (prod
                                                             InterpreterStackBigIntptr.LLVM.Local.local_env
                                                             InterpreterStackBigIntptr.LLVM.Stack.lstack)
                                                          (prod
                                                             InterpreterStackBigIntptr.LLVM.Global.global_env
                                                             InterpreterStackBigIntptr.LP.Events.DV.dvalue)))))
                                          with
                                          | Throw x3 =>
                                              (fun (H7 : unit) (H8 : @eq Type Empty_set X0) =>
                                               (fun H9 : @eq Type Empty_set X0 =>
                                                let H10 : @eq Type Empty_set X0 := H9 in
                                                @eq_rect Type Empty_set
                                                  (fun _ : Type =>
                                                   forall _ : unit,
                                                   itree InfLP.Events.L4
                                                     (prod
                                                        InterpreterStackBigIntptr.LLVM.MEM.MMEP.MMSP.MemState
                                                        (prod MemPropT.store_id
                                                           (prod
                                                              (prod
                                                                 InterpreterStackBigIntptr.LLVM.Local.local_env
                                                                 InterpreterStackBigIntptr.LLVM.Stack.lstack)
                                                              (prod
                                                                 InterpreterStackBigIntptr.LLVM.Global.global_env
                                                                 InterpreterStackBigIntptr.LP.Events.DV.dvalue)))))
                                                  (fun _ : unit =>
                                                   @eq_rect Type Empty_set
                                                     (fun X1 : Type =>
                                                      forall
                                                        (_ : forall _ : X1,
                                                             itree L4
                                                               (prod FinMem.MMEP.MMSP.MemState
                                                                  (prod MemPropT.store_id
                                                                     (prod
                                                                        (prod local_env
                                                                         (@stack local_env))
                                                                        (prod global_env dvalue)))))
                                                        (_ : FailureE X1),
                                                      itree InfLP.Events.L4
                                                        (prod
                                                           InterpreterStackBigIntptr.LLVM.MEM.MMEP.MMSP.MemState
                                                           (prod MemPropT.store_id
                                                              (prod
                                                                 (prod
                                                                    InterpreterStackBigIntptr.LLVM.Local.local_env
                                                                    InterpreterStackBigIntptr.LLVM.Stack.lstack)
                                                                 (prod
                                                                    InterpreterStackBigIntptr.LLVM.Global.global_env
                                                                    InterpreterStackBigIntptr.LP.Events.DV.dvalue)))))
                                                     (fun
                                                        (_ : forall _ : Empty_set,
                                                             itree L4
                                                               (prod FinMem.MMEP.MMSP.MemState
                                                                  (prod MemPropT.store_id
                                                                     (prod
                                                                        (prod local_env
                                                                         (@stack local_env))
                                                                        (prod global_env dvalue)))))
                                                        (_ : FailureE Empty_set) =>
                                                      @LLVMEvents.raise InfLP.Events.L4
                                                        (prod
                                                           InterpreterStackBigIntptr.LLVM.MEM.MMEP.MMSP.MemState
                                                           (prod MemPropT.store_id
                                                              (prod
                                                                 (prod
                                                                    InterpreterStackBigIntptr.LLVM.Local.local_env
                                                                    InterpreterStackBigIntptr.LLVM.Stack.lstack)
                                                                 (prod
                                                                    InterpreterStackBigIntptr.LLVM.Global.global_env
                                                                    InterpreterStackBigIntptr.LP.Events.DV.dvalue))))
                                                        (@ReSum_inr (forall _ : Type, Type) IFun sum1
                                                           Cat_IFun Inr_sum1 FailureE
                                                           (sum1 OOME
                                                              (sum1 UBE (sum1 DebugE FailureE)))
                                                           InfLP.Events.ExternalCallE
                                                           (@ReSum_inr (forall _ : Type, Type) IFun
                                                              sum1 Cat_IFun Inr_sum1 FailureE
                                                              (sum1 UBE (sum1 DebugE FailureE)) OOME
                                                              (@ReSum_inr
                                                                 (forall _ : Type, Type) IFun sum1
                                                                 Cat_IFun Inr_sum1 FailureE
                                                                 (sum1 DebugE FailureE) UBE
                                                                 (@ReSum_inr
                                                                    (forall _ : Type, Type) IFun sum1
                                                                    Cat_IFun Inr_sum1 FailureE
                                                                    FailureE DebugE
                                                                    (@ReSum_id
                                                                       (forall _ : Type, Type) IFun
                                                                       Id_IFun FailureE)))))
                                                        EmptyString) X0 H9 k0 H6) X0 H10) H8 H7) x3
                                          end in
                                        X1 (@eq_refl Type X0)) H5) x2
                                  end in
                                X1) H3) x1
                          end in
                        X1) H1) x0
                  end in
                X1) H) x
          end in
        X1) X e k
   end.

  Lemma get_inf_tree_L4_equation :
    forall t_fin2,
      get_inf_tree_L4 t_fin2 â‰… _get_inf_tree_L4 (observe t_fin2).
  Proof.
    pcofix CIH.
    intros t_fin2.
    destruct (observe t_fin2) eqn:HTFIN.
    - rewrite (itree_eta_ t_fin2).
      rewrite HTFIN.
      cbn.
      pstep; red; cbn.
      constructor.
      reflexivity.
    - rewrite (itree_eta_ t_fin2).
      rewrite HTFIN.
      cbn.
      pstep; red; cbn.
      constructor.
      left.
      apply paco2_eq_itree_refl.
    - rewrite (itree_eta_ t_fin2).
      unfold _get_inf_tree.
      rewrite HTFIN.
      destruct e.
      { (* ExternalCallE *)
        destruct e.
        cbn.
        pstep; red; cbn.
        constructor.
        intros v; red.
        left; eapply paco2_mon_bot; eauto.
        (* Why won't reflexivity work? *)
        eapply paco2_eqit_b1b2_RR_refl; eauto.
      }

      destruct s.
      { (* OOM *)
        destruct o.
        cbn.
        pstep; red; cbn.
        constructor.
        intros [].
      }

      destruct s.
      { (* UBE *)
        destruct u.
        cbn.
        pstep; red; cbn.
        constructor.
        intros [].
      }

      destruct s.
      { (* DebugE *)
        destruct d.
        cbn.
        pstep; red; cbn.
        constructor.
        intros []; red.
        left; eapply paco2_mon_bot; eauto.
        (* Why won't reflexivity work? *)
        eapply paco2_eqit_b1b2_RR_refl; eauto.
      }

      { (* FailureE *)
        destruct f.
        cbn.
        pstep; red; cbn.
        constructor.
        intros [].
      }
  Qed.

  Lemma get_inf_tree_L4_orutt :
    forall t,
      orutt (OOM:=OOME) L4_refine_strict L4_res_refine_strict
        (MemState_refine_prop
           Ã— (eq
                Ã— (local_refine_strict Ã— stack_refine_strict
                     Ã— (global_refine_strict Ã— DVC1.dvalue_refine_strict)))) (get_inf_tree_L4 t) t.
  Proof.
    intros t.
    rewrite (itree_eta_ t).
    genobs t ot.
    clear t Heqot.
    revert ot.
    pcofix CIH.
    intros ot.

    induction ot.
    - (* Ret *)
      pstep; red; cbn.
      constructor.
      destruct r0.
      repeat destruct p.
      destruct p0.
      constructor.
      apply lift_MemState_refine_prop.
      repeat constructor; cbn.
      + apply lift_local_env_refine_strict.
      + apply lift_stack_refine_strict.
      + apply lift_global_env_refine_strict.
      + apply fin_to_inf_dvalue_refine_strict.
    - (* Tau *)
      pstep; red; cbn.
      constructor.
      right.
      rewrite (itree_eta_ t).
      apply CIH.
    - (* Vis nodes *)
      destruct e.
      { (* ExternalCallE *)
        destruct e.
        pstep; red; cbn.

        constructor.
        { red. cbn.
          split; auto.
          split.
          apply fin_to_inf_uvalue_refine_strict.
          apply Util.Forall2_forall.
          split.
          apply map_length.

          intros i a b H H0.
          apply Nth_map_iff in H.
          destruct H. destruct H.
          subst.

          cbn in *.
          rewrite H1 in H0.
          inv H0.
          apply fin_to_inf_dvalue_refine_strict.
        }

        { intros a b [TT [F [ARGS AB]]].
          rewrite DVCInfFin.dvalue_refine_strict_equation in AB.
          rewrite AB.
          rewrite (itree_eta_ (k b)).
          right.
          apply CIH.
        }

        { intros o CONTRA; inv CONTRA.
        }
      }

      destruct s.
      { (* OOM *)
        destruct o.
        pstep; red; cbn.

        change (inr1 (inl1 (ThrowOOM u))) with (@subevent _ _ (ReSum_inr IFun sum1 OOME
                                                                 (OOME +' UBE +' DebugE +' FailureE)
                                                                 ExternalCallE) _ (ThrowOOM u)).

        apply EqVisOOM.
      }

      destruct s.
      { (* UBE *)
        destruct u.
        pstep; red; cbn.

        constructor.
        { cbn; auto.
        }

        { intros [] [] _.
        }

        { intros o CONTRA; inv CONTRA.
        }
      }

      destruct s.
      { (* DebugE *)
        destruct d.
        pstep; red; cbn.

        constructor.
        { cbn; auto.
        }

        { intros [] [] _.
          rewrite (itree_eta_ (k _)).
          right.
          apply CIH.
        }

        { intros o CONTRA; inv CONTRA.
        }
      }

      { (* FailureE *)
        destruct f.
        pstep; red; cbn.

        constructor.
        { cbn; auto.
          destruct u.
          unfold print_msg.
          reflexivity.
        }

        { intros [] [] _.
        }

        { intros o CONTRA; inv CONTRA.
        }
      }
  Qed.

  #[global] Instance get_inf_tree_L4_eq_itree_eq_Proper :
    Proper (eq_itree eq ==> eq_itree eq) get_inf_tree_L4.
  Proof.
    unfold Proper, respectful.
    intros x y EQ.
    rewrite (itree_eta_ x) in *.
    rewrite (itree_eta_ y) in *.
    genobs x ox.
    genobs y oy.
    clear x Heqox y Heqoy.
    revert ox oy EQ.
    pcofix CIH.
    intros ox oy EQ.
    punfold EQ. red in EQ. cbn in EQ.
    dependent induction EQ.
    - (* Ret Ret *)
      subst.
      pstep; red; cbn.
      constructor; auto.
    - (* Tau Tau *)
      pstep; red; cbn.
      constructor.
      right.
      rewrite (itree_eta_ m1).
      rewrite (itree_eta_ m2).
      eapply CIH.
      pclearbot.
      repeat rewrite <- itree_eta_.
      apply REL.
    - (* Vis Vis *)
      destruct e.

      { (* ExternalCallE *)
        destruct e.
        pstep; red; cbn.
        constructor.
        intros v.
        red.
        right.
        rewrite (itree_eta_
                   match DVCInfFin.dvalue_convert_strict v with
                   | NoOom a => k1 a
                   | Oom s => raiseOOM s
                   end).
        rewrite (itree_eta_
                   match DVCInfFin.dvalue_convert_strict v with
                   | NoOom a => k2 a
                   | Oom s => raiseOOM s
                   end).
        apply CIH.
        repeat rewrite <- itree_eta_.
        break_match; [|reflexivity].
        specialize (REL d).
        red in REL.
        pclearbot.
        eauto.
      }

      destruct s.
      { (* OOME *)
        destruct o.
        pstep; red; cbn.
        constructor.
        intros [] _.
      }

      destruct s.
      { (* UBE *)
        destruct u0.
        pstep; red; cbn.
        constructor.
        intros [] _.
      }

      destruct s.
      { (* DebugE *)
        destruct d.
        pstep; red; cbn.
        constructor.
        intros [].
        red.
        right.
        match goal with
        | H: _ |- r (get_inf_tree_L4 ?t1) (get_inf_tree_L4 ?t2) =>
            rewrite (itree_eta_ t1);
            rewrite (itree_eta_ t2)
        end.
        apply CIH.
        repeat rewrite <- itree_eta_.
        specialize (REL tt).
        red in REL.
        pclearbot.
        eauto.
      }

      { (* FailureE *)
        destruct f.
        pstep; red; cbn.
        constructor.
        intros [] _.
      }
    - (* TauL *)
      pstep; red; cbn.
      constructor; auto.
      punfold IHEQ.
    - (* TauR *)
      pstep; red; cbn.
      constructor; auto.
      punfold IHEQ.
  Qed.

  #[global] Instance get_inf_tree_L4_eq_itree_Proper :
    Proper (eq_itree (Memory64BitIntptr.MMEP.MemSpec.MemState_eqv Ã— eq) ==> eq_itree (MemoryBigIntptr.MMEP.MemSpec.MemState_eqv Ã— eq)) get_inf_tree_L4.
  Proof.
    unfold Proper, respectful.
    intros x y EQ.
    rewrite (itree_eta_ x) in *.
    rewrite (itree_eta_ y) in *.
    genobs x ox.
    genobs y oy.
    clear x Heqox y Heqoy.
    revert ox oy EQ.
    pcofix CIH.
    intros ox oy EQ.
    punfold EQ. red in EQ. cbn in EQ.
    dependent induction EQ.
    - (* Ret Ret *)
      subst.
      pstep; red; cbn.
      constructor; auto.
      destruct r1 as (ms1&sid1&((lenv1&stack1)&genv1&r1)).
      destruct r2 as (ms2&sid2&((lenv2&stack2)&genv2&r2)).
      inv REL.
      cbn in *.
      inv snd_rel.
      constructor; cbn; auto.
      eapply MemState_eqv_lift_MemState; auto.
    - (* Tau Tau *)
      pstep; red; cbn.
      constructor.
      right.
      rewrite (itree_eta_ m1).
      rewrite (itree_eta_ m2).
      eapply CIH.
      pclearbot.
      repeat rewrite <- itree_eta_.
      apply REL.
    - (* Vis Vis *)
      destruct e.

      { (* ExternalCallE *)
        destruct e.
        pstep; red; cbn.
        constructor.
        intros v.
        red.
        right.
        rewrite (itree_eta_
                   match DVCInfFin.dvalue_convert_strict v with
                   | NoOom a => k1 a
                   | Oom s => raiseOOM s
                   end).
        rewrite (itree_eta_
                   match DVCInfFin.dvalue_convert_strict v with
                   | NoOom a => k2 a
                   | Oom s => raiseOOM s
                   end).
        apply CIH.
        repeat rewrite <- itree_eta_.
        break_match; [|reflexivity].
        specialize (REL d).
        red in REL.
        pclearbot.
        eauto.
      }

      destruct s.
      { (* OOME *)
        destruct o.
        pstep; red; cbn.
        constructor.
        intros [] _.
      }

      destruct s.
      { (* UBE *)
        destruct u0.
        pstep; red; cbn.
        constructor.
        intros [] _.
      }

      destruct s.
      { (* DebugE *)
        destruct d.
        pstep; red; cbn.
        constructor.
        intros [].
        red.
        right.
        match goal with
        | H: _ |- r (get_inf_tree_L4 ?t1) (get_inf_tree_L4 ?t2) =>
            rewrite (itree_eta_ t1);
            rewrite (itree_eta_ t2)
        end.
        apply CIH.
        repeat rewrite <- itree_eta_.
        specialize (REL tt).
        red in REL.
        pclearbot.
        eauto.
      }

      { (* FailureE *)
        destruct f.
        pstep; red; cbn.
        constructor.
        intros [] _.
      }
    - (* TauL *)
      pstep; red; cbn.
      constructor; auto.
      punfold IHEQ.
    - (* TauR *)
      pstep; red; cbn.
      constructor; auto.
      punfold IHEQ.
  Qed.

  #[global] Instance get_inf_tree_L4_eq_Proper :
    Proper (eutt eq ==> eutt eq) get_inf_tree_L4.
  Proof.
    unfold Proper, respectful.
    intros x y EQ.
    rewrite (itree_eta_ x) in *.
    rewrite (itree_eta_ y) in *.
    genobs x ox.
    genobs y oy.
    clear x Heqox y Heqoy.
    revert ox oy EQ.
    pcofix CIH.
    intros ox oy EQ.
    punfold EQ. red in EQ. cbn in EQ.
    dependent induction EQ.
    - (* Ret Ret *)
      subst.
      pstep; red; cbn.
      constructor; auto.
    - (* Tau Tau *)
      pstep; red; cbn.
      constructor.
      right.
      rewrite (itree_eta_ m1).
      rewrite (itree_eta_ m2).
      eapply CIH.
      pclearbot.
      repeat rewrite <- itree_eta_.
      apply REL.
    - (* Vis Vis *)
      destruct e.

      { (* ExternalCallE *)
        destruct e.
        pstep; red; cbn.
        constructor.
        intros v.
        red.
        right.
        rewrite (itree_eta_
                   match DVCInfFin.dvalue_convert_strict v with
                   | NoOom a => k1 a
                   | Oom s => raiseOOM s
                   end).
        rewrite (itree_eta_
                   match DVCInfFin.dvalue_convert_strict v with
                   | NoOom a => k2 a
                   | Oom s => raiseOOM s
                   end).
        apply CIH.
        repeat rewrite <- itree_eta_.
        break_match; [|reflexivity].
        specialize (REL d).
        red in REL.
        pclearbot.
        eauto.
      }

      destruct s.
      { (* OOME *)
        destruct o.
        pstep; red; cbn.
        constructor.
        intros [] _.
      }

      destruct s.
      { (* UBE *)
        destruct u0.
        pstep; red; cbn.
        constructor.
        intros [] _.
      }

      destruct s.
      { (* DebugE *)
        destruct d.
        pstep; red; cbn.
        constructor.
        intros [].
        red.
        right.
        match goal with
        | H: _ |- r (get_inf_tree_L4 ?t1) (get_inf_tree_L4 ?t2) =>
            rewrite (itree_eta_ t1);
            rewrite (itree_eta_ t2)
        end.
        apply CIH.
        repeat rewrite <- itree_eta_.
        specialize (REL tt).
        red in REL.
        pclearbot.
        eauto.
      }

      { (* FailureE *)
        destruct f.
        pstep; red; cbn.
        constructor.
        intros [] _.
      }
    - (* TauL *)
      pstep; red; cbn.
      constructor; auto.
      punfold IHEQ.
    - (* TauR *)
      pstep; red; cbn.
      constructor; auto.
      punfold IHEQ.
  Qed.

  #[global] Instance get_inf_tree_L4_Proper :
    Proper (eutt (Memory64BitIntptr.MMEP.MemSpec.MemState_eqv Ã— eq) ==> eutt (MemoryBigIntptr.MMEP.MemSpec.MemState_eqv Ã— eq)) get_inf_tree_L4.
  Proof.
    unfold Proper, respectful.
    intros x y EQ.
    rewrite (itree_eta_ x) in *.
    rewrite (itree_eta_ y) in *.
    genobs x ox.
    genobs y oy.
    clear x Heqox y Heqoy.
    revert ox oy EQ.
    pcofix CIH.
    intros ox oy EQ.
    punfold EQ. red in EQ. cbn in EQ.
    dependent induction EQ.
    - (* Ret Ret *)
      subst.
      pstep; red; cbn.
      destruct r1 as (ms1&sid1&((lenv1&stack1)&genv1&r1)).
      destruct r2 as (ms2&sid2&((lenv2&stack2)&genv2&r2)).
      constructor; auto.
      inv REL.
      cbn in *.
      inv snd_rel.
      constructor; cbn; auto.
      eapply MemState_eqv_lift_MemState; auto.
    - (* Tau Tau *)
      pstep; red; cbn.
      constructor.
      right.
      rewrite (itree_eta_ m1).
      rewrite (itree_eta_ m2).
      eapply CIH.
      pclearbot.
      repeat rewrite <- itree_eta_.
      apply REL.
    - (* Vis Vis *)
      destruct e.

      { (* ExternalCallE *)
        destruct e.
        pstep; red; cbn.
        constructor.
        intros v.
        red.
        right.
        rewrite (itree_eta_
                   match DVCInfFin.dvalue_convert_strict v with
                   | NoOom a => k1 a
                   | Oom s => raiseOOM s
                   end).
        rewrite (itree_eta_
                   match DVCInfFin.dvalue_convert_strict v with
                   | NoOom a => k2 a
                   | Oom s => raiseOOM s
                   end).
        apply CIH.
        repeat rewrite <- itree_eta_.
        break_match; [|reflexivity].
        specialize (REL d).
        red in REL.
        pclearbot.
        eauto.
      }

      destruct s.
      { (* OOME *)
        destruct o.
        pstep; red; cbn.
        constructor.
        intros [] _.
      }

      destruct s.
      { (* UBE *)
        destruct u0.
        pstep; red; cbn.
        constructor.
        intros [] _.
      }

      destruct s.
      { (* DebugE *)
        destruct d.
        pstep; red; cbn.
        constructor.
        intros [].
        red.
        right.
        match goal with
        | H: _ |- r (get_inf_tree_L4 ?t1) (get_inf_tree_L4 ?t2) =>
            rewrite (itree_eta_ t1);
            rewrite (itree_eta_ t2)
        end.
        apply CIH.
        repeat rewrite <- itree_eta_.
        specialize (REL tt).
        red in REL.
        pclearbot.
        eauto.
      }

      { (* FailureE *)
        destruct f.
        pstep; red; cbn.
        constructor.
        intros [] _.
      }
    - (* TauL *)
      pstep; red; cbn.
      constructor; auto.
      punfold IHEQ.
    - (* TauR *)
      pstep; red; cbn.
      constructor; auto.
      punfold IHEQ.
  Qed.

  (* TODO: Move this import *)
  From Vellvm Require Import Utils.InterpPropOOM.

  (* TODO: Move this *)
  Lemma interp_prop_oom_raiseOOM :
    forall {E F : Type -> Type} {OOM1 : OOME -< E} {OOM2 : OOME -< F}
      (h : forall T : Type, E T -> PropT F T) {T : Type} (b1 b2 o1 : bool)
      t oom_msg
      (RR : relation T),
      interp_prop_oom' (OOM:=OOME) h RR b1 b2 o1 true t (raiseOOM oom_msg).
  Proof.
    intros E F OOM1 OOM2 h T b1 b2 o1 t oom_msg RR.
    pstep; red; cbn.
    observe_vis_r.
    eapply Interp_Prop_OomT_Vis_OOM_R; eauto.
    reflexivity.
  Qed.

  Lemma model_undef_h_fin_inf :
    forall (t_fin : itree (FinLP.Events.ExternalCallE +' PickUvalueE +' OOME +' UBE +' DebugE +' FailureE)
                 (MMEP.MMSP.MemState * (MemPropT.store_id * (local_env * @stack (list (LLVMAst.raw_id * uvalue)) * res_L1))))
      (t_inf : itree InfLP.Events.L3 TopLevelBigIntptr.res_L6)
      (t_fin' : itree L4 (FinMem.MMEP.MMSP.MemState * (MemPropT.store_id * (local_env * @stack (list (LLVMAst.raw_id * uvalue)) * res_L1))))
      (REL: orutt (OOM:=OOME) L3_refine_strict L3_res_refine_strict
              (MemState_refine_prop
                 Ã— (eq
                      Ã— (local_refine_strict Ã— stack_refine_strict
                           Ã— (global_refine_strict Ã— DVC1.dvalue_refine_strict)))) t_inf t_fin)
      (UNDEF_FIN: FinLLVM.Pick.model_undef_h TLR_FIN.R.refine_res3 t_fin t_fin'),
      InfLLVM.Pick.model_undef_h TLR_INF.R.refine_res3 t_inf (get_inf_tree_L4 t_fin').
  Proof.
    (* intros t_fin t_inf t_fin' REL UNDEF_FIN. *)
    (* red. *)
    (* red in UNDEF_FIN. *)

    (* red. *)
    (* revert UNDEF_FIN. *)
    (* revert REL. *)

    (* rewrite (itree_eta_ t_fin). *)
    (* rewrite (itree_eta_ t_fin'). *)
    (* rewrite (itree_eta_ t_inf). *)

    (* genobs t_fin ot_fin. *)
    (* genobs t_fin' ot_fin'. *)
    (* genobs t_inf ot_inf. *)
    (* clear t_inf Heqot_inf. *)
    (* clear t_fin Heqot_fin. *)
    (* clear t_fin' Heqot_fin'. *)

    (* revert ot_inf ot_fin ot_fin'. *)
    (* pcofix CIH. *)
    (* intros ot_inf ot_fin ot_fin2 REL RUN. *)

    (* punfold RUN. *)
    (* red in RUN; cbn in RUN. *)
    (* dependent induction RUN. *)
    (* - (* Ret *) *)
    (*   apply orutt_inv_Ret_r in REL. *)
    (*   destruct REL as (?&?&?). *)
    (*   eapply paco2_mon_bot; eauto. *)
    (*   setoid_rewrite H. *)
    (*   rewrite get_inf_tree_L4_equation. *)
    (*   cbn. *)
    (*   pstep; red; cbn. *)
    (*   constructor. *)
    (*   destruct x as (?&?&?&?&?). *)
    (*   destruct r1 as (?&?&?&?&?). *)
    (*   destruct r2 as (?&?&?&?&?). *)
    (*   destruct H0 as (?&?&?&?&?). *)
    (*   destruct REL0 as (?&?&?&?&?). *)
    (*   cbn in *. *)
    (*   destruct p1. *)
    (*   repeat split; cbn; subst; auto. *)
    (*   apply fin_to_inf_dvalue_refine_strict'; eauto. *)
    (* - (* Double Tau *) *)
    (*   apply orutt_inv_Tau_r in REL. *)
    (*   pclearbot. *)

    (*   rewrite (itree_eta t1) in REL, HS. *)
    (*   genobs t1 ot1. *)
    (*   clear t1 Heqot1. *)

    (*   assert (DEC: (exists m3, ot_inf = TauF m3) \/ (forall m3, ot_inf <> TauF m3)). *)
    (*   { destruct ot_inf; eauto; right; red; intros; inversion H. } *)

    (*   destruct DEC as [EQ | EQ]. *)
    (*   { (* Tau on the right and left... Coinductive case *) *)
    (*     destruct EQ as (m3&EQ). *)
    (*     subst. *)
    (*     rewrite (itree_eta_ t2). *)
    (*     rewrite (itree_eta_ m3). *)
    (*     pstep; red; cbn. *)
    (*     constructor. *)
    (*     right. *)

    (*     apply orutt_inv_Tau_l in REL. *)

    (*     eapply CIH. *)
    (*     - repeat rewrite <- itree_eta. *)
    (*       eauto. *)
    (*     - repeat rewrite <- itree_eta. *)
    (*       apply HS. *)
    (*   } *)

    (*   pstep; red; cbn. *)
    (*   constructor; eauto. *)
    (*   pinversion REL. *)

    (*   apply interp_prop_oom_inv_tau_l in RUN. *)

    (*   punfold REL; red in REL; cbn in REL. *)
    (*   dependent induction REL. *)

    (* punfold REL. *)
    (* red in REL. *)
    (* cbn in REL. *)

    (* dependent induction REL. *)
    (* - (* EqRet *) *)
    (*   apply interp_prop_oom_ret_inv in RUN. *)
    (*   destruct RUN as [RUN | RUN]. *)
    (*   2: { *)
    (*     destruct RUN as (?&?&?&?). *)
    (*     eapply paco2_mon_bot; eauto. *)
    (*     setoid_rewrite H0. *)
    (*     rewrite get_inf_tree_L4_equation. *)
    (*     cbn. *)
    (*     destruct x0. *)
    (*     cbn. *)

    (*     apply interp_prop_oom_raiseOOM. *)
    (*   } *)

    (*   destruct RUN as (?&?&?). *)
    (*   eapply paco2_mon_bot; eauto. *)
    (*   rewrite H1. *)
    (*   pstep; red; cbn. *)
    (*   constructor. *)
    (*   destruct r1 as (?&?&?&?&?). *)
    (*   destruct r2 as (?&?&?&?&?). *)
    (*   destruct x as (?&?&?&?&?). *)
    (*   destruct p0. *)
    (*   repeat constructor. *)
    (*   cbn in *. *)

    (*   destruct H as (?&?&?&?&?). *)
    (*   destruct H0 as (?&?&?&?&?). *)
    (*   cbn in *. *)
    (*   destruct p1. *)
    (*   cbn. *)
    (*   subst. *)
    (*   eapply fin_to_inf_dvalue_refine_strict'; eauto. *)
    (* - (* EqTau *) *)
    (*   pclearbot. *)
    (*   assert (DEC: (exists m3, ot_fin2 = TauF m3) \/ (forall m3, ot_fin2 <> TauF m3)). *)
    (*   { destruct ot_fin2; eauto; right; red; intros; inversion H0. } *)

    (*   destruct DEC as [EQ | EQ]. *)
    (*   { (* Tau on the right and left... Coinductive case *) *)
    (*     destruct EQ as (m3&EQ). *)
    (*     subst. *)
    (*     rewrite (itree_eta_ m1). *)
    (*     rewrite (itree_eta_ m3). *)
    (*     pstep; red; cbn. *)
    (*     constructor. *)
    (*     right. *)

    (*     eapply CIH. *)
    (*     - repeat rewrite <- itree_eta. *)
    (*       eauto. *)
    (*     - repeat rewrite <- itree_eta. *)
    (*       eapply interp_prop_oom_inv_tau; eauto. *)
    (*   } *)

    (*   apply interp_prop_oom_inv_tau_l in RUN. *)
    (*   rewrite (itree_eta_ m2) in H. *)
    (*   rewrite (itree_eta_ m2) in RUN. *)
    (*   genobs m2 om2. *)
    (*   clear Heqom2 m2. *)
    (*   genobs m1 om1. *)
    (*   clear Heqom1 m1. *)
    (*   punfold RUN; red in RUN; cbn in RUN. *)
    (*   dependent induction RUN; subst. *)
    (*   -- apply orutt_inv_Ret_r in H. *)
    (*      eapply paco2_mon_bot; eauto. *)
    (*      destruct H as (r2'&M1&H). *)
    (*      rewrite tau_eutt. *)
    (*      rewrite M1. *)
    (*      rewrite get_inf_tree_L4_equation. *)
    (*      cbn. *)
    (*      eapply interp_prop_oom_ret_refine. *)
    (*      destruct r1 as (?&?&?&?&?). *)
    (*      destruct r2 as (?&?&?&?&?). *)
    (*      destruct r2' as (?&?&?&?&?). *)
    (*      repeat constructor. *)
    (*      cbn; destruct p0; cbn. *)
    (*      destruct H as (?&?&?&?&?). *)
    (*      destruct REL as (?&?&?&?&?). *)
    (*      cbn in *; subst. *)
    (*      eapply fin_to_inf_dvalue_refine_strict'; eauto. *)
    (*   -- specialize (EQ t2). *)
    (*      contradiction. *)
    (*   -- eapply IHRUN; eauto. *)
    (*      rewrite <- itree_eta_. *)
    (*      apply orutt_inv_Tau_r; eauto. *)
    (*   -- specialize (EQ t2). *)
    (*      contradiction. *)
    (*   -- inv CHECK. *)
    (*   -- destruct e, u. *)
    (*      pinversion HT1; subst_existT. *)
    (*      2: inv CHECK0. *)
    (*      eapply paco2_mon_bot; eauto. *)
    (*      setoid_rewrite get_inf_tree_L4_equation. *)
    (*      cbn. *)
    (*      eapply interp_prop_oom_raiseOOM. *)
    (*   -- (* Interp_PropT_Vis case *) *)
    (*     repeat red in H0. *)
    (*     destruct e. *)
    (*     { (* ExternalCallE *) *)
    (*       rewrite (itree_eta_ m1) in H. *)
    (*       rewrite (itree_eta_ m1). *)
    (*       genobs m1 om1. *)
    (*       clear m1 Heqom1. *)

    (*       punfold H. *)
    (*       red in H. *)
    (*       cbn in H. *)
    (*       dependent induction H. *)
    (*       2: { (* Tau *) *)
    (*         assert (DECm1: (exists m3, om1 = TauF m3) \/ (forall m3, om1 <> TauF m3)). *)
    (*       { destruct om1; eauto; right; red; intros; inv H2. } *)

    (*       destruct DECm1 as [EQm1 | EQm1]. *)
    (*       { (* Tau only on left *) *)
    (*         destruct EQm1 as (m3&EQm1). *)
    (*         subst. *)
    (*         pstep; red; cbn. *)
    (*         constructor; auto. *)
    (*         constructor; auto. *)
    (*         right. *)

    (*         pclearbot. *)
    (*         eapply CIH. *)
    (*         - repeat rewrite <- itree_eta. *)
    (*           eauto. *)
    (*         - repeat rewrite <- itree_eta. *)
    (*           eapply interp_prop_oom_inv_tau; eauto. *)

    (*       } *)

    (*       } *)
    (*       { (* Vis *) *)
    (*         red in H. *)
    (*       } *)
    (*       destruct om1. *)
    (*       pinversion H. *)
    (*       pinversion H. *)

    (*       red in H0. *)
    (*       rewrite H0 in H1. *)
    (*       setoid_rewrite bind_bind in H1. *)
    (*       setoid_rewrite bind_ret_l in H1. *)
    (*       setoid_rewrite bind_trigger in H1. *)

    (*       pinversion H1; subst_existT. *)
    (*       2: exfalso; eapply EQ; eauto. *)

    (*       pstep; red; cbn. *)
    (*       constructor; auto. *)

    (*       break_match_goal. *)
    (*       cbn. *)
    (*       constructor. *)

    (*       pstep; red; cbn. *)
    (*       constructor; auto. *)

    (*       cbn; break_match_goal; cbn. *)

    (*       apply orutt_inv_Vis_r in H. *)
    (*       destruct H as [(?&?&?&?&?) | OOM]. *)
    (*       2: { *)
    (*         destruct OOM. *)
    (*         inv H. *)
    (*       } *)

    (*       destruct H2. *)
    (*       red in H2. *)
    (*       destruct x0. *)
    (*       2: repeat destruct s; inv H2. *)
    (*       destruct e0. *)
    (*       (* Why can I not destruct e...? *) *)
    (*       dependent destruction e. *)
    (*       inv Heqe0. *)
    (*       destruct H2 as (?&F&ARGS). *)
    (*       subst. *)

    (*       rewrite H. *)
    (*       pstep; red; cbn. *)
    (*       observe_vis_r. *)
    (*       eapply Interp_Prop_OomT_Vis with *)
    (*         (k2:=(fun v => get_inf_tree_L4 *)
    (*                       match DVCInfFin.dvalue_convert_strict v with *)
    (*                       | NoOom a => k2 a *)
    (*                       | Oom s => raiseOOM s *)
    (*                       end)). *)
    (*       2: { *)
    (*         cbn. *)
    (*         red. *)
    (*         setoid_rewrite bind_ret_r. *)
    (*         reflexivity. *)
    (*       } *)
    (*       2: { *)
    (*         setoid_rewrite bind_trigger. *)
    (*         erewrite <- fin_to_inf_uvalue_refine_strict'; eauto. *)

    (*         (* TODO: Move this *) *)
    (*         Lemma map_fin_to_inf_uvalue_refine_strict' : *)
    (*           forall dv_fins dv_infs, *)
    (*             Forall2 DVCInfFin.dvalue_refine_strict dv_infs dv_fins -> *)
    (*             map fin_to_inf_dvalue dv_fins = dv_infs. *)
    (*         Proof. *)
    (*           intros dv_fins dv_infs REF. *)
    (*           erewrite Forall2_map_eq; eauto. *)
    (*           unfold DVCInfFin.dvalue_refine_strict in REF. *)
    (*           apply Util.Forall2_forall. *)
    (*           apply Util.Forall2_forall in REF as (LENGTH & REF). *)
    (*           split; auto. *)
    (*           intros i a b H H0. *)
    (*           pose proof (REF i b a H0 H). *)
    (*           apply fin_to_inf_convert_dvalue_inversion; auto. *)
    (*         Qed. *)

    (*         erewrite map_fin_to_inf_uvalue_refine_strict'; eauto. *)
    (*         reflexivity. *)
    (*       } *)

    (*       intros a RET. *)
    (*       break_match_goal. *)
    (*       - specialize (H3 a d). *)
    (*         forward H3; cbn; try tauto. *)

    (*         left. *)
    (*         specialize (HK d). *)
    (*         forward HK. *)
    (*         { rewrite H0. *)
    (*           setoid_rewrite bind_trigger. *)
    (*           eapply ReturnsVis. *)
    (*           reflexivity. *)
    (*           cbn. *)
    (*           constructor. *)
    (*           reflexivity. *)
    (*         } *)

    (*         pclearbot. *)
    (*         rewrite H3. *)
    (*       - left. *)
    (*         rewrite get_inf_tree_L4_equation. *)
    (*         cbn. *)

    (*         Lemma interp_prop_raise_oom : *)
    (*           forall {E1 E2} `{OOME2 : OOME -< E2} *)
    (*             {R1 R2} *)
    (*             (R1R2 : R1 -> R2 -> Prop) *)
    (*             t msg *)
    (*             (X Y : Type) h_spec, *)
    (*             interp_prop (E:=E1) (F:=E2) h_spec R1R2 t (raiseOOM msg). *)
    (*         Proof. *)
    (*           intros E1 E2 OOME2 R1 R2 R1R2 t msg X Y h_spec. *)
    (*           pstep; red; cbn. *)
    (*           eapply  *)
    (*         Qed. *)

    (*           forall  *)




    (*       Lemma interp_prop_vis_refine : *)
    (*         forall {E1 E2} `{OOME2 : OOME -< E2} *)
    (*           (REF : prerel E1 E2) *)
    (*           (RES_REF : postrel E1 E2) *)
    (*           {R1 R2} *)
    (*           (R1R2 : R1 -> R2 -> Prop) *)
    (*           (X Y : Type) h_spec (e1 : E1 X) (e2 : E2 Y) k1 k2, *)
    (*           (forall x y, RES_REF X Y e1 x e2 y -> orutt (OOM:=OOME) REF RES_REF R1R2 (k1 x) (k2 y)) -> *)
    (*           interp_prop h_spec R1R2 (vis e1 k1) (vis e2 k2). *)
    (*       Proof. *)
    (*         intros. *)
    (*         pstep; red; cbn. *)
    (*         match goal with *)
    (*         | |- interp_PropTF _ _ _ _ _ _ (VisF ?e ?k) => *)
    (*             change (VisF e k) with (observe (Vis e k)) *)
    (*         end. *)
    (*         eapply Interp_PropT_Vis. with (ta:=) *)
    (*         econstructor. *)
    (*         3: { *)
    (*           cbn. *)
    (*           rewrite bind_trigger. *)
    (*           cbn. *)
    (*           replace k2 with (fun x => k2 x). *)
    (*           reflexivity. *)
    (*         } *)
    (*         2: { *)
    (*           red. *)
    (*         } *)
    (*         - intros a H0. *)
    (*           left. *)
    (*           eauto. *)


    (*         generalize dependent y. *)
    (*         generalize dependent x. *)
    (*         pcofix CIH. *)
    (*         intros x y RRxy. *)
    (*         pstep. *)
    (*         cbn. *)
    (*         econstructor; eauto. *)
    (*       Qed. *)

    (*       pstep; red; cbn. *)

    (*       cbn. *)
    (*       pstep; red; cbn. *)

    (*       constructor. *)
    (*       { red. cbn. *)
    (*         split; auto. *)
    (*         split. *)
    (*         apply fin_to_inf_uvalue_refine_strict. *)
    (*         apply Util.Forall2_forall. *)
    (*         split. *)
    (*         apply map_length. *)

    (*         intros i a b H H0. *)
    (*         apply Nth_map_iff in H. *)
    (*         destruct H. destruct H. *)
    (*         subst. *)

    (*         cbn in *. *)
    (*         rewrite H1 in H0. *)
    (*         inv H0. *)
    (*         apply fin_to_inf_dvalue_refine_strict. *)
    (*       } *)

    (*       { intros a b [TT [F [ARGS AB]]]. *)
    (*         rewrite DVCInfFin.dvalue_refine_strict_equation in AB. *)
    (*         rewrite AB. *)
    (*         rewrite (itree_eta_ (k b)). *)
    (*         right. *)
    (*         apply CIH. *)
    (*       } *)

    (*       { intros o CONTRA; inv CONTRA. *)
    (*       } *)

    (*     } *)
    (*          left. *)
    (*          pclearbot. *)
    (*          assert (orutt (OOM:=OOME) (@L2_refine_strict) (@L2_res_refine_strict) (local_refine_strict Ã— stack_refine_strict *)
    (*                                                                                   Ã— (global_refine_strict Ã— DVCInfFin.dvalue_refine_strict)) m1 (Tau t1)). *)
    (*          { apply H. *)
    (*          } *)
    (*          setoid_rewrite tau_eutt in H0. *)
    (*          rewrite <- itree_eta_. *)
    (*          apply H0. *)
    (*       -- specialize (EQ t2). *)
    (*          contradiction. *)



    (*   applpunfold RUN. *)
    (*   red in RUN. *)
    (*   inversion RUN; cbn in H0. *)
    (*   + exfalso; eapply EQ; eauto. *)
    (*   + subst. *)

    (*   pstep; red; cbn. *)
    (*   constructor; eauto. *)
    (*   destruct DEC *)


    (*   constructor; auto. *)
    (*   rewrite  *)
  Admitted.

  Lemma model_E1E2_34_orutt_strict :
    forall t_inf t_fin,
      L3_E1E2_orutt_strict t_inf t_fin ->
      L4_E1E2_orutt_strict (InfLLVM.Pick.model_undef TLR_INF.R.refine_res3 t_inf) (FinLLVM.Pick.model_undef TLR_FIN.R.refine_res3 t_fin).
  Proof.
    intros t_inf_set t_fin_set REL.
    (* t_inf_set and t_fin_set are both sets of itrees.

       REL is a relation between these sets, stating that for any tree
       in the finite set there is one in the infinite set that is
       orutt this tree at L3.
     *)

    red in REL.
    red.
    intros t_fin_L4 UNDEF_FIN.

    (* Given t_fin_L4 âˆˆ t_fin_set, I should be able to find an
       appropriate t_inf_4 such that t_inf_L4 âˆˆ t_inf_set... Such that
       orutt t_inf_L4 t_fin_L4...
     *)
    exists (get_inf_tree_L4 t_fin_L4).
    split.
    2: apply get_inf_tree_L4_orutt.

    red.
    red in UNDEF_FIN.
    destruct UNDEF_FIN as (t_fin_L3 & T_FIN & UNDEF_FIN).

    specialize (REL t_fin_L3 T_FIN).
    destruct REL as (t_inf_L3 & T_INF & REL).

    exists t_inf_L3.
    split; auto.
    eapply model_undef_h_fin_inf; eauto.
  Qed.

  Lemma model_E1E2_L4_orutt_strict_sound
    (p : list
           (LLVMAst.toplevel_entity
              LLVMAst.typ
              (LLVMAst.block LLVMAst.typ * list (LLVMAst.block LLVMAst.typ)))) :
    model_E1E2_L4_orutt_strict p p.
  Proof.
    apply model_E1E2_34_orutt_strict; apply model_E1E2_L3_orutt_strict_sound.
  Qed.

  (** Model UB *)

  Definition L5_E1E2_orutt_strict
    (t1 : PropT InfLP.Events.L5 (InfMemMMSP.MemState *
                                   (MemPropT.store_id * (InfLLVM.Local.local_env * InfLLVM.Stack.lstack * (InfLLVM.Global.global_env * InfLP.Events.DV.dvalue)))))
    (t2 : PropT FinLP.Events.L5 (FinMemMMSP.MemState *
                                   (MemPropT.store_id * (FinLLVM.Local.local_env * FinLLVM.Stack.lstack * (FinLLVM.Global.global_env * FinLP.Events.DV.dvalue)))))
    : Prop :=
    forall t', t2 t' ->
          (exists t, t1 t /\
                  orutt
                    L4_refine_strict
                    L4_res_refine_strict
                    (MemState_refine_prop Ã— (eq Ã— (local_refine_strict Ã— stack_refine_strict Ã— (global_refine_strict Ã— DVC1.dvalue_refine_strict))))
                    t t' (OOM:=OOME)) \/
            (exists ub, t1 ub /\ ContainsUB.contains_UB ub).

  Definition model_E1E2_L5_orutt_strict p1 p2 :=
    L5_E1E2_orutt_strict
      (TopLevelBigIntptr.model_oom_L5 TLR_INF.R.refine_res2 TLR_INF.R.refine_res3 p1)
      (TopLevel64BitIntptr.model_oom_L5 TLR_FIN.R.refine_res2 TLR_FIN.R.refine_res3 p2).

  Lemma orutt_L4_contains_UB :
    forall (t_inf_ub : itree InfLP.Events.L4 TopLevelBigIntptr.res_L6) (t_fin_ub : itree E2 res_L6),
      orutt (OOM:=OOME) L4_refine_strict L4_res_refine_strict (MemState_refine_prop Ã— (eq Ã— (local_refine_strict Ã— stack_refine_strict Ã— (global_refine_strict Ã— DVC1.dvalue_refine_strict)))) t_inf_ub t_fin_ub ->
      ContainsUB.contains_UB t_fin_ub ->
      ContainsUB.contains_UB t_inf_ub.
  Proof.
    intros t_inf_ub t_fin_ub EQV UB.
    revert t_inf_ub EQV.
    induction UB; intros t_inf_ub EQV.
    - (* CrawlTau *)
      eapply IHUB.
      rewrite H in EQV.
      rewrite tau_eutt in EQV.
      eauto.
    - (* CrawlVis *)
      rewrite H in EQV.
      punfold EQV; red in EQV; cbn in EQV.
      dependent induction EQV.
      + rewrite itree_eta_.
        setoid_rewrite <- x.

        (* Need to figure out what event we're working with to know
        what A and Y are... *)
        destruct e1.
        { (* ExternalCallE *)
          destruct e0.
          repeat red in H2.
          break_match_hyp; try contradiction.
          destruct e0.
          destruct H2 as (?&?&?).

          specialize (H0 (fin_to_inf_dvalue x0) x0).
          forward H0.
          cbn.
          repeat split; eauto.
          apply fin_to_inf_dvalue_refine_strict.
          
          eapply ContainsUB.CrawlVis with (k:=k1).
          change 
            (@inl1 InterpreterStackBigIntptr.LP.Events.ExternalCallE (OOME +' UBE +' DebugE +' FailureE)
               InterpreterStackBigIntptr.LP.Events.DV.dvalue
               (InterpreterStackBigIntptr.LP.Events.ExternalCall t f args))
            with
            (@subevent InterpreterStackBigIntptr.LP.Events.L4 InterpreterStackBigIntptr.LP.Events.L4
             (@ReSum_id (forall _ : Type, Type) IFun Id_IFun InterpreterStackBigIntptr.LP.Events.L4)
             InterpreterStackBigIntptr.LP.Events.DV.dvalue (inl1 (InterpreterStackBigIntptr.LP.Events.ExternalCall t f args))).
          reflexivity.

          eapply IHUB.
          pclearbot; eauto.
        }

        destruct s.
        { (* OOM *)
          destruct o.
          cbn in H2.
          break_match_hyp; try contradiction.
          destruct s; try contradiction.
          destruct o.
          destruct x0.
        }

        destruct s.
        { (* UBE *)
          destruct u.
          cbn in H2.
          break_match_hyp; try contradiction.
          repeat (destruct s; try contradiction).
          destruct u0.
          destruct x0.
        }

        destruct s.
        { (* DebugE *)
          destruct d.
          cbn in H2.
          break_match_hyp; try contradiction.
          repeat (destruct s; try contradiction).
          destruct d; subst.
          specialize (H0 tt tt).
          forward H0; cbn; auto.

          eapply ContainsUB.CrawlVis with (k:=k1).
          change 
            (@inr1 InterpreterStackBigIntptr.LP.Events.ExternalCallE (OOME +' UBE +' DebugE +' FailureE) unit
               (@inr1 OOME (UBE +' DebugE +' FailureE) unit
                  (@inr1 UBE (DebugE +' FailureE) unit (@inl1 DebugE FailureE unit (Debug u0)))))
            with
            (@subevent InterpreterStackBigIntptr.LP.Events.L4 InterpreterStackBigIntptr.LP.Events.L4
             (@ReSum_id (forall _ : Type, Type) IFun Id_IFun InterpreterStackBigIntptr.LP.Events.L4)
             unit
             (inr1 (inr1 (inr1 (inl1 (Debug u0)))))).
          reflexivity.

          destruct x0.
          eapply IHUB.
          pclearbot; eauto.
        }

        { (* FailureE *)
          destruct f.
          cbn in H2.
          repeat break_match_hyp; try contradiction.
        }
      + destruct e0.
        destruct x0.
      + rewrite itree_eta.
        setoid_rewrite <- x.
        rewrite tau_eutt.
        eapply IHEQV; eauto.
    - (* FindUB *)
      rewrite H in EQV.
      punfold EQV; red in EQV; cbn in EQV.
      dependent induction EQV.
      + destruct e1 as [e1 | [e1 | [e1 | e1]]];
          cbn in H2.
        * destruct e1.
          try contradiction.
        * repeat break_match_hyp; try contradiction.
        * repeat break_match_hyp; try contradiction.
          subst.
          destruct e1.

          eapply ContainsUB.FindUB.
          rewrite itree_eta.
          setoid_rewrite <- x.
          rewrite subevent_subevent.

          change 
            (@inr1 InterpreterStackBigIntptr.LP.Events.ExternalCallE (OOME +' UBE +' DebugE +' FailureE)
               void
               (@inr1 OOME (UBE +' DebugE +' FailureE) void (@inl1 UBE (DebugE +' FailureE) void (ThrowUB u))))
            with
            (@subevent UBE InfLP.Events.L4
               (fun (x0 : Type) (f : UBE x0) =>
                  @ReSum_id (forall _ : Type, Type) IFun Id_IFun InfLP.Events.L4 x0
                    (@ReSum_inr (forall _ : Type, Type) IFun sum1 Cat_IFun Inr_sum1 UBE
                       (sum1 OOME (sum1 UBE (sum1 DebugE FailureE))) InfLP.Events.ExternalCallE
                       (@ReSum_inr (forall _ : Type, Type) IFun sum1 Cat_IFun Inr_sum1 UBE
                          (sum1 UBE (sum1 DebugE FailureE)) OOME
                          (@ReSum_inl (forall _ : Type, Type) IFun sum1 Cat_IFun Inl_sum1 UBE UBE
                             (sum1 DebugE FailureE) (@ReSum_id (forall _ : Type, Type) IFun Id_IFun UBE)))
                       x0 f)) Empty_set (ThrowUB u)).
          reflexivity.
        * repeat break_match_hyp; try contradiction.
      + rewrite itree_eta.
        setoid_rewrite <- x.
        rewrite tau_eutt.
        eapply IHEQV; eauto.
  Qed.

  Lemma model_E1E2_45_orutt_strict :
    forall t_inf t_fin,
      L4_E1E2_orutt_strict t_inf t_fin ->
      L5_E1E2_orutt_strict (model_UB t_inf) (model_UB t_fin).
  Proof.
    intros t_inf_set t_fin_set REL.
    (* t_inf_set and t_fin_set are both sets of itrees. *)
    red in REL.
    red.
    intros t_fin_L5 UB_FIN.
    red in UB_FIN.
    destruct UB_FIN.
    { (* No UB *)
      specialize (REL t_fin_L5 H).
      destruct REL as (t_inf_L5 & T_INF & REL).

      left.
      exists t_inf_L5.
      split; eauto.
      red; eauto.
    }

    (* UB *)
    destruct H as (t_fin_ub & T_FIN_UB & UB).
    specialize (REL t_fin_ub T_FIN_UB).
    destruct REL as (t_inf_ub & T_INF & REL).

    right.
    exists t_inf_ub.
    split; eauto.
    red; eauto.

    eapply orutt_L4_contains_UB; eauto.
  Qed.

  Lemma model_E1E2_L5_orutt_strict_sound
    (p : list
           (LLVMAst.toplevel_entity
              LLVMAst.typ
              (LLVMAst.block LLVMAst.typ * list (LLVMAst.block LLVMAst.typ)))) :
    model_E1E2_L5_orutt_strict p p.
  Proof.
    apply model_E1E2_45_orutt_strict; apply model_E1E2_L4_orutt_strict_sound.
  Qed.

  Definition L6_E1E2_orutt_strict
    (t1 : PropT InfLP.Events.L6 (InfMemMMSP.MemState *
                                   (MemPropT.store_id * (InfLLVM.Local.local_env * InfLLVM.Stack.lstack * (InfLLVM.Global.global_env * InfLP.Events.DV.dvalue)))))
    t2
    : Prop :=
    forall t', t2 t' ->
          (exists t, t1 t /\
                  orutt
                    L4_refine_strict
                    L4_res_refine_strict
                    (MemState_refine_prop Ã— (eq Ã— (local_refine_strict Ã— stack_refine_strict Ã— (global_refine_strict Ã— DVC1.dvalue_refine_strict))))
                    t t' (OOM:=OOME)) \/
            (exists ub, t1 ub /\ ContainsUB.contains_UB ub).

  Definition model_E1E2_L6_orutt_strict p1 p2 :=
    L6_E1E2_orutt_strict
      (TopLevelBigIntptr.model_oom_L6 TLR_INF.R.refine_res2 TLR_INF.R.refine_res3 eq p1)
      (TopLevel64BitIntptr.model_oom_L6 TLR_FIN.R.refine_res2 TLR_FIN.R.refine_res3 eq p2).

  Lemma refine_OOM_h_orutt :
    forall
      (t : itree InterpreterStackBigIntptr.LP.Events.L4
             (InfMem.MMEP.MMSP.MemState *
                (MemPropT.store_id *
                   (InterpreterStackBigIntptr.LLVM.Local.local_env * stack * TopLevelBigIntptr.res_L1))))
      (t1 t2 : itree L4 (MMEP.MMSP.MemState * (MemPropT.store_id * (local_env * stack * res_L1)))),
      refine_OOM_h eq t1 t2 ->
      orutt (OOM:=OOME) L4_refine_strict L4_res_refine_strict
        (MemState_refine_prop
           Ã— (eq
                Ã— (local_refine_strict Ã— stack_refine_strict
                     Ã— (global_refine_strict Ã— DVC1.dvalue_refine_strict)))) t t1 ->
      orutt (OOM:=OOME) L4_refine_strict L4_res_refine_strict
        (MemState_refine_prop
           Ã— (eq
                Ã— (local_refine_strict Ã— stack_refine_strict
                     Ã— (global_refine_strict Ã— DVC1.dvalue_refine_strict)))) t t2.
  Proof.
    pcofix CIH.
    intros t t1 t2 REF EQV.

    rewrite (itree_eta_ t1) in REF, EQV.
    rewrite (itree_eta_ t2) in REF.
    rewrite (itree_eta_ t2).
    rewrite (itree_eta_ t).
    rewrite (itree_eta_ t) in EQV.

    genobs t1 ot1.
    genobs t2 ot2.
    genobs t ot.
    
    clear t t1 t2 Heqot1 Heqot2 Heqot.
    punfold EQV.
    red in EQV.
    cbn in EQV.

    dependent induction EQV.
    - (* EqRet *)
      punfold REF.
      red in REF.
      cbn in REF.
      pstep; red; cbn.

      dependent induction REF; subst.
      + red in REL; subst.
        constructor.
        auto.
      + constructor.
        eauto.
      + pinversion HT1.
        2: inv CHECK0.
        subst_existT.
        constructor.
      + exfalso.
        rewrite (itree_eta_ t2) in H0.
        rewrite x in H0.
        red in H.
        rewrite H in H0.
        clear - H0.

        setoid_rewrite bind_trigger in H0.
        apply eutt_ret_vis_abs in H0; auto.
    - (* EqTau *)
      assert (DEC: (exists m3, ot2 = TauF m3) \/ (forall m3, ot2 <> TauF m3)).
      { destruct ot2; eauto; right; red; intros; inv H0. }

      destruct DEC as [EQ | EQ].
      { destruct EQ; subst.
        pstep; red; cbn.
        constructor.
        right.
        eapply CIH.
        apply InterpPropOOM.interp_prop_oom_inv_tau in REF.
        apply REF.
        pclearbot.
        eauto.
      }

      pclearbot.

      apply InterpPropOOM.interp_prop_oom_inv_tau_r in REF.
      punfold REF.
      red in REF.
      cbn in REF.

      rewrite (itree_eta_ m2) in H.
      genobs m2 om2.
      clear m2 Heqom2.

      dependent induction REF; subst.
      + (* Ret *) 
        red in REL; cbn in REL; subst.
        eapply paco2_mon_bot; eauto.
        eapply orutt_add_Tau_l.
        eauto.
      + (* Tau Tau *)
        exfalso; eapply EQ.
        reflexivity.
      + (* TauL *)
        exfalso; eapply EQ.
        reflexivity.
      + (* TauR *)
        eapply IHREF; eauto.
        eapply orutt_inv_Tau_r in H.
        rewrite <- itree_eta_.
        eapply H.
      + (* Vis_OOM_L *)
        pinversion HT1; try inv CHECK0.
        subst_existT.
        pstep; red; cbn.
        constructor.
      + (* Vis_OOM_R *)
        inv CHECK.
      + (* Vis *)
        assert (DEC: (exists o : OOME A, e = subevent A o) \/ forall o : OOME A, e <> subevent A o).
        { clear - e.
          destruct e;
            try solve [right; intros o CONTRA;
                       inv CONTRA].
          destruct s;
            try solve [right; intros o CONTRA;
                       inv CONTRA].

          left.
          exists o.
          reflexivity.
        }

        destruct DEC as [OOM | NOOM].
        { destruct OOM.
          subst.
          pstep; red; cbn.
          constructor.
        }

        red in H.
        rewrite H in H0.
        rewrite (itree_eta_ t2) in H0.
        setoid_rewrite bind_trigger in H0.
        setoid_rewrite H in HK.

        eapply orutt_Proper_R3 with (x:=L4_refine_strict) in H1.
        6: symmetry; apply H0.
        all: try reflexivity.

        eapply orutt_inv_Vis_r in H1.
        destruct H1 as [VIS | OOM].
        2: {
          destruct OOM.
          destruct e; inv H1.
          change
            (@inr1 ExternalCallE (OOME +' UBE +' DebugE +' FailureE) A
               (@resum (Type -> Type) IFun OOME (OOME +' UBE +' DebugE +' FailureE)
                  (@ReSum_inl (Type -> Type) IFun sum1 Cat_IFun Inl_sum1 OOME OOME
                     (UBE +' DebugE +' FailureE) (@ReSum_id (Type -> Type) IFun Id_IFun OOME)) A x))
 with
            (@subevent OOME L4
         (@ReSum_inr (Type -> Type) IFun sum1 Cat_IFun Inr_sum1 OOME
            (OOME +' UBE +' DebugE +' FailureE) ExternalCallE
            (@ReSum_inl (Type -> Type) IFun sum1 Cat_IFun Inl_sum1 OOME OOME
               (UBE +' DebugE +' FailureE) (@ReSum_id (Type -> Type) IFun Id_IFun OOME))) A x).

          pstep; red; cbn.
          constructor.
        }

        destruct VIS as (?&?&?&?&?&?).

        pstep; red; cbn.
        constructor.
        punfold H1; red in H1; cbn in H1.
        genobs m1 om1.
        clear m1 Heqom1.
        dependent induction H1.
        2: {
          constructor.
          eapply IHeqitF; eauto.
        }

        constructor; eauto.

        intros a b H4.
        right.
        eapply CIH.
        specialize (HK b).
        forward HK.
        eapply ReturnsVis.
        unfold trigger.
        reflexivity.
        constructor.
        reflexivity.
        pclearbot.
        apply HK.

        specialize (REL a).
        red in REL.
        pclearbot.

        eapply orutt_Proper_R3.
        4: apply REL.
        all: try reflexivity.

        eauto.
    - (* EqVis *)
      punfold REF; red in REF; cbn in REF.
      dependent induction REF.
      + (* Tau *)
        forward IHREF; auto.
        specialize (IHREF B _ _ eq_refl).
        specialize (IHREF A e1 k1 H H0 H1).
        rewrite (itree_eta_ t1).
        genobs t1 ot1.
        clear t1 Heqot1.

        pstep; red; cbn.
        punfold IHREF. red in IHREF; cbn in IHREF.
        clear REF.
        dependent induction IHREF.
        * constructor.
          constructor; eauto.
        * constructor.
          eapply OOMRutt.EqVisOOM.
        * constructor; eauto.
          cbn.
          rewrite (itree_eta_ t2).
          eapply IHIHREF; eauto.
      + (* OOM *)
        pinversion HT1; subst_existT.
        * pstep; red; cbn.
          apply OOMRutt.EqVisOOM.
        * inv CHECK0.
      + (* Not OOM *)
        red in H.
        rewrite H in H0.
        rewrite (itree_eta_ t2) in H0.
        rewrite x in H0.
        setoid_rewrite bind_trigger in H0.
        pinversion H0; repeat subst_existT.

        pstep; red; cbn.
        constructor; eauto.

        intros a b H4.
        right.
        eapply CIH.
        specialize (HK b).
        forward HK.
        eapply ReturnsVis.
        rewrite H.
        unfold trigger.
        reflexivity.
        constructor.
        reflexivity.
        pclearbot.
        apply HK.

        repeat red in H0.
        inv H0; subst_existT.
        specialize (REL0 b); red in REL0.
        pclearbot.

        eapply orutt_Proper_R3.
        5: symmetry; apply REL0.
        all: try reflexivity.

        specialize (H2 _ _ H4).
        pclearbot; eauto.
    - (* EqVisOOM *)
      punfold REF; red in REF; cbn in REF.
      dependent induction REF.
      + (* Tau *)
        forward IHREF; auto.
        specialize (IHREF _ _ _ eq_refl t0).
        rewrite (itree_eta_ t1).
        genobs t1 ot1.
        clear t1 Heqot1.

        pstep; red; cbn.
        constructor.
        punfold IHREF. 
      + (* OOM *)
        pinversion HT1; subst_existT.
        * pstep; red; cbn.
          apply OOMRutt.EqVisOOM.
        * inv CHECK0.
      + (* Not OOM *)
        red in H.
        rewrite H in H0.
        rewrite (itree_eta_ t2) in H0.
        rewrite x in H0.
        setoid_rewrite bind_trigger in H0.
        pinversion H0; repeat subst_existT.
        pstep; red; cbn.
        destruct e0; inv H6.
        change
          (@inr1 ExternalCallE (OOME +' UBE +' DebugE +' FailureE) A0
             (@resum (Type -> Type) IFun OOME (OOME +' UBE +' DebugE +' FailureE)
                (@ReSum_inl (Type -> Type) IFun sum1 Cat_IFun Inl_sum1 OOME OOME
                   (UBE +' DebugE +' FailureE) (@ReSum_id (Type -> Type) IFun Id_IFun OOME)) A0 e))
          with
          (@subevent OOME L4
             (@ReSum_inr (Type -> Type) IFun sum1 Cat_IFun Inr_sum1 OOME
                (OOME +' UBE +' DebugE +' FailureE) ExternalCallE
                (@ReSum_inl (Type -> Type) IFun sum1 Cat_IFun Inl_sum1 OOME OOME
                   (UBE +' DebugE +' FailureE) (@ReSum_id (Type -> Type) IFun Id_IFun OOME))) A0 e).

        apply OOMRutt.EqVisOOM.
    - (* EqTauL *)
      specialize (IHEQV REF).
      punfold IHEQV. red in IHEQV. cbn in IHEQV.
      rewrite (itree_eta_ t1).
      genobs t1 ot1; clear t1 Heqot1.
      pstep; red; cbn.
      constructor; cbn; eauto.
    - (* EqTauR *)
      apply InterpPropOOM.interp_prop_oom_inv_tau_r in REF.
      rewrite (itree_eta_ t2) in REF.
      specialize (IHEQV REF).
      auto.
  Qed.

  Lemma model_E1E2_56_orutt_strict :
    forall t_inf t_fin,
      L5_E1E2_orutt_strict t_inf t_fin ->
      L6_E1E2_orutt_strict (refine_OOM eq t_inf) (refine_OOM eq t_fin).
  Proof.
    intros t_inf_set t_fin_set REL.
    (* t_inf_set and t_fin_set are both sets of itrees. *)

    red in REL.
    red.
    intros t_fin_L6 OOM_FIN.
    red in OOM_FIN.
    destruct OOM_FIN as (?&?&OOM).
    specialize (REL _ H).
    destruct REL as [REL | UB].
    2: {
      destruct UB as (ub & FIN_UB & UB).
      right.
      exists ub.
      split; eauto.
      red.
      exists ub.
      split; eauto.
      reflexivity.
    }

    left.
    destruct REL as (t_inf & T_INF & ORUTT).
    exists t_inf.
    split; eauto.
    2: {
      eapply refine_OOM_h_orutt; eauto.
    }

    red.
    exists t_inf.
    split; eauto.
    reflexivity.
  Qed.

  Lemma model_E1E2_L6_orutt_strict_sound
    (p : list
           (LLVMAst.toplevel_entity
              LLVMAst.typ
              (LLVMAst.block LLVMAst.typ * list (LLVMAst.block LLVMAst.typ)))) :
    model_E1E2_L6_orutt_strict p p.
  Proof.
    apply model_E1E2_56_orutt_strict; apply model_E1E2_L5_orutt_strict_sound.
  Qed.

  Print Assumptions model_E1E2_L6_orutt_strict_sound.

  (* Bogus for safety... *)
  euoauaohuhaoseu
End InfiniteToFinite.
