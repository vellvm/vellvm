(*** This file sets up some testing infrastructure.

  See README.md for more details. *)
open LLVMAst
open TopLevel

open InterpretationStack.InterpreterStackBigIntptr.LP.Events

open Llvm_printer
open Either
module GA = Generate.GA
open List

type raw_assertion_string =
  | Eq of {lhs: string; rhs: string}
  | Poison' of {fcall: string}

let string_of_raw_assertion_string = function
  | Eq {lhs; rhs} -> Printf.sprintf "Eq{LHS:%s; RHS:%s}" lhs rhs
  | Poison' {fcall} -> Printf.sprintf "Poison'{fcall:%s}" fcall
(* SPECIAL TREATMENT FOR Alive2 TESTS

   - ERROR comments put the assertion parser into a different mode: "; ERROR:
   Value mismatch" "; ERROR: Target's return value is more undefined" ";
   ERROR: Source is more defined than target" "; ERROR: Mismatch in
   memory" *)

(* These modes affect the behavior of what kind of test is generated by the ;
   ASSERT SRCTGT <num> directive

   - NormalEquality generates the usual dvalue comparison The others are
   _expected_ error conditions: - ValueMismatch succeeds when the values are
   _different_ - TargetMorePoisonous succeeds when the target is poison and
   the source is not (TODO: any other cases?) - TargetMoreUndefined succeeds
   when the target - SourceMoreDefined succeeds when TODO - MismatchInMemory
   succeeds when TODO *)

type src_tgt_mode =
  | NormalEquality
  | ValueMismatch
  | TargetMorePoisonous
  | TargetMoreUndefined
  | SourceMoreDefined
  | MismatchInMemory

let int_of_src_tgt_mode = function
  | NormalEquality -> 1
  | ValueMismatch -> 2
  | TargetMorePoisonous -> 3
  | TargetMoreUndefined -> 4
  | SourceMoreDefined -> 5
  | MismatchInMemory -> 6

let show_src_tgt_mode = function
  | NormalEquality -> "NormalEquality"
  | ValueMismatch -> "ValueMismatch"
  | TargetMorePoisonous -> "TargetMorePoisonous"
  | TargetMoreUndefined -> "TargetMoreUndefined"
  | SourceMoreDefined -> "SourceMoreDefined"
  | MismatchInMemory -> "MismatchedInMemory"

type test =
  (* expected dvalue, dynamic type, entry, arguments *)
  | EQTest of DV.dvalue * DynamicTypes.dtyp * string * DV.uvalue list
  (* dynamic type, entry, arguments *)
  | POISONTest of DynamicTypes.dtyp * string * DV.uvalue list
  (* Find a better name for this *)
  (* retty, args for src, (t, args) for arguments to source and test *)
  (* Source target mode, dynamic type, Left is arguments and right is AST*)
  | SRCTGTTest of
      src_tgt_mode
      * DynamicTypes.dtyp
      * ( (LLVMAst.typ * DV.uvalue) list
        , (LLVMAst.typ, GA.runnable_blocks) LLVMAst.toplevel_entity list )
        Either.t

(* DVALUE equality *)
(* TODO: implement this in ASTLib and use extraction *)
let rec eq_dvalue (l : DV.dvalue) (r : DV.dvalue) : bool = DV.dvalue_eqb l r
(* match l, r with | DVALUE_I1 l', DVALUE_I1 r' -> let bitwidth =
   Camlcoq.Z.of_uint 1 in let pow = BinInt.Z.pow BinInt.Z.two bitwidth in let
   fixed = fun i -> Camlcoq.Z.modulo i pow in Camlcoq.Z.eq (fixed l') (fixed
   r') | DVALUE_I8 l', DVALUE_I8 r' -> let bitwidth = Camlcoq.Z.of_uint 8 in
   let pow = BinInt.Z.pow BinInt.Z.two bitwidth in let fixed = fun i ->
   Camlcoq.Z.modulo i pow in Camlcoq.Z.eq (fixed l') (fixed r') | DVALUE_I32
   l', DVALUE_I32 r' -> let bitwidth = Camlcoq.Z.of_uint 32 in let pow =
   BinInt.Z.pow BinInt.Z.two bitwidth in let fixed = fun i ->
   Camlcoq.Z.modulo i pow in Camlcoq.Z.eq (fixed l') (fixed r') | DVALUE_I64
   l', DVALUE_I64 r' -> let bitwidth = Camlcoq.Z.of_uint 64 in let pow =
   BinInt.Z.pow BinInt.Z.two bitwidth in let fixed = fun i ->
   Camlcoq.Z.modulo i pow in Camlcoq.Z.eq (fixed l') (fixed r') | DVALUE_Addr
   l', DVALUE_Addr r' -> l' = r' | DVALUE_Double l', DVALUE_Double r' -> l' =
   r' | DVALUE_Float l', DVALUE_Float r' -> l' = r' | DVALUE_Poison l',
   DVALUE_Poison r' -> l' = r' | DVALUE_None, DVALUE_None -> true |
   DVALUE_Struct ul, DVALUE_Struct ur -> List.for_all2 eq_dvalue ul ur |
   DVALUE_Packed_struct ul, DVALUE_Packed_struct ur -> List.for_all2
   eq_dvalue ul ur | DVALUE_Array ul, DVALUE_Array ur -> List.for_all2
   eq_dvalue ul ur | DVALUE_Vector ul, DVALUE_Vector ur -> List.for_all2
   eq_dvalue ul ur | _ -> false *)
(* Directly converts a piece of syntax to a dvalue without going through
   semantic interpretation. Only works on literals. *)

let rec typ_to_dtyp (typ : LLVMAst.typ) : DynamicTypes.dtyp =
  match typ with
  | TYPE_Void -> DTYPE_Void
  | TYPE_I i -> DTYPE_I i
  | TYPE_Float -> DTYPE_Float
  | TYPE_Double -> DTYPE_Double
  | TYPE_Array (sz, dtyp) -> DTYPE_Array (sz, typ_to_dtyp dtyp)
  | TYPE_Struct dtyps -> DTYPE_Struct (List.map typ_to_dtyp dtyps)
  | TYPE_Packed_struct dtyps ->
      DTYPE_Packed_struct (List.map typ_to_dtyp dtyps)
  | TYPE_Vector (sz, dtyp) -> DTYPE_Vector (sz, typ_to_dtyp dtyp)
  | _ ->
      failwith
        (Printf.sprintf "Assertion includes unsupported type:\n\t %s"
           (string_of_typ typ) )

let rec texp_to_dvalue ((typ, exp) : LLVMAst.typ * LLVMAst.typ LLVMAst.exp) :
    DV.dvalue =
  match (typ, exp) with
  (* Allow null pointers literals *)
  | TYPE_Pointer _, EXP_Null ->
      DVALUE_Addr InterpretationStack.InterpreterStackBigIntptr.LP.ADDR.null
  | TYPE_I i, EXP_Integer x ->
     DVALUE_I (i, x)
  | TYPE_Float, EXP_Float f -> DVALUE_Float f
  | TYPE_Double, EXP_Double f -> DVALUE_Double f
  | TYPE_Double, EXP_Hex f -> DVALUE_Double f
  | TYPE_Array _, EXP_Array (t, elts) ->
      DVALUE_Array (typ_to_dtyp t, (List.map texp_to_dvalue elts))
  | TYPE_Struct _, EXP_Struct elts ->
      DVALUE_Struct (List.map texp_to_dvalue elts)
  | TYPE_Packed_struct _, EXP_Packed_struct elts ->
      DVALUE_Packed_struct (List.map texp_to_dvalue elts)
  | TYPE_Vector _, EXP_Vector (t, elts) ->
      DVALUE_Vector (typ_to_dtyp t, (List.map texp_to_dvalue elts))
  | _, _ ->
      failwith
        (Printf.sprintf "Assertion includes unsupported expression:\n\t%s %s"
           (string_of_typ typ) (string_of_exp exp) )

let rec texp_to_uvalue ((typ, exp) : LLVMAst.typ * LLVMAst.typ LLVMAst.exp) :
    DV.uvalue =
  match (typ, exp) with
  (* Allow null pointers literals *)
  | TYPE_Pointer _, EXP_Null ->
      UVALUE_Addr InterpretationStack.InterpreterStackBigIntptr.LP.ADDR.null
  | TYPE_I i, EXP_Integer x ->
     UVALUE_I (i, x)
  | TYPE_Float, EXP_Float f -> UVALUE_Float f
  | TYPE_Double, EXP_Double f -> UVALUE_Double f
  | TYPE_Double, EXP_Hex f -> UVALUE_Double f
  | TYPE_Array _, EXP_Array (t, elts) ->
      UVALUE_Array (typ_to_dtyp t, (List.map texp_to_uvalue elts))
  | TYPE_Struct _, EXP_Struct elts ->
      UVALUE_Struct (List.map texp_to_uvalue elts)
  | TYPE_Packed_struct _, EXP_Packed_struct elts ->
      UVALUE_Packed_struct (List.map texp_to_uvalue elts)
  | TYPE_Vector _, EXP_Vector (t, elts) ->
      UVALUE_Vector (typ_to_dtyp t, (List.map texp_to_uvalue elts))
  | _, _ ->
      failwith
        (Printf.sprintf "Assertion includes unsupported expression:\n\t%s %s"
           (string_of_typ typ) (string_of_exp exp) )

let texp_to_function_name (_, exp) : string =
  match exp with
  | EXP_Ident (ID_Global (Name x)) -> Camlcoq.camlstring_of_coqstring x
  | _ -> failwith "found non-function name"

(* | INSTR_Call of 't texp * 't texp list *)
let instr_to_call_data instr =
  match instr with
  | INSTR_Call (fn, args, _) ->
      ( texp_to_function_name fn
      , List.map (fun x -> texp_to_uvalue (fst x)) args )
  | _ ->
      failwith "Assertion includes unsupported instruction (must be a call)"

let texp_to_name_retty (texp : LLVMAst.typ texp) : DynamicTypes.dtyp * string
    =
  let t, exp = texp in
  match exp with
  | EXP_Ident (ID_Global (Name x)) ->
      (typ_to_dtyp t, Camlcoq.camlstring_of_coqstring x)
  | _ -> failwith "found non-function name"

let instr_to_call_data' instr =
  match instr with
  | INSTR_Call (fn, args, _) ->
      let t, fname = texp_to_name_retty fn in
      (t, fname, List.map (fun x -> texp_to_uvalue (fst x)) args)
  | _ ->
      failwith "Assertion includes unsupported instruction (must be a call)"

let parsing_mode = ref NormalEquality

let reset_parsing_mode () = parsing_mode := NormalEquality

(* Top level for parsing assertions *)
let rec parse_assertion (filename : string) (line : string) : test list =
  if parse_error_comment line then []
  else
    let assertions =
      [ parse_poison_assertion line
      ; parse_eq_assertion line
      ; parse_srctgt_assertion filename line ]
    in
    List.flatten assertions

and parse_error_comment line : bool =
  let regex_value_mismatch = "^[ \t]*; ERROR: Value mismatch" in
  let regex_tgt_poison =
    "^[ \t]*; ERROR: Target is more poisonous than source"
  in
  if Str.string_match (Str.regexp regex_value_mismatch) line 0 then (
    parsing_mode := ValueMismatch ;
    true )
  else if Str.string_match (Str.regexp regex_tgt_poison) line 0 then (
    parsing_mode := TargetMorePoisonous ;
    true )
  else false

and parse_poison_assertion (line : string) : test list =
  (* ws* "ASSERT" ws+ "POISON" ws* ':' ws* (anything+ as r) *)
  let regex = "^[ \t]*;[ \t]*ASSERT[ \t]+POISON[ \t]*:[ \t]*\\(.*\\)" in
  if not (Str.string_match (Str.regexp regex) line 0) then []
  else
    let assertion = Str.matched_group 1 line in
    let poisoned_fcall =
      Llvm_lexer.parse_test_call (Lexing.from_string assertion)
    in
    let ty, fn, args = instr_to_call_data' poisoned_fcall in
    [POISONTest (ty, fn, args)]

and parse_eq_assertion (line : string) : test list =
  (* ws* "ASSERT" ws+ "EQ" ws* ':' ws* (anything+ as l) ws* '=' ws*
     (anything+ as r) *)
  let regex = "^[ \t]*;[ \t]*ASSERT[ \t]+EQ[ \t]*:[ \t]*\\(.*\\)=\\(.*\\)" in
  if not (Str.string_match (Str.regexp regex) line 0) then
    (* let _ = print_endline ("NO MATCH: " ^ line) in *)
    []
  else
    (* let _ = print_endline ("MATCH: " ^ line) in *)
    let lhs = Str.matched_group 1 line in
    (* let _ = print_endline ("LHS: " ^ lhs) in *)
    let rhs = Str.matched_group 2 line in
    (* let _ = print_endline ("RHS: " ^ rhs) in *)
    let l = Llvm_lexer.parse_texp (Lexing.from_string lhs) in
    (* let _ = print_endline "PARSED LHS" in *)
    let r =
      try Llvm_lexer.parse_test_call (Lexing.from_string rhs)
      with _ -> failwith (Printf.sprintf "Ill-formed ASSERT EQ: %s" rhs)
    in
    (* let _ = print_endline "PARSED RHS" in *)
    let uv = texp_to_dvalue l in
    let dt = typ_to_dtyp (fst l) in
    let fn, args = instr_to_call_data r in
    [EQTest (uv, dt, fn, args)]

and parse_srctgt_assertion (filename : string) (line : string) : test list =
  (* ws* ; ws* "ASSERT" ws+ "SRCTGT" ws+ (some optional number) *)
  let regex = "^[ \t]*;[ \t]*ASSERT[ \t]+SRCTGT[ \t]*\\(.*\\)?" in
  (* annoying duplication of parse file :( *)
  let read_and_parse (file : string) =
    let lines = ref [] in
    let channel = open_in file in
    ( try
        while true do
          lines := input_line channel :: !lines
        done ;
        ""
      with End_of_file ->
        close_in channel ;
        String.concat "\n" (List.rev !lines) )
    |> Lexing.from_string |> Llvm_lexer.parse
  in
  (* Given an ast, find the source and target functions *)
  let find_fn fname toplevel_entity =
    match toplevel_entity with
    | TLE_Definition df -> (
      match df.df_prototype.dc_name with
      | Name coqstr -> Camlcoq.camlstring_of_coqstring coqstr = fname
      | _ -> false )
    | _ -> false
  in
  (* Find the function type for a given top level entity NOTE: does not work
     with vararg functions *)
  let find_ty toplevel_entity : LLVMAst.typ list * LLVMAst.typ =
    match toplevel_entity with
    | TLE_Definition df -> (
      match df.df_prototype.dc_type with
      | LLVMAst.TYPE_Function (rt, args, _) -> (args, rt)
      | _ -> failwith "given entity not a function definition" )
    | _ -> failwith "not a function definition"
  in
  if not (Str.string_match (Str.regexp regex) line 0) then []
  else
    let ast = read_and_parse filename in
    let num_trials = 1 in
    (* SAZ: replaced this by 1 temporarily let str = Str.matched_group 1 line
       in try int_of_string str with _ -> 10 in *)
    (* TODO: Choose between two modes *)
    let src_fxn, tgt_fxn =
      (List.find_opt (find_fn "src") ast, List.find_opt (find_fn "tgt") ast)
    in
    match (src_fxn, tgt_fxn) with
    | Some src, Some tgt -> (
      try
        let src_t, tgt_t = (find_ty src, find_ty tgt) in
        (* TODO: Need to edit dummy_bool into something determined
           dynamically, then there can be two modes *)
        let dummy_bool = false in
        match dummy_bool with
        | true ->
            (* TODO: Need to replace the following command with generate
               program and do SRCTGTTEST with it -> type to dtype*)
            let generated_args : (LLVMAst.typ * DV.uvalue) list list =
              Generate.generate_n_args num_trials (fst src_t)
            in
            (* tgt_t is args_t * ret_t*)
            List.map
              (fun arg ->
                SRCTGTTest (!parsing_mode, typ_to_dtyp (snd tgt_t), Left arg)
                )
              generated_args
        | false ->
            let generated_asts :
                ( (LLVMAst.typ, GA.runnable_blocks) LLVMAst.toplevel_entity
                * (LLVMAst.typ, GA.runnable_blocks) LLVMAst.toplevel_entity
                )
                list =
              Generate.generate_n_runner num_trials (fst src_t) (snd src_t)
                (Generate.explode_str "src")
                (Generate.explode_str "tgt")
            in
            List.map
              (fun ast ->
                SRCTGTTest
                  ( !parsing_mode
                  , typ_to_dtyp (snd tgt_t)
                  , Right [fst ast; snd ast] ) )
              generated_asts
      with _ -> [] )
    | _ -> []
